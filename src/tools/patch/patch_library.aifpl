;;; AIFPL Patch Library - Fixed Implementation
;;; Core patching logic with fuzzy matching for unified diff application

;; Define all helper functions and export the main API
(let (
  (normalize-line (lambda (line)
    (string-trim line) ) )
  
  (lines-match? (lambda (line1 line2)
    (string=? (string-trim line1) (string-trim line2) ) ) )
  
  (line-similarity (lambda (line1 line2)
    (if (string=? (string-trim line1) (string-trim line2) )
        1.0
        (let ( (len1 (string-length line1) )
              (len2 (string-length line2) ) )
          (if (or (= len1 0) (= len2 0) )
              0.0
              (let ( (min-len (min len1 len2) ) )
                (let ( (count-match (lambda (i acc)
                                    (if (>= i min-len)
                                        acc
                                        (if (string=? (substring line1 i (+ i 1) )
                                                     (substring line2 i (+ i 1) ) )
                                            (count-match (+ i 1) (+ acc 1) )
                                            (count-match (+ i 1) acc) ) ) ) ) )
                  (/ (count-match 0 0) (max len1 len2) ) ) ) ) ) ) ) )
  
  ;; NEW: Extract context lines with their file-relative positions
  ;; Returns list of (file-offset, line-text) pairs
  (extract-context-with-positions (lambda (changes)
    (let ( (extract-helper (lambda (remaining file-offset results)
                           (if (null? remaining)
                               results
                               (let ( (change (first remaining) )
                                     (change-type (first change) )
                                     (line-text (first (rest change) ) ) )
                                 (if (= change-type "context")
                                     ;; Context line: add to results and increment offset
                                     (extract-helper (rest remaining)
                                                   (+ file-offset 1)
                                                   (append results (list (list file-offset line-text) ) ) )
                                     (if (= change-type "delete")
                                         ;; Delete line: increment offset but don't add to results
                                         (extract-helper (rest remaining)
                                                       (+ file-offset 1)
                                                       results)
                                         ;; Insert line: don't increment offset, don't add to results
                                         (extract-helper (rest remaining)
                                                       file-offset
                                                       results) ) ) ) ) ) ) )
      (extract-helper changes 0 (list) ) ) ) )
  
  (count-leading-context (lambda (changes)
    (let ( (count-helper (lambda (remaining acc)
                         (if (null? remaining)
                             acc
                             (if (= (first (first remaining) ) "context")
                                 (count-helper (rest remaining) (+ acc 1) )
                                 acc) ) ) ) )
      (count-helper changes 0) ) ) )
  
  ;; NEW: Score a position based on context with positions
  (score-position-with-offsets (lambda (file-lines base-position context-with-positions)
    (if (null? context-with-positions)
        1.0  ;; No context to match, perfect score
        (let ( (check-all (lambda (remaining total-score count)
                          (if (null? remaining)
                              (/ total-score count)
                              (let ( (item (first remaining) )
                                    (file-offset (first item) )
                                    (expected-line (first (rest item) ) ) )
                                (let ( (file-pos (+ base-position file-offset) ) )
                                  (if (or (< file-pos 0) (>= file-pos (length file-lines) ) )
                                      0.0  ;; Out of bounds, score is 0
                                      (let ( (actual-line (list-ref file-lines file-pos) ) )
                                        (let ( (similarity (line-similarity expected-line actual-line) ) )
                                          (check-all (rest remaining)
                                                   (+ total-score similarity)
                                                   (+ count 1) ) ) ) ) ) ) ) ) ) )
          (check-all context-with-positions 0.0 0) ) ) ) )
  
  (find-best-match (lambda (file-lines hunk-start changes fuzz-range)
    (let ( (context-with-positions (extract-context-with-positions changes) ) )
      (if (null? context-with-positions)
          ;; No context, use hunk-start as-is
          (list "match" hunk-start 1.0)
          (let ( (search-start (max 0 (- hunk-start fuzz-range) ) )
                (search-end (min (length file-lines) (+ hunk-start fuzz-range 1) ) ) )
            (let ( (positions (range search-start search-end) ) )
              (if (null? positions)
                  (list "no-match" "Empty search range")
                  (let ( (scored (map (lambda (pos)
                                      (list pos (score-position-with-offsets file-lines pos context-with-positions) ) )
                                    positions) ) )
                    (let ( (find-best (lambda (remaining best-pos best-score)
                                      (if (null? remaining)
                                          (if (> best-score 0.5)
                                              (list "match" best-pos best-score)
                                              (list "no-match" "No good match found") )
                                          (let ( (current (first remaining) ) )
                                            (let ( (pos (first current) )
                                                  (score (first (rest current) ) ) )
                                              (if (> score best-score)
                                                  (find-best (rest remaining) pos score)
                                                  (find-best (rest remaining) best-pos best-score) ) ) ) ) ) ) )
                      (find-best scored -1 0.0) ) ) ) ) ) ) ) ) )
  
  (apply-change (lambda (file-lines position change)
    (let ( (change-type (first change) )
          (line-text (first (rest change) ) ) )
      (if (= change-type "context")
          (if (>= position (length file-lines) )
              (list "error" "Context beyond file end" position)
              (if (lines-match? (list-ref file-lines position) line-text)
                  (list "ok" file-lines (+ position 1) )
                  (list "error" "Context mismatch" position) ) )
          (if (= change-type "delete")
              (if (>= position (length file-lines) )
                  (list "error" "Delete beyond file end" position)
                  (if (lines-match? (list-ref file-lines position) line-text)
                      (let ( (new-lines (append (take position file-lines)
                                              (drop (+ position 1) file-lines) ) ) )
                        (list "ok" new-lines position) )
                      (list "error" "Delete mismatch" position) ) )
              (if (= change-type "insert")
                  (let ( (new-lines (append (take position file-lines)
                                          (list line-text)
                                          (drop position file-lines) ) ) )
                    (list "ok" new-lines (+ position 1) ) )
                  (list "error" "Unknown change type" position) ) ) ) ) ) )
  
  (apply-changes (lambda (file-lines start-pos changes)
    (let ( (apply-all (lambda (lines pos remaining)
                      (if (null? remaining)
                          (list "success" lines)
                          (let ( (result (apply-change lines pos (first remaining) ) ) )
                            (let ( (status (first result) ) )
                              (if (= status "ok")
                                  (let ( (new-lines (first (rest result) ) )
                                        (new-pos (first (rest (rest result) ) ) ) )
                                    (apply-all new-lines new-pos (rest remaining) ) )
                                  (list "error" (first (rest result) ) (first (rest (rest result) ) ) ) ) ) ) ) ) ) )
      (apply-all file-lines start-pos changes) ) ) )
  
  (get-start-line (lambda (hunk) (first (rest (first hunk) ) ) ) )
  (get-changes (lambda (hunk) (first (rest (first (rest (rest (rest hunk) ) ) ) ) ) ) )
  
  (apply-hunk (lambda (file-lines hunk fuzz-range)
    (let ( (start-line (get-start-line hunk) )
          (changes (get-changes hunk) ) )
      ;; Use the new find-best-match that handles positions correctly
      (let ( (match-result (find-best-match file-lines start-line changes fuzz-range) ) )
        (let ( (match-status (first match-result) ) )
          (if (= match-status "match")
              (let ( (best-pos (first (rest match-result) ) ) )
                (apply-changes file-lines best-pos changes) )
              (list "error" (first (rest match-result) ) start-line) ) ) ) ) ) )
  
  (apply-hunks (lambda (file-lines hunks fuzz-range)
    (let ( (apply-all (lambda (lines remaining hunk-num)
                      (if (null? remaining)
                          (list "success" lines)
                          (let ( (result (apply-hunk lines (first remaining) fuzz-range) ) )
                            (let ( (status (first result) ) )
                              (if (= status "success")
                                  (apply-all (first (rest result) ) (rest remaining) (+ hunk-num 1) )
                                  (list "error" (first (rest result) ) hunk-num) ) ) ) ) ) ) )
      (apply-all file-lines hunks 1) ) ) )
  
  (validate-hunk (lambda (file-lines hunk fuzz-range)
    (let ( (result (apply-hunk file-lines hunk fuzz-range) ) )
      (let ( (status (first result) ) )
        (if (= status "success")
            (list "valid" "Can apply")
            (list "invalid" (first (rest result) ) ) ) ) ) ) )
  
  (validate-hunks (lambda (file-lines hunks fuzz-range)
    (let ( (validate-all (lambda (remaining hunk-num results)
                         (if (null? remaining)
                             (if (all? (lambda (r) (= (first (first (rest r) ) ) "valid") ) results)
                                 (list "all-valid" results)
                                 (list "some-invalid" results) )
                             (let ( (validation (validate-hunk file-lines (first remaining) fuzz-range) ) )
                               (validate-all (rest remaining)
                                           (+ hunk-num 1)
                                           (append results (list (list hunk-num validation) ) ) ) ) ) ) ) )
      (validate-all hunks 1 (list) ) ) ) )
  
  (patch-apply (lambda (file-lines hunks fuzz-range)
    (apply-hunks file-lines hunks fuzz-range) ) )
  
  (patch-validate (lambda (file-lines hunks fuzz-range)
    (validate-hunks file-lines hunks fuzz-range) ) ) )
  
  ;; Export the main functions
  (list
    (list "patch-apply" patch-apply)
    (list "patch-validate" patch-validate)
    (list "apply-hunk" apply-hunk)
    (list "find-best-match" find-best-match)
    (list "score-position-with-offsets" score-position-with-offsets)
    (list "extract-context-with-positions" extract-context-with-positions) ) )
