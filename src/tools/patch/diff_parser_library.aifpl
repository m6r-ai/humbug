;;; AIFPL Diff Parser Library - Reformatted
;;; Parses unified diff format into structured hunks
;;;
;;; Formatting: One closing paren per line for complex forms

;; Main diff parser implementation
(let (
  ;; ============================================================================
  ;; STRING UTILITIES
  ;; ============================================================================
  
  ;; Check if string starts with prefix
  (string-starts-with? (lambda (str prefix)
    (if (> (string-length prefix) (string-length str))
        #f
        (string=? (substring str 0 (string-length prefix)) prefix)
    ) ; end if
  ) ; end lambda string-starts-with?
  ) ; end string-starts-with? binding
  
  ;; Remove prefix from string if present
  (string-strip-prefix (lambda (str prefix)
    (if (string-starts-with? str prefix)
        (substring str (string-length prefix) (string-length str))
        str
    ) ; end if
  ) ; end lambda string-strip-prefix
  ) ; end string-strip-prefix binding
  
  ;; Check if a string contains only digits (and optional leading minus)
  (is-numeric-string? (lambda (str)
    (if (= (string-length str) 0)
        #f
        (let ((first-char (substring str 0 1)))
          (if (string=? first-char "-")
              ;; Negative number - check rest
              (if (< (string-length str) 2)
                  #f
                  (let ((rest-str (substring str 1 (string-length str))))
                    (all? (lambda (c)
                            (or (string=? c "0") (string=? c "1") (string=? c "2")
                                (string=? c "3") (string=? c "4") (string=? c "5")
                                (string=? c "6") (string=? c "7") (string=? c "8")
                                (string=? c "9"))
                          ) ; end lambda
                          (string->list rest-str)
                    ) ; end all?
                  ) ; end let rest-str
              ) ; end if < length
              ;; Positive number - check all chars
              (all? (lambda (c)
                      (or (string=? c "0") (string=? c "1") (string=? c "2")
                          (string=? c "3") (string=? c "4") (string=? c "5")
                          (string=? c "6") (string=? c "7") (string=? c "8")
                          (string=? c "9"))
                    ) ; end lambda
                    (string->list str)
              ) ; end all?
          ) ; end if = first-char
        ) ; end let first-char
    ) ; end if = length
  ) ; end lambda is-numeric-string?
  ) ; end is-numeric-string? binding
  
  ;; ============================================================================
  ;; FILENAME EXTRACTION
  ;; ============================================================================
  
  ;; Extract clean filename from diff path
  (extract-filename (lambda (path)
    ;; Remove "a/" or "b/" prefix if present
    (let ((without-a (if (string-starts-with? path "a/")
                         (string-strip-prefix path "a/")
                         path
                     ) ; end if
         ) ; end without-a binding
         )
      (let ((without-b (if (string-starts-with? without-a "b/")
                           (string-strip-prefix without-a "b/")
                           without-a
                       ) ; end if
           ) ; end without-b binding
           )
        ;; Remove timestamp (split by tab or multiple spaces)
        (let ((parts (string-split without-b "\t")))
          (if (> (length parts) 0)
              (string-trim (first parts))
              without-b
          ) ; end if
        ) ; end let parts
      ) ; end let without-b
    ) ; end let without-a
  ) ; end lambda extract-filename
  ) ; end extract-filename binding
  
  ;; ============================================================================
  ;; HUNK HEADER PARSING
  ;; ============================================================================
  
  ;; Parse "@@ -1,5 +1,5 @@" into (old-start old-count new-start new-count)
  (parse-hunk-header (lambda (line)
    (if (not (string-starts-with? line "@@"))
        (list "error" "Not a hunk header")
        ;; Extract the part between @@ and @@
        (let ((without-prefix (string-strip-prefix line "@@")))
          (let ((parts (string-split without-prefix "@@")))
            (if (< (length parts) 1)
                (list "error" "Malformed hunk header")
                (let ((range-part (string-trim (first parts))))
                  ;; Split by space to get old and new ranges
                  (let ((ranges (string-split range-part " ")))
                    (if (< (length ranges) 2)
                        (list "error" "Missing range information")
                        (let ((old-range (first ranges))
                              (new-range (first (rest ranges)))
                             )
                          ;; Parse old range: -start,count
                          (let ((old-parsed (parse-range old-range "-")))
                            (if (string=? (first old-parsed) "error")
                                old-parsed
                                (let ((new-parsed (parse-range new-range "+")))
                                  (if (string=? (first new-parsed) "error")
                                      new-parsed
                                      (list "ok"
                                            (first (rest old-parsed))   ; old-start
                                            (first (rest (rest old-parsed)))  ; old-count
                                            (first (rest new-parsed))   ; new-start
                                            (first (rest (rest new-parsed)))  ; new-count
                                      ) ; end list ok
                                  ) ; end if = error
                                ) ; end let new-parsed
                            ) ; end if = error
                          ) ; end let old-parsed
                        ) ; end let old-range/new-range
                    ) ; end if < length
                  ) ; end let ranges
                ) ; end let range-part
            ) ; end if < length
          ) ; end let parts
        ) ; end let without-prefix
    ) ; end if not starts-with
  ) ; end lambda parse-hunk-header
  ) ; end parse-hunk-header binding
  
  ;; Parse "-1,5" or "+1,5" into (start count)
  ;; FIXED: Validate numeric strings before calling string->number
  (parse-range (lambda (range-str prefix)
    (if (not (string-starts-with? range-str prefix))
        (list "error" (string-append "Range doesn't start with " prefix))
        (let ((without-prefix (string-strip-prefix range-str prefix)))
          (let ((parts (string-split without-prefix ",")))
            (if (= (length parts) 0)
                (list "error" "Empty range")
                (let ((start-str (first parts)))
                  (if (not (is-numeric-string? start-str))
                      (list "error" "Invalid start number")
                      (let ((start (string->number start-str)))
                        (if (= (length parts) 1)
                            ;; No comma, count is 1
                            (list "ok" start 1)
                            ;; Has comma, parse count
                            (let ((count-str (first (rest parts))))
                              (if (not (is-numeric-string? count-str))
                                  (list "error" "Invalid count number")
                                  (let ((count (string->number count-str)))
                                    (list "ok" start count)
                                  ) ; end let count
                              ) ; end if not is-numeric
                            ) ; end let count-str
                        ) ; end if = length 1
                      ) ; end let start
                  ) ; end if not is-numeric
                ) ; end let start-str
            ) ; end if = length 0
          ) ; end let parts
        ) ; end let without-prefix
    ) ; end if not starts-with
  ) ; end lambda parse-range
  ) ; end parse-range binding
  
  ;; ============================================================================
  ;; LINE CLASSIFICATION
  ;; ============================================================================
  
  ;; Classify a diff line as context, insert, delete, or skip
  (classify-line (lambda (line)
    (if (= (string-length line) 0)
        (list "context" "")
        (let ((first-char (substring line 0 1)))
          (if (string=? first-char " ")
              (list "context" (substring line 1 (string-length line)))
              (if (string=? first-char "+")
                  (list "insert" (substring line 1 (string-length line)))
                  (if (string=? first-char "-")
                      (list "delete" (substring line 1 (string-length line)))
                      (if (string=? first-char "\\")
                          ;; "\ No newline at end of file" - skip
                          (list "skip" "")
                          ;; Unknown line type, treat as context
                          (list "context" line)
                      ) ; end if = backslash
                  ) ; end if = minus
              ) ; end if = plus
          ) ; end if = space
        ) ; end let first-char
    ) ; end if = length 0
  ) ; end lambda classify-line
  ) ; end classify-line binding
  
  ;; ============================================================================
  ;; FILE HEADER PARSING
  ;; ============================================================================
  
  ;; Find --- and +++ file headers in diff
  ;; FIXED: Use boolean? to check if old-file/new-file are still #f
  (find-file-headers (lambda (lines)
    (let ((find-helper (lambda (remaining old-file new-file)
      (if (null? remaining)
          (if (and (string? old-file) (string? new-file))
              (list "ok" old-file new-file)
              (list "error" "Missing file headers")
          ) ; end if and
          (let ((line (first remaining)))
            (if (and (boolean? old-file) (string-starts-with? line "---"))
                (let ((path (string-trim (string-strip-prefix line "---"))))
                  (find-helper (rest remaining) path new-file)
                ) ; end let path
                (if (and (string? old-file) (boolean? new-file) (string-starts-with? line "+++"))
                    (let ((path (string-trim (string-strip-prefix line "+++"))))
                      (list "ok" old-file path)
                    ) ; end let path
                    (find-helper (rest remaining) old-file new-file)
                ) ; end if and old-file
            ) ; end if and not old-file
          ) ; end let line
      ) ; end if null?
    ) ; end lambda find-helper
    ) ; end find-helper binding
    ) ; end let find-helper
      (find-helper lines #f #f)
    ) ; end let body
  ) ; end lambda find-file-headers
  ) ; end find-file-headers binding
  
  ;; ============================================================================
  ;; HUNK BODY PARSING
  ;; ============================================================================
  
  ;; Parse the body of a hunk (the actual changes)
  (parse-hunk-body (lambda (lines start-idx old-count new-count)
    (let ((parse-helper (lambda (remaining idx changes old-processed new-processed)
      (if (or (null? remaining)
              (and (>= old-processed old-count)
                   (>= new-processed new-count))
          ) ; end or
          ;; Done with this hunk
          (list "ok" changes idx)
          (let ((line (first remaining)))
            ;; Check if we've hit the next hunk
            (if (string-starts-with? line "@@")
                (list "ok" changes idx)
                (let ((classified (classify-line line)))
                  (let ((change-type (first classified))
                        (change-text (first (rest classified)))
                       )
                    (if (string=? change-type "skip")
                        ;; Skip this line
                        (parse-helper (rest remaining) (+ idx 1) changes old-processed new-processed)
                        (if (string=? change-type "context")
                            ;; Context line
                            (parse-helper (rest remaining)
                                        (+ idx 1)
                                        (append changes (list (list "context" change-text)))
                                        (+ old-processed 1)
                                        (+ new-processed 1)
                            ) ; end parse-helper context
                            (if (string=? change-type "delete")
                                ;; Delete line
                                (parse-helper (rest remaining)
                                            (+ idx 1)
                                            (append changes (list (list "delete" change-text)))
                                            (+ old-processed 1)
                                            new-processed
                                ) ; end parse-helper delete
                                (if (string=? change-type "insert")
                                    ;; Insert line
                                    (parse-helper (rest remaining)
                                                (+ idx 1)
                                                (append changes (list (list "insert" change-text)))
                                                old-processed
                                                (+ new-processed 1)
                                    ) ; end parse-helper insert
                                    ;; Unknown, skip
                                    (parse-helper (rest remaining) (+ idx 1) changes old-processed new-processed)
                                ) ; end if = insert
                            ) ; end if = delete
                        ) ; end if = context
                    ) ; end if = skip
                  ) ; end let change-type/change-text
                ) ; end let classified
            ) ; end if starts-with @@
          ) ; end let line
      ) ; end if or
    ) ; end lambda parse-helper
    ) ; end parse-helper binding
    ) ; end let parse-helper
      (if (>= start-idx (length lines))
          (list "ok" (list) start-idx)
          (parse-helper (drop start-idx lines) start-idx (list) 0 0)
      ) ; end if >=
    ) ; end let body
  ) ; end lambda parse-hunk-body
  ) ; end parse-hunk-body binding
  
  ;; ============================================================================
  ;; HUNK PARSING
  ;; ============================================================================
  
  ;; Parse all hunks from lines starting at start-idx
  (parse-hunks (lambda (lines start-idx)
    (let ((parse-all (lambda (idx hunks)
      (if (>= idx (length lines))
          (list "ok" hunks)
          (let ((line (list-ref lines idx)))
            (if (not (string-starts-with? line "@@"))
                ;; Skip non-hunk lines
                (parse-all (+ idx 1) hunks)
                ;; Parse hunk header
                (let ((header-result (parse-hunk-header line)))
                  (if (string=? (first header-result) "error")
                      header-result
                      (let ((old-start (first (rest header-result)))
                            (old-count (first (rest (rest header-result))))
                            (new-start (first (rest (rest (rest header-result)))))
                            (new-count (first (rest (rest (rest (rest header-result))))))
                           )
                        ;; Parse hunk body
                        (let ((body-result (parse-hunk-body lines (+ idx 1) old-count new-count)))
                          (if (string=? (first body-result) "error")
                              body-result
                              (let ((changes (first (rest body-result)))
                                    (next-idx (first (rest (rest body-result))))
                                   )
                                ;; Create hunk structure (0-based indexing)
                                (let ((hunk (list
                                             (list "start-line" (- old-start 1))
                                             (list "old-count" old-count)
                                             (list "new-count" new-count)
                                             (list "changes" changes)
                                            ) ; end hunk list
                                     ) ; end hunk binding
                                     )
                                  (parse-all next-idx (append hunks (list hunk)))
                                ) ; end let hunk
                              ) ; end let changes/next-idx
                          ) ; end if = error
                        ) ; end let body-result
                      ) ; end let old-start/old-count/new-start/new-count
                  ) ; end if = error
                ) ; end let header-result
            ) ; end if not starts-with @@
          ) ; end let line
      ) ; end if >=
    ) ; end lambda parse-all
    ) ; end parse-all binding
    ) ; end let parse-all
      (parse-all start-idx (list))
    ) ; end let body
  ) ; end lambda parse-hunks
  ) ; end parse-hunks binding
  
  ;; ============================================================================
  ;; MAIN PARSE FUNCTION
  ;; ============================================================================
  
  ;; Main function: parse unified diff text into structured format
  (parse-diff-text (lambda (diff-text)
    ;; Split into lines
    (let ((lines (string-split diff-text "\n")))
      ;; Find file headers
      (let ((header-result (find-file-headers lines)))
        (if (string=? (first header-result) "error")
            (list "error" (first (rest header-result)))
            (let ((old-file (first (rest header-result)))
                  (new-file (first (rest (rest header-result))))
                 )
              ;; Extract filename (prefer new file)
              (let ((filename (extract-filename new-file)))
                (let ((final-filename (if (or (string=? filename "") (string=? filename "/dev/null"))
                                          (extract-filename old-file)
                                          filename
                                      ) ; end if or
                     ) ; end final-filename binding
                     )
                  ;; Find where hunks start (after +++ line)
                  (let ((find-hunk-start (lambda (remaining idx)
                    (if (null? remaining)
                        idx
                        (if (string-starts-with? (first remaining) "+++")
                            (+ idx 1)
                            (find-hunk-start (rest remaining) (+ idx 1))
                        ) ; end if starts-with
                    ) ; end if null?
                  ) ; end lambda find-hunk-start
                  ) ; end find-hunk-start binding
                  ) ; end let find-hunk-start
                    (let ((hunk-start-idx (find-hunk-start lines 0)))
                      ;; Parse hunks
                      (let ((hunks-result (parse-hunks lines hunk-start-idx)))
                        (if (string=? (first hunks-result) "error")
                            hunks-result
                            (let ((hunks (first (rest hunks-result))))
                              (list "ok" final-filename hunks)
                            ) ; end let hunks
                        ) ; end if = error
                      ) ; end let hunks-result
                    ) ; end let hunk-start-idx
                  ) ; end let body (find-hunk-start)
                ) ; end let final-filename
              ) ; end let filename
            ) ; end let old-file/new-file
        ) ; end if = error
      ) ; end let header-result
    ) ; end let lines
  ) ; end lambda parse-diff-text
  ) ; end parse-diff-text binding
  
  ;; ============================================================================
  ;; COMBINED PARSE AND APPLY
  ;; ============================================================================
  
  ;; Combined function: parse diff and apply to file lines
  (parse-and-apply (lambda (diff-text file-lines fuzz-range patch-apply-fn)
    ;; Parse the diff
    (let ((parse-result (parse-diff-text diff-text)))
      (if (string=? (first parse-result) "error")
          (list "error" (first (rest parse-result)) 0)
          (let ((filename (first (rest parse-result)))
                (hunks (first (rest (rest parse-result))))
               )
            ;; Apply the patch
            (patch-apply-fn file-lines hunks fuzz-range)
          ) ; end let filename/hunks
      ) ; end if = error
    ) ; end let parse-result
  ) ; end lambda parse-and-apply
  ) ; end parse-and-apply binding

 ) ; end all bindings list
  
  ;; Export functions (this is the body of the let)
  (list
    (list "parse-diff-text" parse-diff-text)
    (list "parse-and-apply" parse-and-apply)
  ) ; end export list
) ; end outer let
