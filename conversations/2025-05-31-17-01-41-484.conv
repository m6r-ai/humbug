{
  "metadata": {
    "version": "0.1"
  },
  "conversation": [
    {
      "id": "8196005b-074f-4728-a4f8-af506cc84185",
      "timestamp": "2025-05-31T17:01:41.803698",
      "type": "user_message",
      "content": "The following preamble describes some elements of a language called Metaphor.  Please pay\nextremely close attention to the details as they will affect the way you interpret\neverything that follows after \"BEGIN DESCRIPTION IN METAPHOR:\"\n\nMetaphor is a structured natural language prompt creation language.  It is designed to\nlet a user convey their requirements to a large language model AI.\n\nMetaphor has the structure of a document tree with branches and leaves being prefixed\nby new sections containing the keywords \"Role:\", \"Context:\" or \"Action:\".  Each of\nthese indicates the start of a new block of information.  Blocks are introduced using\nMarkdown-style headings (using hash symbols).  The number of hashes gives an indication\nof the nesting depth and the parent/child relationship.\n\nBlock keywords have an optional name that will immediately follow them on the same line.\nIf this is missing then the block name is not defined.\n\nAfter a block heading there may be one or more lines of text that will describe the purpose\nof that block.  A block may also include one or more optional child blocks inside them and\nthat further clarify their parent block.\n\nWithin the text of a block, you may be presented with code or document fragments inside a\nblock delimited by 3 backticks.  Please pay close attention to the indentation level of the\nopening 3 backticks.  The identation of such code or document fragments is relative to this,\nnot relative to the block in which the code or document fragment occurs.\n\nIf \"Role:\" block exists then this contains details about the role you should fulfil.  This\nmay also describe specific skills you have, knowledge you should apply, and the\napproach you take to apply these.\n\n\"Context:\" blocks provide context necessary to understand what you will be asked to do.\n\n\"Action:\" blocks describes the task, or tasks, you should do.\n\nIf you are asked to offer any opinions on the Metaphor prompt then always provide the full\nset of parent headings leading up to any block you want to talk about.  This will allow\nthe user to understand which part of the Metaphor prompt is being discussed.\n\nWhen you process the actions please carefully ensure you do all of them accurately and\ncomplete all the elements requested.  Unless otherwise instructed, do not include any\nplaceholders in your responses.\n\nBEGIN DESCRIPTION IN METAPHOR:\n\n# Role:\n\nYou are a world class python programmer, highly skilled in accurate and performant software development.  You\nare going to assist me in making modifications to my application.\n\n# Context:\n\n## Context: Python implementation rules\n\nAs an engineer working with the application, I want the application to be easy to use and understand,\nso I can maintain and enhance it over time.\n\n### Context: Implement in Python 3\n\nThe application will be written in the latest version of Python 3.  Assume a baseline of Python 3.10.\n\n### Context: Indentation of code\n\nCode must be indented by 4 spaces.\n\n### Context: Use docstrings\n\nDocstrings must be used to describe all modules, classes, and functions.  This should follow PEP 257 guidelines.\n\n### Context: Use type hints\n\nType hints must be used for function arguments and return values.\n\nAs we're using Python 3.10 as a minimum, use union types.  E.g. use `T | None` instead of `Optional[T]`.\n\n`self` parameters do not need to have type hints.\n\n### Context: Use comments\n\nComments must be used to describe any complex logic, or rationale that would not be obvious from\nsimply reading the code.  This ensures that anyone reading the code for the first time will be able\nto understand why the code is the way it is.\n\n### Context: PEP 8 imports\n\nThe import list in any module should follow PEP 8 guidelines, including the ordering of imports.\n\n### Context: Avoid unnecessary `elif` and `else` statements\n\nTo improve readability, do not use `elif` or `else` statements if the preceding `if` branch ends with\na `return`, `continue`, or `break`.\n\nFor example, do this:\n\n```python\nif condition:\n    return\n\nnext_statement()\n```\n\ninstead of this:\n\n```python\nif condition:\n    return\nelse:\n    next_statement()\n```\n\n### Context: Handle error and exception paths early\n\nIf it is possible to detect errors and exceptions early then do so.  Always prefer to do this as early\nas possible within the code so we have the fewest possible conditional checks by the time we reach the\nmain purpose of any function or method.\n\nThis is sometimes known as \"flattening the code to the left\" as there is generally less indentation required\nwhen we do this.  This makes the code easier to read.\n\n### Context: Exception handling philosophy\n\n#### Context: Exception documentation\n\nDocument what exceptions each function may raise in its docstring.\n\n#### Context: Handling exceptions\n\nAttempt to handle and mitigate exceptions at the level closest to which they are first\ndetected.  If we cannot handle or mitigate the exception then it should be wrapped in a domain-appropriate\nexception class and this re-raised to the next level up the call stack.\n\nInclude contextual information when wrapping exceptions.\n\nPreserve the exception chain using `raise ... from e` syntax.\n\n#### Context: Avoid bare `except:` or `except Exception:` clauses.\n\nAvoid the use of bare `except:` or `except Exception:` clauses unless a function we are calling\ncan only have exceptions handled this way.\n\nWe should always catch specific exception types that could occur from an operation.\n\n#### Context: Exception logging\n\nAll exceptions should be logged when they occur, before re-raising or wrapping them.\n\nUse appropriate log levels:\n- ERROR for exceptions that indicate failure.\n- WARNING for exceptions that can be handled/recovered from.\n- DEBUG for detailed exception information during development.\n\nWe must include sufficient context in log messages to aid debugging.\n\nLogging must use lazy evaluation of any arguments rather.\n\n#### Context: Exception wrapping example\n\nDo this:\n\n```python\ntry:\n    await self.api_client.fetch_data()\n\nexcept ConnectionError as e:\n    logger.error(\"Failed to retrieve data from API endpoint\", exc_info=True)\n    raise DataFetchError(f\"Failed to retrieve data from API endpoint: {e}\") from e\n\nexcept TimeoutError as e:\n    logger.warning(\"API request timed out, will retry\", exc_info=True)\n```\n\nNot this:\n\n```python\ntry:\n    await self.api_client.fetch_data()\nexcept Exception as e:\n    logger.error(f\"Error: {e}\")  # Insufficient context, no stack trace\n    raise  # No wrapping or additional context\n```\n\n## Context: Dependencies\n\nLeverage standard library tools before custom solutions, unless specifically instructed, or\nunless a depdency is already in use.\n\n## Context: Existing code\n\nThe following files are used in my application:\n\nFile: /Users/dave/github/m6r/humbug/src/humbug/markdown/markdown_ast_builder.py\n\n```python\n\"\"\"\nParser to construct an AST from Markdown.\n\"\"\"\n\nimport logging\nimport re\nfrom typing import Dict, List, Tuple, Any, cast\n\nfrom humbug.markdown.markdown_ast_node import (\n    MarkdownASTNode, MarkdownDocumentNode, MarkdownTextNode, MarkdownLineBreakNode,\n    MarkdownEmphasisNode, MarkdownBoldNode, MarkdownHeadingNode,\n    MarkdownParagraphNode, MarkdownOrderedListNode, MarkdownUnorderedListNode,\n    MarkdownListItemNode, MarkdownInlineCodeNode, MarkdownCodeBlockNode,\n    MarkdownTableNode, MarkdownTableHeaderNode, MarkdownTableBodyNode,\n    MarkdownTableRowNode, MarkdownTableCellNode, MarkdownHorizontalRuleNode,\n    MarkdownImageNode, MarkdownLinkNode\n)\nfrom humbug.syntax.parser_registry import ParserRegistry\nfrom humbug.syntax.programming_language import ProgrammingLanguage\nfrom humbug.syntax.programming_language_utils import ProgrammingLanguageUtils\n\n\nclass MarkdownASTBuilderError(Exception):\n    \"\"\"Exception raised for errors during markdown parsing.\"\"\"\n\n\nclass TableBufferState:\n    \"\"\"Class to track and buffer table elements during parsing.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize the table buffer state.\"\"\"\n        # Buffer for table rows before commitment\n        self.header_rows: List[List[str]] = []\n        self.separator_row: List[str] = []\n        self.body_rows: List[List[str]] = []\n\n        # Table state\n        self.is_in_potential_table: bool = False\n        self.is_confirmed_table: bool = False\n        self.alignments: List[str] = []\n\n        # Line tracking for AST nodes\n        self.start_line: int = -1\n        self.current_line: int = -1\n\n    def reset(self) -> None:\n        \"\"\"Reset the table buffer state.\"\"\"\n        self.header_rows = []\n        self.separator_row = []\n        self.body_rows = []\n        self.is_in_potential_table = False\n        self.is_confirmed_table = False\n        self.alignments = []\n        self.start_line = -1\n        self.current_line = -1\n\n    def is_valid_table(self) -> bool:\n        \"\"\"\n        Check if we have sufficient elements for a valid table.\n\n        Returns:\n            True if we have a header row, separator row, and at least one body row\n        \"\"\"\n        return (len(self.header_rows) > 0 and\n                len(self.separator_row) > 0 and\n                len(self.body_rows) > 0)\n\n\nclass ListState:\n    \"\"\"Tracks the state of a list and its items during parsing.\"\"\"\n\n    def __init__(self, list_node: MarkdownOrderedListNode | MarkdownUnorderedListNode, indent: int) -> None:\n        \"\"\"\n        Initialize a list state tracker.\n\n        Args:\n            list_node: The list node (MarkdownOrderedListNode or MarkdownUnorderedListNode)\n            indent: The indentation level of the list marker\n        \"\"\"\n        self.list_node = list_node\n        self.indent = indent\n        self.marker_length = 0\n        self.last_item: MarkdownListItemNode | None = None\n        self.contains_blank_line = False\n\n\nclass MarkdownASTBuilder:\n    \"\"\"\n    Builder class for constructing an AST from markdown text.\n\n    This class handles the incremental parsing of markdown text into an\n    Abstract Syntax Tree (AST) representation.\n    \"\"\"\n\n    def __init__(self, no_underscores: bool):\n        \"\"\"Initialize the AST builder with regex patterns for markdown elements.\"\"\"\n        self._no_underscores = no_underscores\n        self._source_path: str | None = None\n\n        # Regular expressions for markdown elements\n        self._heading_pattern = re.compile(r'^(#{1,10})\\s+(.*?)(?:\\s+#{1,10})?$', re.MULTILINE)\n        self._unordered_list_pattern = re.compile(r'^(\\s*)([*+-])\\s+(.*?)$', re.MULTILINE)\n        self._ordered_list_pattern = re.compile(r'^(\\s*)(\\d+)\\.[ \\t]+(.*?)$', re.MULTILINE)\n        self._code_block_pattern = re.compile(r'^```(?:([\\w\\-#+./*():\\s]+))?$')\n        self._table_row_pattern = re.compile(r'^(\\|.+\\|)$', re.MULTILINE)\n        self._table_separator_pattern = re.compile(r'^(\\|[\\s:-]+\\|)$', re.MULTILINE)\n        self._horizontal_rule_pattern = re.compile(r'^(?:\\s*(?:[-*_])\\s*){3,}$')\n\n        self._logger = logging.getLogger(\"MarkdownASTBuilder\")\n\n        # Initialize an empty document\n        self._document = MarkdownDocumentNode()\n\n        # Mapping from line numbers to nodes for incremental updates\n        self._line_to_node_map: Dict[int, List[MarkdownASTNode]] = {}\n\n        # Track header IDs to allow us to create unique link anchors for headings with the same text\n        self._used_header_ids: Dict[str, int] = {}\n\n        # List state tracking\n        self._list_stack: List[ListState] = []\n\n        # Text continuation tracking\n        self._last_paragraph: MarkdownParagraphNode | None = None\n        self._last_processed_line_type: str = \"\"\n        self._blank_line_count: int = 0\n\n        # Code block state tracking\n        self._in_code_block = False\n        self._code_block_language = \"\"\n        self._code_block_content: List[str] = []\n        self._code_block_start_line = -1\n        self._code_block_nesting_level = 0\n        self._code_block_indents: List[int] = []\n        self._embedded_parser_state: Any = None\n        self._embedded_language: ProgrammingLanguage = ProgrammingLanguage.UNKNOWN\n\n        # Table state tracking using the new buffer approach\n        self._table_buffer = TableBufferState()\n\n    def document(self) -> MarkdownDocumentNode:\n        \"\"\"\n        Get the current document node.\n\n        Returns:\n            The document node\n        \"\"\"\n        return self._document\n\n    def _should_parse_code_block_as_continuation(\n        self,\n        language: ProgrammingLanguage,\n        line_content: str\n    ) -> bool:\n        \"\"\"\n        Check if a line should be parsed as a continuation by the embedded parser.\n\n        Args:\n            language: The programming language of the code block\n            line_content: The content of the line to check\n\n        Returns:\n            True if this line should be treated as a continuation\n        \"\"\"\n        if language == ProgrammingLanguage.TEXT:\n            return False\n\n        # Get or create parser for this language\n        parser = ParserRegistry.create_parser(language)\n        if not parser:\n            return False\n\n        # If language changed, reset state\n        if language != self._embedded_language:\n            self._embedded_parser_state = None\n            self._embedded_language = language\n\n        try:\n            # Parse the line and check if we're in a continuation\n            new_state = parser.parse(self._embedded_parser_state, line_content)\n\n            # Update stored state\n            self._embedded_parser_state = new_state\n\n            # Return whether we're in a continuation\n            return new_state is not None and new_state.parsing_continuation\n\n        except Exception as e:\n            self._logger.warning(\n                \"Error checking continuation for %s: %s\",\n                language.name,\n                str(e)\n            )\n            return False\n\n    def identify_line_type(self, line: str) -> Tuple[str, Any]:\n        \"\"\"\n        Identify the type of a markdown line.\n\n        Args:\n            line: The line to identify\n\n        Returns:\n            A tuple of (line_type, content) where line_type is one of:\n            'heading', 'unordered_list_item', 'ordered_list_item', 'blank', 'text',\n            'code_block_start', 'code_block_end', 'code_block_content',\n            'table_row', 'table_separator', 'line_break', 'horizontal_rule'\n\n        Raises:\n            None\n        \"\"\"\n        # Handle code block state\n        lstripped_line = line.lstrip()\n        indent = len(line) - len(lstripped_line)\n\n        if self._in_code_block:\n            # Check if our embedded parser indicates this should be a continuation\n            if self._code_block_language:\n                language = ProgrammingLanguageUtils.from_name(self._code_block_language)\n                if self._should_parse_code_block_as_continuation(language, line):\n                    return 'code_block_content', line\n\n            # Check for code fence.  If we have one then we're either closing\n            # this block or nesting another.\n            code_block_match = self._code_block_pattern.match(lstripped_line)\n            if code_block_match:\n                language = code_block_match.group(1)\n                if language is not None or indent > self._code_block_indents[-1]:\n                    self._code_block_nesting_level += 1\n                    self._code_block_indents.append(indent)\n                    return 'code_block_content', line\n\n                self._code_block_indents.pop()\n                self._code_block_nesting_level -= 1\n                if self._code_block_nesting_level == 0:\n                    return 'code_block_end', None\n\n            return 'code_block_content', line\n\n        # Check for code block start\n        code_block_match = self._code_block_pattern.match(lstripped_line)\n        if code_block_match:\n            language = code_block_match.group(1) or \"\"\n            self._code_block_nesting_level = 1\n            self._code_block_indents.append(indent)\n            return 'code_block_start', language\n\n        # Check for a line break\n        if indent >= 2 and not lstripped_line:\n            return 'line_break', None\n\n        # Check for blank line\n        stripped_line = line.strip()\n        if not stripped_line:\n            return 'blank', None\n\n        # Check for heading\n        heading_match = self._heading_pattern.match(line)\n        if heading_match:\n            level = len(heading_match.group(1))\n            content = heading_match.group(2).strip()\n            return 'heading', (level, content)\n\n        # Check for table separator row\n        if stripped_line.startswith('|') and stripped_line.endswith('|'):\n            # Check if it's a separator row with at least one colon or dash\n            if '-' in line and (':-' in line or '-:' in line or '--' in line):\n                return 'table_separator', stripped_line\n\n            # Regular table row\n            return 'table_row', stripped_line\n\n        # Check for unordered list item\n        unordered_match = self._unordered_list_pattern.match(line)\n        if unordered_match:\n            indent = len(unordered_match.group(1))\n            marker = unordered_match.group(2)\n            content = unordered_match.group(3)\n            return 'unordered_list_item', (indent, marker, content)\n\n        # Check for ordered list item\n        ordered_match = self._ordered_list_pattern.match(line)\n        if ordered_match:\n            indent = len(ordered_match.group(1))\n            number = ordered_match.group(2)\n            content = ordered_match.group(3)\n            return 'ordered_list_item', (indent, number, content)\n\n        # Check for horizontal rule\n        if self._horizontal_rule_pattern.match(line):\n            return 'horizontal_rule', None\n\n        # Default to regular text\n        return 'text', line\n\n    def _find_closing_parenthesis(self, text: str, start_pos: int) -> int:\n        \"\"\"\n        Find the closing parenthesis that matches an opening one, handling nested parentheses.\n\n        Args:\n            text: The text to search in\n            start_pos: The position after the opening parenthesis\n\n        Returns:\n            The position of the closing parenthesis, or -1 if not found\n        \"\"\"\n        paren_count = 1\n        pos = start_pos\n\n        while pos < len(text):\n            if text[pos] == '(':\n                paren_count += 1\n\n            elif text[pos] == ')':\n                paren_count -= 1\n                if paren_count == 0:\n                    return pos\n            pos += 1\n\n        return -1\n\n    def _parse_url_and_title(self, url_title: str) -> Tuple[str, str | None]:\n        \"\"\"\n        Parse a URL string that may contain a title in quotes.\n\n        Args:\n            url_title: The string containing URL and optional title\n\n        Returns:\n            A tuple of (url, title) where title may be None\n        \"\"\"\n        # Look for title in quotes\n        title_match = re.search(r'\\s+[\\'\"](.+?)[\\'\"]$', url_title)\n        if title_match:\n            title = title_match.group(1)\n            url = url_title[:title_match.start()].strip()\n            return url, title\n\n        return url_title.strip(), None\n\n    def parse_inline_formatting(self, text: str) -> List[MarkdownASTNode]:\n        \"\"\"\n        Parse inline formatting (bold, italic, inline code) in text and create appropriate AST nodes.\n\n        Args:\n            text: The text to parse\n\n        Returns:\n            A list of AST nodes representing the formatted text\n\n        Raises:\n            None\n        \"\"\"\n        # Check if text has trailing line break\n        has_line_break = text.endswith('  ')\n        if has_line_break:\n            text = text[:-2]\n\n        # Simple state machine for inline formatting\n        i = 0\n        nodes: List[MarkdownASTNode] = []\n        current_text = \"\"\n\n        while i < len(text):\n            # Check for image (highest precedence due to the '!' prefix)\n            if text[i] == '!' and i + 1 < len(text) and text[i+1] == '[':\n                # Look for the closing '](' pattern\n                bracket_end = text.find('](', i + 2)\n                if bracket_end != -1:\n                    # Find closing parenthesis\n                    paren_end = self._find_closing_parenthesis(text, bracket_end + 2)\n                    if paren_end != -1:\n                        # Add any accumulated text before this image\n                        if current_text:\n                            nodes.append(MarkdownTextNode(current_text))\n                            current_text = \"\"\n\n                        # Extract the alt text and URL\n                        alt_text = text[i+2:bracket_end]\n                        url_title = text[bracket_end+2:paren_end]\n                        url, title = self._parse_url_and_title(url_title)\n\n                        # Create image node\n                        image_node = MarkdownImageNode(url, alt_text, title)\n                        nodes.append(image_node)\n\n                        # Move past the closing parenthesis\n                        i = paren_end + 1\n                        continue\n\n            # Check for link\n            elif text[i] == '[':\n                # Look for the closing '](' pattern\n                bracket_end = text.find('](', i + 1)\n                if bracket_end != -1:\n                    # Find closing parenthesis\n                    paren_end = self._find_closing_parenthesis(text, bracket_end + 2)\n                    if paren_end != -1:\n                        # Add any accumulated text before this link\n                        if current_text:\n                            nodes.append(MarkdownTextNode(current_text))\n                            current_text = \"\"\n\n                        # Extract the link text and URL\n                        link_text = text[i+1:bracket_end]\n                        url_title = text[bracket_end+2:paren_end]\n                        url, title = self._parse_url_and_title(url_title)\n\n                        # Create link node\n                        link_node = MarkdownLinkNode(url, title)\n\n                        # Process the content inside the link text recursively\n                        for child_node in self.parse_inline_formatting(link_text):\n                            link_node.add_child(child_node)\n\n                        nodes.append(link_node)\n\n                        # Move past the closing parenthesis\n                        i = paren_end + 1\n                        continue\n\n            # Check for inline code (high precedence)\n            elif text[i] == '`':\n                # Look for the closing backtick\n                end_pos = text.find('`', i + 1)\n                if end_pos != -1:\n                    # Add any accumulated text before this code block\n                    if current_text:\n                        nodes.append(MarkdownTextNode(current_text))\n                        current_text = \"\"\n\n                    # Extract the code content (excluding backticks)\n                    code_content = text[i+1:end_pos]\n                    nodes.append(MarkdownInlineCodeNode(code_content))\n\n                    # Move past the closing backtick\n                    i = end_pos + 1\n                    continue\n\n            # Check for bold formatting\n            elif (i + 1 < len(text) and\n                    ((text[i:i+2] == '**') or (text[i:i+2] == '__' and not self._no_underscores))):\n                # Determine which marker we're using\n                marker = text[i:i+2]\n\n                # Look for the closing marker\n                end_pos = text.find(marker, i + 2)\n                if end_pos != -1:\n                    # Add any accumulated text before this bold block\n                    if current_text:\n                        nodes.append(MarkdownTextNode(current_text))\n                        current_text = \"\"\n\n                    # Extract the bold content (excluding markers)\n                    bold_content = text[i+2:end_pos]\n\n                    # Create bold node and process its content recursively\n                    bold_node = MarkdownBoldNode()\n\n                    # Process the content inside the bold\n                    for child_node in self.parse_inline_formatting(bold_content):\n                        bold_node.add_child(child_node)\n\n                    nodes.append(bold_node)\n\n                    # Move past the closing marker\n                    i = end_pos + 2\n                    continue\n\n            # Check for italic formatting\n            elif (text[i] == '*' or (text[i] == '_' and not self._no_underscores)) and (\n                    i == 0 or text[i-1] != text[i]):  # Avoid mistaking ** as *\n\n                # Determine which marker we're using\n                marker = text[i]\n\n                # Look for the closing marker\n                end_pos = text.find(marker, i + 1)\n                if end_pos != -1 and (end_pos + 1 >= len(text) or text[end_pos+1] != marker):  # Avoid **\n                    # Add any accumulated text before this italic block\n                    if current_text:\n                        nodes.append(MarkdownTextNode(current_text))\n                        current_text = \"\"\n\n                    # Extract the italic content (excluding markers)\n                    italic_content = text[i+1:end_pos]\n\n                    # Create emphasis node and process its content recursively\n                    emphasis_node = MarkdownEmphasisNode()\n\n                    # Process the content inside the emphasis\n                    for child_node in self.parse_inline_formatting(italic_content):\n                        emphasis_node.add_child(child_node)\n\n                    nodes.append(emphasis_node)\n\n                    # Move past the closing marker\n                    i = end_pos + 1\n                    continue\n\n            # No formatting found, accumulate normal text\n            current_text += text[i]\n            i += 1\n\n        # Add any remaining accumulated text\n        if current_text:\n            nodes.append(MarkdownTextNode(current_text))\n\n        # Append a line break node if needed\n        if has_line_break:\n            nodes.append(MarkdownLineBreakNode())\n\n        return nodes\n\n    def _create_id_from_text(self, text: str) -> str:\n        \"\"\"\n        Create a simplified ID from text suitable for HTML anchor links.\n\n        Args:\n            text: The text to convert to an ID\n\n        Returns:\n            A simplified string suitable for use as an element ID\n        \"\"\"\n        # Convert to lowercase\n        text = text.lower()\n\n        # Replace spaces with hyphens\n        text = text.replace(' ', '-')\n\n        # Remove special characters\n        text = re.sub(r'[^a-z0-9-]', '', text)\n\n        # Ensure it doesn't start with a number\n        if text and text[0].isdigit():\n            text = 'h-' + text\n\n        return text\n\n    def parse_heading(self, level: int, content: str, line_num: int) -> None:\n        \"\"\"\n        Parse a heading line and create a heading node.\n\n        Args:\n            level: The heading level (1-6)\n            content: The heading content\n            line_num: The line number\n        \"\"\"\n        anchor_id = self._create_id_from_text(content)\n\n        # Check if this ID already exists.  If it doesn't, then record we've seen it.   If it does,\n        # then add a suffix to it to make it unique.\n        if anchor_id not in self._used_header_ids:\n            self._used_header_ids[anchor_id] = 0\n\n        else:\n            # This ID already exists, increment the counter and append it\n            self._used_header_ids[anchor_id] += 1\n            anchor_id = f\"{anchor_id}-{self._used_header_ids[anchor_id]}\"\n\n        heading = MarkdownHeadingNode(level, anchor_id)\n        for node in self.parse_inline_formatting(content):\n            heading.add_child(node)\n\n        heading.line_start = line_num\n        heading.line_end = line_num\n        self.register_node_line(heading, line_num)\n\n        self._document.add_child(heading)\n\n    def parse_text(self, text: str, line_num: int) -> MarkdownParagraphNode:\n        \"\"\"\n        Parse a text line and create a paragraph node.\n\n        Args:\n            text: The text content\n            line_num: The line number\n        \"\"\"\n        paragraph = MarkdownParagraphNode()\n        for node in self.parse_inline_formatting(text):\n            paragraph.add_child(node)\n\n        paragraph.line_start = line_num\n        paragraph.line_end = line_num\n        self.register_node_line(paragraph, line_num)\n\n        self._document.add_child(paragraph)\n        return paragraph\n\n    def _current_list_state(self) -> ListState | None:\n        \"\"\"\n        Return the current list state or None if not in a list.\n\n        Returns:\n            The current list state or None\n        \"\"\"\n        return self._list_stack[-1] if self._list_stack else None\n\n    def _parent_list_state(self) -> ListState | None:\n        \"\"\"\n        Return the parent list state or None if there's no parent.\n\n        Returns:\n            The parent list state or None\n        \"\"\"\n        return self._list_stack[-2] if len(self._list_stack) > 1 else None\n\n    def _close_lists_at_indent(self, indent: int, consider_marker: bool) -> bool:\n        \"\"\"\n        Close all lists deeper than the given indent level.\n\n        Args:\n            indent: The indentation level\n            consider_marker: Whether to consider the marker length for closing lists\n\n        Returns:\n            True if lists were closed, False otherwise\n        \"\"\"\n        if not self._list_stack:\n            return False\n\n        closed_lists = False\n\n        while self._list_stack:\n            marker_adjust = self._list_stack[-1].marker_length if consider_marker else 0\n            if (self._list_stack[-1].indent + marker_adjust) <= indent:\n                break\n\n            self._list_stack.pop()\n            closed_lists = True\n\n        return closed_lists\n\n    def _find_parent_for_list(self) -> MarkdownASTNode:\n        \"\"\"\n        Find the appropriate parent for a new list.\n\n        Returns:\n            The parent node\n        \"\"\"\n        if not self._list_stack:\n            return self._document\n\n        # Find the last list item of the deepest list to be the parent\n        current_list = self._list_stack[-1]\n        if current_list.last_item:\n            return current_list.last_item\n\n        # If there's no list item yet, go up the stack\n        for i in range(len(self._list_stack) - 2, -1, -1):\n            list_state = self._list_stack[i]\n            if list_state.last_item:\n                return list_state.last_item\n\n        # If no list items found, use the document\n        return self._document\n\n    def find_or_create_ordered_list(self, indent: int, start_number: int) -> MarkdownOrderedListNode:\n        \"\"\"\n        Find or create an ordered list at the given indent level with specified start number.\n\n        Args:\n            indent: The indentation level\n            start_number: The starting number\n\n        Returns:\n            The created ordered list node\n        \"\"\"\n        # Check if we already have an ordered list at this level\n        if self._list_stack and self._list_stack[-1].indent == indent:\n            list_state = self._list_stack[-1]\n            if isinstance(list_state.list_node, MarkdownOrderedListNode):\n                return list_state.list_node\n\n            # Different list type, close it\n            self._list_stack.pop()\n\n        # Find parent\n        parent = self._find_parent_for_list()\n\n        # Create new ordered list\n        new_list = MarkdownOrderedListNode(indent, start_number)\n        parent.add_child(new_list)\n\n        # Create and add list state\n        list_state = ListState(new_list, indent)\n        self._list_stack.append(list_state)\n\n        return new_list\n\n    def find_or_create_unordered_list(self, indent: int) -> MarkdownUnorderedListNode:\n        \"\"\"\n        Find or create an unordered list at the given indent level.\n\n        Args:\n            indent: The indentation level\n\n        Returns:\n            The created unordered list node\n        \"\"\"\n        # Check if we already have an unordered list at this level\n        if self._list_stack and self._list_stack[-1].indent == indent:\n            list_state = self._list_stack[-1]\n            if isinstance(list_state.list_node, MarkdownUnorderedListNode):\n                return list_state.list_node\n\n            # Different list type, close it\n            self._list_stack.pop()\n\n        # Find parent\n        parent = self._find_parent_for_list()\n\n        # Create new unordered list\n        new_list = MarkdownUnorderedListNode(indent)\n        parent.add_child(new_list)\n\n        # Create and add list state\n        list_state = ListState(new_list, indent)\n        self._list_stack.append(list_state)\n\n        return new_list\n\n    def parse_ordered_list_item(self, indent: int, number: str, content: str, line_num: int) -> None:\n        \"\"\"\n        Parse an ordered list item and create a list item node.\n\n        Args:\n            indent: The indentation level\n            number: The list item number (as a string)\n            content: The item content\n            line_num: The line number\n        \"\"\"\n        # Extract the starting number\n        try:\n            start_number = int(number)\n\n        except ValueError:\n            start_number = 1\n\n        # Close deeper lists\n        self._close_lists_at_indent(indent, False)\n\n        # If we're in a list, and we've seen a blank line, then mark the list as loose\n        if self._list_stack and self._blank_line_count > 0:\n            self._list_stack[-1].contains_blank_line = True\n            self._list_stack[-1].list_node.tight = False\n\n        list_node = self.find_or_create_ordered_list(indent, start_number)\n        current_list = cast(ListState, self._current_list_state())\n\n        # Create the list item\n        item = MarkdownListItemNode()\n        list_node.add_child(item)\n\n        # Calculate the actual content indentation for this specific marker\n        current_list.marker_length = len(number) + 2  # +2 for the \".\" and space after number\n\n        # Create a paragraph for the content\n        paragraph = MarkdownParagraphNode()\n        for node in self.parse_inline_formatting(content):\n            paragraph.add_child(node)\n\n        paragraph.line_start = line_num\n        paragraph.line_end = line_num\n        item.add_child(paragraph)\n        self.register_node_line(paragraph, line_num)\n\n        item.line_start = line_num\n        item.line_end = line_num\n        self.register_node_line(item, line_num)\n\n        # Update tracking variables\n        current_list.last_item = item\n        self._last_processed_line_type = 'ordered_list_item'\n\n    def parse_unordered_list_item(self, indent: int, marker: str, content: str, line_num: int) -> None:\n        \"\"\"\n        Parse an unordered list item and create a list item node.\n\n        Args:\n            indent: The indentation level\n            marker: The bullet marker (-, *, +)\n            content: The item content\n            line_num: The line number\n        \"\"\"\n        # Close deeper lists\n        self._close_lists_at_indent(indent, False)\n\n        # If we're in a list, and we've seen a blank line, then mark the list as loose\n        if self._list_stack and self._blank_line_count > 0:\n            self._list_stack[-1].contains_blank_line = True\n            self._list_stack[-1].list_node.tight = False\n\n        list_node = self.find_or_create_unordered_list(indent)\n        current_list = cast(ListState, self._current_list_state())\n\n        # Create the list item\n        item = MarkdownListItemNode()\n        list_node.add_child(item)\n\n        # Calculate the actual content indentation for this specific marker\n        current_list.marker_length = len(marker) + 1  # +1 for the space after marker\n\n        # Create a paragraph for the content\n        paragraph = MarkdownParagraphNode()\n        for node in self.parse_inline_formatting(content):\n            paragraph.add_child(node)\n\n        paragraph.line_start = line_num\n        paragraph.line_end = line_num\n        item.add_child(paragraph)\n        self.register_node_line(paragraph, line_num)\n\n        item.line_start = line_num\n        item.line_end = line_num\n        self.register_node_line(item, line_num)\n\n        # Update tracking variables\n        current_list.last_item = item\n        self._last_processed_line_type = 'unordered_list_item'\n\n    def parse_horizontal_rule(self, line_num: int) -> MarkdownHorizontalRuleNode:\n        \"\"\"\n        Parse a horizontal rule line and create a horizontal rule node.\n\n        Args:\n            line_num: The line number\n\n        Returns:\n            A horizontal rule node\n        \"\"\"\n        horizontal_rule = MarkdownHorizontalRuleNode()\n        horizontal_rule.line_start = line_num\n        horizontal_rule.line_end = line_num\n        self.register_node_line(horizontal_rule, line_num)\n\n        return horizontal_rule\n\n    def _parse_table_separator(self, separator_line: str) -> List[str]:\n        \"\"\"\n        Parse a table separator line to determine column alignments.\n\n        Args:\n            separator_line: A line containing the table column separators (e.g., |---|:---:|--:|)\n\n        Returns:\n            List of alignment strings ('left', 'center', 'right') for each column\n        \"\"\"\n        cells = [cell.strip() for cell in separator_line.split('|')[1:-1]]\n        alignments = []\n\n        for cell in cells:\n            if cell.startswith(':') and cell.endswith(':'):\n                alignments.append('center')\n\n            elif cell.endswith(':'):\n                alignments.append('right')\n\n            else:\n                alignments.append('left')\n\n        return alignments\n\n    def _handle_table_row(self, line: str, line_num: int) -> None:\n        \"\"\"\n        Handle a table row line in the parsing process.\n\n        Args:\n            line: The table row line\n            line_num: The line number\n\n        Returns:\n            None\n        \"\"\"\n        # If this is the first potential table row\n        if not self._table_buffer.is_in_potential_table:\n            self._table_buffer.is_in_potential_table = True\n            self._table_buffer.start_line = line_num\n\n            # Store this as a header row\n            cells = [cell.strip() for cell in line.split('|')[1:-1]]\n            self._table_buffer.header_rows.append(cells)\n\n        elif self._table_buffer.is_confirmed_table:\n            # This is a body row\n            cells = [cell.strip() for cell in line.split('|')[1:-1]]\n            self._table_buffer.body_rows.append(cells)\n\n        else:\n            # This is another potential header row\n            cells = [cell.strip() for cell in line.split('|')[1:-1]]\n            self._table_buffer.header_rows.append(cells)\n\n        self._table_buffer.current_line = line_num\n\n    def _handle_table_separator(self, line: str, line_num: int) -> None:\n        \"\"\"\n        Handle a table separator line in the parsing process.\n\n        Args:\n            line: The table separator line\n            line_num: The line number\n\n        Returns:\n            None\n        \"\"\"\n        # If we're not already in a potential table, ignore it\n        if not self._table_buffer.is_in_potential_table:\n            # Treat as normal text\n            self.parse_text(line, line_num)\n            return\n\n        # Store the separator row\n        cells = [cell.strip() for cell in line.split('|')[1:-1]]\n        self._table_buffer.separator_row = cells\n\n        # Parse alignments\n        self._table_buffer.alignments = self._parse_table_separator(line)\n        self._table_buffer.current_line = line_num\n\n        # Mark as a confirmed table now that we have a separator\n        self._table_buffer.is_confirmed_table = True\n\n    def _create_table_from_buffer(self) -> None:\n        \"\"\"\n        Create a table node from the buffered content.\n\n        Returns:\n            None\n        \"\"\"\n        # Create the table structure\n        table_node = MarkdownTableNode()\n        header_node = MarkdownTableHeaderNode()\n        body_node = MarkdownTableBodyNode()\n\n        # Set line information\n        table_node.line_start = self._table_buffer.start_line\n        table_node.line_end = self._table_buffer.current_line\n        header_node.line_start = self._table_buffer.start_line\n\n        # Add header and body to table\n        table_node.add_child(header_node)\n        table_node.add_child(body_node)\n\n        # Process header rows\n        for i, row_cells in enumerate(self._table_buffer.header_rows):\n            row_node = MarkdownTableRowNode()\n            row_line = self._table_buffer.start_line + i\n            row_node.line_start = row_line\n            row_node.line_end = row_line\n\n            for j, cell_content in enumerate(row_cells):\n                # Determine alignment\n                alignment = 'left'\n                if j < len(self._table_buffer.alignments):\n                    alignment = self._table_buffer.alignments[j]\n\n                # Create cell\n                cell_node = MarkdownTableCellNode(is_header=True, alignment=alignment)\n\n                # Add content to cell\n                for text_node in self.parse_inline_formatting(cell_content):\n                    cell_node.add_child(text_node)\n\n                row_node.add_child(cell_node)\n\n            header_node.add_child(row_node)\n            self.register_node_line(row_node, row_line)\n\n        # Set header end line\n        header_node.line_end = self._table_buffer.start_line + len(self._table_buffer.header_rows) - 1\n\n        # Process body rows\n        body_start_line = self._table_buffer.start_line + len(self._table_buffer.header_rows) + 1\n        body_node.line_start = body_start_line\n\n        for i, row_cells in enumerate(self._table_buffer.body_rows):\n            row_node = MarkdownTableRowNode()\n            row_line = body_start_line + i\n            row_node.line_start = row_line\n            row_node.line_end = row_line\n\n            for j, cell_content in enumerate(row_cells):\n                # Determine alignment\n                alignment = 'left'\n                if j < len(self._table_buffer.alignments):\n                    alignment = self._table_buffer.alignments[j]\n\n                # Create cell\n                cell_node = MarkdownTableCellNode(is_header=False, alignment=alignment)\n\n                # Add content to cell\n                for text_node in self.parse_inline_formatting(cell_content):\n                    cell_node.add_child(text_node)\n\n                row_node.add_child(cell_node)\n\n            body_node.add_child(row_node)\n            self.register_node_line(row_node, row_line)\n\n        body_node.line_end = self._table_buffer.current_line\n\n        # Add the table to the document\n        self._document.add_child(table_node)\n\n        # Register table with line mappings\n        for i in range(self._table_buffer.start_line, self._table_buffer.current_line + 1):\n            self.register_node_line(table_node, i)\n\n        # Reset table buffer\n        self._table_buffer.reset()\n\n    def _handle_incomplete_table(self) -> None:\n        \"\"\"\n        Handle buffered table content that doesn't form a complete table.\n        Convert it to regular paragraphs.\n\n        Returns:\n            None\n        \"\"\"\n        # Render header rows as regular text\n        for i, row in enumerate(self._table_buffer.header_rows):\n            line_num = self._table_buffer.start_line + i\n            # Convert back to text line\n            line_text = '|' + '|'.join(row) + '|'\n            self.parse_text(line_text, line_num)\n\n        # Handle separator if present\n        if self._table_buffer.separator_row:\n            line_num = self._table_buffer.start_line + len(self._table_buffer.header_rows)\n            # Reconstruct separator line\n            parts = []\n            for alignment in self._table_buffer.alignments:\n                if alignment == 'center':\n                    parts.append(':---:')\n\n                elif alignment == 'right':\n                    parts.append('---:')\n\n                else:\n                    parts.append('---')\n\n            line_text = '|' + '|'.join(parts) + '|'\n            self.parse_text(line_text, line_num)\n\n        # Handle any body rows\n        body_start = self._table_buffer.start_line + len(self._table_buffer.header_rows)\n        if self._table_buffer.separator_row:\n            body_start += 1\n\n        for i, row in enumerate(self._table_buffer.body_rows):\n            line_num = body_start + i\n            # Convert back to text line\n            line_text = '|' + '|'.join(row) + '|'\n            self.parse_text(line_text, line_num)\n\n        # Reset table buffer\n        self._table_buffer.reset()\n\n    def register_node_line(self, node: MarkdownASTNode, line_num: int) -> None:\n        \"\"\"\n        Register a node with a line number for later reference.\n\n        Args:\n            node: The AST node\n            line_num: The line number\n\n        Returns:\n            None\n\n        Raises:\n            None\n        \"\"\"\n        if line_num not in self._line_to_node_map:\n            self._line_to_node_map[line_num] = []\n\n        self._line_to_node_map[line_num].append(node)\n\n    def _finalize_code_block(self, end_line: int) -> None:\n        \"\"\"\n        Finalize a code block that might be unclosed at document end.\n\n        Args:\n            end_line: The last line number in the document\n\n        Returns:\n            None\n        \"\"\"\n        # Create a code block node for the unclosed block\n        code_block = MarkdownCodeBlockNode(\n            language=self._code_block_language,\n            content='\\n'.join(self._code_block_content)\n        )\n        code_block.line_start = self._code_block_start_line\n        code_block.line_end = end_line\n\n        # Add to document\n        self._document.add_child(code_block)\n\n        # Register code block with all lines it spans\n        for i in range(self._code_block_start_line, end_line + 1):\n            self.register_node_line(code_block, i)\n\n        # Reset code block state\n        self._in_code_block = False\n        self._code_block_language = \"\"\n        self._code_block_content = []\n        self._code_block_start_line = -1\n        self._code_block_nesting_level = 0\n        self._code_block_indents = []\n        self._embedded_parser_state = None\n        self._embedded_language = ProgrammingLanguage.UNKNOWN\n\n    def _handle_text_continuation(self, text: str, line_num: int) -> bool:\n        \"\"\"\n        Handle text as a continuation of the previous paragraph or list item.\n        A text line is a continuation of a list item if it is indented\n        by at least the same amount as the list item's content indent.\n\n        Args:\n            text: The text content\n            line_num: The line number\n\n        Returns:\n            True if handled as a continuation, False otherwise\n        \"\"\"\n        # Case 1: Continue a paragraph\n        if self._last_paragraph and self._last_processed_line_type == 'text':\n            # Add a space between the continued text as long as we didn't just have a line break\n            if not isinstance(self._last_paragraph.children[-1], MarkdownLineBreakNode):\n                self._last_paragraph.add_child(MarkdownTextNode(\" \"))\n\n            for node in self.parse_inline_formatting(text):\n                self._last_paragraph.add_child(node)\n\n            self._last_paragraph.line_end = line_num\n            self.register_node_line(self._last_paragraph, line_num)\n            return True\n\n        # Case 2: Continue a list item paragraph\n        if self._list_stack and self._last_processed_line_type in ('unordered_list_item', 'ordered_list_item', 'blank', 'text'):\n            # Get the indentation of the current line\n            current_indent = len(text) - len(text.lstrip())\n\n            if self._close_lists_at_indent(current_indent, True):\n                # We closed one or more lists, we should treat it as if a blank line was encountered\n                # This will ensure proper formatting when returning to an outer list\n                if self._list_stack:\n                    self._last_processed_line_type = 'blank'\n                    self._blank_line_count = 1\n\n                # Reset the paragraph continuity as well\n                self._last_paragraph = None\n\n            # If we're continuing a list item and we've seen a blank line, mark the list as loose\n            if self._list_stack and self._blank_line_count > 0:\n                self._list_stack[-1].contains_blank_line = True\n                self._list_stack[-1].list_node.tight = False\n\n            list_state = self._current_list_state()\n            if not list_state or not list_state.last_item:\n                return False\n\n            formatted_text = text.lstrip()\n\n            # Find the paragraph within the last list item and continue it\n            last_item = list_state.last_item\n            paragraph = cast(MarkdownParagraphNode, last_item.children[-1])\n\n            # If we weren't just preceded by a line break then add a space\n            if paragraph.children and not isinstance(paragraph.children[-1], MarkdownLineBreakNode):\n                paragraph.add_child(MarkdownTextNode(\" \"))\n\n            for node in self.parse_inline_formatting(formatted_text):\n                paragraph.add_child(node)\n\n            paragraph.line_end = line_num\n            self.register_node_line(paragraph, line_num)\n\n            last_item.line_end = line_num\n            self.register_node_line(last_item, line_num)\n            return True\n\n        return False\n\n    def _reset_list_state(self) -> None:\n        \"\"\"Reset all list tracking state.\"\"\"\n        self._list_stack = []\n\n    def parse_line(self, line: str, line_num: int) -> None:\n        \"\"\"\n        Parse a single line and add the resulting nodes to the AST.\n\n        Args:\n            line: The line to parse\n            line_num: The line number\n\n        Returns:\n            None\n\n        Raises:\n            MarkdownASTBuilderError: If there's an error parsing the line\n        \"\"\"\n        try:\n            line_type, content = self.identify_line_type(line)\n\n            # Reset paragraph tracking if not continuing text\n            if line_type not in ('text', 'blank', 'line_break'):\n                self._last_paragraph = None\n\n            # Handle table ends when a non-table line is encountered\n            if self._table_buffer.is_in_potential_table and line_type not in ('table_row', 'table_separator'):\n                # Check if we have a complete table to create\n                if self._table_buffer.is_valid_table():\n                    self._create_table_from_buffer()\n\n                else:\n                    # Not a valid table, render as regular text\n                    self._handle_incomplete_table()\n\n            if line_type == 'line_break':\n                self._document.add_child(MarkdownLineBreakNode())\n                return\n\n            if line_type == 'blank':\n                self._blank_line_count += 1\n                self._last_processed_line_type = line_type\n                return\n\n            if line_type == 'unordered_list_item':\n                indent, marker, text = content\n                self.parse_unordered_list_item(indent, marker, text, line_num)\n                self._last_processed_line_type = line_type\n                self._blank_line_count = 0\n                return\n\n            if line_type == 'ordered_list_item':\n                indent, number, text = content\n                self.parse_ordered_list_item(indent, number, text, line_num)\n                self._last_processed_line_type = line_type\n                self._blank_line_count = 0\n                return\n\n            if line_type == 'code_block_start':\n                self._in_code_block = True\n                self._code_block_language = content\n                self._code_block_content = []\n                self._code_block_start_line = line_num\n                self._last_processed_line_type = line_type\n                self._blank_line_count = 0\n                return\n\n            if line_type == 'code_block_content':\n                self._code_block_content.append(content)\n                self._last_processed_line_type = line_type\n                self._blank_line_count = 0\n                return\n\n            if line_type == 'code_block_end':\n                self._finalize_code_block(line_num)\n                self._reset_list_state()\n                self._last_processed_line_type = line_type\n                self._blank_line_count = 0\n                return\n\n            # Handle table-related lines\n            if line_type == 'table_row':\n                self._handle_table_row(content, line_num)\n                self._last_processed_line_type = line_type\n                self._blank_line_count = 0\n                return\n\n            if line_type == 'table_separator':\n                self._handle_table_separator(content, line_num)\n                self._last_processed_line_type = line_type\n                self._blank_line_count = 0\n                return\n\n            # Process other line types\n            if line_type == 'heading':\n                level, heading_text = content\n                self.parse_heading(level, heading_text, line_num)\n                self._reset_list_state()\n                self._last_processed_line_type = line_type\n                self._blank_line_count = 0\n                return\n\n            if line_type == 'horizontal_rule':\n                horizontal_rule = self.parse_horizontal_rule(line_num)\n                self._document.add_child(horizontal_rule)\n                self._reset_list_state()\n                self._last_processed_line_type = line_type\n                self._blank_line_count = 0\n                return\n\n            # We have text left\n            # Try to handle as a continuation first\n            if self._handle_text_continuation(content, line_num):\n                self._last_processed_line_type = line_type\n                return\n\n            # Regular paragraph\n            paragraph = self.parse_text(content, line_num)\n            self._last_paragraph = paragraph\n            self._reset_list_state()\n            self._last_processed_line_type = line_type\n            self._blank_line_count = 0\n\n        except Exception as e:\n            self._logger.exception(\"Error parsing line %d: %s\", line_num, line)\n            raise MarkdownASTBuilderError(f\"Failed to parse line {line_num}: {e}\") from e\n\n    def build_ast(self, text: str) -> MarkdownDocumentNode:\n        \"\"\"\n        Build a complete AST from the given text.\n\n        Args:\n            text: The markdown text to parse\n\n        Returns:\n            The document root node\n\n        Raises:\n            MarkdownASTBuilderError: If there's an error parsing the text\n        \"\"\"\n        self._document = MarkdownDocumentNode(self._source_path)\n        self._line_to_node_map = {}\n        self._reset_list_state()\n        self._last_paragraph = None\n        self._last_processed_line_type = \"\"\n        self._blank_line_count = 0\n        self._in_code_block = False\n        self._code_block_language = \"\"\n        self._code_block_content = []\n        self._code_block_start_line = -1\n        self._code_block_nesting_level = 0\n        self._code_block_indents = []\n\n        # Reset table buffer\n        self._table_buffer.reset()\n\n        # Parse line by line\n        lines = text.split('\\n')\n        for i, line in enumerate(lines):\n            self.parse_line(line, i)\n\n        # Check for any buffered table content at the end of the document\n        if self._table_buffer.is_in_potential_table:\n            if self._table_buffer.is_valid_table():\n                self._create_table_from_buffer()\n\n            else:\n                self._handle_incomplete_table()\n\n        # Handle case where document ends while still in a code block\n        if self._in_code_block:\n            self._finalize_code_block(len(lines) - 1)\n\n        return self._document\n\n    def update_ast(self, text: str, previous_text: str, path: str | None = None) -> MarkdownDocumentNode:\n        \"\"\"\n        Update the AST incrementally based on changes between previous_text and text.\n\n        Args:\n            text: The new markdown text\n            previous_text: The previous markdown text, or None if this is the first update\n            path: Optional path to the source markdown file\n\n        Returns:\n            The updated document root node\n\n        Raises:\n            MarkdownASTBuilderError: If there's an error updating the AST\n        \"\"\"\n        self._source_path = path\n        if previous_text is None or not self._document.children:\n            # First update or empty document, build from scratch\n            return self.build_ast(text)\n\n        # Split into lines\n        new_lines = text.split('\\n')\n        old_lines = previous_text.split('\\n')\n\n        # Find common prefix length (unchanged lines)\n        common_prefix_len = 0\n        for i, (old, new) in enumerate(zip(old_lines, new_lines)):\n            if old == new:\n                common_prefix_len = i + 1\n\n            else:\n                break\n\n        # Find common suffix length (unchanged lines from the end)\n        common_suffix_len = 0\n        for i, (old, new) in enumerate(zip(reversed(old_lines), reversed(new_lines))):\n            if old == new and common_prefix_len + common_suffix_len < min(len(old_lines), len(new_lines)):\n                common_suffix_len = i + 1\n\n            else:\n                break\n\n        # Calculate changed region\n        start = common_prefix_len\n        old_end = len(old_lines) - common_suffix_len\n        new_end = len(new_lines) - common_suffix_len\n\n        # If nothing changed, return existing document\n        if start >= old_end and start >= new_end:\n            return self._document\n\n        # For now, just rebuild the entire AST\n        # In the future we might implement incremental updates\n        return self.build_ast(text)\n```\n\nI have the following test files being used to test the AST builder:\n\nFile: /Users/dave/github/m6r/humbug/tests/markdown/test_markdown_ast_builder.py\n\n```python\n\"\"\"\nTests for the markdown AST builder\n\"\"\"\nimport os\nimport pytest\n\nfrom humbug.markdown.markdown_ast_builder import MarkdownASTBuilder, MarkdownASTBuilderError\nfrom test_utils import (\n    find_test_files,\n    parse_and_compare\n)\n\n\n@pytest.fixture\ndef ast_builder():\n    \"\"\"Fixture providing a markdown AST builder instance.\"\"\"\n    return MarkdownASTBuilder(no_underscores=False)\n\n\n@pytest.fixture\ndef ast_builder_no_underscores():\n    \"\"\"Fixture providing a markdown AST builder instance with underscores disabled.\"\"\"\n    return MarkdownASTBuilder(no_underscores=True)\n\n\nclass TestMarkdownASTBuilder:\n    \"\"\"Tests for the MarkdownASTBuilder class.\"\"\"\n\n    @pytest.mark.parametrize(\"markdown_path,expected_json_path\", find_test_files())\n    def test_parse_fixture_files(self, markdown_path, expected_json_path):\n        \"\"\"Test parsing markdown files against expected JSON outputs.\"\"\"\n        is_match, diff = parse_and_compare(markdown_path, expected_json_path)\n        assert is_match, f\"AST mismatch for {os.path.basename(markdown_path)}:\\n{diff}\"\n\n    def test_empty_document(self, ast_builder):\n        \"\"\"Test parsing an empty document.\"\"\"\n        doc = ast_builder.build_ast(\"\")\n        assert doc is not None\n        assert len(doc.children) == 0\n\n    def test_simple_paragraph(self, ast_builder):\n        \"\"\"Test parsing a simple paragraph.\"\"\"\n        doc = ast_builder.build_ast(\"This is a paragraph.\")\n        assert doc is not None\n        assert len(doc.children) == 1\n        assert doc.children[0].__class__.__name__ == \"MarkdownParagraphNode\"\n        assert len(doc.children[0].children) == 1\n        assert doc.children[0].children[0].__class__.__name__ == \"MarkdownTextNode\"\n        assert doc.children[0].children[0].content == \"This is a paragraph.\"\n\n    def test_heading(self, ast_builder):\n        \"\"\"Test parsing a heading.\"\"\"\n        doc = ast_builder.build_ast(\"# Heading 1\")\n        assert doc is not None\n        assert len(doc.children) == 1\n        assert doc.children[0].__class__.__name__ == \"MarkdownHeadingNode\"\n        assert doc.children[0].level == 1\n        assert len(doc.children[0].children) == 1\n        assert doc.children[0].children[0].__class__.__name__ == \"MarkdownTextNode\"\n        assert doc.children[0].children[0].content == \"Heading 1\"\n\n    def test_bold_text(self, ast_builder):\n        \"\"\"Test parsing bold text.\"\"\"\n        doc = ast_builder.build_ast(\"This is **bold** text.\")\n        assert doc is not None\n        assert len(doc.children) == 1\n        paragraph = doc.children[0]\n        assert paragraph.__class__.__name__ == \"MarkdownParagraphNode\"\n        assert len(paragraph.children) == 3\n        assert paragraph.children[0].__class__.__name__ == \"MarkdownTextNode\"\n        assert paragraph.children[0].content == \"This is \"\n        assert paragraph.children[1].__class__.__name__ == \"MarkdownBoldNode\"\n        assert paragraph.children[1].children[0].__class__.__name__ == \"MarkdownTextNode\"\n        assert paragraph.children[1].children[0].content == \"bold\"\n        assert paragraph.children[2].__class__.__name__ == \"MarkdownTextNode\"\n        assert paragraph.children[2].content == \" text.\"\n\n    def test_underscore_formatting(self, ast_builder, ast_builder_no_underscores):\n        \"\"\"Test underscore formatting behavior.\"\"\"\n        # With underscores enabled\n        doc = ast_builder.build_ast(\"_italic_ and __bold__\")\n        assert doc.children[0].children[0].__class__.__name__ == \"MarkdownEmphasisNode\"\n        assert doc.children[0].children[2].__class__.__name__ == \"MarkdownBoldNode\"\n\n        # With underscores disabled\n        doc = ast_builder_no_underscores.build_ast(\"_italic_ and __bold__\")\n        assert doc.children[0].children[0].__class__.__name__ == \"MarkdownTextNode\"\n        assert doc.children[0].children[0].content == \"_italic_ and __bold__\"\n\n    def test_nested_formatting(self, ast_builder):\n        \"\"\"Test nested formatting.\"\"\"\n        doc = ast_builder.build_ast(\"This is **bold with *italic* inside**.\")\n        paragraph = doc.children[0]\n        bold_node = paragraph.children[1]\n        assert bold_node.__class__.__name__ == \"MarkdownBoldNode\"\n        assert len(bold_node.children) == 3\n        assert bold_node.children[0].__class__.__name__ == \"MarkdownTextNode\"\n        assert bold_node.children[0].content == \"bold with \"\n        assert bold_node.children[1].__class__.__name__ == \"MarkdownEmphasisNode\"\n\n    def test_unordered_list(self, ast_builder):\n        \"\"\"Test parsing an unordered list.\"\"\"\n        markdown = \"\"\"\n- Item 1\n- Item 2\n- Item 3\n\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        assert len(doc.children) == 1\n        list_node = doc.children[0]\n        assert list_node.__class__.__name__ == \"MarkdownUnorderedListNode\"\n        assert len(list_node.children) == 3\n        for item in list_node.children:\n            assert item.__class__.__name__ == \"MarkdownListItemNode\"\n\n    def test_ordered_list(self, ast_builder):\n        \"\"\"Test parsing an ordered list.\"\"\"\n        markdown = \"\"\"\n1. First item\n2. Second item\n3. Third item\n\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        assert len(doc.children) == 1\n        list_node = doc.children[0]\n        assert list_node.__class__.__name__ == \"MarkdownOrderedListNode\"\n        assert len(list_node.children) == 3\n        assert list_node.start == 1\n\n    def test_nested_list(self, ast_builder):\n        \"\"\"Test parsing a nested list.\"\"\"\n        markdown = \"\"\"\n- Item 1\n  - Nested 1.1\n  - Nested 1.2\n- Item 2\n- Item 3\n\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        assert len(doc.children) == 1\n        list_node = doc.children[0]\n        assert len(list_node.children) == 3\n\n        # Check first item has a nested list\n        first_item = list_node.children[0]\n        assert len(first_item.children) == 2\n        nested_list = first_item.children[0]\n        assert nested_list.__class__.__name__ == \"MarkdownParagraphNode\"\n        nested_list = first_item.children[1]\n        assert nested_list.__class__.__name__ == \"MarkdownUnorderedListNode\"\n        assert len(nested_list.children) == 2\n\n    def test_code_block(self, ast_builder):\n        \"\"\"Test parsing a code block.\"\"\"\n        markdown = \"\"\"```python\ndef hello():\n    print(\"Hello, world!\")\n```\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        assert len(doc.children) == 1\n        code_block = doc.children[0]\n        assert code_block.__class__.__name__ == \"MarkdownCodeBlockNode\"\n        assert code_block.language == \"python\"\n        assert \"def hello():\" in code_block.content\n        assert \"print(\\\"Hello, world!\\\")\" in code_block.content\n\n    def test_table(self, ast_builder):\n        \"\"\"Test parsing a table.\"\"\"\n        markdown = \"\"\"\n| Header 1 | Header 2 |\n|----------|----------|\n| Cell 1   | Cell 2   |\n| Cell 3   | Cell 4   |\n\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        assert len(doc.children) == 1\n        table = doc.children[0]\n        assert table.__class__.__name__ == \"MarkdownTableNode\"\n        assert len(table.children) == 2\n\n        # Check header\n        header = table.children[0]\n        assert header.__class__.__name__ == \"MarkdownTableHeaderNode\"\n        assert len(header.children) == 1  # One row\n\n        # Check body\n        body = table.children[1]\n        assert body.__class__.__name__ == \"MarkdownTableBodyNode\"\n        assert len(body.children) == 2  # Two rows\n\n    def test_horizontal_rule(self, ast_builder):\n        \"\"\"Test parsing a horizontal rule.\"\"\"\n        markdown = \"\"\"\nBefore rule\n\n---\n\nAfter rule\n\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        assert len(doc.children) == 3\n        assert doc.children[0].__class__.__name__ == \"MarkdownParagraphNode\"\n        assert doc.children[1].__class__.__name__ == \"MarkdownHorizontalRuleNode\"\n        assert doc.children[2].__class__.__name__ == \"MarkdownParagraphNode\"\n\n    def test_link(self, ast_builder):\n        \"\"\"Test parsing a link.\"\"\"\n        doc = ast_builder.build_ast(\"Here is a [link](https://example.com) to a website.\")\n        paragraph = doc.children[0]\n        assert len(paragraph.children) == 3\n        link = paragraph.children[1]\n        assert link.__class__.__name__ == \"MarkdownLinkNode\"\n        assert link.url == \"https://example.com\"\n        assert len(link.children) == 1\n        assert link.children[0].content == \"link\"\n\n    def test_image(self, ast_builder):\n        \"\"\"Test parsing an image.\"\"\"\n        doc = ast_builder.build_ast(\"![Alt text](image.jpg \\\"Image title\\\")\")\n        paragraph = doc.children[0]\n        image = paragraph.children[0]\n        assert image.__class__.__name__ == \"MarkdownImageNode\"\n        assert image.url == \"image.jpg\"\n        assert image.alt_text == \"Alt text\"\n        assert image.title == \"Image title\"\n\n    def test_line_to_node_mapping(self, ast_builder):\n        \"\"\"Test the line to node mapping functionality.\"\"\"\n        markdown = \"\"\"# Heading\n\nParagraph 1.\n\nParagraph 2.\n\"\"\"\n        ast_builder.build_ast(markdown)\n\n        # Check mapping exists for each line\n        assert 0 in ast_builder._line_to_node_map  # Heading\n        assert 2 in ast_builder._line_to_node_map  # Paragraph 1\n        assert 4 in ast_builder._line_to_node_map  # Paragraph 2\n\n    def test_update_ast(self, ast_builder):\n        \"\"\"Test updating an AST incrementally.\"\"\"\n        original = \"# Original heading\\n\\nOriginal paragraph.\"\n        updated = \"# Updated heading\\n\\nUpdated paragraph.\"\n\n        # Build original AST\n        ast_builder.build_ast(original)\n\n        # Update AST\n        doc = ast_builder.update_ast(updated, original)\n\n        # Check that the AST was updated\n        assert doc.children[0].children[0].content == \"Updated heading\"\n        assert doc.children[1].children[0].content == \"Updated paragraph.\"\n\n    def test_ast_builder_error(self):\n        \"\"\"Test that ast_builder errors are raised appropriately.\"\"\"\n        # Create a ast_builder with a broken regex to force an error\n        broken_ast_builder = MarkdownASTBuilder(no_underscores=False)\n        broken_ast_builder._heading_pattern = None  # type: ignore\n\n        with pytest.raises(MarkdownASTBuilderError):\n            broken_ast_builder.parse_line(\"# This should fail\", 0)\n\n\nclass TestEdgeCases:\n    \"\"\"Tests for edge cases and error conditions.\"\"\"\n\n    def test_unclosed_code_block(self, ast_builder):\n        \"\"\"Test handling of unclosed code blocks.\"\"\"\n        markdown = \"\"\"```python\ndef unclosed_function():\n    print(\"This code block is not closed\")\n\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        assert len(doc.children) == 1\n        code_block = doc.children[0]\n        assert code_block.__class__.__name__ == \"MarkdownCodeBlockNode\"\n        assert code_block.language == \"python\"\n\n    def test_nested_code_blocks(self, ast_builder):\n        \"\"\"Test handling of nested code blocks.\"\"\"\n        markdown = \"\"\"```\nOuter code block\n  ```\n  Nested code block\n  ```\nOuter code block continues\n```\n\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        assert len(doc.children) == 1\n        code_block = doc.children[0]\n        assert code_block.__class__.__name__ == \"MarkdownCodeBlockNode\"\n        assert \"Nested code block\" in code_block.content\n\n    def test_incomplete_table(self, ast_builder):\n        \"\"\"Test handling of incomplete tables.\"\"\"\n        markdown = \"\"\"\n| Header 1 | Header 2 |\n|----------|----------|\n\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        # The AST builder should not create a table without any body rows\n        assert len(doc.children) == 2\n        assert doc.children[0].__class__.__name__ == \"MarkdownParagraphNode\"\n        assert doc.children[1].__class__.__name__ == \"MarkdownParagraphNode\"\n\n    def test_invalid_table_separator(self, ast_builder):\n        \"\"\"Test handling of invalid table separators.\"\"\"\n        markdown = \"\"\"\n| Header 1 | Header 2 |\n| Invalid | Separator |\n| Cell 1   | Cell 2   |\n\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        # Should be treated as paragraphs\n        assert len(doc.children) == 3\n        assert all(child.__class__.__name__ == \"MarkdownParagraphNode\" for child in doc.children)\n```\n\nFile: /Users/dave/github/m6r/humbug/tests/markdown/ast_serializer.py\n\n```python\n\"\"\"\nVisitor class for serializing and comparing markdown AST structures\n\"\"\"\nfrom typing import Dict, Any\nimport json\n\nfrom humbug.markdown.markdown_ast_node import (\n    MarkdownASTVisitor, MarkdownASTNode, MarkdownDocumentNode,\n    MarkdownTextNode, MarkdownLineBreakNode, MarkdownEmphasisNode,\n    MarkdownBoldNode, MarkdownHeadingNode, MarkdownParagraphNode,\n    MarkdownOrderedListNode, MarkdownUnorderedListNode, MarkdownListItemNode,\n    MarkdownInlineCodeNode, MarkdownCodeBlockNode, MarkdownTableNode,\n    MarkdownTableHeaderNode, MarkdownTableBodyNode, MarkdownTableRowNode,\n    MarkdownTableCellNode, MarkdownHorizontalRuleNode, MarkdownImageNode,\n    MarkdownLinkNode\n)\n\n\nclass MarkdownASTSerializer(MarkdownASTVisitor):\n    \"\"\"Visitor that serializes the AST structure for comparison.\"\"\"\n\n    def __init__(self, include_line_numbers: bool = False) -> None:\n        \"\"\"\n        Initialize the AST serializer.\n        \n        Args:\n            include_line_numbers: Whether to include line numbers in the serialized output\n        \"\"\"\n        super().__init__()\n        self.include_line_numbers = include_line_numbers\n\n    def _add_line_info(self, result: Dict[str, Any], node: MarkdownASTNode) -> None:\n        \"\"\"Add line information to the result if requested.\"\"\"\n        if not self.include_line_numbers:\n            return\n\n        if node.line_start is not None:\n            result[\"line_start\"] = node.line_start\n\n        if node.line_end is not None:\n            result[\"line_end\"] = node.line_end\n\n    def visit_MarkdownDocumentNode(self, node: MarkdownDocumentNode) -> Dict[str, Any]:\n        \"\"\"Serialize a document node.\"\"\"\n        result = {\n            \"type\": \"document\",\n            \"children\": []\n        }\n\n        if node.source_path:\n            result[\"source_path\"] = node.source_path\n\n        self._add_line_info(result, node)\n\n        # Visit children\n        children = super().generic_visit(node)\n        result[\"children\"] = children\n\n        return result\n\n    def visit_MarkdownTextNode(self, node: MarkdownTextNode) -> Dict[str, Any]:\n        \"\"\"Serialize a text node.\"\"\"\n        result = {\n            \"type\": \"text\",\n            \"content\": node.content\n        }\n        self._add_line_info(result, node)\n        return result\n\n    def visit_MarkdownLineBreakNode(self, node: MarkdownLineBreakNode) -> Dict[str, Any]:\n        \"\"\"Serialize a line break node.\"\"\"\n        result = {\"type\": \"linebreak\"}\n        self._add_line_info(result, node)\n        return result\n\n    def visit_MarkdownEmphasisNode(self, node: MarkdownEmphasisNode) -> Dict[str, Any]:\n        \"\"\"Serialize an emphasis node.\"\"\"\n        result = {\n            \"type\": \"emphasis\",\n            \"children\": []\n        }\n        self._add_line_info(result, node)\n\n        # Visit children\n        children = super().generic_visit(node)\n        result[\"children\"] = children\n\n        return result\n\n    def visit_MarkdownBoldNode(self, node: MarkdownBoldNode) -> Dict[str, Any]:\n        \"\"\"Serialize a bold node.\"\"\"\n        result = {\n            \"type\": \"bold\",\n            \"children\": []\n        }\n        self._add_line_info(result, node)\n\n        # Visit children\n        children = super().generic_visit(node)\n        result[\"children\"] = children\n\n        return result\n\n    def visit_MarkdownHeadingNode(self, node: MarkdownHeadingNode) -> Dict[str, Any]:\n        \"\"\"Serialize a heading node.\"\"\"\n        result = {\n            \"type\": \"heading\",\n            \"level\": node.level,\n            \"id\": node.anchor_id,\n            \"children\": []\n        }\n        self._add_line_info(result, node)\n\n        # Visit children\n        children = super().generic_visit(node)\n        result[\"children\"] = children\n\n        return result\n\n    def visit_MarkdownParagraphNode(self, node: MarkdownParagraphNode) -> Dict[str, Any]:\n        \"\"\"Serialize a paragraph node.\"\"\"\n        result = {\n            \"type\": \"paragraph\",\n            \"children\": []\n        }\n        self._add_line_info(result, node)\n\n        # Visit children\n        children = super().generic_visit(node)\n        result[\"children\"] = children\n\n        return result\n\n    def visit_MarkdownOrderedListNode(self, node: MarkdownOrderedListNode) -> Dict[str, Any]:\n        \"\"\"Serialize an ordered list node.\"\"\"\n        result = {\n            \"type\": \"ordered_list\",\n            \"indent\": node.indent,\n            \"start\": node.start,\n            \"children\": []\n        }\n        self._add_line_info(result, node)\n\n        # Visit children\n        children = super().generic_visit(node)\n        result[\"children\"] = children\n\n        return result\n\n    def visit_MarkdownUnorderedListNode(self, node: MarkdownUnorderedListNode) -> Dict[str, Any]:\n        \"\"\"Serialize an unordered list node.\"\"\"\n        result = {\n            \"type\": \"unordered_list\",\n            \"indent\": node.indent,\n            \"children\": []\n        }\n        self._add_line_info(result, node)\n\n        # Visit children\n        children = super().generic_visit(node)\n        result[\"children\"] = children\n\n        return result\n\n    def visit_MarkdownListItemNode(self, node: MarkdownListItemNode) -> Dict[str, Any]:\n        \"\"\"Serialize a list item node.\"\"\"\n        result = {\n            \"type\": \"list_item\",\n            \"children\": []\n        }\n        self._add_line_info(result, node)\n\n        # Visit children\n        children = super().generic_visit(node)\n        result[\"children\"] = children\n\n        return result\n\n    def visit_MarkdownInlineCodeNode(self, node: MarkdownInlineCodeNode) -> Dict[str, Any]:\n        \"\"\"Serialize an inline code node.\"\"\"\n        result = {\n            \"type\": \"inline_code\",\n            \"content\": node.content\n        }\n        self._add_line_info(result, node)\n        return result\n\n    def visit_MarkdownCodeBlockNode(self, node: MarkdownCodeBlockNode) -> Dict[str, Any]:\n        \"\"\"Serialize a code block node.\"\"\"\n        result = {\n            \"type\": \"code_block\",\n            \"language\": node.language,\n            \"content\": node.content\n        }\n        self._add_line_info(result, node)\n        return result\n\n    def visit_MarkdownTableNode(self, node: MarkdownTableNode) -> Dict[str, Any]:\n        \"\"\"Serialize a table node.\"\"\"\n        result = {\n            \"type\": \"table\",\n            \"children\": []\n        }\n        self._add_line_info(result, node)\n\n        # Visit children\n        children = super().generic_visit(node)\n        result[\"children\"] = children\n\n        return result\n\n    def visit_MarkdownTableHeaderNode(self, node: MarkdownTableHeaderNode) -> Dict[str, Any]:\n        \"\"\"Serialize a table header node.\"\"\"\n        result = {\n            \"type\": \"table_header\",\n            \"children\": []\n        }\n        self._add_line_info(result, node)\n\n        # Visit children\n        children = super().generic_visit(node)\n        result[\"children\"] = children\n\n        return result\n\n    def visit_MarkdownTableBodyNode(self, node: MarkdownTableBodyNode) -> Dict[str, Any]:\n        \"\"\"Serialize a table body node.\"\"\"\n        result = {\n            \"type\": \"table_body\",\n            \"children\": []\n        }\n        self._add_line_info(result, node)\n\n        # Visit children\n        children = super().generic_visit(node)\n        result[\"children\"] = children\n\n        return result\n\n    def visit_MarkdownTableRowNode(self, node: MarkdownTableRowNode) -> Dict[str, Any]:\n        \"\"\"Serialize a table row node.\"\"\"\n        result = {\n            \"type\": \"table_row\",\n            \"children\": []\n        }\n        self._add_line_info(result, node)\n\n        # Visit children\n        children = super().generic_visit(node)\n        result[\"children\"] = children\n\n        return result\n\n    def visit_MarkdownTableCellNode(self, node: MarkdownTableCellNode) -> Dict[str, Any]:\n        \"\"\"Serialize a table cell node.\"\"\"\n        result = {\n            \"type\": \"table_cell\",\n            \"is_header\": node.is_header,\n            \"alignment\": node.alignment,\n            \"children\": []\n        }\n        self._add_line_info(result, node)\n\n        # Visit children\n        children = super().generic_visit(node)\n        result[\"children\"] = children\n\n        return result\n\n    def visit_MarkdownHorizontalRuleNode(self, node: MarkdownHorizontalRuleNode) -> Dict[str, Any]:\n        \"\"\"Serialize a horizontal rule node.\"\"\"\n        result = {\"type\": \"horizontal_rule\"}\n        self._add_line_info(result, node)\n        return result\n\n    def visit_MarkdownLinkNode(self, node: MarkdownLinkNode) -> Dict[str, Any]:\n        \"\"\"Serialize a link node.\"\"\"\n        result = {\n            \"type\": \"link\",\n            \"url\": node.url,\n            \"children\": []\n        }\n\n        if node.title:\n            result[\"title\"] = node.title\n\n        self._add_line_info(result, node)\n\n        # Visit children\n        children = super().generic_visit(node)\n        result[\"children\"] = children\n\n        return result\n\n    def visit_MarkdownImageNode(self, node: MarkdownImageNode) -> Dict[str, Any]:\n        \"\"\"Serialize an image node.\"\"\"\n        result = {\n            \"type\": \"image\",\n            \"url\": node.url,\n            \"alt_text\": node.alt_text\n        }\n\n        if node.title:\n            result[\"title\"] = node.title\n\n        self._add_line_info(result, node)\n        return result\n\n\ndef serialize_ast(node: MarkdownASTNode, include_line_numbers: bool = False) -> Dict[str, Any]:\n    \"\"\"\n    Serialize an AST node to a dictionary.\n\n    Args:\n        node: The AST node to serialize\n        include_line_numbers: Whether to include line numbers in the output\n\n    Returns:\n        A dictionary representation of the AST\n    \"\"\"\n    serializer = MarkdownASTSerializer(include_line_numbers)\n    return serializer.visit(node)\n\n\ndef save_ast_to_json(node: MarkdownASTNode, file_path: str, include_line_numbers: bool = False) -> None:\n    \"\"\"\n    Save an AST node to a JSON file.\n\n    Args:\n        node: The AST node to serialize\n        file_path: The path to save the JSON file to\n        include_line_numbers: Whether to include line numbers in the output\n    \"\"\"\n    serialized = serialize_ast(node, include_line_numbers)\n    with open(file_path, 'w', encoding='utf-8') as f:\n        json.dump(serialized, f, indent=2)\n\n\ndef load_ast_from_json(file_path: str) -> Dict[str, Any]:\n    \"\"\"\n    Load an AST from a JSON file.\n\n    Args:\n        file_path: The path to the JSON file\n\n    Returns:\n        A dictionary representation of the AST\n    \"\"\"\n    with open(file_path, 'r', encoding='utf-8') as f:\n        return json.load(f)\n```\n\nFile: /Users/dave/github/m6r/humbug/tests/markdown/conftest.py\n\n```python\nimport os\nimport sys\nfrom pathlib import Path\n\n# Add the src directory to Python path\nproject_root = Path(__file__).parent.parent\nsys.path.insert(0, str(project_root / \"src\"))\n```\n\nFile: /Users/dave/github/m6r/humbug/tests/markdown/test_utils.py\n\n```python\n\"\"\"\nUtility functions for markdown AST builder tests\n\"\"\"\nimport os\nimport json\nfrom pathlib import Path\nimport difflib\nfrom typing import Dict, Any, List, Tuple, Optional\n\nfrom humbug.markdown.markdown_ast_builder import MarkdownASTBuilder\nfrom ast_serializer import serialize_ast, load_ast_from_json\n\n\ndef get_test_fixtures_dir() -> Path:\n    \"\"\"\n    Get the directory containing test fixtures.\n\n    Returns:\n        Path to the test fixtures directory\n    \"\"\"\n    current_dir = Path(__file__).parent\n    return current_dir / \"fixtures\"\n\n\ndef load_markdown_file(file_path: str) -> str:\n    \"\"\"\n    Load a markdown file.\n\n    Args:\n        file_path: Path to the markdown file\n\n    Returns:\n        The contents of the markdown file\n    \"\"\"\n    with open(file_path, 'r', encoding='utf-8') as f:\n        return f.read()\n\n\ndef find_test_files() -> List[Tuple[str, str]]:\n    \"\"\"\n    Find all test files (markdown files with corresponding JSON files).\n\n    Returns:\n        List of tuples containing (markdown_path, json_path)\n    \"\"\"\n    fixtures_dir = get_test_fixtures_dir()\n    test_files = []\n\n    for root, _, files in os.walk(fixtures_dir):\n        for file in files:\n            if file.endswith('.md'):\n                md_path = os.path.join(root, file)\n                json_path = md_path.replace('.md', '.json')\n\n                if os.path.exists(json_path):\n                    test_files.append((md_path, json_path))\n\n    return test_files\n\n\ndef compare_ast_with_expected(\n    actual_ast: Dict[str, Any],\n    expected_ast: Dict[str, Any]\n) -> Tuple[bool, Optional[str]]:\n    \"\"\"\n    Compare an actual AST with an expected AST.\n\n    Args:\n        actual_ast: The actual AST dictionary\n        expected_ast: The expected AST dictionary\n\n    Returns:\n        Tuple of (is_match, diff_message)\n    \"\"\"\n    # Convert to JSON strings for comparison\n    actual_json = json.dumps(actual_ast, indent=2, sort_keys=True)\n    expected_json = json.dumps(expected_ast, indent=2, sort_keys=True)\n\n    if actual_json == expected_json:\n        return True, None\n\n    # Generate a diff if they don't match\n    diff = difflib.unified_diff(\n        expected_json.splitlines(keepends=True),\n        actual_json.splitlines(keepends=True),\n        fromfile='expected',\n        tofile='actual'\n    )\n\n    diff_message = ''.join(diff)\n    return False, diff_message\n\n\ndef parse_and_compare(\n    markdown_path: str,\n    expected_json_path: str,\n    no_underscores: bool = False\n) -> Tuple[bool, Optional[str]]:\n    \"\"\"\n    Parse a markdown file and compare the result with an expected JSON file.\n\n    Args:\n        markdown_path: Path to the markdown file\n        expected_json_path: Path to the expected JSON file\n        no_underscores: Whether to disable underscore formatting\n\n    Returns:\n        Tuple of (is_match, diff_message)\n    \"\"\"\n    # Load the markdown and parse it\n    markdown_text = load_markdown_file(markdown_path)\n    ast_builder = MarkdownASTBuilder(no_underscores=no_underscores)\n    ast = ast_builder.build_ast(markdown_text)\n\n    # Serialize the AST\n    actual_ast = serialize_ast(ast)\n\n    # Load the expected AST\n    expected_ast = load_ast_from_json(expected_json_path)\n\n    # Compare\n    return compare_ast_with_expected(actual_ast, expected_ast)\n```\n\n# Action:\n\nI have unit tests for my MarkdownASTBuilder class but some functions don't have any test coverage:\n\n- document\n- _should_parse_code_block_as_continuation\n- _find_closing_parenthesis\n- parse_inline_formatting\n- _parent_list_state\n- _find_parent_for_list\n- parse_ordered_list_item (loose list handling)\n- parse_unordered_list_item (loose list handling)\n- parse_table_separator (centered and right aligned text)\n- _handle_text_continuation\n\nThe tests must use the existing pytest framework and must not use any non-public APIs or properties.\n\nPlease propose a design for this.",
      "completed": true,
      "usage": null,
      "error": null,
      "model": null,
      "temperature": null
    },
    {
      "id": "be51a3a3-71ac-4c62-a39a-a920d7630c8c",
      "timestamp": "2025-05-31T17:01:44.643305",
      "type": "ai_response",
      "content": "Looking at the existing test structure and the functions that need coverage, I'll propose a comprehensive design for adding the missing test coverage. The design will focus on testing observable behavior through the public API while ensuring all code paths are exercised.\n\n## Design for Missing Test Coverage\n\n### 1. Test Structure Organization\n\nI'll organize the new tests into logical groups within the existing test classes and add new test classes where appropriate:\n\n```python\nclass TestMarkdownASTBuilder:\n    # Existing tests...\n    \n    # New tests for basic functionality\n    def test_document_property(self, ast_builder):\n        \"\"\"Test the document property returns the current document.\"\"\"\n    \n    def test_find_closing_parenthesis_scenarios(self, ast_builder):\n        \"\"\"Test various parenthesis matching scenarios in links/images.\"\"\"\n\nclass TestInlineFormatting:\n    \"\"\"Comprehensive tests for inline formatting parsing.\"\"\"\n    \n    def test_complex_nested_formatting(self, ast_builder):\n        \"\"\"Test deeply nested and complex formatting combinations.\"\"\"\n    \n    def test_malformed_formatting_edge_cases(self, ast_builder):\n        \"\"\"Test handling of malformed or incomplete formatting.\"\"\"\n\nclass TestCodeBlockContinuation:\n    \"\"\"Tests for code block continuation logic.\"\"\"\n    \n    def test_code_block_with_programming_languages(self, ast_builder):\n        \"\"\"Test code blocks with various programming languages.\"\"\"\n    \n    def test_code_block_continuation_edge_cases(self, ast_builder):\n        \"\"\"Test edge cases in code block continuation parsing.\"\"\"\n\nclass TestListHandling:\n    \"\"\"Tests for advanced list functionality.\"\"\"\n    \n    def test_loose_vs_tight_lists(self, ast_builder):\n        \"\"\"Test loose and tight list detection.\"\"\"\n    \n    def test_complex_nested_list_structures(self, ast_builder):\n        \"\"\"Test complex nested list scenarios.\"\"\"\n    \n    def test_list_continuation_and_interruption(self, ast_builder):\n        \"\"\"Test text continuation within lists.\"\"\"\n\nclass TestTableFormatting:\n    \"\"\"Tests for table alignment and formatting.\"\"\"\n    \n    def test_table_alignment_variations(self, ast_builder):\n        \"\"\"Test left, center, and right-aligned table columns.\"\"\"\n    \n    def test_table_with_complex_content(self, ast_builder):\n        \"\"\"Test tables containing formatted text.\"\"\"\n\nclass TestTextContinuation:\n    \"\"\"Tests for text continuation logic.\"\"\"\n    \n    def test_paragraph_continuation(self, ast_builder):\n        \"\"\"Test paragraph continuation across multiple lines.\"\"\"\n    \n    def test_list_item_continuation(self, ast_builder):\n        \"\"\"Test text continuation within list items.\"\"\"\n```\n\n### 2. Specific Test Cases\n\n#### Testing `document` Property\n```python\ndef test_document_property(self, ast_builder):\n    \"\"\"Test the document property returns the current document.\"\"\"\n    # Test with empty document\n    initial_doc = ast_builder.document()\n    assert initial_doc is not None\n    assert len(initial_doc.children) == 0\n    \n    # Test after parsing content\n    ast_builder.build_ast(\"# Test Heading\")\n    updated_doc = ast_builder.document()\n    assert updated_doc is not None\n    assert len(updated_doc.children) == 1\n    assert updated_doc.children[0].__class__.__name__ == \"MarkdownHeadingNode\"\n    \n    # Verify same document instance is returned\n    assert updated_doc is ast_builder.document()\n```\n\n#### Testing `_find_closing_parenthesis` Through Links/Images\n```python\ndef test_complex_link_parentheses(self, ast_builder):\n    \"\"\"Test links with nested parentheses in URLs.\"\"\"\n    test_cases = [\n        \"[Link](http://example.com/path(with)parentheses)\",\n        \"[Link](http://example.com/path(nested(deep)parentheses))\",\n        \"![Image](image(1).jpg)\",\n        \"[Text](url(a(b(c)b)a))\",\n    ]\n    \n    for markdown in test_cases:\n        doc = ast_builder.build_ast(markdown)\n        # Verify the link/image was parsed correctly\n        # (Implementation will verify the parenthesis matching worked)\n```\n\n#### Testing Code Block Continuation\n```python\ndef test_code_block_continuation_scenarios(self, ast_builder):\n    \"\"\"Test code block continuation with various programming languages.\"\"\"\n    # Test Python with incomplete statements\n    python_code = '''```python\ndef incomplete_function(\n    param1,\n    param2\n):\n    if condition:\n        return value\n```'''\n    \n    # Test JavaScript with objects\n    js_code = '''```javascript\nconst obj = {\n    property1: value1,\n    property2: {\n        nested: true\n    }\n};\n```'''\n    \n    for code in [python_code, js_code]:\n        doc = ast_builder.build_ast(code)\n        assert len(doc.children) == 1\n        code_block = doc.children[0]\n        assert code_block.__class__.__name__ == \"MarkdownCodeBlockNode\"\n```\n\n#### Testing Inline Formatting Edge Cases\n```python\ndef test_complex_inline_formatting(self, ast_builder):\n    \"\"\"Test complex inline formatting scenarios.\"\"\"\n    test_cases = [\n        # Nested formatting\n        \"**Bold with *italic* and `code` inside**\",\n        \"*Italic with **bold** inside*\",\n        \n        # Adjacent formatting\n        \"**Bold**_italic_`code`\",\n        \n        # Formatting with links\n        \"**Bold [link](url) text**\",\n        \"*Italic ![image](url) text*\",\n        \n        # Malformed formatting\n        \"**Unclosed bold\",\n        \"*Unclosed italic\",\n        \"`Unclosed code\",\n        \n        # Empty formatting\n        \"****\",\n        \"**\",\n        \"``\",\n    ]\n    \n    for markdown in test_cases:\n        doc = ast_builder.build_ast(markdown)\n        # Verify document parses without errors\n        assert doc is not None\n        assert len(doc.children) >= 1\n```\n\n#### Testing Loose vs Tight Lists\n```python\ndef test_loose_vs_tight_lists(self, ast_builder):\n    \"\"\"Test detection of loose vs tight lists.\"\"\"\n    # Tight list (no blank lines)\n    tight_list = \"\"\"- Item 1\n- Item 2\n- Item 3\"\"\"\n    \n    # Loose list (with blank lines)\n    loose_list = \"\"\"- Item 1\n\n- Item 2\n\n- Item 3\"\"\"\n    \n    # Mixed scenario\n    mixed_list = \"\"\"- Item 1\n- Item 2\n\n- Item 3\"\"\"\n    \n    for list_markdown in [tight_list, loose_list, mixed_list]:\n        doc = ast_builder.build_ast(list_markdown)\n        assert len(doc.children) == 1\n        list_node = doc.children[0]\n        assert list_node.__class__.__name__ == \"MarkdownUnorderedListNode\"\n        # The tight property should reflect the presence of blank lines\n```\n\n#### Testing Table Alignment\n```python\ndef test_table_alignment_variations(self, ast_builder):\n    \"\"\"Test different table column alignments.\"\"\"\n    table_markdown = \"\"\"\n| Left | Center | Right |\n|:-----|:------:|------:|\n| L1   | C1     | R1    |\n| L2   | C2     | R2    |\n\"\"\"\n    \n    doc = ast_builder.build_ast(table_markdown)\n    assert len(doc.children) == 1\n    table = doc.children[0]\n    assert table.__class__.__name__ == \"MarkdownTableNode\"\n    \n    # Check header row for alignment\n    header = table.children[0]\n    header_row = header.children[0]\n    \n    # Verify alignment is set correctly on cells\n    left_cell = header_row.children[0]\n    center_cell = header_row.children[1] \n    right_cell = header_row.children[2]\n    \n    assert left_cell.alignment == \"left\"\n    assert center_cell.alignment == \"center\"\n    assert right_cell.alignment == \"right\"\n```\n\n#### Testing Text Continuation\n```python\ndef test_text_continuation_scenarios(self, ast_builder):\n    \"\"\"Test various text continuation scenarios.\"\"\"\n    \n    # Paragraph continuation\n    paragraph_continuation = \"\"\"This is the first line\nand this continues the same paragraph.\"\"\"\n    \n    doc = ast_builder.build_ast(paragraph_continuation)\n    assert len(doc.children) == 1\n    paragraph = doc.children[0]\n    assert paragraph.__class__.__name__ == \"MarkdownParagraphNode\"\n    # Should contain both lines with a space between them\n    \n    # List item continuation\n    list_continuation = \"\"\"- First list item\n  continues on this line\n- Second list item\"\"\"\n    \n    doc = ast_builder.build_ast(list_continuation)\n    assert len(doc.children) == 1\n    list_node = doc.children[0]\n    first_item = list_node.children[0]\n    # The first item should contain the continued text\n    \n    # List continuation with blank lines (loose list)\n    loose_continuation = \"\"\"- First item\n  continues here\n\n- Second item\n  also continues\"\"\"\n    \n    doc = ast_builder.build_ast(loose_continuation)\n    list_node = doc.children[0]\n    # Should be marked as a loose list\n```\n\n### 3. Implementation Strategy\n\n#### Phase 1: Document Property and Basic Functionality\n- Add tests for the `document` property\n- Add tests for complex parentheses matching through links/images\n- Add basic inline formatting edge cases\n\n#### Phase 2: Code Block and List Handling\n- Add comprehensive code block continuation tests\n- Add loose/tight list detection tests\n- Add complex nested list scenarios\n\n#### Phase 3: Advanced Features\n- Add table alignment tests\n- Add text continuation tests\n- Add comprehensive inline formatting tests\n\n### 4. Test Data Organization\n\nCreate additional fixture files for complex scenarios:\n\n```\ntests/markdown/fixtures/\n\u251c\u2500\u2500 inline_formatting/\n\u2502   \u251c\u2500\u2500 complex_nested.md\n\u2502   \u251c\u2500\u2500 complex_nested.json\n\u2502   \u251c\u2500\u2500 malformed_formatting.md\n\u2502   \u2514\u2500\u2500 malformed_formatting.json\n\u251c\u2500\u2500 lists/\n\u2502   \u251c\u2500\u2500 loose_lists.md\n\u2502   \u251c\u2500\u2500 loose_lists.json\n\u2502   \u251c\u2500\u2500 complex_nested.md\n\u2502   \u2514\u2500\u2500 complex_nested.json\n\u251c\u2500\u2500 tables/\n\u2502   \u251c\u2500\u2500 alignment_variations.md\n\u2502   \u251c\u2500\u2500 alignment_variations.json\n\u2502   \u251c\u2500\u2500 complex_content.md\n\u2502   \u2514\u2500\u2500 complex_content.json\n\u2514\u2500\u2500 continuation/\n    \u251c\u2500\u2500 paragraph_continuation.md\n    \u251c\u2500\u2500 paragraph_continuation.json\n    \u251c\u2500\u2500 list_continuation.md\n    \u2514\u2500\u2500 list_continuation.json\n```\n\n### 5. Coverage Verification\n\nEach test will be designed to exercise specific code paths:\n\n- **`_find_closing_parenthesis`**: Through complex link/image URLs with nested parentheses\n- **`_should_parse_code_block_as_continuation`**: Through code blocks with various programming languages\n- **`parse_inline_formatting`**: Through comprehensive formatting scenarios\n- **`_parent_list_state` and `_find_parent_for_list`**: Through complex nested list structures\n- **Loose list handling**: Through lists with strategic blank line placement\n- **Table alignment**: Through tables with all alignment types\n- **`_handle_text_continuation`**: Through paragraph and list continuation scenarios\n\nThis design ensures comprehensive coverage while maintaining the existing test structure and avoiding reliance on private APIs. The tests focus on observable behavior and edge cases that exercise the internal logic paths.",
      "completed": true,
      "usage": {
        "prompt_tokens": 23005,
        "completion_tokens": 2819,
        "total_tokens": 25824
      },
      "error": null,
      "model": "claude-4-sonnet-20250514",
      "temperature": 0.7
    },
    {
      "id": "d08009ef-36a0-420e-996e-367f91e01f27",
      "timestamp": "2025-05-31T17:04:16.488538",
      "type": "user_message",
      "content": "please give me the complete test_markdown_ast_builder.py file",
      "completed": true,
      "usage": null,
      "error": null,
      "model": null,
      "temperature": null
    },
    {
      "id": "5e31c9b0-491c-417c-9b74-c664c6ad979f",
      "timestamp": "2025-05-31T17:04:20.477131",
      "type": "ai_response",
      "content": "```python\n\"\"\"\nTests for the markdown AST builder\n\"\"\"\nimport os\nimport pytest\n\nfrom humbug.markdown.markdown_ast_builder import MarkdownASTBuilder, MarkdownASTBuilderError\nfrom test_utils import (\n    find_test_files,\n    parse_and_compare\n)\n\n\n@pytest.fixture\ndef ast_builder():\n    \"\"\"Fixture providing a markdown AST builder instance.\"\"\"\n    return MarkdownASTBuilder(no_underscores=False)\n\n\n@pytest.fixture\ndef ast_builder_no_underscores():\n    \"\"\"Fixture providing a markdown AST builder instance with underscores disabled.\"\"\"\n    return MarkdownASTBuilder(no_underscores=True)\n\n\nclass TestMarkdownASTBuilder:\n    \"\"\"Tests for the MarkdownASTBuilder class.\"\"\"\n\n    @pytest.mark.parametrize(\"markdown_path,expected_json_path\", find_test_files())\n    def test_parse_fixture_files(self, markdown_path, expected_json_path):\n        \"\"\"Test parsing markdown files against expected JSON outputs.\"\"\"\n        is_match, diff = parse_and_compare(markdown_path, expected_json_path)\n        assert is_match, f\"AST mismatch for {os.path.basename(markdown_path)}:\\n{diff}\"\n\n    def test_empty_document(self, ast_builder):\n        \"\"\"Test parsing an empty document.\"\"\"\n        doc = ast_builder.build_ast(\"\")\n        assert doc is not None\n        assert len(doc.children) == 0\n\n    def test_document_property(self, ast_builder):\n        \"\"\"Test the document property returns the current document.\"\"\"\n        # Test with empty document\n        initial_doc = ast_builder.document()\n        assert initial_doc is not None\n        assert len(initial_doc.children) == 0\n        \n        # Test after parsing content\n        ast_builder.build_ast(\"# Test Heading\")\n        updated_doc = ast_builder.document()\n        assert updated_doc is not None\n        assert len(updated_doc.children) == 1\n        assert updated_doc.children[0].__class__.__name__ == \"MarkdownHeadingNode\"\n        \n        # Verify same document instance is returned\n        assert updated_doc is ast_builder.document()\n\n    def test_simple_paragraph(self, ast_builder):\n        \"\"\"Test parsing a simple paragraph.\"\"\"\n        doc = ast_builder.build_ast(\"This is a paragraph.\")\n        assert doc is not None\n        assert len(doc.children) == 1\n        assert doc.children[0].__class__.__name__ == \"MarkdownParagraphNode\"\n        assert len(doc.children[0].children) == 1\n        assert doc.children[0].children[0].__class__.__name__ == \"MarkdownTextNode\"\n        assert doc.children[0].children[0].content == \"This is a paragraph.\"\n\n    def test_heading(self, ast_builder):\n        \"\"\"Test parsing a heading.\"\"\"\n        doc = ast_builder.build_ast(\"# Heading 1\")\n        assert doc is not None\n        assert len(doc.children) == 1\n        assert doc.children[0].__class__.__name__ == \"MarkdownHeadingNode\"\n        assert doc.children[0].level == 1\n        assert len(doc.children[0].children) == 1\n        assert doc.children[0].children[0].__class__.__name__ == \"MarkdownTextNode\"\n        assert doc.children[0].children[0].content == \"Heading 1\"\n\n    def test_bold_text(self, ast_builder):\n        \"\"\"Test parsing bold text.\"\"\"\n        doc = ast_builder.build_ast(\"This is **bold** text.\")\n        assert doc is not None\n        assert len(doc.children) == 1\n        paragraph = doc.children[0]\n        assert paragraph.__class__.__name__ == \"MarkdownParagraphNode\"\n        assert len(paragraph.children) == 3\n        assert paragraph.children[0].__class__.__name__ == \"MarkdownTextNode\"\n        assert paragraph.children[0].content == \"This is \"\n        assert paragraph.children[1].__class__.__name__ == \"MarkdownBoldNode\"\n        assert paragraph.children[1].children[0].__class__.__name__ == \"MarkdownTextNode\"\n        assert paragraph.children[1].children[0].content == \"bold\"\n        assert paragraph.children[2].__class__.__name__ == \"MarkdownTextNode\"\n        assert paragraph.children[2].content == \" text.\"\n\n    def test_underscore_formatting(self, ast_builder, ast_builder_no_underscores):\n        \"\"\"Test underscore formatting behavior.\"\"\"\n        # With underscores enabled\n        doc = ast_builder.build_ast(\"_italic_ and __bold__\")\n        assert doc.children[0].children[0].__class__.__name__ == \"MarkdownEmphasisNode\"\n        assert doc.children[0].children[2].__class__.__name__ == \"MarkdownBoldNode\"\n\n        # With underscores disabled\n        doc = ast_builder_no_underscores.build_ast(\"_italic_ and __bold__\")\n        assert doc.children[0].children[0].__class__.__name__ == \"MarkdownTextNode\"\n        assert doc.children[0].children[0].content == \"_italic_ and __bold__\"\n\n    def test_nested_formatting(self, ast_builder):\n        \"\"\"Test nested formatting.\"\"\"\n        doc = ast_builder.build_ast(\"This is **bold with *italic* inside**.\")\n        paragraph = doc.children[0]\n        bold_node = paragraph.children[1]\n        assert bold_node.__class__.__name__ == \"MarkdownBoldNode\"\n        assert len(bold_node.children) == 3\n        assert bold_node.children[0].__class__.__name__ == \"MarkdownTextNode\"\n        assert bold_node.children[0].content == \"bold with \"\n        assert bold_node.children[1].__class__.__name__ == \"MarkdownEmphasisNode\"\n\n    def test_unordered_list(self, ast_builder):\n        \"\"\"Test parsing an unordered list.\"\"\"\n        markdown = \"\"\"\n- Item 1\n- Item 2\n- Item 3\n\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        assert len(doc.children) == 1\n        list_node = doc.children[0]\n        assert list_node.__class__.__name__ == \"MarkdownUnorderedListNode\"\n        assert len(list_node.children) == 3\n        for item in list_node.children:\n            assert item.__class__.__name__ == \"MarkdownListItemNode\"\n\n    def test_ordered_list(self, ast_builder):\n        \"\"\"Test parsing an ordered list.\"\"\"\n        markdown = \"\"\"\n1. First item\n2. Second item\n3. Third item\n\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        assert len(doc.children) == 1\n        list_node = doc.children[0]\n        assert list_node.__class__.__name__ == \"MarkdownOrderedListNode\"\n        assert len(list_node.children) == 3\n        assert list_node.start == 1\n\n    def test_nested_list(self, ast_builder):\n        \"\"\"Test parsing a nested list.\"\"\"\n        markdown = \"\"\"\n- Item 1\n  - Nested 1.1\n  - Nested 1.2\n- Item 2\n- Item 3\n\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        assert len(doc.children) == 1\n        list_node = doc.children[0]\n        assert len(list_node.children) == 3\n\n        # Check first item has a nested list\n        first_item = list_node.children[0]\n        assert len(first_item.children) == 2\n        nested_list = first_item.children[0]\n        assert nested_list.__class__.__name__ == \"MarkdownParagraphNode\"\n        nested_list = first_item.children[1]\n        assert nested_list.__class__.__name__ == \"MarkdownUnorderedListNode\"\n        assert len(nested_list.children) == 2\n\n    def test_code_block(self, ast_builder):\n        \"\"\"Test parsing a code block.\"\"\"\n        markdown = \"\"\"```python\ndef hello():\n    print(\"Hello, world!\")\n```\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        assert len(doc.children) == 1\n        code_block = doc.children[0]\n        assert code_block.__class__.__name__ == \"MarkdownCodeBlockNode\"\n        assert code_block.language == \"python\"\n        assert \"def hello():\" in code_block.content\n        assert \"print(\\\"Hello, world!\\\")\" in code_block.content\n\n    def test_table(self, ast_builder):\n        \"\"\"Test parsing a table.\"\"\"\n        markdown = \"\"\"\n| Header 1 | Header 2 |\n|----------|----------|\n| Cell 1   | Cell 2   |\n| Cell 3   | Cell 4   |\n\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        assert len(doc.children) == 1\n        table = doc.children[0]\n        assert table.__class__.__name__ == \"MarkdownTableNode\"\n        assert len(table.children) == 2\n\n        # Check header\n        header = table.children[0]\n        assert header.__class__.__name__ == \"MarkdownTableHeaderNode\"\n        assert len(header.children) == 1  # One row\n\n        # Check body\n        body = table.children[1]\n        assert body.__class__.__name__ == \"MarkdownTableBodyNode\"\n        assert len(body.children) == 2  # Two rows\n\n    def test_horizontal_rule(self, ast_builder):\n        \"\"\"Test parsing a horizontal rule.\"\"\"\n        markdown = \"\"\"\nBefore rule\n\n---\n\nAfter rule\n\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        assert len(doc.children) == 3\n        assert doc.children[0].__class__.__name__ == \"MarkdownParagraphNode\"\n        assert doc.children[1].__class__.__name__ == \"MarkdownHorizontalRuleNode\"\n        assert doc.children[2].__class__.__name__ == \"MarkdownParagraphNode\"\n\n    def test_link(self, ast_builder):\n        \"\"\"Test parsing a link.\"\"\"\n        doc = ast_builder.build_ast(\"Here is a [link](https://example.com) to a website.\")\n        paragraph = doc.children[0]\n        assert len(paragraph.children) == 3\n        link = paragraph.children[1]\n        assert link.__class__.__name__ == \"MarkdownLinkNode\"\n        assert link.url == \"https://example.com\"\n        assert len(link.children) == 1\n        assert link.children[0].content == \"link\"\n\n    def test_image(self, ast_builder):\n        \"\"\"Test parsing an image.\"\"\"\n        doc = ast_builder.build_ast(\"![Alt text](image.jpg \\\"Image title\\\")\")\n        paragraph = doc.children[0]\n        image = paragraph.children[0]\n        assert image.__class__.__name__ == \"MarkdownImageNode\"\n        assert image.url == \"image.jpg\"\n        assert image.alt_text == \"Alt text\"\n        assert image.title == \"Image title\"\n\n    def test_line_to_node_mapping(self, ast_builder):\n        \"\"\"Test the line to node mapping functionality.\"\"\"\n        markdown = \"\"\"# Heading\n\nParagraph 1.\n\nParagraph 2.\n\"\"\"\n        ast_builder.build_ast(markdown)\n\n        # Check mapping exists for each line\n        assert 0 in ast_builder._line_to_node_map  # Heading\n        assert 2 in ast_builder._line_to_node_map  # Paragraph 1\n        assert 4 in ast_builder._line_to_node_map  # Paragraph 2\n\n    def test_update_ast(self, ast_builder):\n        \"\"\"Test updating an AST incrementally.\"\"\"\n        original = \"# Original heading\\n\\nOriginal paragraph.\"\n        updated = \"# Updated heading\\n\\nUpdated paragraph.\"\n\n        # Build original AST\n        ast_builder.build_ast(original)\n\n        # Update AST\n        doc = ast_builder.update_ast(updated, original)\n\n        # Check that the AST was updated\n        assert doc.children[0].children[0].content == \"Updated heading\"\n        assert doc.children[1].children[0].content == \"Updated paragraph.\"\n\n    def test_ast_builder_error(self):\n        \"\"\"Test that ast_builder errors are raised appropriately.\"\"\"\n        # Create a ast_builder with a broken regex to force an error\n        broken_ast_builder = MarkdownASTBuilder(no_underscores=False)\n        broken_ast_builder._heading_pattern = None  # type: ignore\n\n        with pytest.raises(MarkdownASTBuilderError):\n            broken_ast_builder.parse_line(\"# This should fail\", 0)\n\n\nclass TestInlineFormatting:\n    \"\"\"Comprehensive tests for inline formatting parsing.\"\"\"\n\n    def test_complex_nested_formatting(self, ast_builder):\n        \"\"\"Test deeply nested and complex formatting combinations.\"\"\"\n        test_cases = [\n            # Nested formatting\n            \"**Bold with *italic* and `code` inside**\",\n            \"*Italic with **bold** inside*\",\n            \"`Code with **bold** inside`\",\n            \n            # Adjacent formatting\n            \"**Bold**_italic_`code`\",\n            \"*italic*`code`**bold**\",\n            \n            # Formatting with links\n            \"**Bold [link](url) text**\",\n            \"*Italic ![image](url) text*\",\n            \"[Link with **bold** text](url)\",\n            \n            # Complex nesting\n            \"***Bold italic*** text\",\n            \"**Bold *with italic* and more bold**\",\n            \"*Italic **with bold** and more italic*\",\n        ]\n        \n        for markdown in test_cases:\n            doc = ast_builder.build_ast(markdown)\n            # Verify document parses without errors\n            assert doc is not None\n            assert len(doc.children) >= 1\n            paragraph = doc.children[0]\n            assert paragraph.__class__.__name__ == \"MarkdownParagraphNode\"\n\n    def test_malformed_formatting_edge_cases(self, ast_builder):\n        \"\"\"Test handling of malformed or incomplete formatting.\"\"\"\n        test_cases = [\n            # Unclosed formatting\n            \"**Unclosed bold\",\n            \"*Unclosed italic\",\n            \"`Unclosed code\",\n            \"__Unclosed underscore bold\",\n            \"_Unclosed underscore italic\",\n            \n            # Empty formatting\n            \"****\",\n            \"**\",\n            \"``\",\n            \"____\",\n            \"__\",\n            \n            # Mismatched formatting\n            \"**Bold with *italic**\",\n            \"*Italic with **bold*\",\n            \n            # Formatting at boundaries\n            \"**start bold\",\n            \"end bold**\",\n            \"*start italic\",\n            \"end italic*\",\n        ]\n        \n        for markdown in test_cases:\n            doc = ast_builder.build_ast(markdown)\n            # Verify document parses without errors\n            assert doc is not None\n            assert len(doc.children) >= 1\n\n    def test_complex_link_parentheses(self, ast_builder):\n        \"\"\"Test links with nested parentheses in URLs (tests _find_closing_parenthesis).\"\"\"\n        test_cases = [\n            \"[Link](http://example.com/path(with)parentheses)\",\n            \"[Link](http://example.com/path(nested(deep)parentheses))\",\n            \"[Link](url(a(b(c)b)a))\",\n            \"![Image](image(1).jpg)\",\n            \"![Image](path/to/image(version)(2).png)\",\n            \"[Complex](http://site.com/api/func(param1(nested)param2))\",\n        ]\n        \n        for markdown in test_cases:\n            doc = ast_builder.build_ast(markdown)\n            paragraph = doc.children[0]\n            \n            if markdown.startswith('!'):\n                # Image\n                image = paragraph.children[0]\n                assert image.__class__.__name__ == \"MarkdownImageNode\"\n                assert '(' in image.url and ')' in image.url\n            else:\n                # Link\n                link = paragraph.children[0]\n                assert link.__class__.__name__ == \"MarkdownLinkNode\"\n                assert '(' in link.url and ')' in link.url\n\n    def test_inline_code_with_formatting_inside(self, ast_builder):\n        \"\"\"Test inline code that contains formatting characters.\"\"\"\n        test_cases = [\n            \"`code with **asterisks**`\",\n            \"`code with *single asterisk*`\",\n            \"`code with __underscores__`\",\n            \"`code with _single underscore_`\",\n            \"`code with [brackets](url)`\",\n            \"`code with ![image](url)`\",\n        ]\n        \n        for markdown in test_cases:\n            doc = ast_builder.build_ast(markdown)\n            paragraph = doc.children[0]\n            code_node = paragraph.children[0]\n            assert code_node.__class__.__name__ == \"MarkdownInlineCodeNode\"\n            # Content should be preserved as-is without formatting\n            assert \"**\" in code_node.content or \"*\" in code_node.content or \"__\" in code_node.content or \"_\" in code_node.content or \"[\" in code_node.content\n\n\nclass TestCodeBlockContinuation:\n    \"\"\"Tests for code block continuation logic.\"\"\"\n\n    def test_code_block_with_programming_languages(self, ast_builder):\n        \"\"\"Test code blocks with various programming languages.\"\"\"\n        # Test Python with incomplete statements that should continue\n        python_code = '''```python\ndef incomplete_function(\n    param1,\n    param2\n):\n    if condition:\n        return value\n```'''\n        \n        # Test JavaScript with objects\n        js_code = '''```javascript\nconst obj = {\n    property1: value1,\n    property2: {\n        nested: true\n    }\n};\n```'''\n        \n        # Test C++ with templates\n        cpp_code = '''```cpp\ntemplate<typename T>\nclass MyClass {\npublic:\n    T getValue() {\n        return value;\n    }\n};\n```'''\n        \n        for code in [python_code, js_code, cpp_code]:\n            doc = ast_builder.build_ast(code)\n            assert len(doc.children) == 1\n            code_block = doc.children[0]\n            assert code_block.__class__.__name__ == \"MarkdownCodeBlockNode\"\n            assert len(code_block.content.strip()) > 0\n\n    def test_code_block_continuation_edge_cases(self, ast_builder):\n        \"\"\"Test edge cases in code block continuation parsing.\"\"\"\n        # Code block with nested fences\n        nested_fences = '''```\nOuter code block\n  ```\n  Nested code block\n  ```\nOuter code block continues\n```'''\n        \n        doc = ast_builder.build_ast(nested_fences)\n        assert len(doc.children) == 1\n        code_block = doc.children[0]\n        assert code_block.__class__.__name__ == \"MarkdownCodeBlockNode\"\n        assert \"Nested code block\" in code_block.content\n\n    def test_code_block_with_mixed_content(self, ast_builder):\n        \"\"\"Test code blocks containing markdown-like content.\"\"\"\n        code_with_markdown = '''```\n# This looks like a heading\n- This looks like a list\n**This looks like bold**\n[This looks like a link](url)\n```'''\n        \n        doc = ast_builder.build_ast(code_with_markdown)\n        assert len(doc.children) == 1\n        code_block = doc.children[0]\n        assert code_block.__class__.__name__ == \"MarkdownCodeBlockNode\"\n        # Content should be preserved as-is\n        assert \"# This looks like a heading\" in code_block.content\n        assert \"- This looks like a list\" in code_block.content\n\n\nclass TestListHandling:\n    \"\"\"Tests for advanced list functionality.\"\"\"\n\n    def test_loose_vs_tight_lists(self, ast_builder):\n        \"\"\"Test detection of loose vs tight lists.\"\"\"\n        # Tight list (no blank lines)\n        tight_list = \"\"\"- Item 1\n- Item 2\n- Item 3\"\"\"\n        \n        # Loose list (with blank lines)\n        loose_list = \"\"\"- Item 1\n\n- Item 2\n\n- Item 3\"\"\"\n        \n        # Mixed scenario - becomes loose due to blank line\n        mixed_list = \"\"\"- Item 1\n- Item 2\n\n- Item 3\"\"\"\n        \n        # Test tight list\n        doc = ast_builder.build_ast(tight_list)\n        assert len(doc.children) == 1\n        list_node = doc.children[0]\n        assert list_node.__class__.__name__ == \"MarkdownUnorderedListNode\"\n        assert list_node.tight is True\n        \n        # Test loose list\n        doc = ast_builder.build_ast(loose_list)\n        list_node = doc.children[0]\n        assert list_node.tight is False\n        \n        # Test mixed list\n        doc = ast_builder.build_ast(mixed_list)\n        list_node = doc.children[0]\n        assert list_node.tight is False\n\n    def test_complex_nested_list_structures(self, ast_builder):\n        \"\"\"Test complex nested list scenarios.\"\"\"\n        complex_nested = \"\"\"- Level 1 Item 1\n  - Level 2 Item 1\n    - Level 3 Item 1\n    - Level 3 Item 2\n  - Level 2 Item 2\n- Level 1 Item 2\n  1. Ordered nested item 1\n  2. Ordered nested item 2\n- Level 1 Item 3\"\"\"\n        \n        doc = ast_builder.build_ast(complex_nested)\n        assert len(doc.children) == 1\n        main_list = doc.children[0]\n        assert main_list.__class__.__name__ == \"MarkdownUnorderedListNode\"\n        assert len(main_list.children) == 3\n        \n        # Check first item has nested unordered list\n        first_item = main_list.children[0]\n        assert len(first_item.children) == 2  # paragraph + nested list\n        nested_list = first_item.children[1]\n        assert nested_list.__class__.__name__ == \"MarkdownUnorderedListNode\"\n        \n        # Check second item has nested ordered list\n        second_item = main_list.children[1]\n        assert len(second_item.children) == 2  # paragraph + nested list\n        ordered_nested = second_item.children[1]\n        assert ordered_nested.__class__.__name__ == \"MarkdownOrderedListNode\"\n\n    def test_list_continuation_and_interruption(self, ast_builder):\n        \"\"\"Test text continuation within lists and list interruption.\"\"\"\n        # List with continued text\n        list_with_continuation = \"\"\"- First list item\n  continues on this line\n  and this line too\n- Second list item\n  also continues\"\"\"\n        \n        doc = ast_builder.build_ast(list_with_continuation)\n        assert len(doc.children) == 1\n        list_node = doc.children[0]\n        \n        # First item should have continued text\n        first_item = list_node.children[0]\n        first_paragraph = first_item.children[0]\n        assert \"continues on this line\" in first_paragraph.children[1].content\n        \n        # List interrupted by other content\n        interrupted_list = \"\"\"- Item 1\n- Item 2\n\nNot a list item\n\n- Item 3\"\"\"\n        \n        doc = ast_builder.build_ast(interrupted_list)\n        # Should create two separate lists with paragraph in between\n        assert len(doc.children) == 3\n        assert doc.children[0].__class__.__name__ == \"MarkdownUnorderedListNode\"\n        assert doc.children[1].__class__.__name__ == \"MarkdownParagraphNode\"\n        assert doc.children[2].__class__.__name__ == \"MarkdownUnorderedListNode\"\n\n    def test_ordered_list_with_custom_start(self, ast_builder):\n        \"\"\"Test ordered lists with non-standard start numbers.\"\"\"\n        custom_start = \"\"\"5. Fifth item\n6. Sixth item\n7. Seventh item\"\"\"\n        \n        doc = ast_builder.build_ast(custom_start)\n        assert len(doc.children) == 1\n        list_node = doc.children[0]\n        assert list_node.__class__.__name__ == \"MarkdownOrderedListNode\"\n        assert list_node.start == 5\n\n\nclass TestTableFormatting:\n    \"\"\"Tests for table alignment and formatting.\"\"\"\n\n    def test_table_alignment_variations(self, ast_builder):\n        \"\"\"Test different table column alignments.\"\"\"\n        table_markdown = \"\"\"| Left | Center | Right |\n|:-----|:------:|------:|\n| L1   | C1     | R1    |\n| L2   | C2     | R2    |\"\"\"\n        \n        doc = ast_builder.build_ast(table_markdown)\n        assert len(doc.children) == 1\n        table = doc.children[0]\n        assert table.__class__.__name__ == \"MarkdownTableNode\"\n        \n        # Check header row for alignment\n        header = table.children[0]\n        header_row = header.children[0]\n        \n        # Verify alignment is set correctly on cells\n        left_cell = header_row.children[0]\n        center_cell = header_row.children[1] \n        right_cell = header_row.children[2]\n        \n        assert left_cell.alignment == \"left\"\n        assert center_cell.alignment == \"center\"\n        assert right_cell.alignment == \"right\"\n        \n        # Check body row alignment matches\n        body = table.children[1]\n        body_row = body.children[0]\n        \n        body_left_cell = body_row.children[0]\n        body_center_cell = body_row.children[1]\n        body_right_cell = body_row.children[2]\n        \n        assert body_left_cell.alignment == \"left\"\n        assert body_center_cell.alignment == \"center\"\n        assert body_right_cell.alignment == \"right\"\n\n    def test_table_with_complex_content(self, ast_builder):\n        \"\"\"Test tables containing formatted text.\"\"\"\n        complex_table = \"\"\"| **Bold** | *Italic* | `Code` |\n|----------|----------|--------|\n| **B1**   | *I1*     | `C1`   |\n| [Link](url) | ![Image](img.jpg) | Normal |\"\"\"\n        \n        doc = ast_builder.build_ast(complex_table)\n        assert len(doc.children) == 1\n        table = doc.children[0]\n        assert table.__class__.__name__ == \"MarkdownTableNode\"\n        \n        # Check header contains formatted content\n        header = table.children[0]\n        header_row = header.children[0]\n        \n        # First header cell should contain bold text\n        bold_cell = header_row.children[0]\n        assert len(bold_cell.children) == 1\n        assert bold_cell.children[0].__class__.__name__ == \"MarkdownBoldNode\"\n        \n        # Second header cell should contain italic text\n        italic_cell = header_row.children[1]\n        assert len(italic_cell.children) == 1\n        assert italic_cell.children[0].__class__.__name__ == \"MarkdownEmphasisNode\"\n        \n        # Third header cell should contain code\n        code_cell = header_row.children[2]\n        assert len(code_cell.children) == 1\n        assert code_cell.children[0].__class__.__name__ == \"MarkdownInlineCodeNode\"\n\n    def test_table_edge_cases(self, ast_builder):\n        \"\"\"Test table parsing edge cases.\"\"\"\n        # Table with missing cells\n        uneven_table = \"\"\"| Col1 | Col2 | Col3 |\n|------|------|------|\n| A1   | A2   |\n| B1   | B2   | B3   | B4 |\"\"\"\n        \n        doc = ast_builder.build_ast(uneven_table)\n        assert len(doc.children) == 1\n        table = doc.children[0]\n        assert table.__class__.__name__ == \"MarkdownTableNode\"\n        \n        # Should handle uneven rows gracefully\n        body = table.children[1]\n        assert len(body.children) == 2  # Two body rows\n\n\nclass TestTextContinuation:\n    \"\"\"Tests for text continuation logic.\"\"\"\n\n    def test_paragraph_continuation(self, ast_builder):\n        \"\"\"Test paragraph continuation across multiple lines.\"\"\"\n        paragraph_continuation = \"\"\"This is the first line\nand this continues the same paragraph\nwith even more text on this line.\"\"\"\n        \n        doc = ast_builder.build_ast(paragraph_continuation)\n        assert len(doc.children) == 1\n        paragraph = doc.children[0]\n        assert paragraph.__class__.__name__ == \"MarkdownParagraphNode\"\n        \n        # Should contain all text with spaces between lines\n        full_text = \"\"\n        for child in paragraph.children:\n            if child.__class__.__name__ == \"MarkdownTextNode\":\n                full_text += child.content\n        \n        assert \"This is the first line\" in full_text\n        assert \"and this continues\" in full_text\n        assert \"with even more text\" in full_text\n\n    def test_list_item_continuation(self, ast_builder):\n        \"\"\"Test text continuation within list items.\"\"\"\n        list_continuation = \"\"\"- First list item\n  continues on this line\n  and continues further\n- Second list item\n  also continues here\"\"\"\n        \n        doc = ast_builder.build_ast(list_continuation)\n        assert len(doc.children) == 1\n        list_node = doc.children[0]\n        \n        # First item should contain continued text\n        first_item = list_node.children[0]\n        first_paragraph = first_item.children[0]\n        \n        # Extract all text content\n        full_text = \"\"\n        for child in first_paragraph.children:\n            if child.__class__.__name__ == \"MarkdownTextNode\":\n                full_text += child.content\n        \n        assert \"First list item\" in full_text\n        assert \"continues on this line\" in full_text\n        assert \"and continues further\" in full_text\n\n    def test_continuation_with_line_breaks(self, ast_builder):\n        \"\"\"Test text continuation with explicit line breaks.\"\"\"\n        text_with_breaks = \"\"\"First line  \nSecond line with break\nThird line continues normally\"\"\"\n        \n        doc = ast_builder.build_ast(text_with_breaks)\n        assert len(doc.children) == 1\n        paragraph = doc.children[0]\n        \n        # Should contain line break node\n        has_line_break = False\n        for child in paragraph.children:\n            if child.__class__.__name__ == \"MarkdownLineBreakNode\":\n                has_line_break = True\n                break\n        assert has_line_break\n\n    def test_continuation_edge_cases(self, ast_builder):\n        \"\"\"Test edge cases in text continuation.\"\"\"\n        # Continuation after different elements\n        mixed_continuation = \"\"\"# Heading\n\nParagraph starts here\nand continues on next line\n\n- List item\n  continues here\n  \nAnother paragraph\ncontinues normally\"\"\"\n        \n        doc = ast_builder.build_ast(mixed_continuation)\n        # Should have heading, paragraph, list, and another paragraph\n        assert len(doc.children) == 4\n        assert doc.children[0].__class__.__name__ == \"MarkdownHeadingNode\"\n        assert doc.children[1].__class__.__name__ == \"MarkdownParagraphNode\"\n        assert doc.children[2].__class__.__name__ == \"MarkdownUnorderedListNode\"\n        assert doc.children[3].__class__.__name__ == \"MarkdownParagraphNode\"\n\n\nclass TestEdgeCases:\n    \"\"\"Tests for edge cases and error conditions.\"\"\"\n\n    def test_unclosed_code_block(self, ast_builder):\n        \"\"\"Test handling of unclosed code blocks.\"\"\"\n        markdown = \"\"\"```python\ndef unclosed_function():\n    print(\"This code block is not closed\")\n\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        assert len(doc.children) == 1\n        code_block = doc.children[0]\n        assert code_block.__class__.__name__ == \"MarkdownCodeBlockNode\"\n        assert code_block.language == \"python\"\n\n    def test_nested_code_blocks(self, ast_builder):\n        \"\"\"Test handling of nested code blocks.\"\"\"\n        markdown = \"\"\"```\nOuter code block\n  ```\n  Nested code block\n  ```\nOuter code block continues\n```\n\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        assert len(doc.children) == 1\n        code_block = doc.children[0]\n        assert code_block.__class__.__name__ == \"MarkdownCodeBlockNode\"\n        assert \"Nested code block\" in code_block.content\n\n    def test_incomplete_table(self, ast_builder):\n        \"\"\"Test handling of incomplete tables.\"\"\"\n        markdown = \"\"\"\n| Header 1 | Header 2 |\n|----------|----------|\n\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        # The AST builder should not create a table without any body rows\n        assert len(doc.children) == 2\n        assert doc.children[0].__class__.__name__ == \"MarkdownParagraphNode\"\n        assert doc.children[1].__class__.__name__ == \"MarkdownParagraphNode\"\n\n    def test_invalid_table_separator(self, ast_builder):\n        \"\"\"Test handling of invalid table separators.\"\"\"\n        markdown = \"\"\"\n| Header 1 | Header 2 |\n| Invalid | Separator |\n| Cell 1   | Cell 2   |\n\"\"\"\n        doc = ast_builder.build_ast(markdown)\n        # Should be treated as paragraphs\n        assert len(doc.children) == 3\n        assert all(child.__class__.__name__ == \"MarkdownParagraphNode\" for child in doc.children)\n\n    def test_mixed_list_markers(self, ast_builder):\n        \"\"\"Test lists with mixed markers.\"\"\"\n        mixed_markers = \"\"\"- Item with dash\n* Item with asterisk\n+ Item with plus\n- Back to dash\"\"\"\n        \n        doc = ast_builder.build_ast(mixed_markers)\n        # Should create separate lists for different markers\n        assert len(doc.children) >= 1\n        # All should be unordered lists\n        for child in doc.children:\n            assert child.__class__.__name__ == \"MarkdownUnorderedListNode\"\n\n    def test_empty_elements(self, ast_builder):\n        \"\"\"Test handling of empty elements.\"\"\"\n        empty_elements = \"\"\"\n\n\n# \n\n**\n\n[]()\n\n![]()\n\n```\n```\n\n| |\n|-|\n| |\n\"\"\"\n        doc = ast_builder.build_ast(empty_elements)\n        # Should handle empty elements gracefully without crashing\n        assert doc is not None\n        assert len(doc.children) >= 0\n```",
      "completed": true,
      "usage": {
        "prompt_tokens": 25842,
        "completion_tokens": 8733,
        "total_tokens": 34575
      },
      "error": null,
      "model": "claude-4-sonnet-20250514",
      "temperature": 0.7
    }
  ]
}