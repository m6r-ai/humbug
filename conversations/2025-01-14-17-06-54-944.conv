{
  "metadata": {
    "timestamp": "2025-01-14T17:06:54.944268",
    "version": "0.1"
  },
  "conversation": [
    {
      "id": "a1160cd6-a56f-4a33-a3dd-89968f569432",
      "timestamp": "2025-01-14T17:07:06.284166",
      "type": "user_message",
      "content": "The following preamble describes some elements of a language called Metaphor.  Please pay\nextremely close attention to the details as they will affect the way you interpret\neverything that follows after \"BEGIN DESCRIPTION IN METAPHOR:\"\n\nMetaphor has the structure of a document tree with branches and leaves being prefixed\nby the keywords \"Role:\", \"Context:\" or \"Action:\".  Each of these indicates the\nstart of a new block of information.\n\nBlocks have an optional section name that will immediately follow them on the same line.\nIf this is missing then the section name is not defined.\n\nAfter a keyword line there may be one or more lines of text that will describe the purpose\nof that block.  A block may also include one or more optional child blocks inside them and\nthat further clarify their parent block.  These text blocks and any keywords lines nested\ninside a parent block will be indented by 4 spaces more than its parent.\n\nFor example a \"Context:\" indented by 8 spaces is a child of the block above it that is\nindented by 4 spaces.  One indented 12 spaces would be a child of the block above it that is\nindented by 8 spaces.\n\nWithin the text of a block, you may be presented with code or document fragments inside a\nblock delimited by 3 backticks.  Please pay close attention to the indentation level of the\nopening 3 backticks.  The identation of such code or document fragments is relative to this,\nnot relative to the block in which the code or document fragment occurs.\nFor example, consider:\n    ```plaintext\n    text line 1\n      text line 2\n    ```\n        ```plaintext\n         text line 3\n        ```\nIn this example, \"text line 1\" is not indented from the opening 3 backticks and thus has no\nindentation.  \"text line 2\" is indented by 2 spaces relative to the opening 3 backticks\n \"text line 3\" is indented by 1 space relative to its opening 3 backticks.\n\nIf \"Role:\" blocks exists then these contain details about the role you should fulfil.  This\nsection may also describe specific skills you have, knowledge you should apply, and the\napproach you take to apply these.\n\"Context:\" blocks provide context necessary to understand what you will be asked to do.\n\n\"Action:\" blocks describes the task, or tasks, I would like you to do.\n\nWhen you process the actions please carefully ensure you do all of them accurately and\ncomplete all the elements requested.  Unless otherwise instructed, do not include any\nplaceholders in your responses.\n\nBEGIN DESCRIPTION IN METAPHOR:\nRole:\n    You are a world-class python programmer with a flair for building brilliant software\nContext: Humbug application\n    Context: Capabilities\n        Humbug is a GUI-based application that allows a user to interact with one or more AI backends.\n        Navigation is done using a keyboard and mouse.\n        Context: Version\n            This is version 0.2 of the application.\n        Context: Application window\n            The main window is divided into two primary regions: a file tree view on the left side, and a tabbed\n            interface on the right side. The two regions are separated by a resizable splitter that allows the user\n            to adjust the relative widths.  At the bottom of the main window is an application status bar.\n            Tabs can be arranged as either single column of tabs, or have a split view that has two columns of tabs\n            side-by-side.\n            Context: Tab columns\n                Context: Column layout options\n                    The application supports both single-column and multi-column layouts.\n                    We support a maximum of 6 columns.\n                    Each column maintains its own set of tabs.\n                    One column is always the active column.\n                    The active column receives new tabs by default.\n                    The active column is visually distinguished from inactive columns because the active tab is\n                    clearly visible.\n                    Clicking in a column or its tabs makes it the active column.\n                    Keyboard focus changes also updates the active column.\n                    When a column becomes empty, that column becomes closed and is removed.\n                    If all tabs in a column are closed then the column is also closed.\n                    If multiple columns are open then tabs can be moved from one column to another by dragging and\n                    dropping them with the mouse.\n                Context: Column merging and splitting\n                    Provided there is more than one tab open in the currently-active column, then the currently-active\n                    column can be split, with the current open tab moving to the new column.\n                    Provided there is more than one column open, then the current column can be merged with any\n                    adjacent column, with all tabs moving to that column and the current column being closed.\n                Context: Column persistence\n                    The column layout is persisted with the workspace.\n                    Each tab's column position is restored when reopening a workspace.\n                    Column sizes are preserved between sessions.\n            Context: File tree view\n                The file tree displays the contents of the current workspace:\n                - Shows all files and folders in the workspace directory\n                - Excludes the \".humbug\" directory and other hidden files/folders\n                - Directories are shown before files in the tree\n                - Files and directories are sorted alphabetically within their sections\n                - The tree supports keyboard navigation using arrow keys\n                - Double-clicking or pressing Enter on a file opens it in a new editor tab\n                - If the file is already open, its tab becomes active instead\n                - Directory nodes can be expanded/collapsed using arrow keys or mouse\n                - Initial view is set to 30% of the window width, but can be resized\n                - Styling matches the current application theme (light/dark mode)\n                - The tree view updates automatically when files are added or removed\n                Context: File tree styling\n                    The file tree view must maintain consistent styling:\n                    - Background color matches the application theme\n                    - Tree items use primary text color\n                    - Selected items use tab active background color\n                    - Hover state uses tab hover background color\n                    - Tree lines and expander icons match theme colors\n                    - Splitter handle uses 1px width with theme background\n                    - All colors follow the dark/light mode selection\n                    - Font sizes scale with application zoom level\n                    - Padding and spacing match the theme metrics\n            Context: Tab view\n                The tabbed interface has tabs that correspond to either conversations being\n                had with one or more AI backends, or files being edited.\n                Selecting a tab brings that conversation to the front of the tab group.\n                When there are no tabs open, the application displays a welcome message in the main window area.\n                The welcome message appears in a styled box with dialog-style spacing that shows:\n                - The application name \"Humbug\" in a font twice the size of the default application font\n                - The version number underneath in the default font size\n                Both pieces of text are centered within the styled box.\n                The welcome message is automatically hidden when tabs are created and reappears when all tabs are closed.\n                Context: Tab types\n                    There are two distinct types of tabs:\n                    - Conversation tabs: For AI interactions\n                    - Editor tabs: For file editing\n                    Each type has its own distinct visual appearance and behavior.\n                    Active tabs are a different colour to inactive tabs, and the active tab has a 2px border at the top to\n                    highlight that it is the active tab.\n                    Context: Conversation tabs\n                        Each tab will be named with a conversation name.  This will default to \"Conv: ID\" where <ID> is a\n                        based on the date and time at which the conversation started.  The ID format will be:\n                        \"yyyy-mm-dd-hh-mm-ss-ttt\", substituting the conversation start date and time (in UTC) for yyyy,\n                        mm, dd, hh, mm, ss, ttt (year, numeric month, day-of-month, hours, minutes, seconds, and thousandths of\n                        seconds respectively).\n                        Each tab will have a close button (typically rendered as an \"x\" icon) that appears after the conversation\n                        name.  Clicking this close button will close the tab in the same way as clicking the \"Close Conversation\"\n                        menu item.\n                        The close button will be:\n                        - Always visible but not highlighted on the currently selected tab.\n                        - Hidden by default on non-selected tabs, appearing only when the tab is hovered over.\n                        - Use a transparent background when not hovered\n                        - Highlighted in red (#ff4444) when the mouse hovers over the close button itself.\n                        Context: History display\n                            Each message in the history appears as a distinct \"card\" that spans the full width of the history view.\n                            Each card has:\n                            - A header section containing the sender name (\"You\", \"Assistant\", or \"System Message\"), colour coded\n                            to show these in different colours based on the role.\n                            - A content section.\n                            - 8px spacing between cards\n                            - 8px padding within the content area\n                            - 8px rounded border around each card\n                            The cards dynamically resize with the window:\n                            - The width always matches the window width (minus margins and scroll bar)\n                            - The height adjusts automatically based on the content\n                            - Text wraps within the card boundaries\n                            - Code blocks maintain their formatting while wrapping where possible\n                            Context: Example layout\n                                Here's an ASCII representation of the layout:\n                                ```plaintext\n                                +------------------------------------------+\n                                |  You                                     |\n                                |                                          |\n                                |  This is a user message that wraps       |\n                                |  across multiple lines as needed.        |\n                                +------------------------------------------+\n                                                \u2195 10px\n                                +------------------------------------------+\n                                |  Assistant                               |\n                                |                                          |\n                                |  This is an AI response that also wraps  |\n                                |  across multiple lines as needed.        |\n                                |                                          |\n                                |  ```python                               |\n                                |  def example():                          |\n                                |      print(\"Code blocks maintain their   |\n                                |            formatting\")                  |\n                                |  ```                                     |\n                                +------------------------------------------+\n                                                \u2195 10px\n                                +------------------------------------------+\n                                |  System Message                          |\n                                |                                          |\n                                |  This is a system message that wraps     |\n                                |  across multiple lines as needed.        |\n                                +------------------------------------------+\n                                ```\n                        Context: Input box behavior\n                            The input box starts with a single line and expands vertically as content is added.\n                            The input box supports:\n                                - Home key: Moves cursor to start of current line\n                                - End key: Moves cursor to end of current line\n                                - Ctrl+Home: Moves cursor to start of message\n                                - Ctrl+End: Moves cursor to end of message\n                                - Page Up/Down: Scroll by viewport height\n                        Context: Selection behaviour\n                            Selection of text is limited to within a single message - it cannot span across multiple\n                            messages or between the input area and message history.\n                            When selecting text near the top or bottom of the visible area, the view will\n                            automatically scroll to follow the selection.\n                            The scroll speed increases based on how far outside the visible area the cursor is.\n                            The maximum scroll speed is reached when the cursor is twice the viewport height away.\n                    Context: Editor tabs\n                        Each editor tab will be named with the filename being edited.\n                        For new unsaved files this will be \"Untitled-<num>\" where <num> is a simple incrementing number\n                        starting from 1 for each new file created during the current run of the application.\n                        Like conversation tabs, editor tabs will have a close button that appears after the filename.\n                        If there are unsaved changes in the file, an asterisk (*) will appear after the filename.\n                        The close button behavior matches that of conversation tabs.\n                        Context: Navigation\n                            The editor supports:\n                                - Home key: Moves cursor to start of current line\n                                - End key: Moves cursor to end of current line\n                                - Ctrl+Home: Moves cursor to start of message\n                                - Ctrl+End: Moves cursor to end of message\n                                - Page Up/Down: Scroll by viewport height\n                        Context: Tab key operations\n                            The Tab key indents one or more lines of code.  If the workspace is configured to use not use soft\n                            tabs then indenting is by one tab character.  If the workspace is configured to use soft tabs then\n                            indenting is by \"tabSize\" spaces.\n                            The Shift+Tab key combination key outdents one or more lines of code.  If the workspace is configured\n                            to use not use soft tabs then outdenting is by one tab character, unless there are no leading tab\n                            characters in which case no outdenting occurs.  If the workspace is configured to use soft tabs then\n                            outdenting is by \"tabSize\" spaces, unless there are not enough leading spaces, in which case all\n                            available leading spaces will be removed.\n                            If the user has highlighted a block of text and then presses Tab or Shift+Tab then all of that block\n                            of code should be indented or outdented.  The cursor position should move to the next or previous\n                            tab stop.\n                            If the user has not highlighted a block of text then the Tab operation works from the current column\n                            and will result in moving everything to the right of the cursor to start at the next tab stop.  The\n                            cursor will also move to match the amoutn indented.\n                            If the user has not highlighted a block of text then the Shift+Tab operation works from the current\n                            column and will attempt to outdent everything to the right of the cursor to start at the previous\n                            tab stop, or to the next non-whitespace character if this occurs before the previous tab stop.  The\n                            cursor will move to match the amount outdented.\n                Context: Syntax highlighting\n                    Code blocks and inline code will be syntax highlighted based on the programming language:\n                    - Keywords appear in pink (#ffc0eb)\n                    - Comments appear in green (#68d068)\n                    - Strings appear in red (#f06060)\n                    - Numbers appear in orange (#c08040)\n                    - Operators appear in light grey (#c0c0c0)\n                    - Functions and methods appear in light yellow (#e0e080)\n                    - Class and type names appear in light blue (#80b0f0)\n                    - Regular expressions appear in orange-brown (#c87050)\n                    - Element access appears in light blue (#90e0e8)\n                    - HTML/CSS-specific:\n                        - HTML tags appear in pink (#ffc0eb)\n                        - HTML attributes appear in light blue (#90e0e8)\n                        - CSS at-rules appear in pink (#ffc0eb)\n                        - DOCTYPE declarations appear in grey (#808080)\n                    - Preprocessor directives appear in grey (#808080)\n                    - Error text appears in red (#ff0000)\n                    The syntax highlighting is updated in real-time as text is entered or changed.\n                    Context: Language detection\n                        When a code block starts with a language identifier (e.g., ```python), the\n                        appropriate syntax highlighting rules for that language are applied.\n                        If no language is specified, the code is treated as plain text with no highlighting.\n                    Context: Supported languages\n                        Syntax highlighting is supported for:\n                        - C\n                        - C++\n                        - CSS\n                        - HTML\n                        - JavaScript\n                        - Metaphor\n                        - Python\n                        - TypeScript\n            Context: Dialog styling\n                Modal dialogs must maintain visual consistency with the application theme:\n                Context: Color scheme\n                    Dialogs must use the same color scheme as the main application:\n                    - Dialog background uses BACKGROUND_DIALOG color\n                    - Dialog icon color matches TEXT_PRIMARY color\n                    - Dialog text background matches dialog background\n                    - Text uses TEXT_PRIMARY color\n                    - Buttons use BUTTON_BACKGROUND background color, with BUTTON_BACKGROUND_HOVER for hover state,\n                      BUTTON_BACKGROUND_DISABLED for disabled buttons, and BUTTON_BACKGROUND_PRESSED when they are pressed.\n                    - All text and interactive elements must respect current theme colors\n                Context: Layout\n                    Dialog boxes must maintain consistent layout:\n                    - Minimum width of 400px\n                    - Message text uses minimum height of 40px\n                    - Buttons centered with 8px margin above\n                    - All buttons same size with 80px minimum width\n                    - Button padding of 6px\n                    - 4px margin between buttons\n        Context: Workspace structure\n            A workspace represents a project-specific environment containing its own settings and state.\n            Every workspace is identified by a \".humbug\" directory within the project directory.\n            The workspace \".humbug\" directory contains:\n            - settings.json: Project-specific configuration\n            - session.json: State of active elements\n            Context: Settings file\n                The settings.json file contains workspace-specific configuration:\n                ```json\n                {\n                    \"editor\": {\n                        \"useSoftTabs\": true,\n                        \"tabSize\": 4,\n                        \"fontSize\": 12\n                    }\n                }\n                ```\n                The application validates this file on workspace load:\n                - useSoftTabs must be boolean\n                - tabSize must be positive integer\n                If validation fails:\n                - Show error dialog with specific issues\n                - Use defaults: soft tabs (true) and 4 spaces\n                - Continue loading workspace\n            Context: Recents file\n                The session.json file tracks workspace state for restoration:\n                ```json\n                {\n                    \"tabs\": [\n                        {\n                            \"type\": \"conversation\",\n                            \"path\": \"conversations/2024-01-03-12-34-56-789.conv\"\n                        },\n                        {\n                            \"type\": \"editor\",\n                            \"path\": \"src/main.py\",\n                            \"cursorPosition\": {\n                                \"line\": 10,\n                                \"column\": 15\n                            }\n                        }\n                    ]\n                }\n                ```\n                The file is:\n                - Read on workspace load to restore state\n                - Updated when workspace closes\n                - Updated when application exits\n                During restoration:\n                - Attempt to restore each element\n                - Skip elements that cannot be restored\n                - Continue with remaining elements\n                - No error shown for skipped elements\n            Context: Workspace settings\n                As an engineer maintaining the application, I want to ensure settings are documented so I can understand\n                all configuration options.\n                Context: Settings Dialog\n                    Context: Editor settings\n                        The editor supports configurable settings.\n                        Context: Tab settings\n                            The editor supports configurable tab behavior.\n                            Context: Soft tabs\n                                The useSoftTabs setting controls whether pressing the tab key inserts literal\n                                tab characters or equivalent spaces.\n                            Context: Tab size\n                                The tabSize setting controls how many spaces wide a tab or soft tab will be.\n                        Context: Font size\n                            The fontSize setting controls the base font size used in editors and related text areas.\n                            When not specified, the system default font size will be used.\n                            The font size must be between 8.0 and 24.0 points, and supports one decimal place of precision.\n                    Context: Auto backup settings\n                        The editor supports automatic backup of unsaved changes.\n                        Context: Auto backup\n                            The \"Auto Backup\" setting controls whether automatic backup is enabled.\n                            When enabled, unsaved changes are automatically backed up at regular intervals.\n                            By default, this setting is disabled.\n                        Context: Backup interval\n                            The \"Backup Interval\" setting controls how frequently backups occur.\n                            The interval can be set between 60 seconds (1 minute) and 3600 seconds (1 hour).\n                            Default interval is 300 seconds (5 minutes).\n                        Context: Backup location\n                            For untitled files, backups are stored in the workspace \".humbug/backups\" directory with timestamp.\n                            For saved files, backups are stored alongside the original with \".backup\" extension.\n                        Context: Backup behavior\n                            Backups only occur when:\n                            - Auto backup is enabled in workspace settings\n                            - The file has unsaved changes\n                            - The specified backup interval has elapsed since last backup\n                            Backups do not replace the original file and are preserved until the file is saved.\n        Context: Home directory configuration\n            The application maintains a \".humbug\" directory in the user's home directory.\n            This contains workspace.json tracking the last open workspace:\n            ```json\n            {\n                \"lastWorkspace\": \"/path/to/project/.humbug\"\n            }\n            ```\n            This workspace is restored on application startup if:\n            - The workspace path exists\n            - The workspace is accessible\n            - The workspace contains valid settings.json\n            Context: API key configuration\n                The application supports loading API keys from both environment variables and a configuration file.\n                The configuration file \"api-keys.json\" is stored in the \".humbug\" directory in the user's home directory.\n                Context: API keys file\n                    The api-keys.json file contains API keys for different providers:\n                    ```json\n                    {\n                        \"OPENAI_API_KEY\": \"\",\n                        \"GOOGLE_API_KEY\": \"\",\n                        \"ANTHROPIC_API_KEY\": \"\"\n                    }\n                    ```\n                    The file is:\n                    - Created automatically if it doesn't exist\n                    - Set to mode 0o600 (user read/write only) for security\n                    - Read during application startup\n                    Context: Key precedence\n                        API keys are loaded with the following precedence:\n                        1. Non-empty values from api-keys.json\n                        2. Environment variables if corresponding file value is empty\n                        The environment variables checked are:\n                        - OPENAI_API_KEY for OpenAI models\n                        - GOOGLE_API_KEY for Google models\n                        - ANTHROPIC_API_KEY for Anthropic models\n                    Context: File permissions\n                        For security:\n                        - The .humbug directory is created with mode 0o700 (user access only)\n                        - The api-keys.json file is created with mode 0o600 (user read/write only)\n                    Context: Error handling\n                        If the api-keys.json file:\n                        - Cannot be created: Log error and fall back to environment variables\n                        - Contains invalid JSON: Log error and raise exception\n                        - Has permission issues: Log error and fall back to environment variables\n                        The application requires at least one valid API key to start.\n        Context: Workspace operations\n            Context: File tree interaction\n                When a workspace is opened:\n                - The file tree root is set to the workspace directory\n                - The tree expands to show first level of contents\n                - Previous expansion state is not preserved\n                When a workspace is closed:\n                - The file tree is cleared\n                The file tree supports:\n                - Display filtering to hide .humbug and hidden files\n                - Automatic refresh when files change on disk\n                - Files opened through the tree are tracked in workspace state\n                - Path handling for both absolute and workspace-relative paths\n            Context: Creating workspaces\n                When creating a new workspace:\n                - Show directory selection dialog\n                - Validate no existing \".humbug\" directory\n                - Create \".humbug\" directory if valid\n                - Create default settings.json\n                - Create empty session.json\n                - Show error if creation fails\n            Context: Opening workspaces\n                When opening a workspace:\n                - Show directory selection dialog\n                - Filter for directories with \".humbug\" subdirectory\n                - Close current workspace if one exists\n                - Load selected workspace\n                - Restore workspace state\n                - Update home directory tracking\n            Context: Closing workspaces\n                When closing a workspace:\n                - Save current state to session.json\n                - Close all workspace elements\n                - Clear workspace state\n                - Update home directory tracking\n        Context: State handling\n            Context: Workspace management\n                The application requires an active workspace for most operations:\n                - Conversations are stored within the workspace\n                - Editor files are opened relative to workspace\n                - Settings are loaded from workspace\n                - Application state persists in workspace\n                Without an active workspace:\n                - New conversation operations disabled\n                - File operations disabled\n                - Only workspace creation/open enabled\n                - Welcome message displays workspace instructions\n                On startup:\n                1. Check home directory for last workspace\n                2. If found, attempt to restore.  If any previous tabs cannot be restored then ignore them.\n                3. If restore fails, start without workspace\n                4. Show welcome with workspace options\n                On workspace change:\n                1. Save current workspace state\n                2. Close all active elements\n                3. Load new workspace settings\n                4. Restore workspace elements\n                5. Update home directory tracking\n            Context: File tree state\n                The file tree maintains a visual state that includes:\n                - Current workspace root directory\n                - Expanded/collapsed state of directories\n                - Selected item (if any)\n                - Column widths and sorting order\n                This state is not persisted between sessions.\n                Files opened through the tree are tracked in:\n                - The workspace recents file for persistence\n                - Active tab management for the current session\n        Context: Menus\n            The application will have a series of top-level Menus.\n            Where any action cannot be performed at the current time it will be greyed out.\n            Context: Humbug\n                The \"Humbug\" menu is the main application menu.  When clicked it contains the following:\n                Context: About Humbug\n                    The \"About Humbug\" menu item will deliver a modal pop-up dialog box that gives details of the\n                    application and version information.\n                Context: Separator\n                    There will be a horizontal Separator\n                Context: Quit Humbug\n                    The \"Quit Humbug\" menu item will allow the user to exit the application.\n                    This will be matched with a keyboard shortcut (e.g. \"Ctrl+Q\" for Windows).\n            Context: File\n                The \"File\" menu handles new files and tabs.  When clicked it contains the following:\n                Context: New Workspace\n                    The \"New Workspace\" menu item creates a new workspace:\n                    - Shows directory selection dialog\n                    - Creates \".humbug\" directory and files\n                    We cannot create a \".humbug\" directory where one already exists.\n                    This will be matched with keyboard shortcut \"Ctrl+Alt+N\"\n                Context: New Conversation\n                    The \"New Conversation\" menu item will create a new conversation tab.\n                    This will be matched with a keyboard shortcut (e.g. \"Ctrl+Shift+N\" for Windows).\n                    This option is only valid if a workspace is open.\n                Context: New Metaphor Conversation\n                    The \"New Metaphor Conversation\" menu item will create new conversation tab based on a\n                    Metaphor file.\n                    When invoked the user will be prompted with a file selection dialog allowing them to\n                    select a \"*.m6r\" file to use to start the conversation.  Once a file is selected then\n                    it will be compiled using the m6rclib compiler.  If compilation fails then a message\n                    box will indicate the problem/problems to the user.\n                    On successful compilation of the Metaphor file a new conversation will be opened, and\n                    the compiled prompt will be inserted into the input control, with the cursor placed at\n                    the end of the input.\n                    This will be matched with a keyboard shortcut (e.g. \"Ctrl+Shift+M\" for Windows).\n                    This option is only valid if a worksapce is open.\n                Context: New File\n                    The \"New File\" menu item will create a new empty editor tab.\n                    This will be matched with a keyboard shortcut \"Ctrl+N\".\n                    This option is only valid if a workspace is open.\n                Context: Separator\n                    There will be a horizontal Separator\n                Context: Open Workspace\n                    The \"Open Workspace\" menu item opens an existing workspace:\n                    - Shows directory selection dialog\n                    - Filters for \".humbug\" directories\n                    - Closes current workspace\n                    - Opens selected workspace\n                    This will be matched with a keyboard shortcut (e.g. \"Ctrl+Alt+O\" for Windows).\n                Context: Open Conversation\n                    The \"Open Conversation...\" menu item will show a file selection dialog allowing the user to open\n                    an existing conversation transcript and continue the conversation in the same file.\n                    When opened, the conversation history will be restored including:\n                    - All previous messages (user and AI)\n                    - System messages and error states\n                    - Model selection and temperature settings\n                    If the conversation is already open then that tab should move to being the current active tab.\n                    This will be matched with a keyboard shortcut \"Ctrl+Shift+O\".\n                    This option is only valid if a workspace is open.\n                Context: Open File\n                    The \"Open File...\" menu item will show a file selection dialog allowing the user to open\n                    an existing file in a new editor tab.\n                    This will be matched with a keyboard shortcut (e.g. \"Ctrl+O\" for Windows).\n                    This option is only valid if a workspace is open.\n                Context: Separator\n                    There will be a horizontal Separator\n                Context: Fork Conversation\n                    The \"Fork Conversation\" menu item will create a new conversation tab containing the history of the\n                    currently selected conversation tab.\n                    This will create a new transcript file based on the current date/time, but will retain all previous\n                    message dates and times.\n                    This will be matched with a keyboard shortcut \"Ctrl+Shift+F\".\n                Context: Separator\n                    There will be a horizontal Separator\n                Context: Save\n                    The \"Save\" menu item will save the current file if it is an editor tab.\n                    If this is a new untitled file, this will behave like \"Save As...\".\n                    This will be matched with a keyboard shortcut (e.g. \"Ctrl+S\" for Windows).\n                Context: Save As\n                    The \"Save As...\" menu item will show a file save dialog allowing the user to save the\n                    current file under a new name.\n                    This will be matched with a keyboard shortcut (e.g. \"Ctrl+Shift+S\" for Windows).\n                Context: Separator\n                    There will be a horizontal Separator\n                Context: Close Workspace\n                    The \"Close Workspace\" menu item closes current workspace:\n                    - Saves state to session.json\n                    - Closes all workspace elements\n                    This will be matched with a keyboard shortcut (e.g. \"Ctrl+Alt+W\" for Windows).\n                    This option is only valid if a workspace is open.\n                Context: Close Tab\n                    The \"Close Tab\" menu item with close the current tab, if a tab is active.\n                    This will be matched with a keyboard shortcut (e.g. \"Ctrl+W\" for Windows).\n            Context: Edit\n                The \"Edit\" menu handles edit capabilities.  When clicked it contains the following:\n                Context: Submit Message\n                    The \"Submit Message\" menu item will submit the current user input message to the AI, where there is\n                    an input message to be submitted.\n                    This will be matched with a keyboard shortcut, \"Ctrl+J\".\n                Context: Separator\n                    There will be a horizontal Separator\n                Context: Undo\n                    The \"Undo\" menu item will all the last user input action that has not yet been committed (e.g.\n                    sent to the AI) to be undone.\n                    This will be matched with a standard keyboard shortcut (e.g. \"Ctrl+Z\" for Windows).\n                Context: Redo\n                    The \"Redo\" menu item will restore previos undo operations, where the last user input action has\n                    not yet been committed (e.g. sent to the AI) to be undone.\n                    This will be matched with a standard keyboard shortcut (e.g. \"Ctrl+Shift+Z\" for Windows).\n                Context: Separator\n                    There will be a horizontal Separator\n                Context: Cut\n                    The \"Cut\" menu item will support the cutting of input text from a highlighted area where such\n                    text can be removed.\n                    This will be matched with a standard keyboard shortcut (e.g. \"Ctrl+X\" for Windows).\n                Context: Copy\n                    The \"Copy\" menu item will support the copying of text from a highlighted area.\n                    This will be matched with a standard keyboard shortcut (e.g. \"Ctrl+C\" for Windows).\n                Context: Paste\n                    The \"Paste\" menu item will support the pasting of text at the current input cursor, where\n                    new text can be added.\n                    This will be matched with a standard keyboard shortcut (e.g. \"Ctrl+V\" for Windows).\n                Context: Paste behavior\n                    When text is pasted into the input area via any method (menu, keyboard shortcuts, or right-click),\n                    only the plain text content is transferred.  All formatting from the source text (including fonts,\n                    colours, and text styling) is removed, ensuring the pasted content matches the default input area\n                    styling.\n                    After the paste operation completes, the cursor should be at the end of the pasted block.\n                Context: Separator\n                    There will be a horizontal Separator\n                Context: Workspace Settings\n                    The \"Workspace Settings\" menu item will support setting the current workspace's settings.\n                    This will be matched with a standard keyboard shortcut (e.g. \"Ctrl+Alt+,\" for Windows).\n                Context: Conversation Settings\n                    The \"Conversation Settings\" menu item will support setting the conversation settings of\n                    the currently focused conversation tab (if there is one).\n                    This will be matched with a standard keyboard shortcut (e.g. \"Ctrl+,\" for Windows).\n            Context: View\n                The \"View\" menu handles view settings.  When clicked it contains the following:\n                Context: Dark Mode\n                    The \"Dark Mode\" menu item will have a checkmark indicating if dark mode is enabled or not.\n                    By default it will be enabled.\n                    The application will support a distinct set of light and dark mode colour styling.\n                Context: Separator\n                    There will be a horizontal Separator\n                Context: Zoom In\n                    The \"Zoom In\" menu item will support zooming in and making the contents of the application\n                    larger.  All visual elements must increase in size by a factor of 1.189027, up to a maximum\n                    of 2.0\n                    This will be matched with a keyboard shortcut (e.g. \"Ctrl+=\" for Windows).\n                Context: Zoom Out\n                    The \"Zoom Out\" menu item will support zooming out and making the contents of the application\n                    smaller.  All visual elements must decrease in size by a factor of 1.189027, down to a minimum\n                    of 0.5\n                    This will be matched with a keyboard shortcut (e.g. \"Ctrl+-\" for Windows).\n                Context: Reset Zoom\n                    The \"Reset Zoom\" menu item will restore the zoom level of the application to its default 1.0\n                    of 0.5\n                    This will be matched with a keyboard shortcut (e.g. \"Ctrl+0\" for Windows).\n                Context: Separator\n                    There will be a horizontal Separator\n                Context: Show All Columns\n                    The \"Show All Columns\" menu item will support showing all active columns, by making them all visible\n                    and the same width.\n                    This will be matched with a keyboard shortcut (e.g. \"Ctrl+\\\" for Windows).\n                Context: Split Column Left\n                    The \"Split Column Left\" menu item will support splitting the current column and moving the current\n                    tab to a new column to the left of the current one.\n                    This will only be supported if we have not reached the maximum number of columns.\n                    This will be matched with a keyboard shortcut (e.g. \"Ctrl+Shift+[\" for Windows).\n                Context: Split Column Right\n                    The \"Split Column Right\" menu item will support splitting the current column and moving the current\n                    tab to a new column to the right of the current one.\n                    This will only be supported if we have not reached the maximum number of columns.\n                    This will be matched with a keyboard shortcut (e.g. \"Ctrl+Shift+]\" for Windows).\n                Context: Merge Column Left\n                    The \"Merge Column Left\" menu item will support merging the current column with the one to its left as\n                    long as the current active column is not the left hand column.\n                    This will be matched with a keyboard shortcut (e.g. \"Ctrl+[\" for Windows).\n                Context: Merge Column Right\n                    The \"Merge Column Right\" menu item will support merging the current column with the one to its right as\n                    long as the current active column is not the right hand column.\n                    This will be matched with a keyboard shortcut (e.g. \"Ctrl+]\" for Windows).\n            Context: Menu styling\n                Menus and menu items must have consistent visual styling:\n                - Menu items have 4px border radius for rounded corners\n                - Menu items have 8px horizontal padding and 4px vertical padding\n                - Menu items highlight with a darker background colour on hover\n                - Submenus have a 1px border and 4px border radius\n                The specific colours and measurements should scale with the application's zoom level and colour styling.\n            Context: Menu state updates\n                Menu item states (enabled/disabled) must be updated at least every 50ms to ensure responsive UI\n                feedback to user actions.\n        Context: File editing\n            Editor tabs provide a full-featured text editor with the following capabilities:\n            Context: Basic editing\n                Standard text editing operations including:\n                - Cut/Copy/Paste with standard keyboard shortcuts\n                - Undo/Redo functionality\n                - Find/Replace functionality\n                - Line number display\n                - Cursor position display (line:column) in status bar\n            Context: Syntax highlighting\n                The editor automatically detects and applies syntax highlighting based on file extension\n                and content, using the same highlighting rules defined for conversation code blocks.\n            Context: Save state handling\n                The editor tracks changes and maintains a 'dirty' state:\n                - Modified files are marked with an asterisk in the tab name\n                - Attempting to close a modified file prompts for save\n                - Auto-save backups are maintained periodically if the file has unsaved changes and auto-backup is enabled.\n            Context: Status bar\n                The editor status bar shows:\n                - Current line and column numbers\n                - File encoding (UTF-8, etc.)\n                - Line ending style (CRLF, LF)\n                - File type based on extension or content\n            Context: Editor styling\n                The editor uses the same color scheme as the conversation interface:\n                - Background and text colors match the current theme\n                - Selection highlighting matches conversation selection behavior\n                - Line numbers and gutters use complementary colors\n        Context: User/AI interactions\n            Each conversation is an interaction between a user and one or more AI backends.\n            Interactions occur in a turn-by-turn fashion, where the user edits a message, until they hit \"Ctrl+J\".  On\n            hitting \"Ctrl+J\" the application will add the user's message to the conversation transcript and process the\n            message.  If the message is for the AI then the application will attempt to send the message to the AI\n            and await a response.  If there is an error or exception then the application will report the details to\n            the user.\n            Context: Message submission\n                Messages are submitted using Ctrl+J or the Submit menu item.\n                During streaming response:\n                    - Input area shows \"Processing your request (Esc to cancel)\"\n                    - Submit action is disabled\n                    - Input area is cleared but preserved in history\n                    - Escape key cancels current streaming response\n                    - Cancel adds \"Request cancelled by user\" message\n                    - Partial response is preserved in transcript\n            Context: Streaming handling\n                Status line shows token counts after response completes\n                Partial responses are shown incrementally as received\n                Response streaming can be cancelled by:\n                    - Escape key\n                    - Closing the conversation tab\n                    - Quitting the application\n                Auto-scroll follows streamed content unless user scrolls up\n                Unsaved partial responses are preserved in transcript on error\n        Context: Conversations\n            The top part of the conversation window will show a history of everything that has happened, including\n            messages, responses from the application, and responses from the AI.  Historical messages cannot be edited\n            Below the conversation history is a user input editor.  This input area will increase in size upwards as\n            the user adds more content.  This editable region can be arbitrarily large.\n            To the user, the historical details and the editable region must feel like they're one window.  Where they\n            are required, there is only one vertical scroll bar to cover both the history and editable area.\n            Context: Status bar\n                The status bar at the bottom of each conversation window shows:\n                - Current AI model name (e.g., \"Model: gpt-4o-mini\")\n                - Temperature setting if applicable (e.g., \"Temp: 0.7\" or \"Temp: N/A\" for models without temperature)\n                - Input and output token counts for the last message\n                In parenthesis after the input token count should be the context window size.\n            Context: Highlighting operations\n                While the editable and non-editable regions must feel like they're one thing, if the user wants to\n                interact with them they will behave differently.  For example, highlighting of text cannot span\n                between the editable and non-editable regions.\n            Context: Screen colours\n                The status line background is light grey with black text.\n                Message backgrounds and text colours are:\n                    - User messages: White text on #3c3c3c background\n                    - AI responses: White text on #282828 background\n                    - System messages: White text on #1a3a1a background (dark green)\n            Context: Message display\n                Messages must automatically adjust their display height based on content.  The height adjustment should\n                happen smoothly and in real-time as content is added or removed.\n            Context: Conversation Settings\n                Each conversation can have its own AI model and temperature settings that affect how the AI responds.\n                Context: Settings Dialog\n                    A \"Settings\" dialog can be accessed for each conversation via a menu or keyboard shortcut (see\n                    \"Conversation Settings\" menu item)\n                    The dialog shows the current settings for the active conversation tab.\n                    Context: Model Selection\n                        The AI model is selected via a dropdown menu.\n                        Available models should be configurable at application startup.\n                        Any change to the model selection takes effect on the next message sent to the AI.\n                        If a model's provider is not available (no API key), that model should be disabled in the\n                        conversation settings.\n                    Context: Temperature Setting\n                        The temperature is set via a numeric input field that:\n                        - Accepts values between 0.0 and 1.0\n                        - Shows one decimal place\n                        - Has spinner arrows for adjustment\n                        - Default value is 0.7\n                        - Changes take effect on the next message sent to the AI\n                    Context: Model limits display\n                        The dialog shows the model's limitations:\n                        - Context window size (maximum input tokens)\n                        - Maximum output tokens\n                        These are displayed below the temperature setting.\n                    Context: Dialog Controls\n                        The dialog has:\n                        - \"OK\" button to save changes and close\n                        - \"Cancel\" button to discard changes and close\n                        - \"Apply\" button to save changes without closing\n                        The dialog is modal, preventing interaction with the main window while open.\n            Context: Input formatting\n                The input box supports Markdown-style code formatting:\n                Context: Code blocks\n                    Text between matching triple backticks (```) is displayed as a code block.\n                    Code blocks use a monospace font (set as a family fallback: Lucida Console, Menlo, Consolas, Monaco, Courier New, monospace).\n                    The background colour for code blocks is dark grey (#2d2d2d) and extends across the full width of the input box.\n                    The code block formatting applies to both the triple backtick lines and all content between them.\n                Context: Inline code\n                    Text between single backticks (`) is displayed as inline code.\n                    Inline code uses the same monospace font as code blocks.\n                    Inline code has no background colour.\n                Context: Formatting updates\n                    The formatting is updated in real-time as the user types.\n                    When inside a code block, each new line is automatically formatted with the monospace font and background.\n                    The full width background for code blocks is applied immediately, and not just when a newline is entered.\n            Context: History display formatting\n                The history display supports the same Markdown-style code formatting as the input box:\n                Context: Code blocks\n                    Text between matching triple backticks (```) is displayed as a code block.\n                    Code blocks use the same monospace font as the input area (Lucida Console, Menlo, Consolas, Monaco, Courier New, monospace).\n                    The background colour for code blocks is dark grey (#2d2d2d) and extends across the full width.\n                    The code block formatting applies to both the triple backtick lines and all content between them.\n                Context: Inline code\n                    Text between single backticks (`) is displayed as inline code.\n                    Inline code uses the same monospace font as code blocks.\n                    Inline code has no background colour.\n                Context: Formatting interaction\n                    The Markdown formatting is applied in real-time as messages are added or updated.\n        Context: Conversation transcript files\n            The application will record a transcript of all conversations between the user and the AI, storing each turn\n            in a JSON data structure.  The JSON data structure will be written to a transcript file called\n            \"yyyy-mm-dd-hh-mm-ss-ttt.conv\", substituting the conversation start date and time (in UTC) for yyyy,\n            mm, dd, hh, mm, ss, ttt (year, numeric month, day-of-month, hours, minutes, seconds, and thousandths of\n            seconds respectively).\n            Transcript files will be written to a \"conversations\" directory of the current workspace directory.  If this\n            does not exist then the application should create it.\n            On closing a conversation tab the matching file must be fully closed.\n            Context: Transcript JSON schema\n                Use the following JSON schema:\n                ```json\n                {\n                    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"metadata\": {\n                            \"type\": \"object\",\n                            \"properties\": {\n                                \"timestamp\": { \"type\": \"string\", \"format\": \"date-time\" },\n                                \"version\": { \"type\": \"string\" },\n                            },\n                            \"required\": [\"timestamp\", \"version\"]\n                        },\n                        \"conversation\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"type\": \"object\",\n                                \"properties\": {\n                                    \"id\": { \"type\": \"string\", \"pattern\": \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\" },\n                                    \"timestamp\": { \"type\": \"string\", \"format\": \"date-time\" },\n                                    \"type\": { \"enum\": [\"user_message\", \"ai_response\", \"command\", \"system_message\"] },\n                                    \"content\": { \"type\": \"string\" },\n                                    \"model\": {\n                                        \"type\": \"string\",\n                                        \"description\": \"AI model used (only present for ai_response type)\"\n                                    },\n                                    \"temperature\": {\n                                        \"type\": \"number\",\n                                        \"minimum\": 0,\n                                        \"maximum\": 1,\n                                        \"description\": \"Temperature setting used (only present for ai_response type)\"\n                                    },\n                                    \"usage\": {\n                                        \"type\": \"object\",\n                                        \"properties\": {\n                                            \"prompt_tokens\": { \"type\": \"integer\" },\n                                            \"completion_tokens\": { \"type\": \"integer\" },\n                                            \"total_tokens\": { \"type\": \"integer\" }\n                                        }\n                                    },\n                                    \"error\": {\n                                        \"type\": \"object\",\n                                        \"properties\": {\n                                            \"code\": { \"type\": \"string\" },\n                                            \"message\": { \"type\": \"string\" },\n                                            \"details\": { \"type\": \"object\" }\n                                        }\n                                    }\n                                },\n                                \"required\": [\"id\", \"timestamp\", \"type\", \"content\"]\n                            }\n                        }\n                    },\n                    \"required\": [\"metadata\", \"conversation\"]\n                }\n                ```\n            Context: Error recovery\n                - Write to temp file first.\n                - Atomic rename on successful write.\n                - On write failure:\n                    1. Log error to stderr.\n                    2. Create backup file.\n                    3. Continue with new file.\n        Context: AI interactions\n            The AI backend supports streaming responses that arrive incrementally.  These should be displayed\n            as they arrive with content continuing to be added as more arrives.\n            Context: Streaming responses\n                The backend provides chunks containing:\n                - Content so far\n                - Usage statistics (in final chunk only)\n                Streaming requires that the display:\n                - Shows content immediately as it arrives\n                - Updates transcript periodically during streaming\n                - Writes final response when stream completes\n                - Updates token count after stream completes\n                During streaming, if the user hits \"Esc\" then this will terminate the current streaming response and cancel\n                any ongoing request with the AI.  A message \"Request cancelled by user\" will be added to the history.\n            Context: UI handling of streaming\n                The display must handle streaming responses by:\n                - Tracking where the streamed response starts in history\n                - Updating display incrementally as content arrives\n                - Removing previous content before adding updates\n                - Maintaining newline format and text wrapping\n        Context: AI models\n            The following AI models are available:\n            - \"gpt-4o-mini\": OpenAI GPT-4 Mini model\n            - \"gpt-4o\": OpenAI GPT-4 model\n            - \"o1-mini\": OpenAI O1 Mini model (default for OpenAI)\n            - \"o1-preview\": OpenAI O1 model\n            - \"gemini-1.5-flash\": Google Gemini 1.5 Flash model (default for Google Gemini)\n            - \"gemini-1.5-pro\": Google Gemini 1.5 Pro model\n            - \"gemini-2.0-flash-exp\": Google Gemini 2.0 Flash experimental model\n            - \"claude-3-5-haiku-20241022\": Anthropic Claude 3.5 Haiku model (default for Anthropic)\n            - \"claude-3-5-sonnet-20241022\": Anthropic Claude 3.5 Sonnet model\n            Context: Model providers\n                Models are provided by different AI services:\n                - OpenAI models: \"gpt-4o-mini\", \"gpt-4o\", \"o1-mini\", \"o1-preview\"\n                - Google models: \"gemini-1.5-flash\", \"gemini-1.5-pro\"\n                - Anthropic models: \"claude-3-5-haiku-20241022\", \"claude-3-5-sonnet-20241022\"\n                The AI model is configurable via the settings dialog.  If Google's model is available then we default\n                to it, then to Anthropic, and finally OpenAI.\n            Context: Provider configuration\n                Each provider requires its own API key, as noted in the section about API key configuration.\n                At least one provider must be configured for the application to start.\n        Context: Temperature settings\n            Temperature controls how deterministic or creative the AI's responses are.\n            GPT-4o and Gemini models support temperature adjustment:\n            - gpt-4o-mini: Supports temperature 0.0-1.0\n            - gpt-4o: Supports temperature 0.0-1.0\n            - o1-mini: No temperature setting\n            - o1-preview: No temperature setting\n            - gemini-1.5-flash: Supports temperature 0.0-1.0\n            - gemini-1.5-pro: Supports temperature 0.0-1.0\n            - gemini-2.0-flash-exp: Supports temperature 0.0-1.0\n            - claude-3-5-haiku-20241022: Supports temperature 0.0-1.0\n            - claude-3-5-sonnet-20241022: Supports temperature 0.0-1.0\n            Where adjustable, the AI temperature for an AI model will be configurable via the settings dialog.\n            The temperature control in the Settings dialog is automatically:\n            - Enabled and set to 0.7 by default for models that support temperature.\n            - Disabled for models that do not support a temperature setting.\n            - Preserves previous temperature when switching between models that support temperatures.\n            - Reverts to default when switching from models that do not support temperatures to a model that does.\n        Context: Error handling and recovery\n            Context: Handling other network errors\n                If there are any API errors, such as invalid API keys then the application should report these to the user\n                so they are aware these need to be corrected.\n        Context: Error handling and recovery\n            Context: Error Categories\n                The application handles these error types:\n                - Network: Connection, timeout, DNS failures\n                - API: Authentication, rate limits, invalid requests\n                - Application: Input validation, state corruption\n                - System: File IO, memory, permissions\n            Context: Network timeouts\n                If the AI does not respond within 120 seconds of being sent a request, then the application should treat this as\n                a timeout and retry up to 3 times.  Each time it retries, it should report that it is retrying.\n            Context: Error response strategy\n                For each error:\n                - Log full details to transcript\n                - Display user-friendly message as an application response.  For example:\n                    429: \"Rate limit exceeded.  Retrying in [X] seconds...\"\n                    500: \"OpenAI service error.  Retrying in [X] seconds...\"\n                    timeout: \"Request timed out.  Retrying in [X] seconds...\"\n                - Implement appropriate recovery\n                Recovery approach:\n                - Network errors: Retry with exponential backoff.  Initial delay 2 seconds, doubling each retry.  Max 3 retries.\n                - API errors: Handle rate limits, refresh credentials\n                - Application errors: Reset to known good state\n                - System errors: Graceful degradation\n                During retries, preserve the message in the input box.\n            Context: Provider-specific errors\n                Each AI provider may return different error formats.  The application must normalize these different error formats\n                into a consistent internal format for display and handling.\n                Context: OpenAI errors\n                    OpenAI errors include:\n                    - Invalid API key\n                    - Rate limits exceeded\n                    - Model overloaded\n                Context: Gemini errors\n                    Gemini errors include:\n                    - Invalid API key\n                    - Quota exceeded\n                    - Model not found\n                    - Invalid request format\n            Context: Error display format\n                Errors appear in message history with:\n                - Severity indicator: [ERROR], [WARNING], [INFO]\n                - Clear action message if user intervention needed\n                - Technical details in expandable section\n            Context: Recovery automation\n                Context: Rate Limiting\n                    Track API calls with sliding 60-second window.\n                    Pause requests when approaching limits.\n                Context: Retry strategy\n                    Maximum 3 retries for recoverable errors.\n                    Exponential backoff: 2, 4, 8 seconds.\n                    Preserve conversation context between retries.\n        Context: Security\n            Context: Outputs\n                Ensure that no sensitive data is either logged or displayed on the screen.\n                For example, API keys must never be revealled this way - replace with \"[redacted API key]\".\n            Context: Inputs\n                Ensure that all input control characters except for newlines are stripped from any input prior to processing.\n    Context: Implementation\n        Context: Communication with the AI\n            Communication with the AI is via a REST API.\n            The implementation supports OpenAI, Google Gemini, and Anthropic endpoints.\n            Context: OpenAI REST endpoint\n                Messages are sent via a POST message.\n                The API to use is the \"continuations\" API.  The endpoint is \"https://api.openai.com/v1/chat/completions\".\n                This needs two headers to be provided:\n                \"Content-Type\": \"application/json\"\n                \"Authorization\": {key}\"\n                {key} must be replaced with the API key found in the environment variable `OPENAI_API_KEY`.\n                The data for the POST is of this form:\n                ```json\n                {\n                    \"model\": \"selected-model\",\n                    \"messages\": [{\"role\": \"user\", \"content\": \"Say this is a test!\"}],\n                    \"temperature\": temp-setting,\n                    \"stream\": true,\n                    \"stream_options\": {\"include_usage\": true}\n                }\n                ```\n                In this, \"selected-model\" is name of the selected AI model, and \"temp-setting\" is the numeric temperature\n                setting defined by the user.\n                The \"content\" section of a message should be replaced with the user's message to the AI.\n                With streaming enabled, responses will arrive as chunks. Each chunk begins with \"data: \" followed\n                by a JSON object. This repeats until a chunk containing \"data: [DONE]\" arrives.  Each JSON chunk\n                takes this form:\n                ```json\n                {\n                    \"id\": \"chatcmpl-abc123\",\n                    \"object\": \"chat.completion.chunk\",\n                    \"created\": 1677858242,\n                    \"model\": \"gpt-4o-mini\",\n                    \"choices\": [\n                        {\n                            \"delta\": {\n                                \"content\": \"chunk of text\"\n                            },\n                            \"finish_reason\": null,\n                            \"index\": 0\n                        }\n                    ]\n                }\n                ```\n                The final chunk includes usage information:\n                ```json\n                {\n                    \"id\": \"chatcmpl-abc123\",\n                    \"object\": \"chat.completion.chunk\",\n                    \"created\": 1677858242,\n                    \"model\": \"gpt-4o-mini\",\n                    \"usage\": {\n                        \"prompt_tokens\": 13,\n                        \"completion_tokens\": 7,\n                        \"total_tokens\": 20\n                    },\n                    \"choices\": [\n                        {\n                            \"delta\": {},\n                            \"finish_reason\": \"stop\",\n                            \"index\": 0\n                        }\n                    ]\n                }\n                ```\n                In this message, the content is what should be captured as the AI response, but capture the usage information\n                in the JSON transcript.\n            Context: Google REST endpoint\n                Messages are sent via a POST message.\n                The API to use is the Gemini streaming API. The endpoint pattern is:\n                \"https://generativelanguage.googleapis.com/v1beta/models/{model}:streamGenerateContent?alt=sse\"\n                where {model} is replaced with the selected model name (e.g., \"gemini-1.5-flash\").\n                This needs two headers to be provided:\n                \"Content-Type\": \"application/json\"\n                \"x-goog-api-key\": {key}\n                {key} must be replaced with the API key found in the environment variable `GOOGLE_API_KEY`.\n                The data for the POST is of this form:\n                ```json\n                {\n                    \"contents\": [\n                        {\"role\":\"user\",\n                            \"parts\":[{\n                                \"text\": \"Hello\"\n                            }]\n                        },\n                        {\"role\": \"model\",\n                            \"parts\":[{\n                                \"text\": \"Great to meet you. What would you like to know?\"\n                            }]\n                        },\n                        {\"role\":\"user\",\n                            \"parts\":[{\n                                \"text\": \"I have two dogs in my house. How many paws are in my house?\"\n                            }]\n                        },\n                    ],\n                    \"safetySettings\": [\n                        {\n                            \"category\": \"HARM_CATEGORY_DANGEROUS_CONTENT\",\n                            \"threshold\": \"BLOCK_ONLY_HIGH\"\n                        }\n                    ],\n                    \"generationConfig\": {\n                        \"temperature\": 0.7,\n                        \"topP\": 0.8,\n                        \"topK\": 10\n                    }\n                }\n                ```\n                The temperature value should be omitted for models that don't support it.\n                With streaming enabled (alt=sse parameter), responses arrive as Server-Sent Events.\n                Each event begins with \"data: \" followed by a JSON object.\n                The stream ends with a \"data: [DONE]\" message.\n                Each JSON chunk takes this form:\n                ```json\n                {\n                    \"candidates\": [\n                        {\n                            \"content\": {\n                                \"parts\": [\n                                    {\n                                        \"text\": \"chunk of response text\"\n                                    }\n                                ]\n                            },\n                            \"finishReason\": null\n                        }\n                    ]\n                }\n                ```\n                The final chunk will have finishReason set to \"STOP\" and may include usage information.\n            Context: Anthropic REST endpoint\n                Messages are sent via a POST message.\n                The endpoint is \"https://api.anthropic.com/v1/messages\".\n                This needs three headers to be provided:\n                \"Content-Type\": \"application/json\"\n                \"x-api-key\": {key}\n                \"anthropic-version\": \"2023-06-01\"\n                {key} must be replaced with the API key found in the environment variable `ANTHROPIC_API_KEY`.\n                The data for the POST is of this form:\n                ```json\n                {\n                    \"model\": \"selected-model\",\n                    \"messages\": [{\"role\": \"user\", \"content\": \"Say this is a test!\"}],\n                    \"temperature\": temp-setting,\n                    \"max_tokens\": 1024,\n                    \"stream\": true\n                }\n                ```\n                In this, \"selected-model\" is name of the selected AI model, and \"temp-setting\" is the numeric temperature\n                setting defined by the user.\n                The content section of a message should be replaced with the user's message to the AI.\n                With streaming enabled, responses arrive as server-sent events. Each event begins with \"data: \" followed by\n                event type and a JSON object. The sequence will be:\n                1. message_start with initial usage statistics\n                2. content_block_start to mark beginning of response\n                3. content_block_delta events with actual content\n                4. content_block_stop for end of current block\n                5. message_delta with final usage statistics\n                6. message_stop to end the sequence\n                Example response chunk formats:\n                ```json\n                {\n                    \"type\": \"content_block_delta\",\n                    \"index\": 0,\n                    \"delta\": {\n                        \"type\": \"text_delta\",\n                        \"text\": \"chunk of text\"\n                    }\n                }\n                ```\n                Usage stats are provided in message_start and message_delta events:\n                ```json\n                {\n                    \"usage\": {\n                        \"input_tokens\": 12,\n                        \"output_tokens\": 6\n                    }\n                }\n                ```\n                Context: Provider-specific errors\n                    Context: Anthropic errors\n                        Anthropic errors include:\n                        - Invalid API key\n                        - Overloaded error (too many requests)\n                        - Model overloaded\n        Context: Logging\n            Where appropriate the application will log key operations, errors, and exceptions to a log file.  A new log file\n            will be created at the start of each application run.\n            The log file will be named \"yyyy-mm-dd-hh-mm-ss-ttt.log\", substituting the application start date and time (in UTC)\n            for yyyy, mm, dd, hh, mm, ss, ttt (year, numeric month, day-of-month, hours, minutes, seconds, and thousandths of\n            seconds respectively).\n            The log file will be written to a \"logs\" directory of the \".humbug\" directory in the user's home directory.  If this\n            does not exist then the application should create it.\n            The application will maintain the last 50 log files but delete any older ones.\n            If any log file exceeds 1 MByte in size then it will be rotated.\n        Context: GUI\n            The GUI must be built using the latest version of PySide6, and with qasync to support the integration of this\n            and async IO operations.\n            Note that PySide6 correctly translates the keyboard shortcuts described into appropriate platform-specific\n            shortcuts and no extra logic is required for these.\n            Context: Platform support\n                The GUI must work on MacOS X (any version since 2020), Linux (any version since 2020), and Microsoft\n                Windows 10 or 11.\n            Context: Asynchronous design\n                The UI must be asynchronous to ensure the application can remain reactive.\n            Context: Performance guidelines\n                Context: Scrolling performance\n                    - 60 FPS target for scroll operations\n        Context: Python implementation and dependencies\n            As an engineer working with the application, I want the application to be easy to use and understand,\n            so I can maintain and enhance it over time.\n            Context: Implement in Python 3\n                The application will be written in the latest version of Python 3.\n            Context: Indentation of code\n                Code must be indented by 4 spaces.\n            Context: Use docstrings\n                Use docstrings to describe all modules, classes, and functions.  This should follow PEP 257 guidelines.\n            Context: Use type hints\n                Use type hints for function arguments and return values.\n            Context: Use comments\n                Use additional comments to describe any complex logic.\n            Context: PEP 8 imports\n                The import list in any module should follow PEP 8 guidelines, including the ordering of imports.\n            Context: Avoid unnecessary elif and else statements\n                To improve readability, do not use elif or else statements if the preceding statement returns.\n                For example, do this:\n                ```python\n                if condition:\n                    return\n                next_statement()\n                ```\n                instead of this:\n                ```python\n                if condition:\n                    return\n                else:\n                    next_statement()\n                ```\n            Context: Dependencies\n                Leverage standard library tools before custom solutions, unless specifically instructed.\n                Context: HTTP interations\n                    Use the aiohttp library for HTTP interactions (e.g. the REST API).\n                Context: Metaphor compilation\n                    Use the m6rclib library for Metaphor file compilation.\n            Context: Exception handling philosophy\n                Context: Exception documentation\n                    Document what exceptions each function may raise in its docstring.\n                Context: Handling exceptions\n                    We should attempt to handle and mitigate exceptions at the level closest to which they are first\n                    detected.  If we cannot handle or mitigate the exception then it should be wrapped in a domain-appropriate\n                    exception class and this re-raised to the next level up the call stack.\n                    Include contextual information when wrapping exceptions.\n                    Preserve the exception chain using \"raise ... from e\" syntax.\n                Context: Avoid bare \"except:\" or \"except Exception:\" clauses.\n                    We should avoid the use of bare \"except:\" or \"except Exception:\" clauses unless a function we are calling\n                    can only have exceptions handled this way.\n                    We should always catch specific exception types that could occur from an operation.\n                Context: Exception logging\n                    All exceptions should be logged when they occur, before re-raising or wrapping them.\n                    Use appropriate log levels:\n                    - ERROR for exceptions that indicate failure.\n                    - WARNING for exceptions that can be handled/recovered from.\n                    - DEBUG for detailed exception information during development.\n                    We must include sufficient context in log messages to aid debugging.\n                Context: Exception wrapping example\n                    Do this:\n                    ```python\n                    try:\n                        await self.api_client.fetch_data()\n                    except ConnectionError as e:\n                        logger.error(\"Failed to retrieve data from API endpoint\", exc_info=True)\n                        raise DataFetchError(f\"Failed to retrieve data from API endpoint: {e}\") from e\n                    except TimeoutError as e:\n                        logger.warning(\"API request timed out, will retry\", exc_info=True)\n                    ```\n                    Not this:\n                    ```python\n                    try:\n                        await self.api_client.fetch_data()\n                    except Exception as e:\n                        logger.error(f\"Error: {e}\")  # Insufficient context, no stack trace\n                        raise  # No wrapping or additional context\n                    ```\nAction: Build the software\n    The latest version of the application is provided here.\n    File: src/humbug/conversation/message_source.py\n    ```python\n    \"\"\"Conversation state management for the Humbug application.\"\"\"\n    \n    from enum import Enum\n    \n    \n    class MessageSource(Enum):\n        \"\"\"Enumeration of possible message sources.\"\"\"\n        USER = \"user\"\n        AI = \"ai\"\n        SYSTEM = \"system\"\n    ```\n    File: src/humbug/conversation/usage.py\n    ```python\n    \"\"\"Conversation state management for the Humbug application.\"\"\"\n    \n    from dataclasses import dataclass\n    from typing import Dict\n    \n    \n    @dataclass\n    class Usage:\n        \"\"\"Token usage information.\"\"\"\n        prompt_tokens: int\n        completion_tokens: int\n        total_tokens: int\n    \n        def to_dict(self) -> Dict:\n            \"\"\"Convert usage to dictionary for transcript.\"\"\"\n            return {\n                \"prompt_tokens\": self.prompt_tokens,\n                \"completion_tokens\": self.completion_tokens,\n                \"total_tokens\": self.total_tokens\n            }\n    ```\n    File: src/humbug/conversation/conversation_history.py\n    ```python\n    \"\"\"Conversation state management for the Humbug application.\"\"\"\n    \n    from typing import Dict, List, Optional\n    \n    from humbug.conversation.message import Message\n    from humbug.conversation.message_source import MessageSource\n    from humbug.conversation.usage import Usage\n    \n    class ConversationHistory:\n        \"\"\"Manages the conversation history and state.\"\"\"\n    \n        def __init__(self, conversation_id: str):\n            \"\"\"Initialize empty conversation history.\"\"\"\n            self._conversation_id = conversation_id\n            self._messages: List[Message] = []\n            self._last_response_tokens = {\"input\": 0, \"output\": 0}\n    \n        def add_message(self, message: Message) -> None:\n            \"\"\"Add a message to the history.\"\"\"\n            self._messages.append(message)\n    \n        def update_message(\n            self,\n            message_id: str,\n            content: str,\n            usage: Optional[Usage] = None,\n            completed: bool = None\n        ) -> Optional[Message]:\n            \"\"\"Update an existing message and return the updated message.\"\"\"\n            for message in self._messages:\n                if message.id == message_id:\n                    message.content = content\n                    if usage is not None:\n                        old_usage = message.usage\n                        message.usage = usage\n                        # Only update token counts if we didn't have usage before\n                        if old_usage is None:\n                            self._last_response_tokens[\"input\"] = usage.prompt_tokens\n                            self._last_response_tokens[\"output\"] = usage.completion_tokens\n                    if completed is not None:\n                        message.completed = completed\n                    return message\n            return None\n    \n        def get_messages(self) -> List[Message]:\n            \"\"\"Get a copy of all messages in the conversation history.\n    \n            Returns:\n                List[Message]: Copy of all messages\n            \"\"\"\n            return self._messages.copy()\n    \n        def get_messages_for_context(self) -> List[str]:\n            \"\"\"\n            Get messages formatted for AI context.\n    \n            Returns:\n                List of message dictionaries with role and content.\n            \"\"\"\n            result = []\n            i = 0\n            while i < len(self._messages):\n                if self._messages[i].source == MessageSource.USER:\n                    # Found a user message, look for corresponding AI response\n                    user_msg = self._messages[i]\n                    ai_msg = None\n                    if i + 1 < len(self._messages) and self._messages[i + 1].source == MessageSource.AI:\n                        ai_msg = self._messages[i + 1]\n    \n                    # Only include the exchange if:\n                    # 1. It's a user message without an AI response yet (current exchange)\n                    # 2. Or it's a completed exchange without errors\n                    if (ai_msg is None) or (ai_msg.completed and not ai_msg.error):\n                        result.append({\n                            \"role\": \"user\",\n                            \"content\": user_msg.content\n                        })\n                        if ai_msg:\n                            result.append({\n                                \"role\": \"assistant\",\n                                \"content\": ai_msg.content\n                            })\n                            i += 1  # Skip the AI message since we've handled it\n    \n                i += 1  # Move to next message\n    \n            return result\n    \n        def get_token_counts(self) -> Dict[str, int]:\n            \"\"\"Get token counts from last response.\"\"\"\n            return self._last_response_tokens\n    \n        def update_last_tokens(self, input_tokens: int, output_tokens: int) -> None:\n            \"\"\"Update token counts for the last response.\n    \n            Args:\n                input_tokens: Number of input tokens\n                output_tokens: Number of output tokens\n            \"\"\"\n            self._last_response_tokens = {\n                \"input\": input_tokens,\n                \"output\": output_tokens\n            }\n    ```\n    File: src/humbug/conversation/message.py\n    ```python\n    \"\"\"Conversation state management for the Humbug application.\"\"\"\n    \n    from dataclasses import dataclass\n    from datetime import datetime\n    from typing import Dict, Optional\n    import uuid\n    \n    from humbug.conversation.message_source import MessageSource\n    from humbug.conversation.usage import Usage\n    \n    \n    @dataclass\n    class Message:\n        \"\"\"Represents a single message in the conversation.\"\"\"\n        id: str\n        source: MessageSource\n        content: str\n        timestamp: datetime\n        usage: Optional[Usage] = None\n        error: Optional[Dict] = None\n        model: Optional[str] = None\n        temperature: Optional[float] = None\n        completed: bool = True\n    \n        # Map between MessageSource enum and transcript type strings\n        _SOURCE_TYPE_MAP = {\n            MessageSource.USER: \"user_message\",\n            MessageSource.AI: \"ai_response\",\n            MessageSource.SYSTEM: \"system_message\"\n        }\n        _TYPE_SOURCE_MAP = {v: k for k, v in _SOURCE_TYPE_MAP.items()}\n    \n        @classmethod\n        def create(\n            cls,\n            source: MessageSource,\n            content: str,\n            usage: Optional[Usage] = None,\n            error: Optional[Dict] = None,\n            model: Optional[str] = None,\n            temperature: Optional[float] = None,\n            completed: bool = True,\n            timestamp: Optional[datetime] = None\n        ) -> 'Message':\n            \"\"\"Create a new message with generated ID and current timestamp.\"\"\"\n            if timestamp:\n                msg_timestamp = datetime.fromisoformat(timestamp)\n            else:\n                msg_timestamp = datetime.utcnow()\n    \n            return cls(\n                id=str(uuid.uuid4()),\n                source=source,\n                content=content,\n                timestamp=msg_timestamp,\n                usage=usage,\n                error=error,\n                model=model,\n                temperature=temperature,\n                completed=completed\n            )\n    \n        def to_transcript_dict(self) -> Dict:\n            \"\"\"Convert message to transcript format.\"\"\"\n            message = {\n                \"id\": self.id,\n                \"timestamp\": self.timestamp.isoformat(),\n                \"type\": self._SOURCE_TYPE_MAP[self.source],\n                \"content\": self.content,\n                \"completed\": self.completed\n            }\n    \n            # Always include these fields, even if None\n            message[\"usage\"] = self.usage.to_dict() if self.usage else None\n            message[\"error\"] = self.error\n            message[\"model\"] = self.model\n            message[\"temperature\"] = self.temperature\n    \n            return message\n    \n        @classmethod\n        def from_transcript_dict(cls, data: Dict) -> 'Message':\n            \"\"\"Create a Message instance from transcript dictionary format.\n    \n            Args:\n                data: Dictionary containing message data\n    \n            Returns:\n                New Message instance\n    \n            Raises:\n                ValueError: If required fields are missing or invalid\n            \"\"\"\n            # Validate required fields\n            required_fields = [\"id\", \"timestamp\", \"type\", \"content\"]\n            missing_fields = [f for f in required_fields if f not in data]\n            if missing_fields:\n                raise ValueError(f\"Missing required fields: {', '.join(missing_fields)}\")\n    \n            # Convert message type to source\n            msg_type = data[\"type\"]\n            if msg_type not in cls._TYPE_SOURCE_MAP:\n                raise ValueError(f\"Invalid message type: {msg_type}\")\n            source = cls._TYPE_SOURCE_MAP[msg_type]\n    \n            # Parse timestamp\n            try:\n                timestamp = datetime.fromisoformat(data[\"timestamp\"])\n            except ValueError as e:\n                raise ValueError(f\"Invalid timestamp format: {data['timestamp']}\") from e\n    \n            # Parse usage data if present\n            usage = None\n            if data.get(\"usage\"):\n                try:\n                    usage_data = data[\"usage\"]\n                    usage = Usage(\n                        prompt_tokens=usage_data[\"prompt_tokens\"],\n                        completion_tokens=usage_data[\"completion_tokens\"],\n                        total_tokens=usage_data[\"total_tokens\"]\n                    )\n                except (KeyError, TypeError) as e:\n                    raise ValueError(f\"Invalid usage data format: {data['usage']}\") from e\n    \n            return cls(\n                id=data[\"id\"],\n                source=source,\n                content=data[\"content\"],\n                timestamp=timestamp,\n                usage=usage,\n                error=data.get(\"error\"),\n                model=data.get(\"model\"),\n                temperature=data.get(\"temperature\"),\n                completed=data.get(\"completed\", True)\n            )\n    ```\n    File: src/humbug/syntax/typescript_lexer.py\n    ```python\n    from typing import Set\n    \n    from humbug.syntax.javascript_lexer import JavaScriptLexer\n    \n    \n    class TypeScriptLexer(JavaScriptLexer):\n        \"\"\"\n        Lexer for TypeScript code.\n    \n        This lexer extends the JavaScript lexer to handle TypeScript-specific syntax,\n        particularly its additional keywords.\n        \"\"\"\n    \n        def _is_keyword(self, value: str) -> bool:\n            \"\"\"\n            Check if a given value is a TypeScript keyword.\n    \n            Args:\n                value: The string to check\n    \n            Returns:\n                True if the value is a TypeScript keyword, False otherwise\n            \"\"\"\n            keywords: Set[str] = {\n                'abstract', 'any', 'as', 'asserts', 'async', 'await',\n                'bigint', 'boolean', 'break', 'case', 'catch', 'class',\n                'const', 'continue', 'debugger', 'declare', 'default',\n                'delete', 'do', 'else', 'enum', 'export', 'extends',\n                'false', 'finally', 'for', 'from', 'function', 'get',\n                'if', 'implements', 'import', 'in', 'infer', 'instanceof',\n                'interface', 'is', 'keyof', 'let', 'module', 'namespace',\n                'new', 'null', 'number', 'object', 'of', 'private',\n                'protected', 'public', 'readonly', 'return', 'require',\n                'set', 'static', 'string', 'super', 'switch', 'symbol',\n                'this', 'throw', 'true', 'try', 'type', 'typeof',\n                'unique', 'unknown', 'var', 'void', 'while', 'with',\n                'yield'\n            }\n            return value in keywords\n    ```\n    File: src/humbug/syntax/c_lexer.py\n    ```python\n    from dataclasses import dataclass\n    from typing import Optional, Callable\n    \n    from humbug.syntax.lexer import Lexer, LexerState, Token\n    \n    \n    @dataclass\n    class CLexerState(LexerState):\n        \"\"\"\n        State information for the C lexer.\n    \n        Attributes:\n            in_block_comment: Indicates if we're currently parsing a block comment\n        \"\"\"\n        in_block_comment: bool = False\n    \n    \n    class CLexer(Lexer):\n        \"\"\"\n        Lexer for C code.\n    \n        This lexer handles C-specific syntax including keywords, operators, numbers,\n        strings, comments, and preprocessor directives.\n        \"\"\"\n    \n        def __init__(self):\n            super().__init__()\n            self._in_block_comment = False\n    \n        def lex(self, prev_lexer_state: Optional[CLexerState], input_str: str) -> CLexerState:\n            \"\"\"\n            Lex all the tokens in the input.\n            \"\"\"\n            self._input = input_str\n            if prev_lexer_state:\n                self._in_block_comment = prev_lexer_state.in_block_comment\n    \n            if self._in_block_comment:\n                self._read_block_comment(0)\n    \n            if not self._in_block_comment:\n                self._inner_lex()\n    \n            lexer_state = CLexerState()\n            lexer_state.in_block_comment = self._in_block_comment\n            return lexer_state\n    \n        def _get_lexing_function(self, ch: str) -> Callable[[], None]:\n            \"\"\"\n            Get the lexing function that matches a given start character.\n    \n            Args:\n                ch: The start character\n    \n            Returns:\n                The appropriate lexing function for the character\n            \"\"\"\n            if ch == '\\n':\n                return self._read_newline\n    \n            if self._is_whitespace(ch):\n                return self._read_whitespace\n    \n            if ch == 'L':\n                return self._read_l\n    \n            if self._is_letter(ch) or ch == '_':\n                return self._read_identifier_or_keyword\n    \n            if self._is_digit(ch):\n                return self._read_number\n    \n            if ch in ('\"', \"'\"):\n                return self._read_string\n    \n            if ch == '.':\n                return self._read_dot\n    \n            if ch == '/':\n                return self._read_forward_slash\n    \n            if ch == '#':\n                return self._read_preprocessor_directive\n    \n            return self._read_operator\n    \n        def _read_l(self) -> None:\n            \"\"\"\n            Read an L character, which could be the start of a wide string literal\n            or an identifier.\n            \"\"\"\n            if (self._position + 1 < len(self._input) and\n                    self._input[self._position + 1] == '\"'):\n                self._read_string()\n                return\n    \n            self._read_identifier_or_keyword()\n    \n        def _read_dot(self) -> None:\n            \"\"\"\n            Read a dot operator or decimal point in a number.\n            \"\"\"\n            if (self._position + 1 < len(self._input) and\n                    self._is_digit(self._input[self._position + 1])):\n                self._read_number()\n                return\n    \n            self._read_operator()\n    \n        def _read_forward_slash(self) -> None:\n            \"\"\"\n            Read a forward slash, which could be the start of a comment or an operator.\n            \"\"\"\n            if self._position + 1 < len(self._input):\n                if self._input[self._position + 1] == '/':\n                    self._read_comment()\n                    return\n    \n                if self._input[self._position + 1] == '*':\n                    self._read_block_comment(2)\n                    return\n    \n            self._read_operator()\n    \n        def _read_string(self) -> None:\n            \"\"\"\n            Read a string literal token, including wide string literals.\n    \n            Handles escape sequences within strings.\n            \"\"\"\n            start = self._position\n            quote = self._input[self._position]\n            self._position += 1\n    \n            if quote == 'L':\n                self._position += 1\n                quote = '\"'\n    \n            while self._position < len(self._input) and self._input[self._position] != quote:\n                if (self._input[self._position] == '\\\\' and\n                        self._position + 1 < len(self._input)):\n                    self._position += 2\n                    continue\n    \n                self._position += 1\n    \n            if self._position < len(self._input):\n                self._position += 1\n    \n            self._tokens.append(Token(\n                type='STRING',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_number(self) -> None:\n            \"\"\"\n            Read a numeric literal token.\n    \n            Handles decimal, hexadecimal, binary numbers, and their suffixes.\n            \"\"\"\n            start = self._position\n            has_suffix = False\n    \n            if (self._position + 1 < len(self._input) and\n                    self._input[self._position] == '0'):\n                next_char = self._input[self._position + 1].lower()\n                if next_char == 'x':  # Hexadecimal\n                    self._position += 2\n                    while (self._position < len(self._input) and\n                           self._is_hex_digit(self._input[self._position])):\n                        self._position += 1\n                elif next_char == 'b':  # Binary\n                    self._position += 2\n                    while (self._position < len(self._input) and\n                           self._is_binary_digit(self._input[self._position])):\n                        self._position += 1\n                else:  # Decimal or floating-point\n                    self._read_decimal_number()\n            else:\n                self._read_decimal_number()\n    \n            # Handle suffixes\n            suffix_start = self._position\n            while (self._position < len(self._input) and\n                   self._input[self._position].lower() in 'ulfj'):\n                self._position += 1\n                has_suffix = True\n    \n            # Validate suffix combination\n            if has_suffix:\n                suffix = self._input[suffix_start:self._position].lower()\n                valid_integer_suffixes = {'u', 'ul', 'ull', 'lu', 'llu'}\n                valid_float_suffixes = {'f', 'l'}\n                if suffix not in valid_integer_suffixes and suffix not in valid_float_suffixes:\n                    self._position = suffix_start\n    \n            self._tokens.append(Token(\n                type='NUMBER',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_decimal_number(self) -> None:\n            \"\"\"\n            Read a decimal or floating-point number.\n            \"\"\"\n            while (self._position < len(self._input) and\n                   self._is_digit(self._input[self._position])):\n                self._position += 1\n    \n            if (self._position < len(self._input) and\n                    self._input[self._position] == '.'):\n                self._position += 1\n                while (self._position < len(self._input) and\n                       self._is_digit(self._input[self._position])):\n                    self._position += 1\n    \n            if (self._position < len(self._input) and\n                    self._input[self._position].lower() == 'e'):\n                self._position += 1\n                if self._input[self._position] in ('+', '-'):\n                    self._position += 1\n    \n                while (self._position < len(self._input) and\n                       self._is_digit(self._input[self._position])):\n                    self._position += 1\n    \n        def _read_comment(self) -> None:\n            \"\"\"\n            Read a single-line comment token.\n            \"\"\"\n            start = self._position\n            self._position += 2  # Skip //\n            while (self._position < len(self._input) and\n                   self._input[self._position] != '\\n'):\n                self._position += 1\n    \n            self._tokens.append(Token(\n                type='COMMENT',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_block_comment(self, skip_chars: int) -> None:\n            \"\"\"\n            Read a block comment token.\n            \"\"\"\n            self._in_block_comment = True\n            start = self._position\n            self._position += skip_chars  # Skip /*\n            while (self._position + 1) < len(self._input):\n                if self._input[self._position] == '*' and self._input[self._position + 1] == '/':\n                    self._in_block_comment = False\n                    self._position += 2\n                    break\n    \n                self._position += 1\n    \n            # If we're still in a block comment we've got one character left on this line and\n            # we need to include it in the comment too.\n            if self._in_block_comment:\n                self._position = len(self._input)\n    \n            self._tokens.append(Token(\n                type='COMMENT',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_identifier_or_keyword(self) -> None:\n            \"\"\"\n            Read an identifier or keyword token.\n            \"\"\"\n            start = self._position\n            self._position += 1\n            while (self._position < len(self._input) and\n                   (self._is_letter_or_digit(self._input[self._position]) or\n                    self._input[self._position] == '_')):\n                self._position += 1\n    \n            value = self._input[start:self._position]\n            if self._is_keyword(value):\n                self._tokens.append(Token(type='KEYWORD', value=value, start=start))\n                return\n    \n            self._tokens.append(Token(type='IDENTIFIER', value=value, start=start))\n    \n        def _read_preprocessor_directive(self) -> None:\n            \"\"\"\n            Read a preprocessor directive token.\n            \"\"\"\n            start = self._position\n            self._position += 1\n            while (self._position < len(self._input) and\n                   self._input[self._position] != '\\n'):\n                self._position += 1\n    \n            self._tokens.append(Token(\n                type='PREPROCESSOR',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_operator(self) -> None:\n            \"\"\"\n            Read an operator or punctuation token.\n            \"\"\"\n            operators = [\n                '>>=', '<<=', '&&=', '||=', '!=', '==', '+=', '-=', '*=',\n                '/=', '%=', '&=', '|=', '^=', '<=', '>=', '&&', '||', '<<',\n                '>>', '++', '--', '->', '+', '-', '*', '/', '%', '&', '~',\n                '!', '|', '^', '=', '<', '>', '(', ')', '{', '}', '[', ']',\n                ';', ':', '?', '.', ','\n            ]\n    \n            for operator in operators:\n                if self._input[self._position:].startswith(operator):\n                    start = self._position\n                    self._position += len(operator)\n                    self._tokens.append(Token(\n                        type='OPERATOR',\n                        value=operator,\n                        start=start\n                    ))\n                    return\n    \n            start = self._position\n            ch = self._input[self._position]\n            self._position += 1\n            self._tokens.append(Token(type='ERROR', value=ch, start=start))\n    \n        def _is_keyword(self, value: str) -> bool:\n            \"\"\"\n            Check if a given value is a C keyword.\n    \n            Args:\n                value: The string to check\n    \n            Returns:\n                True if the value is a C keyword, False otherwise\n            \"\"\"\n            keywords = {\n                'auto', 'break', 'case', 'char', 'const', 'continue',\n                'default', 'do', 'double', 'else', 'enum', 'extern',\n                'float', 'for', 'goto', 'if', 'inline', 'int', 'long',\n                'register', 'restrict', 'return', 'short', 'signed',\n                'sizeof', 'static', 'struct', 'switch', 'typedef',\n                'union', 'unsigned', 'void', 'volatile', 'while',\n                '_Bool', '_Complex', '_Imaginary'\n            }\n            return value in keywords\n    ```\n    File: src/humbug/syntax/python_lexer.py\n    ```python\n    from dataclasses import dataclass\n    from typing import Callable, Optional\n    \n    from humbug.syntax.lexer import Lexer, LexerState, Token\n    \n    \n    @dataclass\n    class PythonLexerState(LexerState):\n        \"\"\"\n        State information for the Python lexer.\n    \n        Attributes:\n            in_docstring: Indicates if we're currently parsing a docstring\n        \"\"\"\n        in_docstring: bool = False\n        docstring_quote: str = \"\"\n    \n    \n    class PythonLexer(Lexer):\n        \"\"\"\n        Lexer for Python code.\n    \n        This lexer handles Python-specific syntax including keywords, operators, numbers,\n        strings, docstrings, and comments.\n        \"\"\"\n    \n        def __init__(self):\n            super().__init__()\n            self._in_docstring = False\n            self._docstring_quote = \"\"\n    \n        def lex(self, prev_lexer_state: Optional[PythonLexerState], input_str: str) -> PythonLexerState:\n            \"\"\"\n            Lex all the tokens in the input.\n            \"\"\"\n            self._input = input_str\n            if prev_lexer_state:\n                self._in_docstring = prev_lexer_state.in_docstring\n                self._docstring_quote = prev_lexer_state.docstring_quote\n    \n            if self._in_docstring:\n                self._read_docstring(self._docstring_quote, 0)\n    \n            if not self._in_docstring:\n                self._inner_lex()\n    \n            lexer_state = PythonLexerState()\n            lexer_state.in_docstring = self._in_docstring\n            lexer_state.docstring_quote = self._docstring_quote\n            return lexer_state\n    \n        def _get_lexing_function(self, ch: str) -> Callable[[], None]:\n            \"\"\"\n            Get the lexing function that matches a given start character.\n    \n            Args:\n                ch: The start character\n    \n            Returns:\n                The appropriate lexing function for the character\n            \"\"\"\n            if ch == '\\n':\n                return self._read_newline\n    \n            if self._is_whitespace(ch):\n                return self._read_whitespace\n    \n            if self._is_letter(ch) or ch == '_':\n                return self._read_identifier_or_keyword\n    \n            if self._is_digit(ch):\n                return self._read_number\n    \n            if ch in ('\"', \"'\"):\n                return self._read_quote\n    \n            if ch == '.':\n                return self._read_dot\n    \n            if ch == '#':\n                return self._read_comment\n    \n            return self._read_operator\n    \n        def _read_quote(self) -> None:\n            \"\"\"\n            Read a string or docstring token.\n    \n            Handles both single/double quoted strings and triple-quoted docstrings.\n            \"\"\"\n            ch: str = self._input[self._position]\n            if (self._position + 2 < len(self._input) and\n                    self._input[self._position + 1] == ch and\n                    self._input[self._position + 2] == ch):\n                self._docstring_quote = ch\n                self._read_docstring(ch, 3)\n                return\n    \n            self._read_string()\n    \n        def _read_dot(self) -> None:\n            \"\"\"\n            Read a dot operator or decimal point in a number.\n            \"\"\"\n            if (self._position + 1 < len(self._input) and\n                    self._is_digit(self._input[self._position + 1])):\n                self._read_number()\n                return\n    \n            self._read_operator()\n    \n        def _read_number(self) -> None:\n            \"\"\"\n            Read a numeric literal.\n    \n            Handles decimal, hexadecimal, binary, octal, and complex number literals.\n            \"\"\"\n            start = self._position\n    \n            if (self._input[self._position] == '0' and\n                    self._position + 1 < len(self._input)):\n                next_char = self._input[self._position + 1].lower()\n                if next_char == 'x':  # Hexadecimal\n                    self._position += 2\n                    while (self._position < len(self._input) and\n                           self._is_hex_digit(self._input[self._position])):\n                        self._position += 1\n                elif next_char == 'b':  # Binary\n                    self._position += 2\n                    while (self._position < len(self._input) and\n                           self._is_binary_digit(self._input[self._position])):\n                        self._position += 1\n                elif next_char == 'o':  # Octal\n                    self._position += 2\n                    while (self._position < len(self._input) and\n                           self._is_octal_digit(self._input[self._position])):\n                        self._position += 1\n                else:  # Decimal or floating-point\n                    self._read_decimal_number()\n            else:\n                self._read_decimal_number()\n    \n            # Check for complex number 'j' suffix\n            if (self._position < len(self._input) and\n                    self._input[self._position] == 'j'):\n                self._position += 1\n    \n            self._tokens.append(Token(\n                type='NUMBER',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_decimal_number(self) -> None:\n            \"\"\"\n            Read a decimal or floating-point number.\n            \"\"\"\n            while (self._position < len(self._input) and\n                   self._is_digit(self._input[self._position])):\n                self._position += 1\n    \n            if (self._position < len(self._input) and\n                    self._input[self._position] == '.'):\n                self._position += 1\n                while (self._position < len(self._input) and\n                       self._is_digit(self._input[self._position])):\n                    self._position += 1\n    \n            if (self._position < len(self._input) and\n                    self._input[self._position].lower() == 'e'):\n                self._position += 1\n                if self._input[self._position] in ('+', '-'):\n                    self._position += 1\n    \n                while (self._position < len(self._input) and\n                       self._is_digit(self._input[self._position])):\n                    self._position += 1\n    \n        def _read_identifier_or_keyword(self) -> None:\n            \"\"\"\n            Read an identifier or keyword token.\n            \"\"\"\n            start = self._position\n            self._position += 1\n            while (self._position < len(self._input) and\n                   (self._is_letter_or_digit(self._input[self._position]) or\n                    self._input[self._position] == '_')):\n                self._position += 1\n    \n            value = self._input[start:self._position]\n            if self._is_keyword(value):\n                self._tokens.append(Token(type='KEYWORD', value=value, start=start))\n                return\n    \n            self._tokens.append(Token(type='IDENTIFIER', value=value, start=start))\n    \n        def _read_comment(self) -> None:\n            \"\"\"\n            Read a single-line comment token.\n            \"\"\"\n            start = self._position\n            self._position += 1\n            while (self._position < len(self._input) and\n                   self._input[self._position] != '\\n'):\n                self._position += 1\n    \n            self._tokens.append(Token(\n                type='COMMENT',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_docstring(self, quote_char: str, skip_chars: int) -> None:\n            \"\"\"\n            Read a docstring token.\n    \n            Args:\n                quote_char: The quote character used (single or double quote)\n            \"\"\"\n            self._in_docstring = True\n            start = self._position\n            self._position += skip_chars  # Skip /*\n            while (self._position + 2) < len(self._input):\n                if (self._input[self._position] == quote_char and\n                        self._input[self._position + 1] == quote_char and\n                        self._input[self._position + 2] == quote_char):\n                    self._in_docstring = False\n                    self._position += 3\n    \n                self._position += 1\n    \n            # If we're still in a docstring we need to consume the whole line\n            if self._in_docstring:\n                self._position = len(self._input)\n    \n            self._tokens.append(Token(\n                type='STRING',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_operator(self) -> None:\n            \"\"\"\n            Read an operator or punctuation token.\n            \"\"\"\n            operators = [\n                '>>=', '<<=', '**=', '//=', '@=', ':=', '!=', '==',\n                '+=', '-=', '*=', '/=', '%=', '&=', '|=', '^=',\n                '<=', '>=', '<<', '>>', '++', '--', '**', '//',\n                '->', '@', '+', '-', '*', '/', '%', '&', '~', '|',\n                '^', '=', '<', '>', '(', ')', '{', '}', '[', ']',\n                ':', '.', ','\n            ]\n    \n            for operator in operators:\n                if self._input[self._position:].startswith(operator):\n                    start = self._position\n                    self._position += len(operator)\n                    self._tokens.append(Token(\n                        type='OPERATOR',\n                        value=operator,\n                        start=start\n                    ))\n                    return\n    \n            start = self._position\n            ch = self._input[self._position]\n            self._position += 1\n            self._tokens.append(Token(type='ERROR', value=ch, start=start))\n    \n        def _is_keyword(self, value: str) -> bool:\n            \"\"\"\n            Check if a given value is a Python keyword.\n    \n            Args:\n                value: The string to check\n    \n            Returns:\n                True if the value is a Python keyword, False otherwise\n            \"\"\"\n            keywords = {\n                'and', 'as', 'assert', 'async', 'await', 'break', 'class',\n                'continue', 'def', 'del', 'elif', 'else', 'except', 'False',\n                'finally', 'for', 'from', 'global', 'if', 'import', 'in',\n                'is', 'lambda', 'None', 'nonlocal', 'not', 'or', 'pass',\n                'raise', 'return', 'True', 'try', 'while', 'with', 'yield'\n            }\n            return value in keywords\n    ```\n    File: src/humbug/syntax/conversation_lexer.py\n    ```python\n    from typing import Callable, Optional\n    \n    from humbug.syntax.lexer import Lexer, LexerState, Token\n    \n    \n    class ConversationLexer(Lexer):\n        def lex(self, prev_lexer_state: Optional[LexerState], input_str: str) -> LexerState:\n            \"\"\"\n            Lex all the tokens in the input.\n            \"\"\"\n            self._input = input_str\n            self._inner_lex()\n            return None\n    \n        def _get_lexing_function(self, ch: str) -> Callable[[], None]:\n            \"\"\"\n            Get the lexing function that matches a given start character.\n    \n            :param ch: The start character\n            :return: The lexing function\n            \"\"\"\n            if ch == '\\n':\n                return self._read_newline\n    \n            if self._is_whitespace(ch):\n                return self._read_whitespace\n    \n            if ch == '`':\n                return self._read_backtick\n    \n            if self._is_letter_or_digit(ch):\n                return self._read_text\n    \n            return self._read_symbol\n    \n        def _read_symbol(self) -> None:\n            start: int = self._position\n            self._position += 1\n            text_value = self._input[start:self._position]\n            self._tokens.append(Token(type='SYMBOL', value=text_value, start=start))\n    \n        def _read_text(self) -> None:\n            start: int = self._position\n            self._position += 1\n            while self._position < len(self._input):\n                ch = self._input[self._position]\n                if (not self._is_letter_or_digit(ch)) and (ch != '-') and (ch != '_') and (ch != '+'):\n                    break\n    \n                self._position += 1\n    \n            text_value = self._input[start:self._position]\n            self._tokens.append(Token(type='TEXT', value=text_value, start=start))\n    \n        def _read_backtick(self) -> None:\n            start: int = self._position\n    \n            # Do we have 3 backticks?  If yes, we have code fence and the next word after that\n            # is the (optional) name of the language\n            if self._input[self._position:].startswith('```'):\n                self._position += 3\n                self._tokens.append(Token(type='FENCE', value='```', start=start))\n                return\n    \n            self._position += 1\n            self._tokens.append(Token(type='BACKTICK', value='`', start=start))\n    ```\n    File: src/humbug/syntax/cpp_lexer.py\n    ```python\n    from humbug.syntax.c_lexer import CLexer\n    from humbug.syntax.lexer import Token\n    \n    \n    class CppLexer(CLexer):\n        \"\"\"\n        Lexer for C++ code.\n    \n        This lexer extends the C lexer to handle C++-specific syntax including\n        additional keywords and operators.\n        \"\"\"\n    \n        def _read_operator(self) -> None:\n            \"\"\"\n            Read an operator or punctuation token.\n    \n            Extends the C lexer's operator handling to include C++-specific operators.\n            \"\"\"\n            operators = [\n                '>>=', '<<=', '&&=', '||=', '!=', '==', '+=', '-=', '*=',\n                '/=', '%=', '&=', '|=', '^=', '<=', '>=', '&&', '||', '<<',\n                '>>', '++', '--', '->', '::', '+', '-', '*', '/', '%', '&',\n                '~', '!', '|', '^', '=', '<', '>', '(', ')', '{', '}', '[',\n                ']', ';', ':', '?', '.', ','\n            ]\n    \n            for operator in operators:\n                if self._input[self._position:].startswith(operator):\n                    start = self._position\n                    self._position += len(operator)\n                    self._tokens.append(Token(\n                        type='OPERATOR',\n                        value=operator,\n                        start=start\n                    ))\n                    return\n    \n            start = self._position\n            ch = self._input[self._position]\n            self._position += 1\n            self._tokens.append(Token(type='ERROR', value=ch, start=start))\n    \n        def _is_keyword(self, value: str) -> bool:\n            \"\"\"\n            Check if a given value is a C++ keyword.\n    \n            Args:\n                value: The string to check\n    \n            Returns:\n                True if the value is a C++ keyword, False otherwise\n            \"\"\"\n            keywords = {\n                'alignas', 'alignof', 'and', 'and_eq', 'asm',\n                'atomic_cancel', 'atomic_commit', 'atomic_noexcept',\n                'auto', 'bitand', 'bitor', 'bool', 'break', 'case',\n                'catch', 'char', 'char16_t', 'char32_t', 'class',\n                'compl', 'concept', 'const', 'const_cast', 'consteval',\n                'constexpr', 'constinit', 'continue', 'co_await',\n                'co_return', 'co_yield', 'decltype', 'default',\n                'delete', 'do', 'double', 'dynamic_cast', 'else',\n                'enum', 'explicit', 'export', 'extern', 'false',\n                'float', 'for', 'friend', 'goto', 'if', 'inline',\n                'int', 'long', 'mutable', 'namespace', 'new',\n                'noexcept', 'not', 'not_eq', 'nullptr', 'operator',\n                'or', 'or_eq', 'private', 'protected', 'public',\n                'register', 'reinterpret_cast', 'requires', 'return',\n                'short', 'signed', 'sizeof', 'static', 'static_assert',\n                'static_cast', 'struct', 'switch', 'template', 'this',\n                'thread_local', 'throw', 'true', 'try', 'typedef',\n                'typeid', 'typename', 'union', 'unsigned', 'using',\n                'virtual', 'void', 'volatile', 'wchar_t', 'while',\n                'xor', 'xor_eq'\n            }\n            return value in keywords\n    ```\n    File: src/humbug/syntax/text_parser.py\n    ```python\n    from dataclasses import dataclass\n    from typing import Optional\n    \n    from humbug.syntax.lexer import Token\n    from humbug.syntax.parser import Parser, ParserState\n    from humbug.syntax.programming_language import ProgrammingLanguage\n    from humbug.syntax.parser_registry import ParserRegistry\n    \n    \n    @dataclass\n    class TextParserState(ParserState):\n        \"\"\"\n        State information for the Text parser.\n        \"\"\"\n    \n    \n    @ParserRegistry.register_parser(ProgrammingLanguage.TEXT)\n    class TextParser(Parser):\n        \"\"\"\n        Parser for text.\n        \"\"\"\n    \n        def parse(self, prev_parser_state: Optional[TextParserState], input_str: str) -> TextParserState:\n            \"\"\"\n            Parse the input string using the provided parser state.\n    \n            Args:\n                prev_parser_state: Optional previous parser state\n                input_str: The input string to parse\n    \n            Returns:\n                The updated parser state after parsing\n            \"\"\"\n            self._tokens.append(Token(\n                type='CODE',\n                value=input_str,\n                start=0\n            ))\n    \n            parser_state = TextParserState()\n            return parser_state\n    ```\n    File: src/humbug/syntax/programming_language.py\n    ```python\n    from enum import IntEnum\n    \n    \n    class ProgrammingLanguage(IntEnum):\n        UNKNOWN = -1\n        C = 0\n        CPP = 1\n        CSS = 2\n        HTML = 3\n        JAVASCRIPT = 4\n        METAPHOR = 5\n        PYTHON = 6\n        TEXT = 7\n        TYPESCRIPT = 8\n    ```\n    File: src/humbug/syntax/css_parser.py\n    ```python\n    from dataclasses import dataclass\n    from typing import Optional\n    \n    from humbug.syntax.lexer import Token\n    from humbug.syntax.parser import Parser, ParserState\n    from humbug.syntax.css_lexer import CSSLexer\n    from humbug.syntax.programming_language import ProgrammingLanguage\n    from humbug.syntax.parser_registry import ParserRegistry\n    \n    \n    @dataclass\n    class CSSParserState(ParserState):\n        \"\"\"\n        State information for the CSS parser.\n    \n        This maintains parsing context information that may be needed across\n        multiple parse operations.\n        \"\"\"\n    \n    \n    @ParserRegistry.register_parser(ProgrammingLanguage.CSS)\n    class CSSParser(Parser):\n        \"\"\"\n        Parser for CSS code.\n    \n        This parser processes tokens from the CSS lexer and handles special cases\n        like function calls and property values.\n        \"\"\"\n    \n        def parse(self, prev_parser_state: Optional[CSSParserState], input_str: str) -> CSSParserState:\n            \"\"\"\n            Parse the input string using the provided parser state.\n    \n            Args:\n                prev_parser_state: Optional previous parser state\n                input_str: The input string to parse\n    \n            Returns:\n                The updated parser state after parsing\n    \n            Note:\n                The parser converts identifier tokens to FUNCTION_OR_METHOD tokens\n                when they're followed by parentheses.\n            \"\"\"\n            prev_lexer_state = None\n            if prev_parser_state:\n                prev_lexer_state = prev_parser_state.lexer_state\n    \n            lexer = CSSLexer()\n            lexer_state = lexer.lex(prev_lexer_state, input_str)\n    \n            while True:\n                token = lexer.get_next_token()\n                if not token:\n                    break\n    \n                if token.type == 'HEX' or token.type == 'DIMENSION':\n                    self._tokens.append(Token(\n                        type='NUMBER',\n                        value=token.value,\n                        start=token.start\n                    ))\n                    continue\n    \n                if token.type == 'HASH':\n                    self._tokens.append(Token(\n                        type='IDENTIFIER',\n                        value=token.value,\n                        start=token.start\n                    ))\n                    continue\n    \n                if token.type != 'IDENTIFIER':\n                    self._tokens.append(token)\n                    continue\n    \n                # Look at the next token. If it's a '(' operator then we're making a\n                # function call!\n                next_token = lexer.peek_next_token(['WHITESPACE'])\n                if next_token and next_token.type == 'OPERATOR':\n                    if next_token.value == '(':\n                        self._tokens.append(Token(\n                            type='FUNCTION_OR_METHOD',\n                            value=token.value,\n                            start=token.start\n                        ))\n                        continue\n    \n                self._tokens.append(token)\n    \n            parser_state = CSSParserState()\n            parser_state.continuation_state = 1 if lexer_state.in_comment else 0\n            parser_state.lexer_state = lexer_state\n            return parser_state\n    ```\n    File: src/humbug/syntax/lexer.py\n    ```python\n    from abc import ABC, abstractmethod\n    from dataclasses import dataclass\n    from typing import List, Callable, Optional\n    \n    \n    @dataclass\n    class Token:\n        type: str\n        value: str\n        start: int\n    \n    \n    @dataclass\n    class LexerState:\n        \"\"\"\n        State information for the Lexer.\n        \"\"\"\n    \n    \n    class Lexer(ABC):\n        def __init__(self):\n            self._input: str = None\n            self._position: int = 0\n            self._tokens: List[Token] = []\n            self._next_token: int = 0\n    \n            # Initialize lexing functions for ASCII characters (0-127)\n            self._lexing_functions: List[Callable[[], None]] = [self._get_lexing_function(chr(i)) for i in range(128)]\n    \n        @abstractmethod\n        def _get_lexing_function(self, ch: str) -> Callable[[], None]:\n            \"\"\"\n            Get the lexing function that matches a given start character.\n    \n            :param ch: The start character\n            :return: The lexing function\n            \"\"\"\n    \n        @abstractmethod\n        def lex(self, prev_lexer_state: Optional[LexerState], input_str: str) -> LexerState:\n            \"\"\"\n            Parse the input string\n            \"\"\"\n    \n        def _inner_lex(self) -> None:\n            \"\"\"\n            Lex all the tokens in the input.\n            \"\"\"\n            while self._position < len(self._input):\n                ch = self._input[self._position]\n                ch_val = ord(ch)\n                if ch_val < 128:\n                    fn = self._lexing_functions[ch_val]\n                else:\n                    fn = self._get_lexing_function(ch)\n    \n                fn()\n    \n        def get_next_token(self, filter_list: List=None) -> Optional[Token]:\n            \"\"\"\n            Gets the next token from the input that does not have a type found in the filter list.\n    \n            :return: The next Token available or None if there are no tokens left.\n            \"\"\"\n            while True:\n                if self._next_token >= len(self._tokens):\n                    return None\n    \n                token = self._tokens[self._next_token]\n                self._next_token += 1\n                if (not filter_list) or (token.type not in filter_list):\n                    return token\n    \n        def peek_next_token(self, filter_list: List=None) -> Optional[Token]:\n            \"\"\"\n            Get the next token that does not have a type found in the filter list.\n    \n            :return: The next syntactic Token or None if none found.\n            \"\"\"\n            current_token_index = self._next_token\n            token = self.get_next_token(filter_list)\n            self._next_token = current_token_index\n            return token\n    \n        def _read_string(self) -> None:\n            \"\"\"\n            Reads a string token.\n            \"\"\"\n            quote: str = self._input[self._position]\n            start = self._position\n            self._position += 1\n    \n            while self._position < len(self._input) and self._input[self._position] != quote:\n                if self._input[self._position] == '\\\\' and (self._position + 1) < len(self._input):\n                    self._position += 1  # Skip the escape character\n    \n                self._position += 1\n    \n            self._position += 1  # Skip the closing quote\n            string_value = self._input[start:self._position]\n            self._tokens.append(Token(type='STRING', value=string_value, start=start))\n    \n        def _read_newline(self) -> None:\n            \"\"\"\n            Reads a newline in the input.\n            \"\"\"\n            start = self._position\n            self._position += 1\n            self._tokens.append(Token(type='NEWLINE', value='\\n', start=start))\n    \n        def _read_whitespace(self) -> None:\n            \"\"\"\n            Reads whitespace in the input.\n            \"\"\"\n            start = self._position\n            self._position += 1\n            while self._position < len(self._input) and self._is_whitespace(self._input[self._position]):\n                self._position += 1\n    \n            whitespace_value = self._input[start:self._position]\n            self._tokens.append(Token(type='WHITESPACE', value=whitespace_value, start=start))\n    \n        # Helper Methods\n    \n        def _is_letter(self, ch: str) -> bool:\n            \"\"\"\n            Determines if a character is a letter.\n    \n            :param ch: The character to check.\n            :return: True if the character is a letter, False otherwise.\n            \"\"\"\n            return ('a' <= ch <= 'z') or ('A' <= ch <= 'Z')\n    \n        def _is_octal_digit(self, ch: str) -> bool:\n            \"\"\"\n            Determines if a character is an octal digit.\n    \n            :param ch: The character to check.\n            :return: True if the character is an octal digit, False otherwise.\n            \"\"\"\n            return '0' <= ch <= '7'\n    \n        def _is_binary_digit(self, ch: str) -> bool:\n            \"\"\"\n            Determines if a character is a binary digit.\n    \n            :param ch: The character to check.\n            :return: True if the character is a binary digit, False otherwise.\n            \"\"\"\n            return ch in ('0', '1')\n    \n        def _is_digit(self, ch: str) -> bool:\n            \"\"\"\n            Determines if a character is a digit.\n    \n            :param ch: The character to check.\n            :return: True if the character is a digit, False otherwise.\n            \"\"\"\n            return '0' <= ch <= '9'\n    \n        def _is_hex_digit(self, ch: str) -> bool:\n            \"\"\"\n            Determines if a character is a hexadecimal digit.\n    \n            :param ch: The character to check.\n            :return: True if the character is a hexadecimal digit, False otherwise.\n            \"\"\"\n            return self._is_digit(ch) or ('a' <= ch <= 'f') or ('A' <= ch <= 'F')\n    \n        def _is_letter_or_digit(self, ch: str) -> bool:\n            \"\"\"\n            Determines if a character is a letter or digit.\n    \n            :param ch: The character to check.\n            :return: True if the character is a letter or digit, False otherwise.\n            \"\"\"\n            return self._is_letter(ch) or self._is_digit(ch)\n    \n        def _is_whitespace(self, ch: str) -> bool:\n            \"\"\"\n            Determines if a character is a non-newline whitespace.\n    \n            :param ch: The character to check.\n            :return: True if the character is a non-newline whitespace character, False otherwise.\n            \"\"\"\n            whitespace_chars = {\n                ' ', '\\t', '\\n', '\\r', '\\v', '\\f',\n                '\\u00A0', '\\u1680',\n                # Range \\u2000 to \\u200A\n                *(chr(c) for c in range(0x2000, 0x200B)),\n                '\\u2028', '\\u2029', '\\u202F', '\\u205F', '\\u3000'\n            }\n            return ch in whitespace_chars\n    ```\n    File: src/humbug/syntax/css_lexer.py\n    ```python\n    from dataclasses import dataclass\n    from typing import Callable, Optional\n    \n    from humbug.syntax.lexer import Lexer, LexerState, Token\n    \n    \n    @dataclass\n    class CSSLexerState(LexerState):\n        \"\"\"\n        State information for the CSS lexer.\n    \n        Attributes:\n            in_comment: Indicates if we're currently parsing a comment\n        \"\"\"\n        in_comment: bool = False\n    \n    \n    class CSSLexer(Lexer):\n        \"\"\"\n        Lexer for CSS code.\n    \n        This lexer handles CSS-specific syntax including identifiers, dimensions,\n        at-rules, hex colors, and CSS-specific operators.\n        \"\"\"\n    \n        def __init__(self):\n            super().__init__()\n            self._in_comment = False\n    \n        def lex(self, prev_lexer_state: Optional[CSSLexerState], input_str: str) -> CSSLexerState:\n            \"\"\"\n            Lex all the tokens in the input.\n            \"\"\"\n            self._input = input_str\n            if prev_lexer_state:\n                self._in_comment = prev_lexer_state.in_comment\n    \n            if self._in_comment:\n                self._read_comment(0)\n    \n            if not self._in_comment:\n                self._inner_lex()\n    \n            lexer_state = CSSLexerState(in_comment=False)\n            lexer_state.in_comment = self._in_comment\n            return lexer_state\n    \n        def _get_lexing_function(self, ch: str) -> Callable[[], None]:\n            \"\"\"\n            Get the lexing function that matches a given start character.\n    \n            Args:\n                ch: The start character\n    \n            Returns:\n                The appropriate lexing function for the character\n            \"\"\"\n            if ch == '\\n':\n                return self._read_newline\n    \n            if self._is_whitespace(ch):\n                return self._read_whitespace\n    \n            if self._is_letter(ch):\n                return self._read_identifier\n    \n            if self._is_digit(ch):\n                return self._read_number\n    \n            if ch in ('\"', \"'\"):\n                return self._read_string\n    \n            if ch == '/':\n                return self._read_forward_slash\n    \n            if ch == '#':\n                return self._read_hex_or_id\n    \n            if ch == '.':\n                return self._read_dot\n    \n            if ch == '-':\n                return self._read_minus\n    \n            if ch == '@':\n                return self._read_at_rule\n    \n            return self._read_operator\n    \n        def _read_dot(self) -> None:\n            \"\"\"\n            Read a dot operator or start of a class selector.\n            \"\"\"\n            if (self._position + 1 < len(self._input) and\n                    self._is_digit(self._input[self._position + 1])):\n                self._read_number()\n                return\n    \n            self._read_identifier()\n    \n        def _read_forward_slash(self) -> None:\n            \"\"\"\n            Read a forward slash operator or start of a comment.\n            \"\"\"\n            if (self._position + 1 < len(self._input) and\n                    self._input[self._position + 1] == '*'):\n                self._read_comment(2)\n                return\n    \n            self._read_operator()\n    \n        def _read_minus(self) -> None:\n            \"\"\"\n            Read a minus operator, negative number, or identifier starting with a dash.\n            \"\"\"\n            if (self._position + 1 < len(self._input) and\n                    self._is_digit(self._input[self._position + 1])):\n                self._read_number()\n                return\n    \n            if (self._position + 1 < len(self._input) and\n                    (self._is_letter(self._input[self._position + 1]) or\n                     self._input[self._position + 1] == '-')):\n                self._read_identifier()\n                return\n    \n            self._read_operator()\n    \n        def _read_identifier(self) -> None:\n            \"\"\"\n            Read a CSS identifier token.\n            \"\"\"\n            start = self._position\n            while (self._position < len(self._input) and\n                   self._input[self._position] in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.#[]=- '):\n                self._position += 1\n    \n            self._tokens.append(Token(\n                type='IDENTIFIER',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_comment(self, skip_chars: int) -> None:\n            \"\"\"\n            Read a CSS /* */ style comment token.\n            \"\"\"\n            self._in_comment = True\n            start = self._position\n            self._position += skip_chars  # Skip /*\n            while (self._position + 1) < len(self._input):\n                if self._input[self._position] == '*' and self._input[self._position + 1] == '/':\n                    self._in_comment = False\n                    self._position += 2\n                    break\n    \n                self._position += 1\n    \n            # If we're still in a block comment we've got one character left on this line and\n            # we need to include it in the comment too.\n            if self._in_comment:\n                self._position = len(self._input)\n    \n            self._tokens.append(Token(\n                type='COMMENT',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_at_rule(self) -> None:\n            \"\"\"\n            Read a CSS at-rule token (e.g. @media, @import).\n            \"\"\"\n            start = self._position\n            self._position += 1\n            while (self._position < len(self._input) and\n                   self._input[self._position] in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-'):\n                self._position += 1\n    \n            self._tokens.append(Token(\n                type='CSS_AT_RULE',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_number(self) -> None:\n            \"\"\"\n            Read a numeric token, which may include dimensions (e.g. px, em, %).\n            \"\"\"\n            start = self._position\n            if self._input[self._position] == '-':\n                self._position += 1\n    \n            while (self._position < len(self._input) and\n                   self._input[self._position] in '0123456789.'):\n                self._position += 1\n    \n            if (self._position < len(self._input) and\n                    self._input[self._position] in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ%'):\n                self._read_dimension(start)\n                return\n    \n            self._tokens.append(Token(\n                type='NUMBER',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_dimension(self, start: int) -> None:\n            \"\"\"\n            Read a CSS dimension token (e.g. 12px, 2em, 50%).\n    \n            Args:\n                start: The starting position of the dimension value\n            \"\"\"\n            while (self._position < len(self._input) and\n                   self._input[self._position] in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ%'):\n                self._position += 1\n    \n            self._tokens.append(Token(\n                type='DIMENSION',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_hex_or_id(self) -> None:\n            \"\"\"\n            Read a hexadecimal color value or ID selector.\n            \"\"\"\n            start = self._position\n            self._position += 1\n    \n            # Peek ahead to determine if this is a hex value or an ID\n            is_hex = (self._position < len(self._input) and\n                     self._is_hex_digit(self._input[self._position]))\n    \n            while (self._position < len(self._input) and\n                   self._is_hex_digit(self._input[self._position])):\n                self._position += 1\n    \n            if is_hex and (self._position - start == 4 or self._position - start == 7):\n                self._tokens.append(Token(\n                    type='HEX',\n                    value=self._input[start:self._position],\n                    start=start\n                ))\n                return\n    \n            # If not a valid hex, treat as ID selector\n            while (self._position < len(self._input) and\n                   self._input[self._position] in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._-'):\n                self._position += 1\n    \n            self._tokens.append(Token(\n                type='HASH',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_operator(self) -> None:\n            \"\"\"\n            Read an operator or punctuation token.\n            \"\"\"\n            operators = [\n                '~=', '$=', '^=', '|=', '*=', '-', '+', '*', '|', '=',\n                '>', '(', ')', '{', '}', '[', ']', ';', ':', ','\n            ]\n    \n            for operator in operators:\n                if self._input[self._position:].startswith(operator):\n                    start = self._position\n                    self._position += len(operator)\n                    self._tokens.append(Token(\n                        type='OPERATOR',\n                        value=operator,\n                        start=start\n                    ))\n                    return\n    \n            start = self._position\n            ch = self._input[self._position]\n            self._position += 1\n            self._tokens.append(Token(type='ERROR', value=ch, start=start))\n    ```\n    File: src/humbug/syntax/cpp_parser.py\n    ```python\n    from dataclasses import dataclass\n    from typing import Optional\n    \n    from humbug.syntax.lexer import Token\n    from humbug.syntax.c_parser import CParser, CParserState\n    from humbug.syntax.cpp_lexer import CppLexer\n    from humbug.syntax.programming_language import ProgrammingLanguage\n    from humbug.syntax.parser_registry import ParserRegistry\n    \n    \n    @dataclass\n    class CppParserState(CParserState):\n        \"\"\"\n        State information for the Cpp parser.\n        \"\"\"\n    \n    \n    @ParserRegistry.register_parser(ProgrammingLanguage.CPP)\n    class CppParser(CParser):\n        \"\"\"\n        Parser for C++ code.\n    \n        This parser extends the C parser to handle C++-specific syntax while\n        maintaining the same token processing logic for function calls and\n        element access.\n        \"\"\"\n    \n        def parse(self, prev_parser_state: Optional[CppParserState], input_str: str) -> CppParserState:\n            \"\"\"\n            Parse the input string using the provided parser state.\n    \n            Args:\n                prev_parser_state: Optional previous parser state\n                input_str: The input string to parse\n    \n            Returns:\n                The updated parser state after parsing\n    \n            Note:\n                The parser converts identifier tokens to FUNCTION_OR_METHOD tokens\n                when they're followed by parentheses, and to ELEMENT tokens when\n                they're part of a dotted or arrow access chain. It also handles\n                C++-specific cases like the 'this' keyword.\n            \"\"\"\n            in_element = False\n            prev_lexer_state = None\n            if prev_parser_state:\n                in_element = prev_parser_state.in_element\n                prev_lexer_state = prev_parser_state.lexer_state\n    \n            lexer = CppLexer()\n            lexer_state = lexer.lex(prev_lexer_state, input_str)\n    \n            while True:\n                token = lexer.get_next_token()\n                if not token:\n                    break\n    \n                if token.type != 'IDENTIFIER':\n                    if token.type == 'OPERATOR' and token.value not in ('.', '->'):\n                        in_element = False\n                        self._tokens.append(token)\n                        continue\n    \n                    if token.type != 'KEYWORD' or token.value != 'this':\n                        self._tokens.append(token)\n                        continue\n    \n                # Look at the next token. If it's a '(' operator then we're making a\n                # function or method call!\n                cur_in_element = in_element\n                next_token = lexer.peek_next_token(['WHITESPACE'])\n                in_element = cur_in_element\n    \n                next_in_element = False\n                if next_token and next_token.type == 'OPERATOR':\n                    if next_token.value == '(':\n                        in_element = False\n                        self._tokens.append(Token(\n                            type='FUNCTION_OR_METHOD',\n                            value=token.value,\n                            start=token.start\n                        ))\n                        continue\n    \n                    # Is the next token going to be an element?\n                    if next_token.value in ('.', '->'):\n                        next_in_element = True\n    \n                in_element = next_in_element\n    \n                if cur_in_element:\n                    self._tokens.append(Token(\n                        type='ELEMENT',\n                        value=token.value,\n                        start=token.start\n                    ))\n                    continue\n    \n                self._tokens.append(token)\n    \n            parser_state = CppParserState()\n            parser_state.continuation_state = 1 if lexer_state.in_block_comment else 0\n            parser_state.lexer_state = lexer_state\n            parser_state.in_element = in_element\n            return parser_state\n    ```\n    File: src/humbug/syntax/typescript_parser.py\n    ```python\n    from dataclasses import dataclass\n    from typing import Optional\n    \n    from humbug.syntax.lexer import Token\n    from humbug.syntax.javascript_parser import JavaScriptParser, JavaScriptParserState\n    from humbug.syntax.typescript_lexer import TypeScriptLexer\n    from humbug.syntax.programming_language import ProgrammingLanguage\n    from humbug.syntax.parser_registry import ParserRegistry\n    \n    \n    @dataclass\n    class TypeScriptParserState(JavaScriptParserState):\n        \"\"\"\n        State information for the Cpp parser.\n        \"\"\"\n    \n    \n    @ParserRegistry.register_parser(ProgrammingLanguage.TYPESCRIPT)\n    class TypeScriptParser(JavaScriptParser):\n        \"\"\"\n        Parser for TypeScript code.\n    \n        This parser extends the JavaScript parser to handle TypeScript-specific syntax\n        and constructs.\n        \"\"\"\n    \n        def parse(self, prev_parser_state: Optional[TypeScriptParserState], input_str: str) -> TypeScriptParserState:\n            \"\"\"\n            Parse the input string using the provided parser state.\n    \n            Args:\n                prev_parser_state: Optional previous parser state\n                input_str: The input string to parse\n    \n            Returns:\n                The updated parser state after parsing\n    \n            Note:\n                Uses the TypeScript lexer for token generation while maintaining the\n                JavaScript parsing logic.\n            \"\"\"\n            in_element = False\n            prev_lexer_state = None\n            if prev_parser_state:\n                in_element = prev_parser_state.in_element\n                prev_lexer_state = prev_parser_state.lexer_state\n    \n            lexer = TypeScriptLexer()\n            lexer_state = lexer.lex(prev_lexer_state, input_str)\n    \n            while True:\n                token = lexer.get_next_token()\n                if not token:\n                    break\n    \n                if token.type != 'IDENTIFIER':\n                    if (token.type == 'OPERATOR' and\n                            token.value not in ('.', '?.')):\n                        in_element = False\n                        self._tokens.append(token)\n                        continue\n    \n                    if token.type != 'KEYWORD':\n                        self._tokens.append(token)\n                        continue\n    \n                    if token.value != 'this' and not in_element:\n                        self._tokens.append(token)\n                        continue\n    \n                # Look at the next token. If it's a '(' operator then we're making a\n                # function or method call!\n                cur_in_element = in_element\n                next_token = lexer.peek_next_token(['WHITESPACE'])\n                in_element = cur_in_element\n    \n                next_in_element = False\n                if next_token and next_token.type == 'OPERATOR':\n                    if next_token.value == '(':\n                        in_element = False\n                        self._tokens.append(Token(\n                            type='FUNCTION_OR_METHOD',\n                            value=token.value,\n                            start=token.start\n                        ))\n                        continue\n    \n                    # Is the next token going to be an element?\n                    if next_token.value in ('.', '?.'):\n                        next_in_element = True\n    \n                in_element = next_in_element\n    \n                if cur_in_element:\n                    self._tokens.append(Token(\n                        type='ELEMENT',\n                        value=token.value,\n                        start=token.start\n                    ))\n                    continue\n    \n                self._tokens.append(token)\n    \n            parser_state = TypeScriptParserState()\n            parser_state.continuation_state = 1 if lexer_state.in_block_comment else 0\n            parser_state.lexer_state = lexer_state\n            parser_state.in_element = in_element\n            return parser_state\n    ```\n    File: src/humbug/syntax/parser.py\n    ```python\n    from abc import ABC, abstractmethod\n    from dataclasses import dataclass\n    from typing import Optional, List\n    \n    \n    from humbug.syntax.lexer import Lexer, LexerState, Token\n    \n    \n    @dataclass\n    class ParserState:\n        \"\"\"\n        State information for the Parser.\n        \"\"\"\n        lexer_state: LexerState = None\n        continuation_state: int = 0\n    \n    \n    class Parser(ABC):\n        def __init__(self):\n            self._lexer: Optional[Lexer] = None\n            self._tokens: List[Token] = []\n            self._next_token: int = 0\n    \n        @abstractmethod\n        def parse(self, prev_parser_state: Optional[ParserState], input_str: str) -> ParserState:\n            \"\"\"\n            Parse the input string\n            \"\"\"\n    \n        def get_next_token(self) -> Optional[Token]:\n            \"\"\"\n            Gets the next token from the input.\n    \n            :return: The next Token available or None if there are no tokens left.\n            \"\"\"\n            if self._next_token >= len(self._tokens):\n                return None\n    \n            token = self._tokens[self._next_token]\n            self._next_token += 1\n            return token\n    ```\n    File: src/humbug/syntax/python_parser.py\n    ```python\n    from dataclasses import dataclass\n    from typing import Optional\n    \n    from humbug.syntax.lexer import Token\n    from humbug.syntax.parser import Parser, ParserState\n    from humbug.syntax.python_lexer import PythonLexer\n    from humbug.syntax.programming_language import ProgrammingLanguage\n    from humbug.syntax.parser_registry import ParserRegistry\n    \n    \n    @dataclass\n    class PythonParserState(ParserState):\n        \"\"\"\n        State information for the Python parser.\n    \n        Attributes:\n            in_element: Indicates if we're currently parsing an element\n        \"\"\"\n        in_element: bool = False\n    \n    \n    @ParserRegistry.register_parser(ProgrammingLanguage.PYTHON)\n    class PythonParser(Parser):\n        \"\"\"\n        Parser for Python code.\n    \n        This parser processes tokens from the Python lexer and handles special cases\n        like function calls and element access.\n        \"\"\"\n    \n        def parse(self, prev_parser_state: Optional[PythonParserState], input_str: str) -> PythonParserState:\n            \"\"\"\n            Parse the input string using the provided parser state.\n    \n            Args:\n                prev_parser_state: Optional previous parser state\n                input_str: The input string to parse\n    \n            Returns:\n                The updated parser state after parsing\n    \n            Note:\n                The parser converts identifier tokens to FUNCTION_OR_METHOD tokens\n                when they're followed by parentheses, and to ELEMENT tokens when\n                they're part of a dotted access chain.\n            \"\"\"\n            in_element = False\n            prev_lexer_state = None\n            if prev_parser_state:\n                in_element = prev_parser_state.in_element\n                prev_lexer_state = prev_parser_state.lexer_state\n    \n            lexer = PythonLexer()\n            lexer_state = lexer.lex(prev_lexer_state, input_str)\n    \n            while True:\n                token = lexer.get_next_token()\n                if not token:\n                    break\n    \n                if token.type != 'IDENTIFIER':\n                    self._tokens.append(token)\n                    continue\n    \n                # Look at the next token. If it's a '(' operator then we're making a\n                # function or method call!\n                cur_in_element = in_element\n                next_token = lexer.peek_next_token(['WHITESPACE'])\n                in_element = cur_in_element\n    \n                next_in_element = False\n                if next_token and next_token.type == 'OPERATOR':\n                    if next_token.value == '(':\n                        in_element = False\n                        self._tokens.append(Token(\n                            type='FUNCTION_OR_METHOD',\n                            value=token.value,\n                            start=token.start\n                        ))\n                        continue\n    \n                    # Is the next token going to be an element?\n                    if next_token.value == '.':\n                        next_in_element = True\n    \n                in_element = next_in_element\n    \n                if cur_in_element:\n                    self._tokens.append(Token(\n                        type='ELEMENT',\n                        value=token.value,\n                        start=token.start\n                    ))\n                    continue\n    \n                self._tokens.append(token)\n    \n            parser_state = PythonParserState()\n            parser_state.continuation_state = 1 if lexer_state.in_docstring else 0\n            parser_state.lexer_state = lexer_state\n            parser_state.in_element = in_element\n            return parser_state\n    ```\n    File: src/humbug/syntax/html_lexer.py\n    ```python\n    from dataclasses import dataclass\n    from typing import Callable, Optional\n    \n    from humbug.syntax.lexer import Lexer, LexerState, Token\n    \n    \n    @dataclass\n    class HTMLLexerState(LexerState):\n        \"\"\"\n        State information for the HTML lexer.\n    \n        Attributes:\n            in_tag: Indicates if we're currently parsing a tag\n            tag_name: The name of any tag we're currently parsing\n            seen_equals: Indicates if we're currently parsing an attribute\n            in_comment: Indicates if we're currently parsing a block comment\n            in_script: Indicates if we're currently parsing a script block\n            in_style: Indicates if we're currently parsing a style block\n        \"\"\"\n        in_tag: bool = False\n        tag_name: str = \"\"\n        seen_equals: bool = False\n        in_comment: bool = False\n        in_script: bool = False\n        in_style: bool = False\n    \n    \n    class HTMLLexer(Lexer):\n        \"\"\"\n        Lexer for HTML code.\n    \n        This lexer handles HTML-specific syntax including tags, attributes, DOCTYPE\n        declarations, comments, and embedded script and style content.\n        \"\"\"\n    \n        def __init__(self) -> None:\n            \"\"\"\n            Initialize the HTML lexer.\n    \n            Args:\n                input_str: The input string to lex\n            \"\"\"\n            super().__init__()\n            self._in_tag = False\n            self._tag_name = ''\n            self._seen_equals = False\n            self._in_comment = False\n            self._in_script = False\n            self._in_style = False\n    \n        def lex(self, prev_lexer_state: Optional[HTMLLexerState], input_str: str) -> HTMLLexerState:\n            \"\"\"\n            Lex all the tokens in the input.\n            \"\"\"\n            self._input = input_str\n            if prev_lexer_state:\n                self._in_tag = prev_lexer_state.in_tag\n                self._tag_name = prev_lexer_state.tag_name\n                self._seen_equals = prev_lexer_state.seen_equals\n                self._in_comment = prev_lexer_state.in_comment\n                self._in_script = prev_lexer_state.in_script\n                self._in_style = prev_lexer_state.in_style\n    \n            if self._in_comment:\n                self._read_html_comment(0)\n            elif self._in_script:\n                self._read_script_block()\n            elif self._in_style:\n                self._read_style_block()\n    \n            if not self._in_comment and not self._in_script and not self._in_style:\n                self._inner_lex()\n    \n            lexer_state = HTMLLexerState()\n            lexer_state.in_tag = self._in_tag\n            lexer_state.tag_name = self._tag_name\n            lexer_state.seen_equals = self._seen_equals\n            lexer_state.in_comment = self._in_comment\n            lexer_state.in_script = self._in_script\n            lexer_state.in_style = self._in_style\n            return lexer_state\n    \n        def _get_lexing_function(self, ch: str) -> Callable[[], None]:\n            \"\"\"\n            Get the lexing function that matches a given start character.\n    \n            Args:\n                ch: The start character\n    \n            Returns:\n                The appropriate lexing function for the character\n            \"\"\"\n            if ch == '\\n':\n                return self._read_newline\n    \n            if self._is_whitespace(ch):\n                return self._read_whitespace\n    \n            if ch == '<':\n                return self._read_open\n    \n            if ch == '>':\n                return self._read_close\n    \n            return self._read_default\n    \n        def _read_open(self) -> None:\n            \"\"\"\n            Read an opening angle bracket and handle DOCTYPE declarations and comments.\n            \"\"\"\n            if (self._position + 1 < len(self._input) and\n                    self._input[self._position + 1] == '!'):\n                if self._input[self._position + 2:].startswith('DOCTYPE'):\n                    self._read_doctype()\n                    return\n    \n                self._in_comment = True\n                self._read_html_comment(4)\n                return\n    \n            self._position += 1\n            self._in_tag = True\n            self._tag_name = ''\n            self._tokens.append(Token(\n                type='OPERATOR',\n                value='<',\n                start=self._position - 1\n            ))\n    \n        def _read_close(self) -> None:\n            \"\"\"\n            Read a closing angle bracket.\n            \"\"\"\n            self._position += 1\n            self._in_tag = False\n            self._tokens.append(Token(\n                type='OPERATOR',\n                value='>',\n                start=self._position - 1\n            ))\n    \n            if self._tag_name.lower() == 'script':\n                self._in_script = True\n                self._read_script_block()\n                return\n    \n            if self._tag_name.lower() == 'style':\n                self._in_style = True\n                self._read_style_block()\n    \n        def _read_default(self) -> None:\n            \"\"\"\n            Read tag content or text between tags.\n            \"\"\"\n            if self._in_tag:\n                self._read_tag()\n                return\n    \n            self._read_text()\n    \n        def _read_doctype(self) -> None:\n            \"\"\"\n            Read a DOCTYPE declaration.\n            \"\"\"\n            start = self._position\n            self._position += 9  # Skip past '<!DOCTYPE'\n            while (self._position < len(self._input) and\n                   self._input[self._position] != '>'):\n                self._position += 1\n    \n            if self._position < len(self._input):\n                self._position += 1\n    \n            self._tokens.append(Token(\n                type='DOCTYPE',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_html_comment(self, skip_chars: int) -> None:\n            \"\"\"\n            Read an HTML comment.\n            \"\"\"\n            start = self._position\n            self._position += skip_chars  # Skip past '<!--'\n            while (self._position + 2) < len(self._input):\n                if self._input[self._position:self._position + 3] == '-->':\n                    self._in_comment = False\n                    self._position += 3\n    \n                self._position += 1\n    \n            # If we're still in a block comment we've got two characters left on this line and\n            # we need to include them in the comment too.\n            if self._in_comment:\n                self._position = len(self._input)\n    \n            self._tokens.append(Token(\n                type='COMMENT',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_script_block(self) -> None:\n            \"\"\"\n            Read a script block.\n            \"\"\"\n            start = self._position\n            script_close = self._input.lower().find('</script', self._position)\n            if script_close != -1:\n                self._in_script = False\n            else:\n                script_close = len(self._input)\n    \n            self._position = script_close\n            self._tokens.append(Token(\n                type='SCRIPT',\n                value=self._input[start:script_close],\n                start=start\n            ))\n    \n        def _read_style_block(self) -> None:\n            \"\"\"\n            Read a style block.\n            \"\"\"\n            start = self._position\n            style_close = self._input.lower().find('</style', self._position)\n            if style_close != -1:\n                self._in_style = False\n            else:\n                style_close = len(self._input)\n    \n            self._position = style_close\n            self._tokens.append(Token(\n                type='STYLE',\n                value=self._input[start:style_close],\n                start=start\n            ))\n    \n        def _read_tag_or_attribute(self, token_type: str) -> Token:\n            \"\"\"\n            Read a tag name or attribute name.\n    \n            Args:\n                token_type: The type of token to create\n    \n            Returns:\n                The created token\n            \"\"\"\n            start = self._position\n            self._position += 1\n            while (self._position < len(self._input) and\n                   (self._is_letter_or_digit(self._input[self._position]) or\n                    self._input[self._position] in ('_', '-', '/'))):\n                self._position += 1\n    \n            return Token(\n                type=token_type,\n                value=self._input[start:self._position],\n                start=start\n            )\n    \n        def _read_tag(self) -> None:\n            \"\"\"\n            Read tag content including tag names and attributes.\n            \"\"\"\n            if not self._tag_name:\n                token = self._read_tag_or_attribute('HTML_TAG')\n                self._tag_name = token.value\n                self._tokens.append(token)\n                return\n    \n            ch = self._input[self._position]\n            if ch == '=':\n                self._position += 1\n                self._seen_equals = True\n                self._tokens.append(Token(\n                    type='OPERATOR',\n                    value='=',\n                    start=self._position - 1\n                ))\n                return\n    \n            seen_equals = self._seen_equals\n            self._seen_equals = False\n    \n            if ch in ('\"', \"'\"):\n                self._read_string()\n                return\n    \n            self._tokens.append(\n                self._read_tag_or_attribute('STRING' if seen_equals else 'HTML_ATTRIBUTE')\n            )\n    \n        def _read_text(self) -> None:\n            \"\"\"\n            Read text content between HTML tags.\n            \"\"\"\n            start = self._position\n            while (self._position < len(self._input) and\n                   self._input[self._position] != '<'):\n                self._position += 1\n    \n            self._tokens.append(Token(\n                type='TEXT',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    ```\n    File: src/humbug/syntax/metaphor_lexer.py\n    ```python\n    from typing import Callable, Dict, Optional\n    \n    from humbug.syntax.lexer import Lexer, LexerState, Token\n    \n    \n    # Define styles as a module-level dictionary similar to the TypeScript implementation\n    styles: Dict[str, str] = {'HEADING': 'heading'}\n    \n    \n    class MetaphorLexer(Lexer):\n        \"\"\"\n        Lexer for Metaphor language.\n    \n        This lexer handles Metaphor-specific syntax including keywords, headings,\n        and text content.\n        \"\"\"\n    \n        def __init__(self) -> None:\n            \"\"\"\n            Initialize the Metaphor lexer.\n            \"\"\"\n            super().__init__()\n            self._seen_keyword: bool = False\n    \n        def lex(self, prev_lexer_state: Optional[LexerState], input_str: str) -> LexerState:\n            \"\"\"\n            Lex all the tokens in the input.\n            \"\"\"\n            self._input = input_str\n            self._inner_lex()\n            return None\n    \n        def _get_lexing_function(self, ch: str) -> Callable[[], None]:\n            \"\"\"\n            Get the lexing function that matches a given start character.\n    \n            Args:\n                ch: The start character\n    \n            Returns:\n                The appropriate lexing function for the character\n            \"\"\"\n            if ch == '\\n':\n                return self._read_newline\n    \n            if self._is_whitespace(ch):\n                return self._read_whitespace\n    \n            if ch == '`':\n                return self._read_backtick\n    \n            if ch == '#':\n                return self._read_comment\n    \n            return self._read_text_or_keyword\n    \n        def _read_text_or_keyword(self) -> None:\n            \"\"\"\n            Read either a text token or a keyword token.\n    \n            Keywords are special strings that end with ':'. If a keyword is found,\n            the remainder of the line is treated as a heading.\n            \"\"\"\n            start = self._position\n    \n            while self._position < len(self._input):\n                ch = self._input[self._position]\n    \n                if ch == '\\n':\n                    break\n    \n                self._position += 1\n    \n                # If we've already seen a keyword on this line then we don't need to\n                # look for another one.\n                if self._seen_keyword:\n                    continue\n    \n                # Is this a keyword?\n                if ch == ':':\n                    potential_keyword = self._input[start:self._position]\n                    if self._is_keyword(potential_keyword):\n                        self._seen_keyword = True\n                        self._tokens.append(Token(\n                            type='KEYWORD',\n                            value=potential_keyword,\n                            start=start\n                        ))\n                        return\n    \n            token_type = 'HEADING' if self._seen_keyword else 'TEXT'\n            self._tokens.append(Token(\n                type=token_type,\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_newline(self) -> None:\n            \"\"\"\n            Read a newline token and reset the keyword flag.\n            \"\"\"\n            start = self._position\n            self._position += 1\n            self._seen_keyword = False\n            self._tokens.append(Token(\n                type='NEWLINE',\n                value='\\n',\n                start=start\n            ))\n    \n        def _read_backtick(self) -> None:\n            start: int = self._position\n    \n            # Do we have 3 backticks?  If yes, we have code fence and the next word after that\n            # is the (optional) name of the language\n            if self._input[self._position:].startswith('```'):\n                self._position += 3\n                self._tokens.append(Token(type='FENCE', value='```', start=start))\n                return\n    \n            self._read_text_or_keyword()\n    \n        def _read_comment(self) -> None:\n            \"\"\"\n            Read a single-line comment token.\n            \"\"\"\n            start = self._position\n            self._position += 1\n            while (self._position < len(self._input) and\n                   self._input[self._position] != '\\n'):\n                self._position += 1\n    \n            self._tokens.append(Token(\n                type='COMMENT',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _is_keyword(self, value: str) -> bool:\n            \"\"\"\n            Check if a given value is a Metaphor keyword.\n    \n            Args:\n                value: The string to check\n    \n            Returns:\n                True if the value is a Metaphor keyword, False otherwise\n            \"\"\"\n            keywords = {\n                'Action:',\n                'Context:',\n                'Embed:',\n                'Include:',\n                'Role:'\n            }\n            return value in keywords\n    ```\n    File: src/humbug/syntax/javascript_parser.py\n    ```python\n    from dataclasses import dataclass\n    from typing import Optional\n    \n    from humbug.syntax.lexer import Token\n    from humbug.syntax.parser import Parser, ParserState\n    from humbug.syntax.javascript_lexer import JavaScriptLexer\n    from humbug.syntax.programming_language import ProgrammingLanguage\n    from humbug.syntax.parser_registry import ParserRegistry\n    \n    \n    @dataclass\n    class JavaScriptParserState(ParserState):\n        \"\"\"\n        State information for the JavaScript parser.\n    \n        Attributes:\n            in_element: Indicates if we're currently parsing an element\n        \"\"\"\n        in_element: bool = False\n    \n    \n    @ParserRegistry.register_parser(ProgrammingLanguage.JAVASCRIPT)\n    class JavaScriptParser(Parser):\n        \"\"\"\n        Parser for JavaScript code.\n    \n        This parser processes tokens from the JavaScript lexer and handles special cases\n        like function calls and element access.\n        \"\"\"\n    \n        def parse(self, prev_parser_state: Optional[JavaScriptParserState], input_str: str) -> JavaScriptParserState:\n            \"\"\"\n            Parse the input string using the provided parser state.\n    \n            Args:\n                prev_parser_state: Optional previous parser state\n                input_str: The input string to parse\n    \n            Returns:\n                The updated parser state after parsing\n    \n            Note:\n                The parser converts identifier tokens to FUNCTION_OR_METHOD tokens\n                when they're followed by parentheses, and to ELEMENT tokens when\n                they're part of a dotted access chain.\n            \"\"\"\n            in_element = False\n            prev_lexer_state = None\n            if prev_parser_state:\n                in_element = prev_parser_state.in_element\n                prev_lexer_state = prev_parser_state.lexer_state\n    \n            lexer = JavaScriptLexer()\n            lexer_state = lexer.lex(prev_lexer_state, input_str)\n    \n            while True:\n                token = lexer.get_next_token()\n                if not token:\n                    break\n    \n                if token.type != 'IDENTIFIER':\n                    if (token.type == 'OPERATOR' and\n                            token.value not in ('.', '?.')):\n                        in_element = False\n                        self._tokens.append(token)\n                        continue\n    \n                    if token.type != 'KEYWORD':\n                        self._tokens.append(token)\n                        continue\n    \n                    if token.value != 'this' and not in_element:\n                        self._tokens.append(token)\n                        continue\n    \n                # Look at the next token. If it's a '(' operator then we're making a\n                # function or method call!\n                cur_in_element = in_element\n                next_token = lexer.peek_next_token(['WHITESPACE'])\n                in_element = cur_in_element\n    \n                next_in_element = False\n                if next_token and next_token.type == 'OPERATOR':\n                    if next_token.value == '(':\n                        in_element = False\n                        self._tokens.append(Token(\n                            type='FUNCTION_OR_METHOD',\n                            value=token.value,\n                            start=token.start\n                        ))\n                        continue\n    \n                    # Is the next token going to be an element?\n                    if next_token.value in ('.', '?.'):\n                        next_in_element = True\n    \n                in_element = next_in_element\n    \n                if cur_in_element:\n                    self._tokens.append(Token(\n                        type='ELEMENT',\n                        value=token.value,\n                        start=token.start\n                    ))\n                    continue\n    \n                self._tokens.append(token)\n    \n            parser_state = JavaScriptParserState()\n            parser_state.continuation_state = 1 if lexer_state.in_block_comment else 0\n            parser_state.lexer_state = lexer_state\n            parser_state.in_element = in_element\n            return parser_state\n    ```\n    File: src/humbug/syntax/conversation_parser.py\n    ```python\n    from dataclasses import dataclass\n    from typing import Optional\n    \n    from humbug.syntax.lexer import Token\n    from humbug.syntax.conversation_lexer import ConversationLexer\n    from humbug.syntax.parser import Parser, ParserState\n    from humbug.syntax.programming_language import ProgrammingLanguage\n    from humbug.syntax.parser_registry import ParserRegistry\n    \n    \n    # Mapping from lowercase language names to enum members\n    LANGUAGE_MAPPING = {\n        \"c\": ProgrammingLanguage.C,\n        \"c++\": ProgrammingLanguage.CPP,\n        \"cpp\": ProgrammingLanguage.CPP,\n        \"css\": ProgrammingLanguage.CSS,\n        \"html\": ProgrammingLanguage.HTML,\n        \"javascript\": ProgrammingLanguage.JAVASCRIPT,\n        \"metaphor\": ProgrammingLanguage.METAPHOR,\n        \"python\": ProgrammingLanguage.PYTHON,\n        \"typescript\": ProgrammingLanguage.TYPESCRIPT\n    }\n    \n    \n    @dataclass\n    class ConversationParserState(ParserState):\n        \"\"\"\n        State information for the Conversation parser.\n    \n        Attributes:\n            in_fence_block: Indicates if we're currently in a code fence block\n            language: The current programming language being parsed\n            embedded_parser_state: State of the embedded language parser\n        \"\"\"\n        in_fence_block: bool = False\n        language: ProgrammingLanguage = ProgrammingLanguage.UNKNOWN\n        embedded_parser_state: ParserState = None\n    \n    \n    class ConversationParser(Parser):\n        \"\"\"\n        Parser for conversation content with embedded code blocks.\n    \n        This parser processes conversation content and delegates embedded code blocks to\n        appropriate language-specific parsers.\n        \"\"\"\n    \n        def _embedded_parse(\n                self,\n                language: ProgrammingLanguage,\n                prev_embedded_parser_state: ParserState,\n                input_str: str\n        ) -> ParserState:\n            \"\"\"\n            Parse embedded code content using an appropriate language parser.\n    \n            Args:\n                language: The programming language to use for parsing\n                prev_embedded_parser_state: Previous parser state if any\n                input_str: The input string to parse\n    \n            Returns:\n                Updated parser state after parsing\n    \n            Note:\n                Uses ParserFactory to instantiate appropriate parser for the language.\n                Returns None if no parser is available for the language.\n            \"\"\"\n            embedded_parser = ParserRegistry.create_parser(language)\n            if not embedded_parser:\n                return None\n    \n            # We apply a per-parser offset to any continuation value in case we switched language!\n            continuation_offset = int(language) * 0x1000\n            embedded_parser_state = embedded_parser.parse(prev_embedded_parser_state, input_str)\n            embedded_parser_state.continuation_state += continuation_offset\n    \n            while True:\n                token = embedded_parser.get_next_token()\n                if token is None:\n                    break\n    \n                self._tokens.append(Token(type=token.type, value=token.value, start=token.start))\n    \n            return embedded_parser_state\n    \n        def parse(self, prev_parser_state: Optional[ConversationParserState], input_str: str) -> ConversationParserState:\n            \"\"\"\n            Parse conversation content including embedded code blocks.\n    \n            Args:\n                prev_parser_state: Optional previous parser state\n                input_str: The input string to parse\n    \n            Returns:\n                The updated parser state after parsing\n    \n            Note:\n                Handles transitions between regular conversation content and code fence blocks,\n                delegating code blocks to appropriate language parsers.\n            \"\"\"\n            in_fence_block = False\n            language = ProgrammingLanguage.UNKNOWN\n            embedded_parser_state = None\n            if prev_parser_state:\n                in_fence_block = prev_parser_state.in_fence_block\n                language = prev_parser_state.language\n                embedded_parser_state = prev_parser_state.embedded_parser_state\n    \n            lexer = ConversationLexer()\n            lexer.lex(None, input_str)\n    \n            seen_text = False\n            parse_embedded = language != ProgrammingLanguage.UNKNOWN\n    \n            while True:\n                lex_token = lexer.get_next_token()\n                if not lex_token:\n                    break\n    \n                if lex_token.type == 'WHITESPACE':\n                    self._tokens.append(Token(type=lex_token.type, value=lex_token.value, start=lex_token.start))\n                    continue\n    \n                if (not seen_text) and (lex_token.type == 'FENCE'):\n                    seen_text = True\n                    if in_fence_block:\n                        self._tokens.append(Token(type='FENCE_END', value='```', start=lex_token.start))\n                        in_fence_block = False\n                        language = ProgrammingLanguage.UNKNOWN\n                        embedded_parser_state = None\n                        parse_embedded = False\n                        continue\n    \n                    in_fence_block = True\n                    embedded_parser_state = None\n                    self._tokens.append(Token(type='FENCE_START', value='```', start=lex_token.start))\n    \n                    next_token = lexer.peek_next_token('WHITESPACE')\n                    if next_token and (next_token.type == 'TEXT'):\n                        next_token = lexer.get_next_token('WHITESPACE')\n                        self._tokens.append(Token(type='LANGUAGE', value=next_token.value, start=next_token.start))\n    \n                        input_normalized = next_token.value.strip().lower()\n                        language = LANGUAGE_MAPPING.get(input_normalized, ProgrammingLanguage.TEXT)\n                        continue\n    \n                    language = LANGUAGE_MAPPING.get('', ProgrammingLanguage.TEXT)\n                    continue\n    \n                seen_text = True\n    \n                if language != ProgrammingLanguage.UNKNOWN:\n                    break\n    \n                self._tokens.append(Token(type=lex_token.type, value=lex_token.value, start=lex_token.start))\n    \n            parser_state = ConversationParserState()\n            parser_state.in_fence_block = in_fence_block\n            parser_state.language = language\n            if parse_embedded:\n                new_embedded_parser_state = self._embedded_parse(parser_state.language, embedded_parser_state, input_str)\n                parser_state.embedded_parser_state = new_embedded_parser_state\n                if new_embedded_parser_state:\n                    parser_state.continuation_state = new_embedded_parser_state.continuation_state\n    \n            return parser_state\n    ```\n    File: src/humbug/syntax/metaphor_parser.py\n    ```python\n    from dataclasses import dataclass\n    from typing import Optional\n    \n    from humbug.syntax.lexer import Token\n    from humbug.syntax.parser import Parser, ParserState\n    from humbug.syntax.metaphor_lexer import MetaphorLexer\n    from humbug.syntax.programming_language import ProgrammingLanguage\n    from humbug.syntax.parser_registry import ParserRegistry\n    \n    \n    # Mapping from lowercase language names to enum members\n    LANGUAGE_MAPPING = {\n        \"c\": ProgrammingLanguage.C,\n        \"c++\": ProgrammingLanguage.CPP,\n        \"cpp\": ProgrammingLanguage.CPP,\n        \"css\": ProgrammingLanguage.CSS,\n        \"html\": ProgrammingLanguage.HTML,\n        \"javascript\": ProgrammingLanguage.JAVASCRIPT,\n        \"metaphor\": ProgrammingLanguage.METAPHOR,\n        \"python\": ProgrammingLanguage.PYTHON,\n        \"typescript\": ProgrammingLanguage.TYPESCRIPT\n    }\n    \n    \n    @dataclass\n    class MetaphorParserState(ParserState):\n        \"\"\"\n        State information for the Conversation parser.\n    \n        Attributes:\n            in_fence_block: Indicates if we're currently in a code fence block\n            language: The current programming language being parsed\n            embedded_parser_state: State of the embedded language parser\n        \"\"\"\n        in_fence_block: bool = False\n        language: ProgrammingLanguage = ProgrammingLanguage.UNKNOWN\n        embedded_parser_state: ParserState = None\n    \n    \n    @ParserRegistry.register_parser(ProgrammingLanguage.METAPHOR)\n    class MetaphorParser(Parser):\n        \"\"\"\n        Parser for Metaphor language.\n    \n        This parser processes tokens from the Metaphor lexer and handles the\n        document tree structure of Role, Context, and Action blocks.\n        \"\"\"\n    \n        def _embedded_parse(\n                self,\n                language: ProgrammingLanguage,\n                prev_embedded_parser_state: ParserState,\n                input_str: str\n        ) -> ParserState:\n            \"\"\"\n            Parse embedded code content using an appropriate language parser.\n    \n            Args:\n                language: The programming language to use for parsing\n                prev_embedded_parser_state: Previous parser state if any\n                input_str: The input string to parse\n    \n            Returns:\n                Updated parser state after parsing\n    \n            Note:\n                Uses ParserFactory to instantiate appropriate parser for the language.\n                Returns None if no parser is available for the language.\n            \"\"\"\n            embedded_parser = ParserRegistry.create_parser(language)\n            if not embedded_parser:\n                return None\n    \n            # We apply a per-parser offset to any continuation value in case we switched language!\n            continuation_offset = int(language) * 0x1000\n            embedded_parser_state = embedded_parser.parse(prev_embedded_parser_state, input_str)\n            embedded_parser_state.continuation_state += continuation_offset\n    \n            while True:\n                token = embedded_parser.get_next_token()\n                if token is None:\n                    break\n    \n                self._tokens.append(Token(type=token.type, value=token.value, start=token.start))\n    \n            return embedded_parser_state\n    \n        def parse(self, prev_parser_state: Optional[MetaphorParserState], input_str: str) -> MetaphorParserState:\n            \"\"\"\n            Parse the input string.\n    \n            Args:\n                input_str: The input string to parse\n    \n            Returns:\n                The updated parser state after parsing\n    \n            Note:\n                Handles transitions between regular conversation content and code fence blocks,\n                delegating code blocks to appropriate language parsers.\n            \"\"\"\n            in_fence_block = False\n            language = ProgrammingLanguage.UNKNOWN\n            embedded_parser_state = None\n            if prev_parser_state:\n                in_fence_block = prev_parser_state.in_fence_block\n                language = prev_parser_state.language\n                embedded_parser_state = prev_parser_state.embedded_parser_state\n    \n            lexer = MetaphorLexer()\n            lexer.lex(None, input_str)\n    \n            parse_embedded = language != ProgrammingLanguage.UNKNOWN\n    \n            while True:\n                lex_token = lexer.get_next_token()\n                if not lex_token:\n                    break\n    \n                if lex_token.type == 'WHITESPACE':\n                    self._tokens.append(Token(type=lex_token.type, value=lex_token.value, start=lex_token.start))\n                    continue\n    \n                if lex_token.type == 'FENCE':\n                    if in_fence_block:\n                        self._tokens.append(Token(type='LANGUAGE', value='```', start=lex_token.start))\n                        in_fence_block = False\n                        language = ProgrammingLanguage.UNKNOWN\n                        embedded_parser_state = None\n                        parse_embedded = False\n                        continue\n    \n                    in_fence_block = True\n                    embedded_parser_state = None\n                    self._tokens.append(Token(type='LANGUAGE', value='```', start=lex_token.start))\n    \n                    next_token = lexer.peek_next_token('WHITESPACE')\n                    if next_token and (next_token.type == 'TEXT'):\n                        next_token = lexer.get_next_token('WHITESPACE')\n                        self._tokens.append(Token(type='LANGUAGE', value=next_token.value, start=next_token.start))\n    \n                        input_normalized = next_token.value.strip().lower()\n                        language = LANGUAGE_MAPPING.get(input_normalized, ProgrammingLanguage.TEXT)\n                        continue\n    \n                    language = LANGUAGE_MAPPING.get('', ProgrammingLanguage.TEXT)\n                    continue\n    \n                if language != ProgrammingLanguage.UNKNOWN:\n                    break\n    \n                self._tokens.append(Token(type=lex_token.type, value=lex_token.value, start=lex_token.start))\n    \n            parser_state = MetaphorParserState()\n            parser_state.in_fence_block = in_fence_block\n            parser_state.language = language\n            if parse_embedded:\n                new_embedded_parser_state = self._embedded_parse(parser_state.language, embedded_parser_state, input_str)\n                parser_state.embedded_parser_state = new_embedded_parser_state\n                if new_embedded_parser_state:\n                    parser_state.continuation_state = new_embedded_parser_state.continuation_state\n    \n            return parser_state\n    ```\n    File: src/humbug/syntax/parser_registry.py\n    ```python\n    from typing import Dict, Optional, Type\n    \n    from humbug.syntax.parser import Parser\n    from humbug.syntax.programming_language import ProgrammingLanguage\n    \n    \n    class ParserRegistry:\n        \"\"\"\n        A registry for parser classes that handles parser creation and dependency management.\n    \n        This registry serves as a central location for registering parser classes and\n        creating parser instances, avoiding cyclic dependencies between parsers and the\n        parser factory.\n    \n        The registry uses a lazy initialization pattern to avoid import cycles, allowing\n        parser classes to be registered after the registry is created.\n        \"\"\"\n    \n        _instance = None\n        _parser_classes: Dict[ProgrammingLanguage, Type[Parser]] = {}\n    \n        def __new__(cls):\n            \"\"\"\n            Implement the singleton pattern to ensure only one registry exists.\n    \n            Returns:\n                The single ParserRegistry instance\n            \"\"\"\n            if cls._instance is None:\n                cls._instance = super(ParserRegistry, cls).__new__(cls)\n    \n            return cls._instance\n    \n        @classmethod\n        def register_parser(cls, language: ProgrammingLanguage) -> callable:\n            \"\"\"\n            Register a parser class for a specific programming language.\n    \n            This is designed to be used as a decorator on parser classes.\n    \n            Args:\n                language: The programming language enum value to register the parser for\n    \n            Returns:\n                A decorator function that registers the parser class\n    \n            Example:\n                @ParserRegistry.register_parser(ProgrammingLanguage.PYTHON)\n                class PythonParser(Parser):\n                    ...\n            \"\"\"\n            def decorator(parser_class: Type[Parser]) -> Type[Parser]:\n                cls._parser_classes[language] = parser_class\n                return parser_class\n    \n            return decorator\n    \n        @classmethod\n        def create_parser(cls, language: ProgrammingLanguage) -> Optional[Parser]:\n            \"\"\"\n            Create and return a parser instance for the specified programming language.\n    \n            Args:\n                language: The programming language enum value indicating which parser to create\n    \n            Returns:\n                A parser instance appropriate for the specified language, or None if the\n                language is unknown or no parser is registered for it\n    \n            Example:\n                >>> parser = ParserRegistry.create_parser(ProgrammingLanguage.PYTHON)\n                >>> python_parser = parser.parse(None, \"def example():\")\n            \"\"\"\n            parser_class = cls._parser_classes.get(language)\n            if parser_class:\n                return parser_class()\n    \n            return None\n    ```\n    File: src/humbug/syntax/html_parser.py\n    ```python\n    from dataclasses import dataclass\n    from typing import Optional\n    \n    from humbug.syntax.lexer import Token\n    from humbug.syntax.parser import Parser, ParserState\n    from humbug.syntax.html_lexer import HTMLLexer\n    from humbug.syntax.parser_registry import ParserRegistry\n    from humbug.syntax.programming_language import ProgrammingLanguage\n    \n    \n    @dataclass\n    class HTMLParserState(ParserState):\n        \"\"\"\n        State information for the HTML parser.\n    \n        Attributes:\n            js_parser: Optional JavaScript parser for script content\n            css_parser: Optional CSS parser for style content\n        \"\"\"\n        embedded_parser_state: ParserState = None\n    \n    \n    @ParserRegistry.register_parser(ProgrammingLanguage.HTML)\n    class HTMLParser(Parser):\n        \"\"\"\n        Parser for HTML code.\n    \n        This parser processes tokens from the HTML lexer and handles special cases\n        like embedded JavaScript and CSS content.\n        \"\"\"\n    \n        def _embedded_parse(\n                self,\n                language: ProgrammingLanguage,\n                prev_embedded_parser_state: ParserState,\n                input_str: str\n        ) -> ParserState:\n            \"\"\"\n            Parse embedded code content using an appropriate language parser.\n    \n            Args:\n                language: The programming language to use for parsing\n                prev_embedded_parser_state: Previous parser state if any\n                input_str: The input string to parse\n    \n            Returns:\n                Updated parser state after parsing\n    \n            Note:\n                Uses ParserFactory to instantiate appropriate parser for the language.\n                Returns None if no parser is available for the language.\n            \"\"\"\n            embedded_parser = ParserRegistry.create_parser(language)\n            if not embedded_parser:\n                return None\n    \n            # We apply a per-parser offset to any continuation value in case we switched language!\n            continuation_offset = int(language) * 0x1000\n            embedded_parser_state = embedded_parser.parse(prev_embedded_parser_state, input_str)\n            embedded_parser_state.continuation_state += continuation_offset\n    \n            while True:\n                token = embedded_parser.get_next_token()\n                if token is None:\n                    break\n    \n                self._tokens.append(Token(type=token.type, value=token.value, start=token.start))\n    \n            return embedded_parser_state\n    \n        def parse(self, prev_parser_state: Optional[HTMLParserState], input_str: str) -> HTMLParserState:\n            \"\"\"\n            Parse the input string using the provided parser state.\n    \n            Args:\n                prev_parser_state: Optional previous parser state\n                input_str: The input string to parse\n    \n            Returns:\n                The updated parser state after parsing\n    \n            Note:\n                The parser handles embedded JavaScript and CSS content by delegating to\n                specialized parsers for those languages.\n            \"\"\"\n            prev_lexer_state = None\n            embedded_parser_state = None\n            if prev_parser_state:\n                prev_lexer_state = prev_parser_state.lexer_state\n                embedded_parser_state = prev_parser_state.embedded_parser_state\n    \n            lexer = HTMLLexer()\n            lexer_state = lexer.lex(prev_lexer_state, input_str)\n    \n            continuation_state = 0\n            if lexer_state.in_comment:\n                continuation_state = 1\n            elif lexer_state.in_script:\n                continuation_state = 2\n            elif lexer_state.in_style:\n                continuation_state = 3\n    \n            while True:\n                token = lexer.get_next_token()\n                if not token:\n                    break\n    \n                if token.type == 'SCRIPT':\n                    embedded_parser_state = self._embedded_parse(ProgrammingLanguage.JAVASCRIPT, embedded_parser_state, token.value)\n                    if embedded_parser_state:\n                        continuation_state = embedded_parser_state.continuation_state\n    \n                    continue\n    \n                if token.type == 'STYLE':\n                    embedded_parser_state = self._embedded_parse(ProgrammingLanguage.CSS, embedded_parser_state, token.value)\n                    if embedded_parser_state:\n                        continuation_state = embedded_parser_state.continuation_state\n    \n                    continue\n    \n                embedded_parser_state = None\n                self._tokens.append(token)\n    \n            parser_state = HTMLParserState()\n            parser_state.continuation_state = continuation_state\n            parser_state.lexer_state = lexer_state\n            parser_state.embedded_parser_state = embedded_parser_state\n            return parser_state\n    ```\n    File: src/humbug/syntax/c_parser.py\n    ```python\n    from dataclasses import dataclass\n    from typing import Optional\n    \n    from humbug.syntax.lexer import Token\n    from humbug.syntax.parser import Parser, ParserState\n    from humbug.syntax.c_lexer import CLexer\n    from humbug.syntax.programming_language import ProgrammingLanguage\n    from humbug.syntax.parser_registry import ParserRegistry\n    \n    \n    @dataclass\n    class CParserState(ParserState):\n        \"\"\"\n        State information for the C parser.\n    \n        Attributes:\n            in_element: Indicates if we're currently parsing an element\n        \"\"\"\n        in_element: bool = False\n    \n    \n    @ParserRegistry.register_parser(ProgrammingLanguage.C)\n    class CParser(Parser):\n        \"\"\"\n        Parser for C code.\n    \n        This parser processes tokens from the C lexer and handles special cases\n        like function calls and element access.\n        \"\"\"\n    \n        def parse(self, prev_parser_state: Optional[CParserState], input_str: str) -> CParserState:\n            \"\"\"\n            Parse the input string using the provided parser state.\n    \n            Args:\n                prev_parser_state: Optional previous parser state\n                input_str: The input string to parse\n    \n            Returns:\n                The updated parser state after parsing\n    \n            Note:\n                The parser converts identifier tokens to FUNCTION_OR_METHOD tokens\n                when they're followed by parentheses, and to ELEMENT tokens when\n                they're part of a dotted or arrow access chain.\n            \"\"\"\n            in_element = False\n            prev_lexer_state = None\n            if prev_parser_state:\n                in_element = prev_parser_state.in_element\n                prev_lexer_state = prev_parser_state.lexer_state\n    \n            lexer = CLexer()\n            lexer_state = lexer.lex(prev_lexer_state, input_str)\n    \n            while True:\n                token = lexer.get_next_token()\n                if not token:\n                    break\n    \n                if token.type != 'IDENTIFIER':\n                    self._tokens.append(token)\n                    continue\n    \n                # Look at the next token. If it's a '(' operator then we're making a\n                # function or method call!\n                cur_in_element = in_element\n                next_token = lexer.peek_next_token(['WHITESPACE'])\n                in_element = cur_in_element\n    \n                next_in_element = False\n                if next_token and next_token.type == 'OPERATOR':\n                    if next_token.value == '(':\n                        in_element = False\n                        self._tokens.append(Token(\n                            type='FUNCTION_OR_METHOD',\n                            value=token.value,\n                            start=token.start\n                        ))\n                        continue\n    \n                    # Is the next token going to be an element?\n                    if next_token.value in ('.', '->'):\n                        next_in_element = True\n    \n                in_element = next_in_element\n    \n                if cur_in_element:\n                    self._tokens.append(Token(\n                        type='ELEMENT',\n                        value=token.value,\n                        start=token.start\n                    ))\n                    continue\n    \n                self._tokens.append(token)\n    \n            parser_state = CParserState()\n            parser_state.continuation_state = 1 if lexer_state.in_block_comment else 0\n            parser_state.lexer_state = lexer_state\n            parser_state.in_element = in_element\n            return parser_state\n    ```\n    File: src/humbug/syntax/javascript_lexer.py\n    ```python\n    from dataclasses import dataclass\n    from typing import Callable, Optional\n    \n    from humbug.syntax.lexer import Lexer, LexerState, Token\n    \n    \n    @dataclass\n    class JavaScriptLexerState(LexerState):\n        \"\"\"\n        State information for the JavaScript lexer.\n    \n        Attributes:\n            in_block_comment: Indicates if we're currently parsing a block comment\n        \"\"\"\n        in_block_comment: bool = False\n    \n    \n    class JavaScriptLexer(Lexer):\n        \"\"\"\n        Lexer for JavaScript code.\n    \n        This lexer handles JavaScript-specific syntax including keywords, operators,\n        strings, regular expressions, comments, and numeric literals.\n        \"\"\"\n    \n        def __init__(self):\n            super().__init__()\n            self._in_block_comment = False\n    \n        def lex(self, prev_lexer_state: Optional[JavaScriptLexerState], input_str: str) -> JavaScriptLexerState:\n            \"\"\"\n            Lex all the tokens in the input.\n            \"\"\"\n            self._input = input_str\n            if prev_lexer_state:\n                self._in_block_comment = prev_lexer_state.in_block_comment\n    \n            if self._in_block_comment:\n                self._read_block_comment(0)\n    \n            if not self._in_block_comment:\n                self._inner_lex()\n    \n            lexer_state = JavaScriptLexerState(in_block_comment=False)\n            lexer_state.in_block_comment = self._in_block_comment\n            return lexer_state\n    \n        def _get_lexing_function(self, ch: str) -> Callable[[], None]:\n            \"\"\"\n            Get the lexing function that matches a given start character.\n    \n            Args:\n                ch: The start character\n    \n            Returns:\n                The appropriate lexing function for the character\n            \"\"\"\n            if ch == '\\n':\n                return self._read_newline\n    \n            if self._is_whitespace(ch):\n                return self._read_whitespace\n    \n            if self._is_letter(ch) or ch == '_' or ch == '$':\n                return self._read_identifier_or_keyword\n    \n            if self._is_digit(ch):\n                return self._read_number\n    \n            if ch in ('\"', \"'\", '`'):\n                return self._read_string\n    \n            if ch == '.':\n                return self._read_dot\n    \n            if ch == '/':\n                return self._read_forward_slash\n    \n            if ch == '#':\n                return self._read_hash\n    \n            return self._read_operator\n    \n        def _read_forward_slash(self) -> None:\n            \"\"\"\n            Read a forward slash token, which could be a comment, block comment,\n            or regular expression.\n            \"\"\"\n            if self._position + 1 < len(self._input):\n                if self._input[self._position + 1] == '/':\n                    self._read_comment()\n                    return\n    \n                if self._input[self._position + 1] == '*':\n                    self._read_block_comment(2)\n                    return\n    \n            self._read_regexp_or_divide()\n    \n        def _read_dot(self) -> None:\n            \"\"\"\n            Read a dot operator or decimal point in a number.\n            \"\"\"\n            if (self._position + 1 < len(self._input) and\n                    self._is_digit(self._input[self._position + 1])):\n                self._read_number()\n                return\n    \n            self._read_operator()\n    \n        def _read_hash(self) -> None:\n            \"\"\"\n            Read a hash token, which could be a hashbang or an error.\n            \"\"\"\n            if (self._position + 1 < len(self._input) and\n                    self._input[self._position + 1] == '!'):\n                self._read_hashbang()\n                return\n    \n            start = self._position\n            self._position += 1\n            self._tokens.append(Token(type='ERROR', value='#', start=start))\n    \n        def _read_hashbang(self) -> None:\n            \"\"\"\n            Read a hashbang token.\n            \"\"\"\n            start = self._position\n            self._position += 2\n            while (self._position < len(self._input) and\n                   self._input[self._position] != '\\n'):\n                self._position += 1\n    \n            self._tokens.append(Token(\n                type='PREPROCESSOR',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_number(self) -> None:\n            \"\"\"\n            Read a numeric literal.\n    \n            Handles decimal, hexadecimal, binary, octal, and BigInt literals.\n            \"\"\"\n            start = self._position\n    \n            if (self._input[self._position] == '0' and\n                    self._position + 1 < len(self._input)):\n                next_char = self._input[self._position + 1].lower()\n                if next_char == 'x':  # Hexadecimal\n                    self._position += 2\n                    while (self._position < len(self._input) and\n                           self._is_hex_digit(self._input[self._position])):\n                        self._position += 1\n                elif next_char == 'b':  # Binary\n                    self._position += 2\n                    while (self._position < len(self._input) and\n                           self._is_binary_digit(self._input[self._position])):\n                        self._position += 1\n                elif next_char == 'o':  # Octal\n                    self._position += 2\n                    while (self._position < len(self._input) and\n                           self._is_octal_digit(self._input[self._position])):\n                        self._position += 1\n                else:  # Decimal or floating-point\n                    self._read_decimal_number()\n            else:\n                self._read_decimal_number()\n    \n            # Check for BigInt 'n' suffix\n            if (self._position < len(self._input) and\n                    self._input[self._position] == 'n'):\n                self._position += 1\n    \n            self._tokens.append(Token(\n                type='NUMBER',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_decimal_number(self) -> None:\n            \"\"\"\n            Read a decimal or floating-point number.\n            \"\"\"\n            while (self._position < len(self._input) and\n                   self._is_digit(self._input[self._position])):\n                self._position += 1\n    \n            if (self._position < len(self._input) and\n                    self._input[self._position] == '.'):\n                self._position += 1\n                while (self._position < len(self._input) and\n                       self._is_digit(self._input[self._position])):\n                    self._position += 1\n    \n            if (self._position < len(self._input) and\n                    self._input[self._position].lower() == 'e'):\n                self._position += 1\n                if self._input[self._position] in ('+', '-'):\n                    self._position += 1\n    \n                while (self._position < len(self._input) and\n                       self._is_digit(self._input[self._position])):\n                    self._position += 1\n    \n        def _read_identifier_or_keyword(self) -> None:\n            \"\"\"\n            Read an identifier or keyword token.\n            \"\"\"\n            start = self._position\n            self._position += 1\n            while (self._position < len(self._input) and\n                   (self._is_letter_or_digit(self._input[self._position]) or\n                    self._input[self._position] in ('_', '$'))):\n                self._position += 1\n    \n            value = self._input[start:self._position]\n            if self._is_keyword(value):\n                self._tokens.append(Token(type='KEYWORD', value=value, start=start))\n                return\n    \n            self._tokens.append(Token(type='IDENTIFIER', value=value, start=start))\n    \n        def _read_comment(self) -> None:\n            \"\"\"\n            Read a single-line comment token.\n            \"\"\"\n            start = self._position\n            self._position += 2\n            while (self._position < len(self._input) and\n                   self._input[self._position] != '\\n'):\n                self._position += 1\n    \n            self._tokens.append(Token(\n                type='COMMENT',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n        def _read_block_comment(self, skip_chars: int) -> None:\n            \"\"\"\n            Read a block comment token.\n            \"\"\"\n            self._in_block_comment = True\n            start = self._position\n            self._position += skip_chars  # Skip /*\n            while (self._position + 1) < len(self._input):\n                if self._input[self._position] == '*' and self._input[self._position + 1] == '/':\n                    self._in_block_comment = False\n                    self._position += 2\n                    break\n    \n                self._position += 1\n    \n            # If we're still in a block comment we've got one character left on this line and\n            # we need to include it in the comment too.\n            if self._in_block_comment:\n                self._position = len(self._input)\n    \n            self._tokens.append(Token(\n                type='COMMENT',\n                value=self._input[start:self._position],\n                start=start\n            ))\n    \n    \n        def _read_regexp_or_divide(self) -> None:\n            \"\"\"\n            Read a regular expression literal or divide operator.\n            \"\"\"\n            self._position += 1\n    \n            # Look for a potential end of line. If we find one then this isn't a regexp literal\n            index = self._position\n            escaped = False\n            while index < len(self._input):\n                ch = self._input[index]\n                index += 1\n    \n                if ch == '\\n':\n                    start = self._position - 1\n                    self._tokens.append(Token(\n                        type='OPERATOR',\n                        value='/',\n                        start=start\n                    ))\n                    return\n    \n                if ch == '\\\\':\n                    escaped = not escaped\n                    continue\n    \n                if escaped:\n                    escaped = False\n                    continue\n    \n                if ch == '/':\n                    break\n    \n            # Check if the next characters seem to be valid regexp flags\n            while index < len(self._input) and self._input[index] in 'dgimsuy':\n                index += 1\n    \n            start = self._position - 1\n            regexp = self._input[start:index]\n            self._position = index\n            self._tokens.append(Token(type='REGEXP', value=regexp, start=start))\n    \n        def _read_operator(self) -> None:\n            \"\"\"\n            Read an operator or punctuation token.\n            \"\"\"\n            operators = [\n                '>>>=', '>>=', '<<=', '&&=', '||=', '??=', '**=',\n                '!==', '===', '>>>', '...', '!=', '==', '+=', '-=',\n                '*=', '/=', '%=', '&=', '|=', '^=', '<=', '>=', '&&',\n                '||', '??', '?.', '<<', '>>', '**', '++', '--', '+',\n                '-', '*', '/', '%', '&', '~', '!', '|', '^', '=', '<',\n                '>', '(', ')', '{', '}', '[', ']', ';', ':', '?', '.',\n                ','\n            ]\n    \n            for operator in operators:\n                if self._input[self._position:].startswith(operator):\n                    start = self._position\n                    self._position += len(operator)\n                    self._tokens.append(Token(\n                        type='OPERATOR',\n                        value=operator,\n                        start=start\n                    ))\n                    return\n    \n            start = self._position\n            ch = self._input[self._position]\n            self._position += 1\n            self._tokens.append(Token(type='ERROR', value=ch, start=start))\n    \n        def _is_keyword(self, value: str) -> bool:\n            \"\"\"\n            Check if a given value is a JavaScript keyword.\n    \n            Args:\n                value: The string to check\n    \n            Returns:\n                True if the value is a JavaScript keyword, False otherwise\n            \"\"\"\n            keywords = {\n                'abstract', 'async', 'await', 'boolean', 'break', 'byte',\n                'case', 'catch', 'char', 'class', 'const', 'continue',\n                'debugger', 'default', 'delete', 'do', 'double', 'else',\n                'enum', 'export', 'extends', 'false', 'final', 'finally',\n                'float', 'for', 'from', 'function', 'goto', 'if',\n                'implements', 'import', 'in', 'instanceof', 'int',\n                'interface', 'let', 'long', 'native', 'new', 'null',\n                'of', 'package', 'private', 'protected', 'public',\n                'return', 'short', 'static', 'super', 'switch',\n                'synchronized', 'this', 'throw', 'throws', 'transient',\n                'true', 'try', 'typeof', 'var', 'void', 'volatile',\n                'while', 'with', 'yield'\n            }\n            return value in keywords\n    ```\n    File: src/humbug/gui/style_manager.py\n    ```python\n    \"\"\"Style manager for handling application-wide style and zoom settings.\n    \n    Implements a singleton pattern to maintain consistent styling across components.\n    Provides signals for style changes and utilities for scaled size calculations.\n    \"\"\"\n    \n    from enum import Enum, auto\n    import os\n    from pathlib import Path\n    from typing import Dict, List, Optional\n    \n    from PySide6.QtCore import QObject, Signal, QOperatingSystemVersion, Qt\n    from PySide6.QtGui import (\n        QTextCharFormat, QFontDatabase, QGuiApplication, QColor, QFontMetricsF, QFont, QPixmap\n    )\n    \n    from humbug.gui.color_role import ColorRole\n    \n    \n    class ColorMode(Enum):\n        \"\"\"Enumeration for color theme modes.\"\"\"\n        LIGHT = auto()\n        DARK = auto()\n    \n    \n    class StyleManager(QObject):\n        \"\"\"\n        Singleton manager for application-wide style settings.\n    \n        Handles zoom factor management and style updates across the application.\n        Emits signals when zoom level changes to notify dependent components.\n    \n        Attributes:\n            style_changed (Signal): Emitted when style changes, passing new zoom factor\n            _instance (StyleManager): Singleton instance\n            _zoom_factor (float): Current zoom scaling factor\n            _initialized (bool): Tracks initialization state of QObject base\n        \"\"\"\n    \n        style_changed = Signal(float)\n        _instance = None\n    \n        def __new__(cls):\n            \"\"\"Create or return singleton instance.\"\"\"\n            if cls._instance is None:\n                cls._instance = super(StyleManager, cls).__new__(cls)\n            return cls._instance\n    \n        def __init__(self):\n            \"\"\"Initialize QObject base class if not already done.\"\"\"\n            if not hasattr(self, '_initialized'):\n                super().__init__()\n                self._zoom_factor = 1.0\n                self._base_font_size = self._determine_base_font_size()\n                self._workspace_font_size = None\n                self._initialized = True\n                self._color_mode = ColorMode.DARK  # Default to dark mode\n                self._colors: Dict[ColorRole, Dict[ColorMode, str]] = self._initialize_colors()\n                self._highlights: Dict[str, QTextCharFormat] = {}\n    \n                self._code_font_families = [\"Cascadia Mono\", \"Consolas\", \"Menlo\", \"Monaco\", \"monospace\"]\n                self._initialize_highlights()\n                self._create_theme_icons()\n    \n        def _initialize_colors(self) -> Dict[ColorRole, Dict[ColorMode, str]]:\n            \"\"\"Initialize the application colours for both light and dark modes.\"\"\"\n            return {\n                # Background colours\n                ColorRole.BACKGROUND_PRIMARY: {\n                    ColorMode.DARK: \"#080808\",\n                    ColorMode.LIGHT: \"#e0e0e0\"\n                },\n                ColorRole.BACKGROUND_SECONDARY: {\n                    ColorMode.DARK: \"#141414\",\n                    ColorMode.LIGHT: \"#f0f0f0\"\n                },\n                ColorRole.BACKGROUND_DIALOG: {\n                    ColorMode.DARK: \"#343434\",\n                    ColorMode.LIGHT: \"#d0d0d0\"\n                },\n    \n                # Text colours\n                ColorRole.TEXT_PRIMARY: {\n                    ColorMode.DARK: \"#ffffff\",\n                    ColorMode.LIGHT: \"#000000\"\n                },\n                ColorRole.TEXT_DISABLED: {\n                    ColorMode.DARK: \"#606060\",\n                    ColorMode.LIGHT: \"#a0a0a0\"\n                },\n                ColorRole.TEXT_SELECTED: {\n                    ColorMode.DARK: \"#808080\",\n                    ColorMode.LIGHT: \"#e0e0e0\"\n                },\n    \n                # Tab colours\n                ColorRole.TAB_BACKGROUND_ACTIVE: {\n                    ColorMode.DARK: \"#242424\",\n                    ColorMode.LIGHT: \"#ffffff\"\n                },\n                ColorRole.TAB_INACTIVE: {\n                    ColorMode.DARK: \"#909090\",\n                    ColorMode.LIGHT: \"#707070\"\n                },\n                ColorRole.TAB_BACKGROUND_INACTIVE: {\n                    ColorMode.DARK: \"#1c1c1c\",\n                    ColorMode.LIGHT: \"#f0f0f0\"\n                },\n                ColorRole.TAB_BACKGROUND_HOVER: {\n                    ColorMode.DARK: \"#242424\",\n                    ColorMode.LIGHT: \"#f8f8f8\"\n                },\n                ColorRole.TAB_BORDER_ACTIVE: {\n                    ColorMode.DARK: \"#8080ff\",\n                    ColorMode.LIGHT: \"#8080ff\"\n                },\n    \n                # Button colours\n                ColorRole.BUTTON_BACKGROUND: {\n                    ColorMode.DARK: \"#1c1c1c\",\n                    ColorMode.LIGHT: \"#ffffff\"\n                },\n                ColorRole.BUTTON_BACKGROUND_DISABLED: {\n                    ColorMode.DARK: \"#242424\",\n                    ColorMode.LIGHT: \"#d8d8d8\"\n                },\n                ColorRole.BUTTON_BACKGROUND_PRESSED: {\n                    ColorMode.DARK: \"#505050\",\n                    ColorMode.LIGHT: \"#b0b0b0\"\n                },\n                ColorRole.BUTTON_BACKGROUND_HOVER: {\n                    ColorMode.DARK: \"#404040\",\n                    ColorMode.LIGHT: \"#c0c0c0\"\n                },\n    \n                # Menu elements\n                ColorRole.MENU_BACKGROUND: {\n                    ColorMode.DARK: \"#2d2d2d\",\n                    ColorMode.LIGHT: \"#f0f0f0\"\n                },\n                ColorRole.MENU_HOVER: {\n                    ColorMode.DARK: \"#3d3d3d\",\n                    ColorMode.LIGHT: \"#e0e0e0\"\n                },\n    \n                # Splitter bars\n                ColorRole.SPLITTER: {\n                    ColorMode.DARK: \"#404040\",\n                    ColorMode.LIGHT: \"#c0c0c0\"\n                },\n    \n                # Scroll bar elements\n                ColorRole.SCROLLBAR_BACKGROUND: {\n                    ColorMode.DARK: \"#2d2d2d\",\n                    ColorMode.LIGHT: \"#f0f0f0\"\n                },\n                ColorRole.SCROLLBAR_HANDLE: {\n                    ColorMode.DARK: \"#404040\",\n                    ColorMode.LIGHT: \"#c0c0c0\"\n                },\n    \n                # Message colours\n                ColorRole.MESSAGE_BACKGROUND: {\n                    ColorMode.DARK: \"#323232\",\n                    ColorMode.LIGHT: \"#e4e4e4\"\n                },\n                ColorRole.MESSAGE_USER: {\n                    ColorMode.DARK: \"#80c080\",\n                    ColorMode.LIGHT: \"#40a040\"\n                },\n                ColorRole.MESSAGE_AI: {\n                    ColorMode.DARK: \"#8080c0\",\n                    ColorMode.LIGHT: \"#4040a0\"\n                },\n                ColorRole.MESSAGE_SYSTEM: {\n                    ColorMode.DARK: \"#c08080\",\n                    ColorMode.LIGHT: \"#a04040\"\n                },\n    \n                # Status bar elements\n                ColorRole.STATUS_BAR_BACKGROUND: {\n                    ColorMode.DARK: \"#121212\",\n                    ColorMode.LIGHT: \"#e8e8e8\"\n                },\n    \n                # Close button states\n                ColorRole.CLOSE_BUTTON_BACKGROUND_HOVER: {\n                    ColorMode.DARK: \"#ff4444\",\n                    ColorMode.LIGHT: \"#ff4444\"\n                },\n    \n                # Line numbers\n                ColorRole.LINE_NUMBER: {\n                    ColorMode.DARK: \"#606060\",\n                    ColorMode.LIGHT: \"#c0c0c0\"\n                },\n    \n                # Syntax highlighting\n                ColorRole.SYNTAX_BACKTICK_CODE: {\n                    ColorMode.DARK: \"#8080f0\",\n                    ColorMode.LIGHT: \"#3030c0\"\n                },\n                ColorRole.SYNTAX_CODE: {\n                    ColorMode.DARK: \"#f0f0f0\",\n                    ColorMode.LIGHT: \"#202020\"\n                },\n                ColorRole.SYNTAX_COMMENT: {\n                    ColorMode.DARK: \"#68d068\",\n                    ColorMode.LIGHT: \"#408040\"\n                },\n                ColorRole.SYNTAX_CSS_AT_RULE: {\n                    ColorMode.DARK: \"#ffc0eb\",\n                    ColorMode.LIGHT: \"#c000a0\"\n                },\n                ColorRole.SYNTAX_ELEMENT: {\n                    ColorMode.DARK: \"#90e0e8\",\n                    ColorMode.LIGHT: \"#0080a0\"\n                },\n                ColorRole.SYNTAX_ERROR: {\n                    ColorMode.DARK: \"#ff0000\",\n                    ColorMode.LIGHT: \"#ff0000\"\n                },\n                ColorRole.SYNTAX_FUNCTION_OR_METHOD: {\n                    ColorMode.DARK: \"#e0e080\",\n                    ColorMode.LIGHT: \"#806000\"\n                },\n                ColorRole.SYNTAX_HEADING: {\n                    ColorMode.DARK: \"#9090f0\",\n                    ColorMode.LIGHT: \"#4040c0\"\n                },\n                ColorRole.SYNTAX_HTML_ATTRIBUTE: {\n                    ColorMode.DARK: \"#90e0e8\",\n                    ColorMode.LIGHT: \"#0080a0\"\n                },\n                ColorRole.SYNTAX_HTML_DOCTYPE: {\n                    ColorMode.DARK: \"#808080\",\n                    ColorMode.LIGHT: \"#606060\"\n                },\n                ColorRole.SYNTAX_HTML_TAG: {\n                    ColorMode.DARK: \"#ffc0eb\",\n                    ColorMode.LIGHT: \"#c000a0\"\n                },\n                ColorRole.SYNTAX_IDENTIFIER: {\n                    ColorMode.DARK: \"#80b0f0\",\n                    ColorMode.LIGHT: \"#0060c0\"\n                },\n                ColorRole.SYNTAX_KEYWORD: {\n                    ColorMode.DARK: \"#ffc0eb\",\n                    ColorMode.LIGHT: \"#c000a0\"\n                },\n                ColorRole.SYNTAX_LANGUAGE: {\n                    ColorMode.DARK: \"#f0e060\",\n                    ColorMode.LIGHT: \"#a09040\"\n                },\n                ColorRole.SYNTAX_NUMBER: {\n                    ColorMode.DARK: \"#c08040\",\n                    ColorMode.LIGHT: \"#804000\"\n                },\n                ColorRole.SYNTAX_OPERATOR: {\n                    ColorMode.DARK: \"#c0c0c0\",\n                    ColorMode.LIGHT: \"#404040\"\n                },\n                ColorRole.SYNTAX_PREPROCESSOR: {\n                    ColorMode.DARK: \"#808080\",\n                    ColorMode.LIGHT: \"#606060\"\n                },\n                ColorRole.SYNTAX_REGEXP: {\n                    ColorMode.DARK: \"#c87050\",\n                    ColorMode.LIGHT: \"#a04020\"\n                },\n                ColorRole.SYNTAX_STRING: {\n                    ColorMode.DARK: \"#f06060\",\n                    ColorMode.LIGHT: \"#c04040\"\n                },\n                ColorRole.SYNTAX_TEXT: {\n                    ColorMode.DARK: \"#c8c8c8\",\n                    ColorMode.LIGHT: \"#484848\"\n                }\n            }\n    \n        def _initialize_highlights(self):\n            # Mapping from token type to colour\n            colour_mapping = {\n                \"BACKTICK_CODE\": ColorRole.SYNTAX_BACKTICK_CODE,\n                \"CODE\": ColorRole. SYNTAX_CODE,\n                \"COMMENT\": ColorRole.SYNTAX_COMMENT,\n                \"CSS_AT_RULE\": ColorRole.SYNTAX_CSS_AT_RULE,\n                \"ELEMENT\": ColorRole.SYNTAX_ELEMENT,\n                \"ERROR\": ColorRole.SYNTAX_ERROR,\n                \"FUNCTION_OR_METHOD\": ColorRole.SYNTAX_FUNCTION_OR_METHOD,\n                \"HEADING\": ColorRole.SYNTAX_HEADING,\n                \"HTML_ATTRIBUTE\": ColorRole.SYNTAX_HTML_ATTRIBUTE,\n                \"HTML_DOCTYPE\": ColorRole.SYNTAX_HTML_DOCTYPE,\n                \"HTML_TAG\": ColorRole.SYNTAX_HTML_TAG,\n                \"IDENTIFIER\": ColorRole.SYNTAX_IDENTIFIER,\n                \"KEYWORD\": ColorRole.SYNTAX_KEYWORD,\n                \"LANGUAGE\": ColorRole.SYNTAX_LANGUAGE,\n                \"NUMBER\": ColorRole.SYNTAX_NUMBER,\n                \"OPERATOR\": ColorRole.SYNTAX_OPERATOR,\n                \"PREPROCESSOR\": ColorRole.SYNTAX_PREPROCESSOR,\n                \"REGEXP\": ColorRole.SYNTAX_REGEXP,\n                \"STRING\": ColorRole.SYNTAX_STRING,\n                \"TEXT\": ColorRole.SYNTAX_TEXT,\n                \"WHITESPACE\": ColorRole.SYNTAX_TEXT\n            }\n    \n            for token_type, role in colour_mapping.items():\n                text_format = self._create_highlight(role)\n                self._highlights[token_type] = text_format\n    \n            self._error_highlight = self._create_highlight(ColorRole.SYNTAX_ERROR)\n    \n        def _create_highlight(self, role: ColorRole) -> QTextCharFormat:\n            text_highlight = QTextCharFormat()\n            text_highlight.setFontFamilies(self._code_font_families)\n            text_highlight.setFontFixedPitch(True)\n            text_highlight.setForeground(QColor(self._colors[role][self._color_mode]))\n    \n            return text_highlight\n    \n        def _create_app_icon_svg(self, bg_color: str, text_color: str) -> str:\n            \"\"\"\n            Create an application icon SVG with specified colors.\n    \n            Args:\n                bg_color: Background color in hex format\n                text_color: Text color in hex format\n    \n            Returns:\n                str: SVG markup for the application icon\n            \"\"\"\n            return f'''\n                <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"128\" height=\"128\" viewBox=\"0 0 384 384\">\n                    <rect x=\"0\" y=\"0\" width=\"384\" height=\"384\" fill=\"{bg_color}\"/>\n                    <g fill=\"{text_color}\">\n                        <g transform=\"translate(38.400004, 250.960113)\">\n                            <path d=\"M 97.234375 0\n                                L 92.125 -64.078125\n                                L 91.46875 -64.078125\n                                L 69.328125-0.65625\n                                L 54.640625 -0.65625\n                                L 32.5 -64.078125\n                                L 31.84375 -64.078125\n                                L 26.734375 0\n                                L 2.09375 0\n                                L 11.796875 -108.109375\n                                L 38 -108.109375\n                                L 61.984375 -45.734375\n                                L 85.96875 -108.109375\n                                L 112.171875 -108.109375\n                                L 121.875 0\n                                Z\"/>\n                        </g>\n                        <g transform=\"translate(162.225522, 250.960113)\">\n                            <path d=\"M 76 -108.109375\n                                L 44.15625 -71.03125\n                                C 46 -72.070312 48.578125 -72.59375 51.890625 -72.59375\n                                C 55.734375 -72.59375 59.617188 -71.785156 63.546875 -70.171875\n                                C 67.484375 -68.554688 71.175781 -66.238281 74.625 -63.21875\n                                C 78.082031 -60.207031 80.898438 -56.210938 83.078125 -51.234375\n                                C 85.265625 -46.253906 86.359375 -40.753906 86.359375 -34.734375\n                                C 86.359375 -28.609375 85.203125 -23.125 82.890625 -18.28125\n                                C 80.578125 -13.4375 77.472656 -9.59375 73.578125 -6.75\n                                C 69.691406 -3.90625 65.429688 -1.738281 60.796875 -0.25\n                                C 56.171875 1.226562 51.328125 1.96875 46.265625 1.96875\n                                C 34.117188 1.96875 23.894531 -1.566406 15.59375 -8.640625\n                                C 7.289062 -15.722656 3.140625 -24.421875 3.140625 -34.734375\n                                C 3.140625 -43.460938 4.363281 -50.644531 6.8125 -56.28125\n                                C 9.257812 -61.914062 13.71875 -69.101562 20.1875 -77.84375\n                                L 45.609375 -108.109375\n                                Z \n                                M 28.703125 -34.734375\n                                C 28.703125 -30.015625 30.226562 -26.101562 33.28125 -23\n                                C 36.34375 -19.894531 40.273438 -18.34375 45.078125 -18.34375\n                                C 49.878906 -18.34375 53.851562 -19.894531 57 -23\n                                C 60.144531 -26.101562 61.71875 -30.015625 61.71875 -34.734375\n                                C 61.71875 -39.535156 60.125 -43.53125 56.9375 -46.71875\n                                C 53.75 -49.90625 49.796875 -51.5 45.078125 -51.5 \n                                C 40.535156 -51.5 36.671875 -49.90625 33.484375 -46.71875\n                                C 30.296875 -43.53125 28.703125 -39.535156 28.703125 -34.734375\n                                Z\"/>\n                        </g>\n                        <g transform=\"translate(249.066902, 250.960113)\">\n                            <path d=\"M 7.859375 -108.109375\n                                L 46.515625 -108.109375\n                                C 56.910156 -108.109375 65.382812 -105.332031 71.9375 -99.78125\n                                C 78.488281 -94.238281 81.765625 -86.3125 81.765625 -76\n                                C 81.765625 -68.050781 79.773438 -61.390625 75.796875 -56.015625\n                                C 71.828125 -50.648438 66.4375 -46.875 59.625 -44.6875\n                                L 96.84375 0\n                                L 65.515625 0\n                                L 32.5 -42.71875\n                                L 32.5 0\n                                L 7.859375 0\n                                Z\n                                M 32.5 -60.15625\n                                L 35.375 -60.15625\n                                C 37.65625 -60.15625 39.578125 -60.195312 41.140625 -60.28125\n                                C 42.710938 -60.363281 44.503906 -60.664062 46.515625 -61.1875\n                                C 48.523438 -61.71875 50.140625 -62.460938 51.359375 -63.421875\n                                C 52.585938 -64.390625 53.640625 -65.789062 54.515625 -67.625\n                                C 55.390625 -69.457031 55.828125 -71.679688 55.828125 -74.296875\n                                C 55.828125 -76.921875 55.390625 -79.148438 54.515625 -80.984375\n                                C 53.640625 -82.816406 52.585938 -84.210938 51.359375 -85.171875\n                                C 50.140625 -86.140625 48.523438 -86.882812 46.515625 -87.40625\n                                C 44.503906 -87.925781 42.710938 -88.226562 41.140625 -88.3125\n                                C 39.578125 -88.40625 37.65625 -88.453125 35.375 -88.453125\n                                L 32.5 -88.453125\n                                Z\"/>\n                        </g>\n                    </g>\n                </svg>\n            '''\n    \n        def _create_theme_icons(self):\n            \"\"\"Create theme-specific icons in the user's .humbug directory.\"\"\"\n            icon_dir = os.path.expanduser(\"~/.humbug/icons\")\n            os.makedirs(icon_dir, exist_ok=True)\n    \n            def write_icon(name: str, svg_data: str):\n                with open(os.path.join(icon_dir, name), 'w', encoding='utf-8') as f:\n                    f.write(svg_data)\n    \n            # Create collapsed and expanded arrows for both themes\n            for mode in ColorMode:\n                color = self._colors[ColorRole.TEXT_PRIMARY][mode]\n                suffix = mode.name.lower()\n    \n                # Right-pointing arrow\n                write_icon(f'arrow-right-{suffix}.svg', f'''\n                    <svg width=\"6\" height=\"6\" viewBox=\"0 0 6 6\" xmlns=\"http://www.w3.org/2000/svg\">\n                        <path stroke=\"{color}\" stroke-width=\"0.75\" fill=\"none\" d=\"M2,1 L4,3 L2,5\"/>\n                    </svg>\n                ''')\n    \n                # Left-pointing arrow\n                write_icon(f'arrow-left-{suffix}.svg', f'''\n                    <svg width=\"6\" height=\"6\" viewBox=\"0 0 6 6\" xmlns=\"http://www.w3.org/2000/svg\">\n                        <path stroke=\"{color}\" stroke-width=\"0.75\" fill=\"none\" d=\"M4,1 L2,3 L4,5\"/>\n                    </svg>\n                ''')\n    \n                # Up-pointing arrow\n                write_icon(f'arrow-up-{suffix}.svg', f'''\n                    <svg width=\"6\" height=\"6\" viewBox=\"0 0 6 6\" xmlns=\"http://www.w3.org/2000/svg\">\n                        <path stroke=\"{color}\" stroke-width=\"0.75\" fill=\"none\" d=\"M1,4 L3,2 L5,4\"/>\n                    </svg>\n                ''')\n    \n                # Down-pointing arrow\n                write_icon(f'arrow-down-{suffix}.svg', f'''\n                    <svg width=\"6\" height=\"6\" viewBox=\"0 0 6 6\" xmlns=\"http://www.w3.org/2000/svg\">\n                        <path stroke=\"{color}\" stroke-width=\"0.75\" fill=\"none\" d=\"M1,2 L3,4 L5,2\"/>\n                    </svg>\n                ''')\n    \n                # Close button - visible version\n                write_icon(f'close-{suffix}.svg', f'''\n                    <svg width=\"64\" height=\"64\" viewBox=\"0 0 64 64\" xmlns=\"http://www.w3.org/2000/svg\">\n                        <path stroke=\"{color}\" stroke-width=\"4\" fill=\"none\"\n                            d=\"M16,16 L48,48 M48,16 L16,48\"/>\n                    </svg>\n                ''')\n    \n                # Checkbox check mark\n                write_icon(f'check-{suffix}.svg', f'''\n                    <svg width=\"12\" height=\"12\" viewBox=\"0 0 12 12\" xmlns=\"http://www.w3.org/2000/svg\">\n                        <path stroke=\"{color}\" stroke-width=\"1.5\" fill=\"none\"\n                            d=\"M2,6 L5,9 L10,3\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n                    </svg>\n                ''')\n    \n                # Message box icons\n                write_icon(f'info-{suffix}.svg', f'''\n                    <svg width=\"64\" height=\"64\" viewBox=\"0 0 64 64\" xmlns=\"http://www.w3.org/2000/svg\">\n                        <circle cx=\"32\" cy=\"32\" r=\"28\" stroke=\"{color}\" stroke-width=\"4\" fill=\"none\"/>\n                        <text x=\"32\" y=\"40\" text-anchor=\"middle\"\n                            font-size=\"36\" fill=\"{color}\" font-family=\"sans-serif\">i</text>\n                    </svg>\n                ''')\n    \n                write_icon(f'warning-{suffix}.svg', f'''\n                    <svg width=\"64\" height=\"64\" viewBox=\"0 0 64 64\" xmlns=\"http://www.w3.org/2000/svg\">\n                        <path d=\"M32 4 L60 56 L4 56 Z\" stroke=\"{color}\" stroke-width=\"4\" fill=\"none\"/>\n                        <text x=\"32\" y=\"48\" text-anchor=\"middle\"\n                            font-size=\"36\" fill=\"{color}\" font-family=\"sans-serif\">!</text>\n                    </svg>\n                ''')\n    \n                write_icon(f'critical-{suffix}.svg', f'''\n                    <svg width=\"64\" height=\"64\" viewBox=\"0 0 64 64\" xmlns=\"http://www.w3.org/2000/svg\">\n                        <circle cx=\"32\" cy=\"32\" r=\"28\" stroke=\"{color}\" stroke-width=\"4\" fill=\"none\"/>\n                        <path stroke=\"{color}\" stroke-width=\"4\" fill=\"none\"\n                            d=\"M20,20 L44,44 M44,20 L20,44\"/>\n                    </svg>\n                ''')\n    \n                write_icon(f'question-{suffix}.svg', f'''\n                    <svg width=\"64\" height=\"64\" viewBox=\"0 0 64 64\" xmlns=\"http://www.w3.org/2000/svg\">\n                        <circle cx=\"32\" cy=\"32\" r=\"28\" stroke=\"{color}\" stroke-width=\"4\" fill=\"none\"/>\n                        <text x=\"32\" y=\"44\" text-anchor=\"middle\"\n                            font-size=\"36\" fill=\"{color}\" font-family=\"sans-serif\">?</text>\n                    </svg>\n                ''')\n    \n            # Create the standard application icon for about dialog\n            write_icon('app-icon.svg', self._create_app_icon_svg('#4040c0', '#ffffff'))\n    \n            # Create light mode disabled version\n            write_icon('app-icon-disabled-light.svg', self._create_app_icon_svg('#c0c0c0', '#e0e0e0'))\n    \n            # Create dark mode disabled version\n            write_icon('app-icon-disabled-dark.svg', self._create_app_icon_svg('#202020', '#404040'))\n    \n        def get_icon_path(self, name: str) -> str:\n            \"\"\"\n            Get the path to a theme-appropriate icon.\n    \n            Args:\n                name: Base name of the icon (without theme suffix or extension)\n    \n            Returns:\n                Full path to the icon file\n            \"\"\"\n            icon_dir = os.path.expanduser(\"~/.humbug/icons\")\n            theme = \"dark\" if self._color_mode == ColorMode.DARK else \"light\"\n            return Path(os.path.join(icon_dir, f\"{name}-{theme}.svg\")).as_posix()\n    \n        def scale_icon(self, icon_path: str, target_size: int) -> QPixmap:\n            \"\"\"\n            Load and scale an icon to the appropriate size.\n    \n            Args:\n                icon_path: Path to the icon file\n                target_size: Desired size in pixels\n    \n            Returns:\n                Scaled QPixmap of the icon\n            \"\"\"\n            pixmap = QPixmap(icon_path)\n            scaled_size = self.get_scaled_size(target_size)\n            return pixmap.scaled(\n                scaled_size, scaled_size, Qt.KeepAspectRatio, Qt.SmoothTransformation\n            )\n    \n        def get_color(self, role: ColorRole) -> QColor:\n            \"\"\"\n            Get a color for a specific role.\n    \n            Args:\n                role: The ColorRole to look up\n    \n            Returns:\n                QColor: The color for the specified role\n    \n            Raises:\n                KeyError: If no color is defined for the role\n            \"\"\"\n            return QColor(self._colors[role][self._color_mode])\n    \n        def get_color_str(self, role: ColorRole) -> str:\n            \"\"\"\n            Get a color string for a specific role.\n    \n            Args:\n                role: The ColorRole to look up\n    \n            Returns:\n                str: The color string (hex format) for the specified role\n    \n            Raises:\n                KeyError: If no color is defined for the role\n            \"\"\"\n            return self._colors[role][self._color_mode]\n    \n        def get_highlight(self, token_type: str) -> QTextCharFormat:\n            if token_type not in self._highlights:\n                print(f\"token type {token_type} not mapped\")\n    \n            return self._highlights.get(token_type, self._error_highlight)\n    \n        def _determine_base_font_size(self) -> float:\n            \"\"\"\n            Determine the default system font size based on the operating system.\n    \n            Returns:\n                int: Base font size in points.\n            \"\"\"\n            # Get current OS\n            os_type = QOperatingSystemVersion.current()\n    \n            # Get system default font\n            system_font = QFontDatabase.systemFont(QFontDatabase.GeneralFont)\n            system_size = system_font.pointSize()\n    \n            # Apply OS-specific adjustments if system detection fails\n            if system_size > 0:\n                return system_size\n    \n            if os_type.type() == QOperatingSystemVersion.MacOS:\n                # macOS typically uses 13pt as default\n                return 13\n    \n            if os_type.type() == QOperatingSystemVersion.Windows:\n                # Windows typically uses 9pt as default\n                return 9\n    \n            # Linux typically uses 10pt as default\n            return 10\n    \n        @property\n        def base_font_size(self) -> float:\n            \"\"\"Get the base font size for the current system.\"\"\"\n            return self._workspace_font_size or self._base_font_size\n    \n        def set_workspace_font_size(self, size: Optional[float]) -> None:\n            \"\"\"Set workspace-specific font size override.\"\"\"\n            if size != self._workspace_font_size:\n                self._workspace_font_size = size\n                self.style_changed.emit(self._zoom_factor)\n    \n        @property\n        def color_mode(self) -> ColorMode:\n            \"\"\"Get the current color mode.\"\"\"\n            return self._color_mode\n    \n        def set_color_mode(self, mode: ColorMode):\n            \"\"\"\n            Set the color mode and update application styles.\n    \n            Args:\n                mode: The ColorMode to switch to\n            \"\"\"\n            if mode != self._color_mode:\n                self._color_mode = mode\n                self._initialize_highlights()  # Reinitialize highlights with new colors\n                self.style_changed.emit(self._zoom_factor)  # Trigger style update\n    \n        @property\n        def zoom_factor(self) -> float:\n            \"\"\"Current zoom scaling factor.\"\"\"\n            return self._zoom_factor\n    \n        def set_zoom(self, factor: float):\n            \"\"\"\n            Set new zoom factor and update application styles.\n    \n            Args:\n                factor: New zoom factor to apply (clamped between 0.5 and 2.0)\n            \"\"\"\n            new_factor = max(0.5, min(2.0, factor))\n            if new_factor != self._zoom_factor:\n                self._zoom_factor = new_factor\n                self.style_changed.emit(self._zoom_factor)\n    \n        def get_scaled_size(self, base_size: float) -> float:\n            \"\"\"\n            Calculate scaled size based on current zoom factor.\n    \n            Args:\n                base_size: Original size to scale\n    \n            Returns:\n                Scaled size adjusted for current zoom factor\n            \"\"\"\n            return base_size * self._zoom_factor\n    \n        def get_space_width(self) -> float:\n            font = QFont(self.monospace_font_families)\n            font.setPointSizeF(self.base_font_size * self._zoom_factor)\n            font_metrics = QFontMetricsF(font)\n            space_width = font_metrics.horizontalAdvance('        ') / 8\n            return space_width\n    \n        def points_to_pixels(self, points: float) -> float:\n            \"\"\"\n            Convert point size to pixels based on device pixel ratio.\n    \n            Args:\n                points: Font size in points\n    \n            Returns:\n                Font size in pixels\n            \"\"\"\n            # Get the primary screen's logical DPI\n            screen = QGuiApplication.primaryScreen()\n            if not screen:\n                return points * 1.333333  # Fallback to standard 96 DPI (72 * 4/3)\n    \n            # Convert points to pixels using the screen's logical DPI\n            logical_dpi = screen.logicalDotsPerInchY()\n            return (points * logical_dpi) / 72.0\n    \n        def pixels_to_points(self, pixels: float) -> float:\n            \"\"\"\n            Convert pixel size to points based on device pixel ratio.\n    \n            Args:\n                pixels: Size in pixels\n    \n            Returns:\n                Size in points\n            \"\"\"\n            screen = QGuiApplication.primaryScreen()\n            if not screen:\n                return pixels * 0.75  # Fallback to standard 96 DPI (72/96)\n    \n            logical_dpi = screen.logicalDotsPerInch()\n            return (pixels * 72.0) / logical_dpi\n    \n        @property\n        def monospace_font_families(self) -> List[str]:\n            \"\"\"Get the standard monospace font family fallback sequence.\"\"\"\n            return self._code_font_families\n    ```\n    File: src/humbug/gui/tab_state.py\n    ```python\n    from dataclasses import dataclass, asdict\n    from datetime import datetime\n    from typing import Any, Dict, Optional\n    \n    from humbug.gui.tab_type import TabType\n    \n    \n    @dataclass\n    class TabState:\n        \"\"\"Container for serializable tab state.\"\"\"\n        type: TabType\n        tab_id: str\n        path: str\n        cursor_position: Optional[Dict[str, int]] = None\n        timestamp: Optional[datetime] = None\n        metadata: Optional[Dict[str, Any]] = None\n    \n        def to_dict(self) -> Dict[str, Any]:\n            \"\"\"Convert the TabState to a JSON-serializable dictionary.\n    \n            Returns:\n                Dictionary with all state fields properly serialized\n            \"\"\"\n            state_dict = asdict(self)\n    \n            # Convert TabType enum to string\n            if state_dict['type']:\n                state_dict['type'] = state_dict['type'].name\n    \n            # Convert datetime to ISO format string\n            if state_dict['timestamp']:\n                state_dict['timestamp'] = state_dict['timestamp'].isoformat()\n    \n            return state_dict\n    \n        @classmethod\n        def from_dict(cls, data: Dict[str, Any]) -> 'TabState':\n            \"\"\"Create a TabState instance from a dictionary.\n    \n            Args:\n                data: Dictionary containing the serialized state\n    \n            Returns:\n                New TabState instance\n            \"\"\"\n            # Convert string back to TabType enum\n            if 'type' in data and isinstance(data['type'], str):\n                data['type'] = TabType[data['type']]\n    \n            # Convert timestamp string back to datetime if present\n            if data.get('timestamp'):\n                data['timestamp'] = datetime.fromisoformat(data['timestamp'])\n    \n            return cls(**data)\n    ```\n    File: src/humbug/gui/workspace_settings_dialog.py\n    ```python\n    \"\"\"\n    Dialog for configuring workspace-specific settings.\n    \n    This dialog allows users to configure workspace settings such as tab behavior and size.\n    Settings are persisted to the workspace's settings.json file.\n    \"\"\"\n    \n    from typing import Optional\n    \n    from PySide6.QtWidgets import (\n        QDialog, QVBoxLayout, QHBoxLayout, QLabel,\n        QPushButton, QSpinBox, QCheckBox, QDoubleSpinBox\n    )\n    from PySide6.QtCore import Signal\n    \n    from humbug.gui.color_role import ColorRole\n    from humbug.gui.style_manager import StyleManager\n    from humbug.workspace.workspace_settings import WorkspaceSettings\n    \n    \n    class WorkspaceSettingsDialog(QDialog):\n        \"\"\"Dialog for editing workspace settings.\"\"\"\n    \n        settings_changed = Signal(WorkspaceSettings)\n    \n        def __init__(self, parent=None):\n            \"\"\"Initialize the workspace settings dialog.\n    \n            Args:\n                parent: Parent widget, typically the main window.\n            \"\"\"\n            super().__init__(parent)\n            self.setWindowTitle(\"Workspace Settings\")\n            self.setMinimumWidth(500)\n            self.setModal(True)\n    \n            self._initial_settings: Optional[WorkspaceSettings] = None\n            self._current_settings: Optional[WorkspaceSettings] = None\n    \n            self._style_manager = StyleManager()\n    \n            # Main layout with proper spacing\n            layout = QVBoxLayout()\n            layout.setSpacing(12)\n            layout.setContentsMargins(20, 20, 20, 20)\n    \n            # Soft tabs setting\n            soft_tabs_layout = QHBoxLayout()\n            soft_tabs_label = QLabel(\"Use Soft Tabs:\")\n            soft_tabs_label.setMinimumHeight(40)\n            self._soft_tabs_check = QCheckBox()\n            self._soft_tabs_check.setMinimumHeight(40)\n            self._soft_tabs_check.setMinimumWidth(300)\n            self._soft_tabs_check.stateChanged.connect(self._handle_value_change)\n            soft_tabs_layout.addWidget(soft_tabs_label)\n            soft_tabs_layout.addStretch()\n            soft_tabs_layout.addWidget(self._soft_tabs_check)\n            layout.addLayout(soft_tabs_layout)\n    \n            # Tab size setting\n            tab_size_layout = QHBoxLayout()\n            tab_size_label = QLabel(\"Tab Size:\")\n            tab_size_label.setMinimumHeight(40)\n            self._tab_size_spin = QSpinBox()\n            self._tab_size_spin.setRange(1, 8)\n            self._tab_size_spin.setMinimumWidth(300)\n            self._tab_size_spin.setMinimumHeight(40)\n            self._tab_size_spin.valueChanged.connect(self._handle_value_change)\n            tab_size_layout.addWidget(tab_size_label)\n            tab_size_layout.addStretch()\n            tab_size_layout.addWidget(self._tab_size_spin)\n            layout.addLayout(tab_size_layout)\n    \n            font_size_layout = QHBoxLayout()\n            font_size_label = QLabel(\"Font Size:\")\n            font_size_label.setMinimumHeight(40)\n            self._font_size_spin = QDoubleSpinBox()\n            self._font_size_spin.setRange(8.0, 24.0)\n            self._font_size_spin.setSingleStep(0.5)\n            self._font_size_spin.setDecimals(1)\n            self._font_size_spin.setMinimumWidth(300)\n            self._font_size_spin.setMinimumHeight(40)\n            self._font_size_spin.setContentsMargins(8, 8, 8, 8)\n            self._font_size_spin.valueChanged.connect(self._handle_value_change)\n            font_size_layout.addWidget(font_size_label)\n            font_size_layout.addStretch()\n            font_size_layout.addWidget(self._font_size_spin)\n            layout.addLayout(font_size_layout)\n    \n            # Add auto-backup settings\n            auto_backup_layout = QHBoxLayout()\n            auto_backup_label = QLabel(\"Auto Backup:\")\n            auto_backup_label.setMinimumHeight(40)\n            self._auto_backup_check = QCheckBox()\n            self._auto_backup_check.setMinimumHeight(40)\n            self._auto_backup_check.setMinimumWidth(300)\n            self._auto_backup_check.stateChanged.connect(self._handle_value_change)\n            auto_backup_layout.addWidget(auto_backup_label)\n            auto_backup_layout.addStretch()\n            auto_backup_layout.addWidget(self._auto_backup_check)\n            layout.addLayout(auto_backup_layout)\n    \n            # Add auto-backup interval setting\n            backup_interval_layout = QHBoxLayout()\n            backup_interval_label = QLabel(\"Backup Interval (seconds):\")\n            backup_interval_label.setMinimumHeight(40)\n            self._backup_interval_spin = QSpinBox()\n            self._backup_interval_spin.setRange(60, 3600)  # 1 minute to 1 hour\n            self._backup_interval_spin.setMinimumWidth(300)\n            self._backup_interval_spin.setMinimumHeight(40)\n            self._backup_interval_spin.valueChanged.connect(self._handle_value_change)\n            backup_interval_layout.addWidget(backup_interval_label)\n            backup_interval_layout.addStretch()\n            backup_interval_layout.addWidget(self._backup_interval_spin)\n            layout.addLayout(backup_interval_layout)\n    \n            # Add spacing before buttons\n            layout.addSpacing(24)\n            layout.addStretch()\n    \n            # Button row\n            button_layout = QHBoxLayout()\n            button_layout.setSpacing(8)\n    \n            self.ok_button = QPushButton(\"OK\")\n            self.cancel_button = QPushButton(\"Cancel\")\n            self.apply_button = QPushButton(\"Apply\")\n    \n            self.ok_button.clicked.connect(self._handle_ok)\n            self.cancel_button.clicked.connect(self.reject)\n            self.apply_button.clicked.connect(self._handle_apply)\n    \n            # Set minimum button sizes\n            min_button_width = 90\n            min_button_height = 40\n            for button in [self.ok_button, self.cancel_button, self.apply_button]:\n                button.setMinimumWidth(min_button_width)\n                button.setMinimumHeight(min_button_height)\n                button.setContentsMargins(8, 8, 8, 8)\n                button_layout.addWidget(button)\n    \n            layout.addLayout(button_layout)\n            self.setLayout(layout)\n    \n            # Apply consistent dialog styling\n            self.setStyleSheet(f\"\"\"\n                QDialog {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.BACKGROUND_DIALOG)};\n                }}\n                QLabel {{\n                    color: {self._style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    background-color: {self._style_manager.get_color_str(ColorRole.BACKGROUND_DIALOG)};\n                }}\n                QCheckBox {{\n                    color: {self._style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    background-color: {self._style_manager.get_color_str(ColorRole.BACKGROUND_DIALOG)};\n                    spacing: 8px;\n                }}\n                QCheckBox::indicator {{\n                    width: 18px;\n                    height: 18px;\n                    border: none;\n                    border-radius: 4px;\n                    background-color: {self._style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND)};\n                }}\n                QCheckBox::indicator:checked {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND)};\n                    image: url({self._style_manager.get_icon_path('check')});\n                }}\n                QCheckBox::indicator:unchecked {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND)};\n                }}\n                QSpinBox {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND)};\n                    color: {self._style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    border: none;\n                    border-radius: 4px;\n                    padding: 8px;\n                }}\n                QDoubleSpinBox {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND)};\n                    color: {self._style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    border: none;\n                    border-radius: 4px;\n                    padding: 8px;\n                }}\n                QDoubleSpinBox:disabled {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND_DISABLED)};\n                    color: {self._style_manager.get_color_str(ColorRole.TEXT_DISABLED)};\n                }}\n                QDoubleSpinBox::up-button, QDoubleSpinBox::down-button {{\n                    border: none;\n                    width: 20px;\n                }}\n                QDoubleSpinBox::up-arrow {{\n                    image: url({self._style_manager.get_icon_path('arrow-up')});\n                    width: 12px;\n                    height: 12px;\n                }}\n                QDoubleSpinBox::up-arrow:disabled, QDoubleSpinBox::up-arrow:off {{\n                    image: none;\n                }}\n                QDoubleSpinBox::down-arrow {{\n                    image: url({self._style_manager.get_icon_path('arrow-down')});\n                    width: 12px;\n                    height: 12px;\n                }}\n                QDoubleSpinBox::down-arrow:disabled, QDoubleSpinBox::down-arrow:off {{\n                    image: none;\n                }}\n                QSpinBox::up-button, QSpinBox::down-button {{\n                    border: none;\n                    width: 20px;\n                }}\n                QSpinBox::up-arrow {{\n                    image: url({self._style_manager.get_icon_path('arrow-up')});\n                    width: 12px;\n                    height: 12px;\n                }}\n                QSpinBox::up-arrow:disabled, QSpinBox::up-arrow:off {{\n                    image: none;\n                }}\n                QSpinBox::down-arrow {{\n                    image: url({self._style_manager.get_icon_path('arrow-down')});\n                    width: 12px;\n                    height: 12px;\n                }}\n                QSpinBox::down-arrow:disabled, QSpinBox::down-arrow:off {{\n                    image: none;\n                }}\n                QPushButton {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND)};\n                    color: {self._style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    border: none;\n                    border-radius: 4px;\n                    padding: 8px;\n                }}\n                QPushButton:hover {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND_HOVER)};\n                }}\n                QPushButton:pressed {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND_PRESSED)};\n                }}\n                QPushButton:disabled {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND_DISABLED)};\n                    color: {self._style_manager.get_color_str(ColorRole.TEXT_DISABLED)};\n                }}\n            \"\"\")\n    \n        def _handle_value_change(self) -> None:\n            \"\"\"Handle changes to any setting value.\"\"\"\n            if not self._current_settings:\n                return\n    \n            self.apply_button.setEnabled(\n                self._soft_tabs_check.isChecked() != self._current_settings.use_soft_tabs or\n                self._tab_size_spin.value() != self._current_settings.tab_size or\n                self._font_size_spin.value() != (self._current_settings.font_size or self._style_manager.base_font_size)\n            )\n    \n        def get_settings(self) -> WorkspaceSettings:\n            \"\"\"Get the current settings from the dialog.\"\"\"\n            return WorkspaceSettings(\n                use_soft_tabs=self._soft_tabs_check.isChecked(),\n                tab_size=self._tab_size_spin.value(),\n                font_size=self._font_size_spin.value(),\n                auto_backup=self._auto_backup_check.isChecked(),\n                auto_backup_interval=self._backup_interval_spin.value()\n            )\n    \n        def set_settings(self, settings: WorkspaceSettings) -> None:\n            \"\"\"Set the current settings in the dialog.\"\"\"\n            self._initial_settings = WorkspaceSettings(\n                use_soft_tabs=settings.use_soft_tabs,\n                tab_size=settings.tab_size,\n                font_size=settings.font_size,\n                auto_backup=settings.auto_backup,\n                auto_backup_interval=settings.auto_backup_interval\n            )\n            self._current_settings = WorkspaceSettings(\n                use_soft_tabs=settings.use_soft_tabs,\n                tab_size=settings.tab_size,\n                font_size=settings.font_size,\n                auto_backup=settings.auto_backup,\n                auto_backup_interval=settings.auto_backup_interval\n            )\n    \n            self._soft_tabs_check.setChecked(settings.use_soft_tabs)\n            self._tab_size_spin.setValue(settings.tab_size)\n            self._font_size_spin.setValue(settings.font_size if settings.font_size is not None else self._style_manager.base_font_size)\n            self._auto_backup_check.setChecked(settings.auto_backup)\n            self._backup_interval_spin.setValue(settings.auto_backup_interval)\n            self.apply_button.setEnabled(False)\n    \n        def _handle_apply(self) -> None:\n            \"\"\"Handle Apply button click.\"\"\"\n            settings = self.get_settings()\n            self._current_settings = settings\n            self.settings_changed.emit(settings)\n            self.apply_button.setEnabled(False)\n    \n        def _handle_ok(self) -> None:\n            \"\"\"Handle OK button click.\"\"\"\n            self._handle_apply()\n            self.accept()\n    \n        def reject(self) -> None:\n            \"\"\"Handle Cancel button click.\"\"\"\n            if self._initial_settings:\n                self.settings_changed.emit(self._initial_settings)\n            super().reject()\n    ```\n    File: src/humbug/gui/about_dialog.py\n    ```python\n    \"\"\"Dialog box for About Humbug.\"\"\"\n    \n    import os\n    from typing import Optional\n    \n    from PySide6.QtWidgets import QDialog, QVBoxLayout, QLabel, QPushButton\n    from PySide6.QtCore import Qt\n    from PySide6.QtGui import QPixmap\n    \n    from humbug import format_version\n    from humbug.gui.color_role import ColorRole\n    from humbug.gui.style_manager import StyleManager\n    \n    \n    class AboutDialog(QDialog):\n        \"\"\"About dialog for Humbug application.\"\"\"\n    \n        def __init__(self, parent: Optional[QDialog] = None) -> None:\n            \"\"\"Initialize the About dialog.\"\"\"\n            super().__init__(parent)\n            self.setWindowTitle(\"About Humbug\")\n            self.setMinimumWidth(400)\n            self.setModal(True)\n    \n            style_manager = StyleManager()\n            base_font_size = style_manager.base_font_size\n    \n            # Main layout with proper spacing\n            layout = QVBoxLayout()\n            layout.setSpacing(8)\n            layout.addSpacing(24)  # Space at the top\n    \n            # Add application icon\n            icon_label = QLabel()\n            icon_path = os.path.expanduser(\"~/.humbug/icons/app-icon.svg\")\n            icon_pixmap = QPixmap(icon_path)\n            scaled_size = int(160 * style_manager.zoom_factor)  # 160px base size\n            icon_label.setPixmap(icon_pixmap.scaled(\n                scaled_size, scaled_size,\n                Qt.KeepAspectRatio,\n                Qt.SmoothTransformation\n            ))\n            icon_label.setAlignment(Qt.AlignCenter)\n            layout.addWidget(icon_label)\n            layout.addSpacing(8)  # Space between icon and title\n    \n            # Title with version\n            title_label = QLabel(f\"Humbug v{format_version()}\")\n            title_label.setObjectName(\"titleLabel\")\n            title_label.setAlignment(Qt.AlignCenter)\n            title_label.setMinimumHeight(40)\n            layout.addWidget(title_label)\n    \n            # Description with hyperlink\n            desc_label = QLabel(\n                \"Visit <a href='https://m6r.ai'>m6r.ai</a> to learn more.\"\n            )\n            desc_label.setWordWrap(True)\n            desc_label.setAlignment(Qt.AlignCenter)\n            desc_label.setMinimumHeight(40)\n            desc_label.setOpenExternalLinks(True)\n            layout.addWidget(desc_label)\n    \n            # Close button with proper styling and sizing\n            close_button = QPushButton(\"Close\")\n            close_button.clicked.connect(self.accept)\n            close_button.setMinimumWidth(80)\n            close_button.setContentsMargins(6, 6, 6, 6)\n            layout.addSpacing(24)  # Add spacing before button\n            layout.addWidget(close_button, alignment=Qt.AlignCenter)\n            layout.addSpacing(16)  # Space at the bottom\n    \n            self.setLayout(layout)\n    \n            # Apply dialog styling\n            link_color = style_manager.get_color_str(ColorRole.TEXT_PRIMARY)\n            self.setStyleSheet(f\"\"\"\n                QDialog {{\n                    background-color: {style_manager.get_color_str(ColorRole.BACKGROUND_DIALOG)};\n                }}\n                QLabel {{\n                    color: {style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    background-color: {style_manager.get_color_str(ColorRole.BACKGROUND_DIALOG)};\n                }}\n                QLabel#titleLabel {{\n                    font-size: {base_font_size * 1.5}pt;\n                    font-weight: bold;\n                    margin: 10px;\n                }}\n                QLabel a {{\n                    color: {link_color};\n                    text-decoration: none;\n                }}\n                QLabel a:hover {{\n                    text-decoration: underline;\n                }}\n                QPushButton {{\n                    background-color: {style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND)};\n                    color: {style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    border: none;\n                    border-radius: 4px;\n                    padding: 6px;\n                    min-width: 80px;\n                }}\n                QPushButton:hover {{\n                    background-color: {style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND_HOVER)};\n                }}\n                QPushButton:pressed {{\n                    background-color: {style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND_PRESSED)};\n                }}\n                QPushButton:disabled {{\n                    background-color: {style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND_DISABLED)};\n                    color: {style_manager.get_color_str(ColorRole.TEXT_DISABLED)};\n                }}\n            \"\"\")\n    ```\n    File: src/humbug/gui/tab_base.py\n    ```python\n    from typing import Dict, Optional\n    \n    from PySide6.QtWidgets import QFrame, QWidget\n    from PySide6.QtCore import Signal, QObject, QEvent\n    \n    from humbug.gui.status_message import StatusMessage\n    from humbug.gui.tab_state import TabState\n    \n    \n    class TabEventFilter(QObject):\n        \"\"\"Event filter to track activation events from child widgets.\"\"\"\n    \n        widget_activated = Signal()\n    \n        def __init__(self, parent=None):\n            \"\"\"Initialize the event filter.\"\"\"\n            super().__init__(parent)\n    \n        def eventFilter(self, obj: QObject, event: QEvent) -> bool:\n            \"\"\"Filter events to detect widget activation.\"\"\"\n            if event.type() in (QEvent.MouseButtonPress, QEvent.FocusIn):\n                self.widget_activated.emit()\n                return False  # Don't consume the event\n    \n            return super().eventFilter(obj, event)\n    \n    \n    class TabBase(QFrame):\n        \"\"\"Base class for all tab content.\"\"\"\n    \n        # Common signals that both conversation and editor tabs will need\n        title_changed = Signal(str, str)  # Emits (tab_id, new_title)\n        modified_state_changed = Signal(str, bool)  # Emits (tab_id, is_modified)\n        status_message = Signal(StatusMessage)\n        activated = Signal()  # Emits when tab is activated by user interaction\n    \n        def __init__(self, tab_id: str, parent=None):\n            \"\"\"\n            Initialize the base tab.\n    \n            Args:\n                tab_id: Unique identifier for this tab\n                parent: Optional parent widget\n            \"\"\"\n            super().__init__(parent)\n            self._tab_id = tab_id\n            self._is_modified = False\n            self._path: Optional[str] = None\n    \n            # Set up activation tracking\n            self._event_filter = TabEventFilter(self)\n            self._event_filter.widget_activated.connect(self.activated)\n            self.installEventFilter(self._event_filter)\n    \n        def _install_activation_tracking(self, widget: QWidget) -> None:\n            \"\"\"\n            Install event filter on widget and all its children recursively.\n    \n            Call this for any new widgets added to the tab that should trigger activation.\n    \n            Args:\n                widget: Widget to track for activation events\n            \"\"\"\n            widget.installEventFilter(self._event_filter)\n            for child in widget.findChildren(QWidget):\n                child.installEventFilter(self._event_filter)\n    \n        @property\n        def tab_id(self) -> str:\n            \"\"\"Get the tab's unique identifier.\"\"\"\n            return self._tab_id\n    \n        @property\n        def path(self) -> Optional[str]:\n            \"\"\"Get the tab's associated file path.\"\"\"\n            return self._path\n    \n        @property\n        def is_modified(self) -> bool:\n            \"\"\"Check if the tab's content has unsaved modifications.\"\"\"\n            return self._is_modified\n    \n        def _set_modified(self, modified: bool) -> None:\n            \"\"\"Update the modified state and emit signal if changed.\"\"\"\n            if modified != self._is_modified:\n                self._is_modified = modified\n                self.modified_state_changed.emit(self._tab_id, modified)\n    \n        def get_state(self, temp_state: bool) -> TabState:\n            \"\"\"Get serializable state for workspace persistence.\n    \n            Must be implemented by subclasses to provide their specific state.\n    \n            Args:\n                temp_state: True if we're saving temporary state to restore locally,\n                    False if we're persisting state\n    \n            Returns:\n                TabState object containing serializable state\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement get_state\")\n    \n        @classmethod\n        def restore_from_state(cls, state: TabState, parent=None) -> 'TabBase':\n            \"\"\"Create and restore a tab from serialized state.\n    \n            Must be implemented by subclasses to handle their specific state.\n    \n            Args:\n                state: TabState object containing serialized state\n                    (note: state.type will be string, not TabType enum)\n                parent: Optional parent widget\n    \n            Returns:\n                Newly created and restored tab instance\n    \n            Raises:\n                ValueError: If state is invalid for this tab type\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement restore_from_state\")\n    \n        def set_cursor_position(self, position: Dict[str, int]) -> None:\n            \"\"\"Set the cursor position in the tab's content.\n    \n            Args:\n                position: Dictionary with cursor position information\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement set_cursor_position\")\n    \n        def get_cursor_position(self) -> Dict[str, int]:\n            \"\"\"Get the current cursor position from the tab's content.\n    \n            Returns:\n                Dictionary with cursor position information\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement get_cursor_position\")\n    \n        def can_close(self) -> bool:\n            \"\"\"\n            Check if the tab can be closed.\n    \n            Must be implemented by subclasses.\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement can_close\")\n    \n        def close(self) -> None:\n            \"\"\"\n            Close the tab's content if applicable.\n    \n            Must be implemented by subclasses.\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement save\")\n    \n        def can_save(self) -> bool:\n            \"\"\"\n            Check if the tab can be saved.\n    \n            Must be implemented by subclasses.\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement can_save\")\n    \n        def save(self) -> bool:\n            \"\"\"\n            Save the tab's content if applicable.\n    \n            Must be implemented by subclasses.\n    \n            Returns:\n                bool: True if save was successful or not needed\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement save\")\n    \n        def can_save_as(self) -> bool:\n            \"\"\"\n            Check if the tab can be saved \"as\".\n    \n            Must be implemented by subclasses.\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement can_save_as\")\n    \n        def save_as(self) -> bool:\n            \"\"\"\n            Save the tab's content \"as\" if applicable.\n    \n            Must be implemented by subclasses.\n    \n            Returns:\n                bool: True if save was successful or not needed\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement save_as\")\n    \n        def can_undo(self) -> bool:\n            \"\"\"\n            Check if undo operation is available.\n    \n            Must be implemented by subclasses.\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement can_undo\")\n    \n        def undo(self) -> None:\n            \"\"\"\n            Perform undo operation.\n    \n            Must be implemented by subclasses.\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement undo\")\n    \n        def can_redo(self) -> bool:\n            \"\"\"\n            Check if redo operation is available.\n    \n            Must be implemented by subclasses.\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement can_redo\")\n    \n        def redo(self) -> None:\n            \"\"\"\n            Perform redo operation.\n    \n            Must be implemented by subclasses.\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement redo\")\n    \n        def can_cut(self) -> bool:\n            \"\"\"\n            Check if cut operation is available.\n    \n            Must be implemented by subclasses.\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement can_cut\")\n    \n        def cut(self) -> None:\n            \"\"\"\n            Perform cut operation.\n    \n            Must be implemented by subclasses.\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement cut\")\n    \n        def can_copy(self) -> bool:\n            \"\"\"\n            Check if copy operation is available.\n    \n            Must be implemented by subclasses.\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement can_copy\")\n    \n        def copy(self) -> None:\n            \"\"\"\n            Perform copy operation.\n    \n            Must be implemented by subclasses.\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement copy\")\n    \n        def can_paste(self) -> bool:\n            \"\"\"\n            Check if paste operation is available.\n    \n            Must be implemented by subclasses.\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement can_paste\")\n    \n        def paste(self) -> None:\n            \"\"\"\n            Perform paste operation.\n    \n            Must be implemented by subclasses.\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement paste\")\n    \n        def can_submit(self) -> bool:\n            \"\"\"\n            Check if submit operation is available.\n    \n            Must be implemented by subclasses.\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement can_submit\")\n    \n        def update_status(self) -> None:\n            \"\"\"\n            Update status bar with tab-specific status information.\n    \n            Must be implemented by subclasses to provide their specific status.\n            \"\"\"\n            raise NotImplementedError(\"Subclasses must implement update_status\")\n    ```\n    File: src/humbug/gui/tab_label.py\n    ```python\n    \"\"\"Tab label management for the Humbug application.\"\"\"\n    \n    from typing import Optional\n    \n    from PySide6.QtWidgets import (\n        QWidget, QLabel, QToolButton, QHBoxLayout, QSizePolicy, QApplication\n    )\n    from PySide6.QtCore import Signal, QSize, Qt, QMimeData, QPoint\n    from PySide6.QtGui import QIcon, QPixmap, QDrag, QMouseEvent\n    \n    from humbug.gui.color_role import ColorRole\n    from humbug.gui.style_manager import StyleManager\n    \n    \n    class TabLabel(QWidget):\n        \"\"\"Custom widget for tab labels with close button and drag support.\"\"\"\n    \n        close_clicked = Signal()\n        drag_started = Signal()\n    \n        def __init__(self, text: str, tab_id: str, parent=None):\n            \"\"\"\n            Initialize the tab label widget.\n    \n            Args:\n                text: The text to display in the tab\n                tab_id: Unique identifier for the associated tab\n                parent: Optional parent widget\n            \"\"\"\n            super().__init__(parent)\n    \n            self._tab_id = tab_id\n            self._is_current = False\n            self._is_hovered = False\n            self._style_manager = StyleManager()\n            self._drag_start_pos: Optional[QPoint] = None\n    \n            self.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)\n    \n            self._layout = QHBoxLayout(self)\n            self.setLayout(self._layout)\n    \n            # Add label with size policy\n            self._label = QLabel(text)\n            self._label.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)\n            self._layout.addWidget(self._label)\n    \n            self._close_button = QToolButton()\n            self._close_button.setCursor(Qt.PointingHandCursor)\n            self._close_button.clicked.connect(self.close_clicked)\n            self._close_button.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)\n            self._layout.addWidget(self._close_button)\n    \n            self.handle_style_changed(self._style_manager.zoom_factor, False)\n    \n            self.setMouseTracking(True)\n    \n        def _create_visible_close_icon(self) -> QIcon:\n            icon = QIcon()\n            icon_path = self._style_manager.get_icon_path(\"close\")\n            pixmap = self._style_manager.scale_icon(icon_path, 16)  # 16px base size\n            icon.addPixmap(pixmap, QIcon.Normal, QIcon.Off)\n            icon.addPixmap(pixmap, QIcon.Active, QIcon.Off)\n            return icon\n    \n        def _create_invisible_close_icon(self) -> QIcon:\n            \"\"\"Create a transparent icon for the inactive state.\"\"\"\n            size = self._style_manager.get_scaled_size(16)\n            transparent_pixmap = QPixmap(size, size)\n            transparent_pixmap.fill(Qt.transparent)\n            return QIcon(transparent_pixmap)\n    \n        def handle_style_changed(self, factor: float, is_active: bool):\n            \"\"\"\n            Handle style changes from StyleManager.\n    \n            Args:\n                factor: New zoom factor\n            \"\"\"\n            colour = ColorRole.TEXT_PRIMARY if is_active else ColorRole.TAB_INACTIVE\n            self._label.setStyleSheet(f\"color: {self._style_manager.get_color_str(colour)}\")\n    \n            self._update_font_size()\n    \n            # Update close button size\n            button_size = 16 * factor\n            self._close_button.setFixedSize(button_size, button_size)\n    \n            # Update icon size\n            icon_size = 16 * factor\n            self._close_button.setIconSize(QSize(icon_size, icon_size))\n    \n            # Recreate icons at new size\n            self._visible_close_icon = self._create_visible_close_icon()\n            self._invisible_close_icon = self._create_invisible_close_icon()\n    \n            # Update layout margins and spacing\n            self._layout.setSpacing(6 * factor)\n            margins = 8 * factor\n            v_margins = 4 * factor\n            self._layout.setContentsMargins(margins, v_margins, margins, v_margins)\n    \n            self._update_close_button()\n    \n            self.adjustSize()\n    \n        def _update_font_size(self):\n            \"\"\"Update the label font size based on current zoom factor.\"\"\"\n            font = self._label.font()\n            base_size = self._style_manager.base_font_size\n            scaled_size = self._style_manager.get_scaled_size(base_size)\n            font.setPointSizeF(scaled_size)\n            self._label.setFont(font)\n    \n        def mousePressEvent(self, event: QMouseEvent):\n            \"\"\"Handle mouse press events for drag initiation.\"\"\"\n            if event.button() == Qt.LeftButton:\n                self._drag_start_pos = event.pos()\n    \n            super().mousePressEvent(event)\n    \n        def mouseMoveEvent(self, event: QMouseEvent):\n            \"\"\"Handle mouse move events for drag operations.\"\"\"\n            if not self._drag_start_pos:\n                return\n    \n            # Check if we've moved far enough to start a drag\n            if (event.pos() - self._drag_start_pos).manhattanLength() < QApplication.startDragDistance():\n                return\n    \n            # Create drag object\n            drag = QDrag(self)\n            mime_data = QMimeData()\n            # Store the tab ID for identification\n            mime_data.setData(\"application/x-humbug-tab\", self._tab_id.encode())\n            drag.setMimeData(mime_data)\n    \n            # Create pixmap for drag visual feedback\n            pixmap = QPixmap(self.size())\n            self.render(pixmap)\n            drag.setPixmap(pixmap)\n            drag.setHotSpot(self._drag_start_pos)\n    \n            # Clear drag tracking\n            self._drag_start_pos = None\n    \n            # Emit signal before starting drag\n            self.drag_started.emit()\n    \n            # Execute drag operation\n            drag.exec_(Qt.MoveAction)\n    \n        def mouseReleaseEvent(self, event: QMouseEvent):\n            \"\"\"Handle mouse release events.\"\"\"\n            self._drag_start_pos = None\n            super().mouseReleaseEvent(event)\n    \n        def enterEvent(self, event):\n            \"\"\"Handle mouse entering the tab label.\"\"\"\n            super().enterEvent(event)\n            self._is_hovered = True\n            self._update_close_button()\n    \n        def leaveEvent(self, event):\n            \"\"\"Handle mouse leaving the tab label.\"\"\"\n            super().leaveEvent(event)\n            self._is_hovered = False\n            self._update_close_button()\n    \n        def _update_close_button(self):\n            \"\"\"Update close button appearance based on current state.\"\"\"\n            visible = self._is_current or self._is_hovered\n    \n            style_manager = StyleManager()\n            if visible:\n                base_color = (ColorRole.TAB_BACKGROUND_ACTIVE if self._is_current\n                            else ColorRole.TAB_BACKGROUND_HOVER)\n                style = f\"\"\"\n                    QToolButton {{\n                        border: none;\n                        outline: none;\n                        padding: 0px;\n                        background: {style_manager.get_color_str(base_color)};\n                    }}\n                    QToolButton:hover {{\n                        background: {style_manager.get_color_str(ColorRole.CLOSE_BUTTON_BACKGROUND_HOVER)};\n                    }}\n                \"\"\"\n                self._close_button.setIcon(self._visible_close_icon)\n                self._close_button.setCursor(Qt.PointingHandCursor)\n                self._close_button.setToolTip(\"Close Tab\")\n            else:\n                style = f\"\"\"\n                    QToolButton {{\n                        border: none;\n                        outline: none;\n                        padding: 0px;\n                        background: {style_manager.get_color_str(ColorRole.TAB_BACKGROUND_INACTIVE)};\n                    }}\n                \"\"\"\n                self._close_button.setIcon(self._invisible_close_icon)\n                self._close_button.setCursor(Qt.ArrowCursor)\n                self._close_button.setToolTip(\"\")\n    \n            self._close_button.setStyleSheet(style)\n    \n        def set_current(self, is_current: bool):\n            \"\"\"Update the current state of the tab.\"\"\"\n            self._is_current = is_current\n            self._update_close_button()\n    \n        @property\n        def tab_id(self) -> str:\n            \"\"\"Get the tab's unique identifier.\"\"\"\n            return self._tab_id\n    \n        def text(self) -> str:\n            \"\"\"\n            Get the current text of the tab label.\n    \n            Returns:\n                str: The current text displayed in the label\n            \"\"\"\n            return self._label.text()\n    \n        def update_text(self, text: str) -> None:\n            \"\"\"\n            Update the text displayed in the tab label.\n    \n            Args:\n                text: New text to display\n            \"\"\"\n            self._label.setText(text)\n            self.adjustSize()\n    ```\n    File: src/humbug/gui/tab_manager.py\n    ```python\n    from datetime import datetime\n    import logging\n    import os\n    from typing import Optional, Dict, List, cast\n    import uuid\n    \n    from PySide6.QtWidgets import QDialog, QTabBar, QWidget, QVBoxLayout, QSplitter, QStackedWidget\n    from PySide6.QtCore import Signal, Qt\n    \n    from humbug.ai.ai_backend import AIBackend\n    from humbug.ai.conversation_settings import ConversationSettings\n    from humbug.gui.conversation_error import ConversationError\n    from humbug.gui.conversation_settings_dialog import ConversationSettingsDialog\n    from humbug.gui.conversation_tab import ConversationTab\n    from humbug.gui.color_role import ColorRole\n    from humbug.gui.editor_tab import EditorTab\n    from humbug.gui.status_message import StatusMessage\n    from humbug.gui.style_manager import StyleManager\n    from humbug.gui.tab_base import TabBase\n    from humbug.gui.tab_column import TabColumn\n    from humbug.gui.tab_label import TabLabel\n    from humbug.gui.tab_state import TabState\n    from humbug.gui.tab_type import TabType\n    from humbug.gui.welcome_widget import WelcomeWidget\n    from humbug.workspace.workspace_manager import WorkspaceManager\n    \n    \n    class TabManager(QWidget):\n        \"\"\"Manages multiple tabs across one or two columns.\"\"\"\n    \n        column_state_changed = Signal()\n        status_message = Signal(StatusMessage)\n    \n        def __init__(self, ai_backends: Dict[str, AIBackend], parent=None):\n            \"\"\"Initialize the tab manager.\"\"\"\n            super().__init__(parent)\n    \n            self._untitled_count = 0\n            self._ai_backends = ai_backends\n            self._workspace_manager = WorkspaceManager()\n            self._logger = logging.getLogger(\"TabManager\")\n    \n            # Create main layout\n            main_layout = QVBoxLayout(self)\n            main_layout.setContentsMargins(0, 0, 0, 0)\n            main_layout.setSpacing(0)\n    \n            # Create stack widget for tab container and welcome message\n            self._stack = QStackedWidget()\n            main_layout.addWidget(self._stack)\n    \n            # Create welcome widget\n            self._welcome_widget = WelcomeWidget()\n            self._stack.addWidget(self._welcome_widget)\n    \n            # Create widget to hold columns\n            self._columns_widget = QWidget()\n            self._columns_layout = QVBoxLayout(self._columns_widget)\n            self._columns_layout.setContentsMargins(0, 0, 0, 0)\n            self._columns_layout.setSpacing(0)\n            self._stack.addWidget(self._columns_widget)\n    \n            # Create splitter for columns\n            self._column_splitter = QSplitter(Qt.Horizontal)\n            self._columns_layout.addWidget(self._column_splitter)\n    \n            # Create initial column\n            self._tab_columns: List[TabColumn] = []\n            self._create_column(0)\n    \n            # Track active column\n            self._active_column = self._tab_columns[0]\n    \n            # Set initial state\n            self._stack.setCurrentWidget(self._welcome_widget)\n    \n            # Track tabs\n            self._tabs: Dict[str, TabBase] = {}\n            self._tab_labels: Dict[str, TabLabel] = {}\n    \n            self._style_manager = StyleManager()\n            self._style_manager.style_changed.connect(self._handle_style_changed)\n    \n            self._handle_style_changed(self._style_manager.zoom_factor)\n    \n        def _handle_tab_drop(self, tab_id: str, target_column: TabColumn, target_index: int) -> None:\n            \"\"\"Handle a tab being dropped into a new position.\n    \n            Args:\n                tab_id: ID of the tab being moved\n                target_column: Column where the tab was dropped\n                target_index: Target position in the column\n            \"\"\"\n            # Find source column and index\n            tab = self._tabs.get(tab_id)\n            if not tab:\n                return\n    \n            source_column = self._find_column_for_tab(tab)\n            if not source_column:\n                return\n    \n            source_index = source_column.indexOf(tab)\n    \n            # Don't process if dropped on itself\n            if (source_column == target_column and\n                (source_index == target_index or source_index == target_index - 1)):\n                return\n    \n            tab_id = tab.tab_id\n            tab_state = tab.get_state(True)\n            tab_title = self._tab_labels[tab_id].text()\n    \n            tab_label = self._tab_labels.pop(tab_id)\n            del self._tabs[tab_id]\n            index = source_column.indexOf(tab)\n            source_column.removeTab(index)\n            tab_label.deleteLater()\n            tab.deleteLater()\n    \n            # Create appropriate tab type\n            new_tab = self._restore_tab_from_state(tab_state)\n            if not new_tab:\n                return\n    \n            self._tabs[tab_id] = new_tab\n            new_tab.activated.connect(lambda: self._handle_tab_activated(new_tab))\n    \n            # Create new label\n            new_tab_label = TabLabel(tab_title, tab_id)\n            new_tab_label.close_clicked.connect(lambda tid=tab_id: self._close_tab_by_id(tid))\n            self._tab_labels[tab_id] = new_tab_label\n    \n            # Add to column\n            index = target_column.addTab(new_tab, \"\")\n            target_column.tabBar().setTabButton(index, QTabBar.LeftSide, new_tab_label)\n            target_column.setCurrentWidget(new_tab)\n    \n            # Set our new active column before we possibly delete the previous one\n            self._active_column = target_column\n    \n            # Did we remove the last tab from our source column?  If yes then close the column\n            if source_column.count() == 0:\n                column_number = self._tab_columns.index(source_column)\n                del self._tab_columns[column_number]\n                source_column.deleteLater()\n    \n                # Resize splitter.  Note +1 on column count because we won't have lost the deleted column yet!\n                num_columns = len(self._tab_columns)\n                sizes = [(self.width() // num_columns) for _ in range(num_columns + 1)]\n                self._column_splitter.setSizes(sizes)\n    \n            # Update active states\n            self._update_tabs()\n            self.column_state_changed.emit()\n    \n        def _create_column(self, index: int) -> TabColumn:\n            \"\"\"Create a new tab column.\"\"\"\n            tab_widget = TabColumn()\n            tab_widget.currentChanged.connect(self._handle_tab_changed)\n            tab_widget.column_activated.connect(self._handle_column_activated)\n            tab_widget.tab_drop.connect(self._handle_tab_drop)\n    \n            self._column_splitter.insertWidget(index, tab_widget)\n            self._tab_columns.insert(index, tab_widget)\n    \n            return tab_widget\n    \n        def _update_tabs(self) -> None:\n            # Update current states for all tabs\n            for tab_id, label in self._tab_labels.items():\n                tab = self._tabs[tab_id]\n                column = self._find_column_for_tab(tab)\n                column_index = column.currentIndex()\n                is_current = column_index != -1 and tab == column.widget(column_index) and column == self._active_column\n                label.set_current(is_current)\n    \n            # Force style refresh to show active state\n            self._handle_style_changed(self._style_manager.zoom_factor)\n    \n            # Emit our new signal with current tab\n            current_tab = self._get_current_tab()\n            if not current_tab:\n                return\n    \n            # Disconnect any existing connections to avoid duplicates\n            try:\n                current_tab.status_message.disconnect()\n            except RuntimeError:\n                pass  # No existing connections\n    \n            current_tab.status_message.connect(self.status_message)\n            current_tab.update_status()\n    \n        def _handle_tab_changed(self, _index: int) -> None:\n            \"\"\"\n            Handle tab selection changes.\n    \n            Args:\n                index: Index of the newly selected tab\n            \"\"\"\n            # Find which column triggered the change\n            sender = self.sender()\n            self._active_column = sender\n            self._update_tabs()\n    \n        def _handle_tab_activated(self, tab: TabBase) -> None:\n            \"\"\"\n            Handle tab activation from widget focus.\n    \n            Args:\n                tab: The tab that was activated\n            \"\"\"\n            # Find which column contains the tab\n            column = self._find_column_for_tab(tab)\n            if not column or column == self._active_column:\n                return\n    \n            # Update active column\n            self._active_column = column\n            self._update_tabs()\n    \n        def _handle_column_activated(self, column: TabColumn) -> None:\n            \"\"\"Handle column activation.\"\"\"\n            if column not in self._tab_columns:\n                return\n    \n            if column == self._active_column:\n                return\n    \n            self._active_column = column\n            self._update_tabs()\n    \n        def add_tab(self, tab: TabBase, title: str) -> None:\n            \"\"\"\n            Add a new tab to the manager.\n    \n            Args:\n                tab: The tab widget to add\n                title: Initial title for the tab\n            \"\"\"\n            tab_id = tab.tab_id\n            self._tabs[tab_id] = tab\n    \n            tab.activated.connect(lambda: self._handle_tab_activated(tab))\n    \n            # Create custom tab label\n            tab_label = TabLabel(title, tab_id)\n            tab_label.close_clicked.connect(lambda: self._close_tab_by_id(tab_id))\n            self._tab_labels[tab_id] = tab_label\n    \n            # Add tab with custom label to active column\n            index = self._active_column.addTab(tab, \"\")\n            self._active_column.tabBar().setTabButton(index, QTabBar.LeftSide, tab_label)\n    \n            # Set initial state\n            if len(self._tabs) == 1:  # If this is the first tab\n                tab_label.set_current(True)\n                self._stack.setCurrentWidget(self._columns_widget)\n    \n            self._active_column.setCurrentWidget(tab)\n    \n        def _close_tab_by_id(self, tab_id: str) -> None:\n            \"\"\"\n            Close a tab by its ID.\n    \n            Args:\n                tab_id: ID of the tab to close\n            \"\"\"\n            tab = self._tabs.get(tab_id)\n            if not tab:\n                return\n    \n            # Check if tab can be closed\n            if not tab.can_close():\n                return\n    \n            # Find which column contains the tab\n            column = self._find_column_for_tab(tab)\n            if not column:\n                return\n    \n            # Remove tab\n            tab_label = self._tab_labels.pop(tab_id)\n            del self._tabs[tab_id]\n            index = column.indexOf(tab)\n            column.removeTab(index)\n            tab_label.deleteLater()\n            tab.deleteLater()\n    \n            # If we closed the last tab in the column, close the column unless it's the last column\n            if column.count() == 0:\n                if len(self._tab_columns) > 1:\n                    column_number = self._tab_columns.index(column)\n                    if self._active_column == column:\n                        new_active_column = 1 if column_number == 0 else column_number - 1\n                        self._active_column = self._tab_columns[new_active_column]\n    \n                    del self._tab_columns[column_number]\n                    column.deleteLater()\n    \n                    self._update_tabs()\n                    self.column_state_changed.emit()\n    \n            # Show welcome message if no tabs remain\n            if not self._tabs:\n                self._stack.setCurrentWidget(self._welcome_widget)\n    \n        def _find_column_for_tab(self, tab: TabBase) -> Optional[TabColumn]:\n            \"\"\"Find which column contains the given tab.\"\"\"\n            for column in self._tab_columns:\n                if column.indexOf(tab) != -1:\n                    return column\n    \n            return None\n    \n        def _get_current_tab(self) -> Optional[TabBase]:\n            \"\"\"\n            Get the currently active tab.\n    \n            Returns:\n                The current tab or None if no tabs exist\n            \"\"\"\n            widget = self._active_column.currentWidget()\n            return cast(TabBase, widget) if widget else None\n    \n        def _set_current_tab(self, tab_id: str) -> None:\n            \"\"\"\n            Set the current tab by ID.\n    \n            Args:\n                tab_id: ID of the tab to make current\n            \"\"\"\n            tab = self._tabs.get(tab_id)\n            if not tab:\n                return\n    \n            # Find which column contains the tab\n            column = self._find_column_for_tab(tab)\n            if column:\n                column.setCurrentWidget(tab)\n                self._active_column = column\n    \n        def _handle_tab_title_changed(self, tab_id: str, title: str) -> None:\n            \"\"\"\n            Update a tab's title.\n    \n            Args:\n                tab_id: ID of the tab to update\n                title: New title for the tab\n            \"\"\"\n            label = self._tab_labels.get(tab_id)\n            if label:\n                label.update_text(title)\n                self.adjustSize()\n    \n        def _handle_tab_modified(self, tab_id: str, modified: bool) -> None:\n            \"\"\"\n            Update a tab's modified state.\n    \n            Args:\n                tab_id: ID of the tab to update\n                modified: Whether the tab is modified\n            \"\"\"\n            tab = self._tabs.get(tab_id)\n            if not tab:\n                return\n    \n            label = self._tab_labels.get(tab_id)\n            if label:\n                current_text = label.text()\n                if modified and not current_text.endswith('*'):\n                    label.update_text(f\"{current_text}*\")\n                elif not modified and current_text.endswith('*'):\n                    label.update_text(current_text[:-1])\n    \n                self.adjustSize()\n    \n        def can_split_column(self) -> bool:\n            \"\"\"Can the current column be split in two?\"\"\"\n            if len(self._tab_columns) >= 6:\n                return False\n    \n            current_column_number = self._get_current_column()\n            current_column = self._tab_columns[current_column_number]\n            return current_column.count() > 1\n    \n        def split_column(self, split_left: bool) -> None:\n            \"\"\"Split the current column in two.\"\"\"\n            if len(self._tab_columns) >= 6:\n                return\n    \n            current_column_number = self._get_current_column()\n            current_column = self._tab_columns[current_column_number]\n            if current_column.count() <= 1:\n                return\n    \n            target_column_number = current_column_number + (0 if split_left else 1)\n            target_column = self._create_column(target_column_number)\n    \n            # Delete the current tab from the current column and recreate it in the new column\n            old_tab = self._get_current_tab()\n            old_tab_id = old_tab.tab_id\n            old_tab_state = old_tab.get_state(True)\n            old_tab_title = self._tab_labels[old_tab_id].text()\n    \n            tab_label = self._tab_labels.pop(old_tab_id)\n            del self._tabs[old_tab_id]\n            index = current_column.indexOf(old_tab)\n            current_column.removeTab(index)\n            tab_label.deleteLater()\n            old_tab.deleteLater()\n    \n            # Create appropriate tab type\n            tab = self._restore_tab_from_state(old_tab_state)\n            if not tab:\n                return\n    \n            self._tabs[old_tab_id] = tab\n            tab.activated.connect(lambda: self._handle_tab_activated(tab))\n    \n            # Create new label\n            tab_label = TabLabel(old_tab_title, old_tab_id)\n            tab_label.close_clicked.connect(lambda tid=old_tab_id: self._close_tab_by_id(tid))\n            self._tab_labels[old_tab_id] = tab_label\n    \n            # Add to column\n            index = target_column.addTab(tab, \"\")\n            target_column.tabBar().setTabButton(index, QTabBar.LeftSide, tab_label)\n    \n            # Resize splitter\n            num_columns = len(self._tab_columns)\n            sizes = [(self.width() // num_columns) for _ in range(num_columns)]\n            self._column_splitter.setSizes(sizes)\n    \n            self._active_column = target_column\n    \n            # Emit signal about column state change\n            self._update_tabs()\n            self.column_state_changed.emit()\n    \n        def can_merge_column(self, merge_left: bool) -> bool:\n            \"\"\"Can the current column be merged?\"\"\"\n            if len(self._tab_columns) <= 1:\n                return False\n    \n            current_column_number = self._get_current_column()\n            if (merge_left and current_column_number == 0) or (not merge_left and current_column_number == len(self._tab_columns) -1):\n                return False\n    \n            return True\n    \n        def merge_column(self, merge_left: bool) -> None:\n            \"\"\"Merge with adjacent column.\"\"\"\n            if len(self._tab_columns) <= 1:\n                return\n    \n            current_column_number = self._get_current_column()\n            if (merge_left and current_column_number == 0) or (not merge_left and current_column_number == len(self._tab_columns) -1):\n                return\n    \n            target_column_number = current_column_number + (-1 if merge_left else 1)\n            target_column = self._tab_columns[target_column_number]\n            current_column = self._active_column\n    \n            # Record tab states and labels from current column\n            tab_states = []\n            for i in range(current_column.count()):\n                tab = current_column.widget(i)\n                tab_states.append((\n                    tab.tab_id,\n                    tab.get_state(True),\n                    self._tab_labels[tab.tab_id].text()\n                ))\n    \n            # Delete all widgets in current column\n            while current_column.count() > 0:\n                tab = current_column.widget(0)\n                tab_label = self._tab_labels.pop(tab.tab_id)\n                del self._tabs[tab.tab_id]\n                current_column.removeTab(0)\n                tab_label.deleteLater()\n                tab.deleteLater()\n    \n            # Ensure target column is active because we're about to delete the current one\n            self._active_column = target_column\n    \n            # Remove and delete current column widget\n            current_column.deleteLater()\n            del self._tab_columns[current_column_number]\n    \n            # Recreate each tab in target column\n            for tab_id, state, title in tab_states:\n                tab = self._restore_tab_from_state(state)\n                if not tab:\n                    continue\n    \n                self._tabs[tab_id] = tab\n                tab.activated.connect(lambda handle_tab=tab: self._handle_tab_activated(handle_tab))\n    \n                # Create new label\n                tab_label = TabLabel(title, tab_id)\n                tab_label.close_clicked.connect(lambda tid=tab_id: self._close_tab_by_id(tid))\n                self._tab_labels[tab_id] = tab_label\n    \n                # Add to column\n                index = target_column.addTab(tab, \"\")\n                target_column.tabBar().setTabButton(index, QTabBar.LeftSide, tab_label)\n    \n            # Resize splitter.  Note +1 on column count because we won't have lost the deleted column yet!\n            num_columns = len(self._tab_columns)\n            sizes = [(self.width() // num_columns) for _ in range(num_columns + 1)]\n            self._column_splitter.setSizes(sizes)\n    \n            # Emit signal about column state change\n            self._update_tabs()\n            self.column_state_changed.emit()\n    \n        def _get_current_column(self) -> int:\n            \"\"\"Get index of currently active column.\"\"\"\n            return self._tab_columns.index(self._active_column)\n    \n        def find_conversation_tab_by_id(self, conversation_id: str) -> Optional[ConversationTab]:\n            \"\"\"\n            Find a conversation tab by its conversation ID.\n    \n            Args:\n                conversation_id: The ID to search for\n    \n            Returns:\n                The ConversationTab if found, None otherwise\n            \"\"\"\n            tab = self._tabs.get(conversation_id)\n            return tab if isinstance(tab, ConversationTab) else None\n    \n        def find_editor_tab_by_filename(self, filename: str) -> Optional[EditorTab]:\n            \"\"\"\n            Find an editor tab by its filename.\n    \n            Args:\n                filename: The filename to search for\n    \n            Returns:\n                The EditorTab if found, None otherwise\n            \"\"\"\n            for tab in self._tabs.values():\n                if isinstance(tab, EditorTab) and tab.filename == filename:\n                    return tab\n            return None\n    \n        def new_file(self) -> EditorTab:\n            \"\"\"Create a new empty editor tab.\"\"\"\n            self._untitled_count += 1\n            tab_id = str(uuid.uuid4())\n            editor = EditorTab(tab_id, self)\n            editor.set_filename(None, self._untitled_count)\n    \n            self._connect_editor_signals(editor)\n            self.add_tab(editor, f\"Untitled-{self._untitled_count}\")\n            return editor\n    \n        def open_file(self, path: str) -> Optional[EditorTab]:\n            \"\"\"Open a file in a new or existing editor tab.\"\"\"\n            # Check if file is already open\n            existing_tab = self.find_editor_tab_by_filename(path)\n            if existing_tab:\n                self._set_current_tab(existing_tab.tab_id)\n                return existing_tab\n    \n            tab_id = str(uuid.uuid4())\n            editor = EditorTab(tab_id, self)\n            editor.set_filename(path)\n    \n            self._connect_editor_signals(editor)\n            self.add_tab(editor, os.path.basename(path))\n            return editor\n    \n        def new_conversation(self, workspace_path: str) -> Optional[str]:\n            \"\"\"Create a new conversation tab and return its ID.\"\"\"\n            # Generate timestamp for ID\n            timestamp = datetime.utcnow()\n            conversation_id = timestamp.strftime(\"%Y-%m-%d-%H-%M-%S-%f\")[:23]\n    \n            # Create path relative to workspace\n            filename = os.path.join(\"conversations\", f\"{conversation_id}.conv\")\n            full_path = os.path.join(workspace_path, filename)\n    \n            conversation_tab = ConversationTab(\n                conversation_id,\n                full_path,\n                timestamp,\n                self._ai_backends,\n                self\n            )\n    \n            # Set default model based on available backends for any new conversation\n            default_model = ConversationSettings.get_default_model(self._ai_backends)\n            conversation_tab.update_conversation_settings(ConversationSettings(model=default_model))\n    \n            self.add_tab(conversation_tab, f\"Conv: {conversation_id}\")\n            return conversation_id\n    \n        def open_conversation(self, path: str) -> Optional[ConversationTab]:\n            \"\"\"Open an existing conversation file.\"\"\"\n            conversation_id = os.path.splitext(os.path.basename(path))[0]\n    \n            # Check if already open\n            existing_tab = self.find_conversation_tab_by_id(conversation_id)\n            if existing_tab:\n                self._set_current_tab(conversation_id)\n                return existing_tab\n    \n            try:\n                conversation_tab = ConversationTab.load_from_file(\n                    path,\n                    self._ai_backends,\n                    self\n                )\n                self.add_tab(conversation_tab, f\"Conv: {conversation_id}\")\n                return conversation_tab\n    \n            except ConversationError as e:\n                self._logger.error(\"Failed to open conversation: %s\", str(e))\n                raise\n    \n        def can_fork_conversation(self) -> bool:\n            tab = self._get_current_tab()\n            if not tab or not isinstance(tab, ConversationTab):\n                return False\n    \n            return True\n    \n        async def fork_conversation(self) -> None:\n            \"\"\"Fork an existing conversation into a new tab.\n    \n            Args:\n                conversation_tab: The conversation tab to fork\n            \"\"\"\n            conversation_tab = self._get_current_tab()\n            if not isinstance(conversation_tab, ConversationTab):\n                return\n    \n            try:\n                # Fork the conversation\n                new_tab = await conversation_tab.fork_conversation()\n    \n                # Add new tab to manager\n                self.add_tab(new_tab, f\"Conv: {new_tab.tab_id}\")\n    \n            except ConversationError as e:\n                self._logger.error(\"Failed to fork conversation: %s\", str(e))\n                raise\n    \n        def save_state(self) -> Dict:\n            \"\"\"Get current state of all tabs.\"\"\"\n            tab_columns = []\n            for column in self._tab_columns:\n                tab_states = []\n                for index in range(column.count()):\n                    tab = column.widget(index)\n                    try:\n                        state = tab.get_state(False)\n                        state_dict = state.to_dict()\n                        tab_states.append(state_dict)\n                    except Exception as e:\n                        self._logger.error(\"Failed to save tab manager state: %s\", str(e))\n                        continue\n                tab_columns.append(tab_states)\n    \n            return {\n                'columns': tab_columns,\n            }\n    \n        def restore_state(self, saved_state: Dict) -> None:\n            \"\"\"Restore tabs from saved state.\"\"\"\n            saved_columns = saved_state.get('columns', [])\n    \n            num_columns = len(saved_columns)\n            for index in range(1, num_columns):\n                self._create_column(index)\n    \n            for column_index, tab_state in enumerate(saved_columns):\n                self._restore_column_state(column_index, tab_state)\n    \n        def _restore_column_state(self, column_index: int, tab_states: List[Dict]) -> None:\n            \"\"\"Restore state for a single column of tabs.\"\"\"\n            for state_dict in tab_states:\n                try:\n                    state = TabState.from_dict(state_dict)\n    \n                    if not os.path.isabs(state.path):\n                        state.path = self._workspace_manager.get_workspace_path(state.path)\n    \n                    tab = self._restore_tab_from_state(state)\n                    if not tab:\n                        continue\n    \n                    self._active_column = self._tab_columns[column_index]\n                    title = self._get_tab_title(tab, state)\n                    self.add_tab(tab, title)\n    \n                except Exception as e:\n                    self._logger.error(\"Failed to restore tab manager state: %s\", str(e))\n                    continue\n    \n        def _restore_tab_from_state(self, state: TabState) -> Optional[TabBase]:\n            \"\"\"Create appropriate tab type from state.\"\"\"\n            if state.type == TabType.CONVERSATION:\n                return ConversationTab.restore_from_state(\n                    state, self, ai_backends=self._ai_backends\n                )\n            elif state.type == TabType.EDITOR:\n                tab = EditorTab.restore_from_state(state, self)\n                self._connect_editor_signals(tab)\n                return tab\n    \n            return None\n    \n        def _connect_editor_signals(self, editor: EditorTab) -> None:\n            \"\"\"Connect standard editor tab signals.\"\"\"\n            editor.title_changed.connect(self._handle_tab_title_changed)\n            editor.modified_state_changed.connect(self._handle_tab_modified)\n    \n        def _get_tab_title(self, tab: TabBase, state: TabState) -> str:\n            \"\"\"Get appropriate title for tab type.\"\"\"\n            if isinstance(tab, ConversationTab):\n                return f\"Conv: {tab.tab_id}\"\n    \n            return os.path.basename(state.path)\n    \n        def _handle_style_changed(self, factor: float = 1.0) -> None:\n            \"\"\"\n            Handle style changes from StyleManager.\n    \n            Args:\n                factor: New zoom factor\n            \"\"\"\n            for column in self._tab_columns:\n                selected_border = ColorRole.TAB_BORDER_ACTIVE if column == self._active_column else ColorRole.TAB_BACKGROUND_ACTIVE\n    \n                style = f\"\"\"\n                    QTabBar::tab {{\n                        background: {self._style_manager.get_color_str(ColorRole.TAB_BACKGROUND_INACTIVE)};\n                        border: none;\n                        margin-right: 2px;\n                        border-bottom: 1px solid {self._style_manager.get_color_str(ColorRole.BACKGROUND_PRIMARY)};\n                    }}\n                    QTabBar::tab:selected {{\n                        background: {self._style_manager.get_color_str(ColorRole.TAB_BACKGROUND_ACTIVE)};\n                        border-top: 2px solid {self._style_manager.get_color_str(selected_border)};\n                        border-bottom: none;\n                    }}\n                    QTabBar::tab:hover {{\n                        background: {self._style_manager.get_color_str(ColorRole.TAB_BACKGROUND_HOVER)};\n                    }}\n                    QTabBar::scroller {{\n                        width: 20px;\n                    }}\n                    QTabBar QToolButton {{\n                        background-color: {self._style_manager.get_color_str(ColorRole.TAB_BACKGROUND_INACTIVE)};\n                        border: none;\n                    }}\n                    QTabBar QToolButton::right-arrow {{\n                        image: url({self._style_manager.get_icon_path('arrow-right')});\n                        width: 12px;\n                        height: 12px;\n                    }}\n                    QTabBar QToolButton::left-arrow {{\n                        image: url({self._style_manager.get_icon_path('arrow-left')});\n                        width: 12px;\n                        height: 12px;\n                    }}\n                \"\"\"\n                column.setStyleSheet(style)\n    \n            # Update all tab labels, setting active state only for the current active tab.\n            for tab_id, label in self._tab_labels.items():\n                tab = self._tabs[tab_id]\n                column = self._find_column_for_tab(tab)\n                is_label_active = column == self._active_column and tab == column.currentWidget()\n                label.handle_style_changed(factor, is_label_active)\n    \n            self._column_splitter.setStyleSheet(f\"\"\"\n                QSplitter::handle {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.SPLITTER)};\n                    margin: 0;\n                    width: 1px;\n                }}\n            \"\"\")\n    \n        def can_undo(self) -> bool:\n            tab = self._get_current_tab()\n            return False if not tab else tab.can_undo()\n    \n        def undo(self):\n            self._get_current_tab().undo()\n    \n        def can_redo(self) -> bool:\n            tab = self._get_current_tab()\n            return False if not tab else tab.can_redo()\n    \n        def redo(self):\n            self._get_current_tab().redo()\n    \n        def can_cut(self) -> bool:\n            tab = self._get_current_tab()\n            return False if not tab else tab.can_cut()\n    \n        def cut(self):\n            self._get_current_tab().cut()\n    \n        def can_copy(self) -> bool:\n            tab = self._get_current_tab()\n            return False if not tab else tab.can_copy()\n    \n        def copy(self):\n            self._get_current_tab().copy()\n    \n        def can_paste(self) -> bool:\n            tab = self._get_current_tab()\n            return False if not tab else tab.can_paste()\n    \n        def paste(self):\n            self._get_current_tab().paste()\n    \n        def can_close_all_tabs(self) -> bool:\n            \"\"\"Can we close all the tabs that are open?\"\"\"\n            all_tabs = list(self._tabs.values())\n            for tab in all_tabs:\n                if tab.is_modified and not tab.can_close():\n                    return False\n    \n            return True\n    \n        def close_all_tabs(self) -> None:\n            \"\"\"Close all open tabs.\"\"\"\n            all_tabs = list(self._tabs.values())\n            for tab in all_tabs:\n                self._close_tab_by_id(tab.tab_id)\n    \n        def can_close_tab(self) -> bool:\n            tab = self._get_current_tab()\n            return False if not tab else True\n    \n        def close_tab(self) -> None:\n            \"\"\"Close the currently active tab.\"\"\"\n            tab = self._get_current_tab()\n            if not tab:\n                return\n    \n            self._close_tab_by_id(tab.tab_id)\n    \n        def can_save_file(self) -> bool:\n            tab = self._get_current_tab()\n            return False if not tab else tab.can_save()\n    \n        def save_file(self) -> None:\n            \"\"\"Save the current file.\"\"\"\n            current_tab = self._get_current_tab()\n            if isinstance(current_tab, EditorTab):\n                current_tab.save()\n    \n        def can_save_file_as(self) -> bool:\n            tab = self._get_current_tab()\n            return False if not tab else tab.can_save_as()\n    \n        def save_file_as(self) -> None:\n            \"\"\"Save the current file with a new name.\"\"\"\n            current_tab = self._get_current_tab()\n            if isinstance(current_tab, EditorTab):\n                current_tab.save_as()\n    \n        def can_show_all_columns(self) -> bool:\n            return False if len(self._tab_columns) == 0 else True\n    \n        def show_all_columns(self) -> None:\n            if len(self._tab_columns) < 1:\n                return\n    \n            num_columns = len(self._tab_columns)\n            sizes = [(self.width() // num_columns) for _ in range(num_columns)]\n            self._column_splitter.setSizes(sizes)\n    \n        def can_submit_message(self) -> bool:\n            tab = self._get_current_tab()\n            return False if not tab else tab.can_submit()\n    \n        def submit_message(self) -> None:\n            \"\"\"Handle message submission.\"\"\"\n            tab = self._get_current_tab()\n            if not tab or not tab.can_submit():\n                return\n    \n            tab.submit()\n    \n        def can_show_conversation_settings_dialog(self) -> bool:\n            tab = self._get_current_tab()\n            if not tab or not isinstance(tab, ConversationTab):\n                return False\n    \n            return True\n    \n        def show_conversation_settings_dialog(self) -> None:\n            \"\"\"Show the conversation settings dialog.\"\"\"\n            tab = self._get_current_tab()\n            if not tab or not isinstance(tab, ConversationTab):\n                return\n    \n            dialog = ConversationSettingsDialog(self._ai_backends, self)\n            dialog.set_settings(tab.get_settings())\n    \n            if dialog.exec() == QDialog.Accepted:\n                tab.update_conversation_settings(dialog.get_settings())\n    \n        def handle_esc_key(self) -> bool:\n            \"\"\"Handle processing of the \"Esc\" key.\"\"\"\n            tab = self._get_current_tab()\n            if not tab or not isinstance(tab, ConversationTab):\n                return False\n    \n            tab.cancel_current_tasks()\n            return True\n    ```\n    File: src/humbug/gui/message_box.py\n    ```python\n    \"\"\"Custom message box dialog with consistent styling and scrollable content.\"\"\"\n    \n    from enum import Enum, auto\n    from typing import Optional, List\n    \n    from PySide6.QtWidgets import (\n        QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QPlainTextEdit\n    )\n    from PySide6.QtCore import Qt, QSize\n    from PySide6.QtGui import QPixmap\n    \n    from humbug.gui.color_role import ColorRole\n    from humbug.gui.style_manager import StyleManager\n    \n    \n    class MessageBoxType(Enum):\n        \"\"\"Types of message box with corresponding icon and title.\"\"\"\n        INFORMATION = auto()\n        WARNING = auto()\n        CRITICAL = auto()\n        QUESTION = auto()\n    \n    \n    class MessageBoxButton(Enum):\n        \"\"\"Standard message box buttons.\"\"\"\n        OK = auto()\n        CANCEL = auto()\n        YES = auto()\n        NO = auto()\n        SAVE = auto()\n        DISCARD = auto()\n    \n    \n    class MessageBox(QDialog):\n        \"\"\"Custom message box dialog with consistent styling and scrollable content.\"\"\"\n    \n        def __init__(self, msg_type: MessageBoxType, title: str, text: str,\n                     buttons: List[MessageBoxButton], parent=None):\n            \"\"\"\n            Initialize the message box.\n    \n            Args:\n                msg_type: Type of message box (affects icon and style)\n                title: Title for the dialog\n                text: Main message text\n                buttons: List of buttons to display\n                parent: Optional parent widget\n            \"\"\"\n            super().__init__(parent)\n            self.setWindowTitle(title)\n            self.setModal(True)\n            self.setMinimumWidth(400)\n    \n            # Get style manager for consistent styling\n            self._style_manager = StyleManager()\n    \n            # Create layout with proper spacing\n            layout = QVBoxLayout()\n            layout.setSpacing(12)\n            layout.setContentsMargins(20, 20, 20, 20)\n    \n            # Create header layout for icon and text\n            header_layout = QHBoxLayout()\n            header_layout.setSpacing(12)\n            header_layout.setContentsMargins(0, 0, 0, 0)\n    \n            # Add icon if appropriate\n            icon = self._create_icon(msg_type)\n            if icon:\n                icon_label = QLabel()\n                icon_label.setPixmap(icon)\n                header_layout.addWidget(icon_label, alignment=Qt.AlignTop)\n    \n            # Add message text using QPlainTextEdit\n            self._text_edit = QPlainTextEdit()\n            self._text_edit.setPlainText(text)\n            self._text_edit.setReadOnly(True)\n            self._text_edit.setFrameStyle(0)  # No frame\n    \n            # Calculate size based on content\n            doc = self._text_edit.document()\n            margins = self._text_edit.contentsMargins()\n            line_count = doc.lineCount()\n            font_metrics = self._text_edit.fontMetrics()\n            line_height = font_metrics.lineSpacing()\n    \n            # For short messages (1-2 lines), use fixed height with small margin\n            if line_count <= 2:\n                content_height = ((line_count + 2) * line_height) + margins.top() + margins.bottom()\n                self._text_edit.setFixedHeight(content_height)\n                self._text_edit.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n            else:\n                # For longer messages, set reasonable max height with scrollbar\n                content_height = min(30 * line_height, int(self.screen().geometry().height() * 0.8))\n                self._text_edit.setMinimumHeight(40)  # Minimum 2 lines\n                self._text_edit.setMaximumHeight(content_height)\n                self._text_edit.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\n    \n            header_layout.addWidget(self._text_edit, stretch=1)\n            layout.addLayout(header_layout)\n    \n            # Add buttons\n            button_layout = QHBoxLayout()\n            button_layout.setSpacing(8)\n    \n            self._button_results = {}\n            default_button = None\n            escape_button = None\n    \n            for button in buttons:\n                btn = QPushButton(self._get_button_text(button))\n                btn.setMinimumSize(QSize(90, 40))\n                btn.setContentsMargins(8, 8, 8, 8)\n                self._button_results[btn] = button\n                btn.clicked.connect(self._handle_button)\n                button_layout.addWidget(btn)\n    \n                # Set default and escape buttons appropriately\n                if button in (MessageBoxButton.OK, MessageBoxButton.YES):\n                    default_button = btn\n                elif button in (MessageBoxButton.CANCEL, MessageBoxButton.NO):\n                    escape_button = btn\n    \n            # If no default button set, use first button\n            if not default_button and buttons:\n                default_button = next(iter(self._button_results.keys()))\n    \n            if default_button:\n                default_button.setDefault(True)\n    \n            # Store escape button for key handling\n            self._escape_button = escape_button\n    \n            # Add spacing before buttons only if we have a scrollbar\n            if line_count > 2:\n                layout.addSpacing(12)\n    \n            layout.addLayout(button_layout)\n            self.setLayout(layout)\n    \n            # Apply styling\n            self._handle_style_changed()\n    \n            # Store result\n            self.result_button: Optional[MessageBoxButton] = None\n    \n        def _create_icon(self, msg_type: MessageBoxType) -> Optional[QPixmap]:\n            \"\"\"Create appropriate icon for message type.\"\"\"\n            # Map message types to icon names\n            icon_names = {\n                MessageBoxType.INFORMATION: \"info\",\n                MessageBoxType.WARNING: \"warning\",\n                MessageBoxType.CRITICAL: \"critical\",\n                MessageBoxType.QUESTION: \"question\"\n            }\n    \n            icon_name = icon_names.get(msg_type)\n            if not icon_name:\n                return None\n    \n            icon_path = self._style_manager.get_icon_path(icon_name)\n            return self._style_manager.scale_icon(icon_path, 32)\n    \n        def _get_button_text(self, button: MessageBoxButton) -> str:\n            \"\"\"Get display text for button type.\"\"\"\n            return {\n                MessageBoxButton.OK: \"OK\",\n                MessageBoxButton.CANCEL: \"Cancel\",\n                MessageBoxButton.YES: \"Yes\",\n                MessageBoxButton.NO: \"No\",\n                MessageBoxButton.SAVE: \"Save\",\n                MessageBoxButton.DISCARD: \"Discard\"\n            }[button]\n    \n        def _handle_button(self):\n            \"\"\"Handle button clicks.\"\"\"\n            button = self.sender()\n            self.result_button = self._button_results[button]\n            self.accept()\n    \n        def keyPressEvent(self, event):\n            \"\"\"Handle key events, specifically for Escape key.\"\"\"\n            if event.key() == Qt.Key_Escape and self._escape_button:\n                self.result_button = self._button_results[self._escape_button]\n                self.reject()\n    \n            return super().keyPressEvent(event)\n    \n        def _handle_style_changed(self) -> None:\n            \"\"\"Update styling when application style changes.\"\"\"\n            style_manager = self._style_manager\n            zoom_factor = style_manager.zoom_factor\n            base_font_size = style_manager.base_font_size\n    \n            # Update font sizes\n            font = self.font()\n            font.setPointSizeF(base_font_size * zoom_factor)\n            self.setFont(font)\n    \n            # Apply scrollbar styling\n            self._text_edit.setStyleSheet(f\"\"\"\n                QPlainTextEdit {{\n                    border: none;\n                    background-color: {style_manager.get_color_str(ColorRole.BACKGROUND_DIALOG)};\n                    color: {style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    font-size: {base_font_size * zoom_factor}pt;\n                }}\n                QScrollBar:vertical {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_BACKGROUND)};\n                    width: 12px;\n                }}\n                QScrollBar::handle:vertical {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_HANDLE)};\n                    min-height: 20px;\n                }}\n                QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {{\n                    background: none;\n                }}\n                QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{\n                    height: 0px;\n                }}\n            \"\"\")\n    \n            # Apply consistent dialog styling\n            self.setStyleSheet(f\"\"\"\n                QDialog {{\n                    background-color: {style_manager.get_color_str(ColorRole.BACKGROUND_DIALOG)};\n                }}\n                QLabel {{\n                    color: {style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    background-color: {style_manager.get_color_str(ColorRole.BACKGROUND_DIALOG)};\n                    font-size: {base_font_size * zoom_factor}pt;\n                }}\n                QPushButton {{\n                    background-color: {style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND)};\n                    color: {style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    border: none;\n                    border-radius: 4px;\n                    padding: 8px;\n                }}\n                QPushButton:hover {{\n                    background-color: {style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND_HOVER)};\n                }}\n                QPushButton:pressed {{\n                    background-color: {style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND_PRESSED)};\n                }}\n                QPushButton:disabled {{\n                    background-color: {style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND_DISABLED)};\n                    color: {style_manager.get_color_str(ColorRole.TEXT_DISABLED)};\n                }}\n            \"\"\")\n    \n        @classmethod\n        def show_message(cls, parent, msg_type: MessageBoxType, title: str, text: str,\n                        buttons: List[MessageBoxButton] = None) -> MessageBoxButton:\n            \"\"\"\n            Show a message box and return the clicked button.\n    \n            Args:\n                parent: Parent widget\n                msg_type: Type of message box\n                title: Dialog title\n                text: Message text\n                buttons: List of buttons (defaults to just OK)\n    \n            Returns:\n                The MessageBoxButton that was clicked\n            \"\"\"\n            if not buttons:\n                buttons = [MessageBoxButton.OK]\n    \n            dialog = cls(msg_type, title, text, buttons, parent)\n            dialog.exec()\n            return dialog.result_button\n    ```\n    File: src/humbug/gui/workspace_file_tree.py\n    ```python\n    \"\"\"File tree view implementation for workspace files.\"\"\"\n    \n    import os\n    from typing import Optional\n    \n    from PySide6.QtWidgets import (\n        QTreeView, QFileSystemModel, QWidget, QVBoxLayout\n    )\n    from PySide6.QtCore import Signal, QModelIndex, Qt\n    \n    from humbug.gui.color_role import ColorRole\n    from humbug.gui.style_manager import StyleManager\n    from humbug.gui.workspace_file_model import WorkspaceFileModel\n    \n    \n    class WorkspaceFileTree(QWidget):\n        \"\"\"Tree view widget for displaying workspace files.\"\"\"\n    \n        file_activated = Signal(str)  # Emits path when file is activated\n    \n        def __init__(self, parent=None):\n            \"\"\"Initialize the file tree widget.\"\"\"\n            super().__init__(parent)\n    \n            self._style_manager = StyleManager()\n    \n            # Create layout\n            layout = QVBoxLayout(self)\n            layout.setContentsMargins(0, 0, 0, 0)\n            layout.setSpacing(0)\n    \n            # Create tree view\n            self._tree_view = QTreeView()\n            self._tree_view.setHeaderHidden(True)\n            self._tree_view.setAnimated(True)\n            self._tree_view.header().setSortIndicator(0, Qt.AscendingOrder)\n            self._tree_view.setSortingEnabled(True)\n    \n            # Create file system model\n            self._fs_model = QFileSystemModel()\n            self._fs_model.setReadOnly(True)\n    \n            # Create filter model\n            self._filter_model = WorkspaceFileModel()\n            self._filter_model.setSourceModel(self._fs_model)\n    \n            # Set model on tree view\n            self._tree_view.setModel(self._filter_model)\n    \n            # Connect signals\n            self._tree_view.activated.connect(self._handle_activation)\n    \n            # Add to layout\n            layout.addWidget(self._tree_view)\n    \n            # Hide horizontal scrollbar\n            self._tree_view.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n    \n            # Apply styling\n            self._handle_style_changed()\n    \n            # Track current workspace\n            self._workspace_path: Optional[str] = None\n            self._style_manager.style_changed.connect(self._handle_style_changed)\n    \n        def set_workspace(self, path: str):\n            \"\"\"Set the workspace root directory.\"\"\"\n            if not path:\n                # Clear the model when no workspace is active\n                self._fs_model.setRootPath(\"\")\n                self._filter_model.set_workspace_root(None)\n                self._tree_view.setRootIndex(self._filter_model.mapFromSource(\n                    self._fs_model.index(\"\")\n                ))\n                return\n    \n            self._fs_model.setRootPath(path)\n            self._filter_model.set_workspace_root(path)\n    \n            # Set the root index through the proxy model\n            root_index = self._filter_model.mapFromSource(\n                self._fs_model.index(path)\n            )\n            self._tree_view.setRootIndex(root_index)\n    \n            # Hide size, type, and date columns\n            self._tree_view.header().hideSection(1)  # Size\n            self._tree_view.header().hideSection(2)  # Type\n            self._tree_view.header().hideSection(3)  # Date\n    \n            # Expand first level\n            self._tree_view.expandToDepth(0)\n    \n        def _handle_activation(self, index: QModelIndex):\n            \"\"\"Handle item activation (double-click or Enter).\"\"\"\n            # Get the file path from the source model\n            source_index = self._filter_model.mapToSource(index)\n            path = self._fs_model.filePath(source_index)\n    \n            # Only emit for files, not directories\n            if os.path.isfile(path):\n                self.file_activated.emit(path)\n    \n        def _handle_style_changed(self):\n            \"\"\"Update styling when application style changes.\"\"\"\n            zoom_factor = self._style_manager.zoom_factor\n            base_font_size = self._style_manager.base_font_size\n    \n            # Update font size\n            font = self.font()\n            font.setPointSizeF(base_font_size * zoom_factor)\n            self.setFont(font)\n            self._tree_view.setFont(font)\n    \n            self.setStyleSheet(f\"\"\"\n                QTreeView {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.BACKGROUND_SECONDARY)};\n                    border: none;\n                    padding: 0px;\n                }}\n                QTreeView::item {{\n                    color: {self._style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    padding: 4px;\n                }}\n                QTreeView::item:selected {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.TAB_BACKGROUND_ACTIVE)};\n                }}\n                QTreeView::item:hover {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.TAB_BACKGROUND_HOVER)};\n                }}\n                QTreeView::branch {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.BACKGROUND_SECONDARY)};\n                }}\n                QTreeView::branch:has-children:!has-siblings:closed,\n                QTreeView::branch:closed:has-children:has-siblings {{\n                    image: url(\"{self._style_manager.get_icon_path(\"arrow-right\")}\");\n                    padding: 4px;\n                }}\n                QTreeView::branch:open:has-children:!has-siblings,\n                QTreeView::branch:open:has-children:has-siblings {{\n                    image: url(\"{self._style_manager.get_icon_path(\"arrow-down\")}\");\n                    padding: 4px;\n                }}\n                QScrollBar:vertical {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_BACKGROUND)};\n                    width: 12px;\n                }}\n                QScrollBar::handle:vertical {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_HANDLE)};\n                    min-height: 20px;\n                }}\n                QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {{\n                    background: none;\n                }}\n                QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{\n                    height: 0px;\n                }}\n            \"\"\")\n    ```\n    File: src/humbug/gui/line_number_area.py\n    ```python\n    from PySide6.QtWidgets import QWidget\n    from PySide6.QtCore import QSize\n    \n    \n    class LineNumberArea(QWidget):\n        \"\"\"Widget that displays line numbers for the editor.\"\"\"\n    \n        def __init__(self, editor):\n            \"\"\"Initialize the line number area.\"\"\"\n            super().__init__(editor)\n            self._editor = editor\n    \n        def sizeHint(self):\n            \"\"\"Get the needed width for the widget.\"\"\"\n            return QSize(self._editor.line_number_area_width(), 0)\n    \n        def paintEvent(self, event):\n            \"\"\"Paint the line numbers.\"\"\"\n            self._editor.line_number_area_paint_event(event)\n    ```\n    File: src/humbug/gui/tab_column.py\n    ```python\n    \"\"\"Columns for managing tabs with drag and drop support.\"\"\"\n    \n    from PySide6.QtWidgets import QTabWidget\n    from PySide6.QtCore import Signal, QEvent\n    from PySide6.QtGui import QDragEnterEvent, QDropEvent\n    \n    \n    class TabColumn(QTabWidget):\n        \"\"\"Enhanced QTabWidget for use in columns with drag and drop support.\"\"\"\n    \n        column_activated = Signal(QTabWidget)\n        tab_drop = Signal(str, QTabWidget, int)  # tab_id, target_column, target_index\n    \n        def __init__(self, parent=None):\n            \"\"\"Initialize the tab widget.\"\"\"\n            super().__init__(parent)\n            self.setMovable(True)\n            self.setDocumentMode(True)\n    \n            # Enable drag and drop\n            self.setAcceptDrops(True)\n    \n            # Configure tab bar\n            tab_bar = self.tabBar()\n            tab_bar.setDrawBase(False)\n            tab_bar.setUsesScrollButtons(True)\n    \n            # Install event filter on all child widgets\n            self.installEventFilter(self)\n            tab_bar.installEventFilter(self)\n    \n        def eventFilter(self, obj, event) -> bool:\n            \"\"\"Handle window activation and mouse events to detect active column.\"\"\"\n            if event.type() in (QEvent.MouseButtonPress, QEvent.FocusIn):\n                # Emit activation on mouse press or focus\n                self.column_activated.emit(self)\n                return False  # Don't consume the event\n    \n            return super().eventFilter(obj, event)\n    \n        def addTab(self, widget, *args, **kwargs):\n            \"\"\"Override addTab to install event filter on new tabs.\"\"\"\n            result = super().addTab(widget, *args, **kwargs)\n            # Install event filter on the widget to catch focus/mouse events\n            widget.installEventFilter(self)\n            return result\n    \n        def removeTab(self, index):\n            \"\"\"Override removeTab to properly clean up event filters.\"\"\"\n            widget = self.widget(index)\n            if widget:\n                widget.removeEventFilter(self)\n    \n            super().removeTab(index)\n    \n        def dragEnterEvent(self, event: QDragEnterEvent):\n            \"\"\"Handle drag enter events for tab drops.\"\"\"\n            if event.mimeData().hasFormat(\"application/x-humbug-tab\"):\n                event.acceptProposedAction()\n            else:\n                event.ignore()\n    \n        def dragMoveEvent(self, event):\n            \"\"\"Handle drag move events to show insertion position.\"\"\"\n            if event.mimeData().hasFormat(\"application/x-humbug-tab\"):\n                event.acceptProposedAction()\n    \n                # Map cursor position to the tab bar to find insertion position\n                pos = self.tabBar().mapFromParent(event.pos())\n                _index = self.tabBar().tabAt(pos)\n                # Note: Could add visual indicator of insertion position here if desired\n            else:\n                event.ignore()\n    \n        def dropEvent(self, event: QDropEvent):\n            \"\"\"Handle drop events for tab movement.\"\"\"\n            mime_data = event.mimeData()\n            if mime_data.hasFormat(\"application/x-humbug-tab\"):\n                # Extract tab ID from mime data\n                tab_id = mime_data.data(\"application/x-humbug-tab\").data().decode()\n    \n                # Map the drop position to the tab bar\n                pos = self.tabBar().mapFromParent(event.pos())\n                target_index = self.tabBar().tabAt(pos)\n    \n                # If dropped past the last tab, append\n                if target_index == -1:\n                    target_index = self.count()\n    \n                # Emit signal with drop info for tab manager to handle\n                self.tab_drop.emit(tab_id, self, target_index)\n                event.acceptProposedAction()\n            else:\n                event.ignore()\n    ```\n    File: src/humbug/gui/editor_highlighter.py\n    ```python\n    \"\"\"Editor highlighter.\"\"\"\n    \n    import logging\n    from typing import Optional\n    \n    from PySide6.QtGui import (\n        QSyntaxHighlighter, QTextDocument, QTextBlockUserData\n    )\n    from humbug.gui.style_manager import StyleManager\n    from humbug.syntax.programming_language import ProgrammingLanguage\n    from humbug.syntax.parser_registry import ParserRegistry\n    \n    \n    class EditorHighlighterBlockData(QTextBlockUserData):\n        \"\"\"Data associated with each text block.\"\"\"\n        def __init__(self):\n            super().__init__()\n            self.parser_state = None\n    \n    \n    class EditorHighlighter(QSyntaxHighlighter):\n        \"\"\"Syntax highlighter for source code files.\"\"\"\n    \n        def __init__(self, parent: Optional[QTextDocument] = None) -> None:\n            \"\"\"Initialize the highlighter.\"\"\"\n            super().__init__(parent)\n    \n            # Consistent font family fallback sequence for all code formats\n            self._style_manager = StyleManager()\n            self._language = ProgrammingLanguage.TEXT\n            self._logger = logging.getLogger(\"EditorHighlighter\")\n    \n        def set_language(self, language: ProgrammingLanguage) -> None:\n            \"\"\"\n            Set the programming language for syntax highlighting.\n    \n            Args:\n                language: The programming language to use\n            \"\"\"\n            if self._language != language:\n                self._language = language\n                self.rehighlight()\n    \n        def highlightBlock(self, text: str) -> None:\n            \"\"\"Apply highlighting to the given block of text.\"\"\"\n            try:\n                current_block = self.currentBlock()\n                prev_block = current_block.previous()\n    \n                prev_block_data: EditorHighlighterBlockData = None\n                prev_parser_state = None\n    \n                if prev_block:\n                    prev_block_data = prev_block.userData()\n                    if prev_block_data:\n                        prev_parser_state = prev_block_data.parser_state\n    \n                continuation_state = -1\n                current_block_data: EditorHighlighterBlockData = current_block.userData()\n    \n                # Use the appropriate language parser\n                parser = ParserRegistry.create_parser(self._language)\n                if not parser:\n                    return\n    \n                parser_state = parser.parse(prev_parser_state, text)\n    \n                # Apply syntax highlighting based on token types\n                while True:\n                    token = parser.get_next_token()\n                    if token is None:\n                        break\n    \n                    self.setFormat(\n                        token.start,\n                        len(token.value),\n                        self._style_manager.get_highlight(token.type)\n                    )\n    \n                # Check if we need to rehighlight everything from this block onwards\n                if current_block_data:\n                    current_parser_state = current_block_data.parser_state\n                    if current_parser_state:\n                        continuation_state = current_parser_state.continuation_state\n    \n                if continuation_state != parser_state.continuation_state:\n                    self.setCurrentBlockState(self.currentBlockState() + 1)\n    \n                block_data = EditorHighlighterBlockData()\n                block_data.parser_state = parser_state\n                current_block.setUserData(block_data)\n    \n            except Exception:\n                self._logger.exception(\"highlighting exception\")\n    ```\n    File: src/humbug/gui/color_role.py\n    ```python\n    \"\"\"Handle application styling\"\"\"\n    \n    from enum import Enum, auto\n    \n    \n    class ColorRole(Enum):\n        \"\"\"Enumeration of color roles in the application.\"\"\"\n        # Background colours\n        BACKGROUND_PRIMARY = auto()         # Main window background\n        BACKGROUND_SECONDARY = auto()       # Secondary elements background\n        BACKGROUND_DIALOG = auto()          # Dialog box background\n    \n        # Text colours\n        TEXT_PRIMARY = auto()               # Primary text color\n        TEXT_DISABLED = auto()              # Disabled text color\n        TEXT_SELECTED = auto()              # Selected text background\n    \n        # Tab colours\n        TAB_BACKGROUND_ACTIVE = auto()      # Active tab background\n        TAB_INACTIVE = auto()               # Inactive tab text colour\n        TAB_BACKGROUND_INACTIVE = auto()    # Inactive tab background\n        TAB_BACKGROUND_HOVER = auto()       # Tab hover background\n        TAB_BORDER_ACTIVE = auto()          # Active tab border\n    \n        # Button colours\n        BUTTON_BACKGROUND = auto()          # Push button background\n        BUTTON_BACKGROUND_DISABLED = auto()\n                                            # Disabled push button background\n        BUTTON_BACKGROUND_PRESSED = auto()  # Pressed push button background\n        BUTTON_BACKGROUND_HOVER = auto()    # Hover state push button background\n    \n        # Menu elements\n        MENU_BACKGROUND = auto()            # Menu background\n        MENU_HOVER = auto()                 # Menu item hover\n    \n        # Splitter bars\n        SPLITTER = auto()                   # Splitter bar\n    \n        # Scroll bar elements\n        SCROLLBAR_BACKGROUND = auto()       # Scrollbar background\n        SCROLLBAR_HANDLE = auto()           # Scrollbar handle\n    \n        # Message colours\n        MESSAGE_BACKGROUND = auto()         # Message background\n        MESSAGE_USER = auto()               # User message background\n        MESSAGE_AI = auto()                 # AI message background\n        MESSAGE_SYSTEM = auto()             # System message background\n    \n        # Status bar elements\n        STATUS_BAR_BACKGROUND = auto()      # Status bar background\n    \n        # Close button states\n        CLOSE_BUTTON_BACKGROUND_HOVER = auto()\n                                            # Hover state close button background\n    \n        # Editor line numbers\n        LINE_NUMBER = auto()                # Line number\n    \n        # Syntax highlighting\n        SYNTAX_BACKTICK_CODE = auto()\n        SYNTAX_CODE = auto()\n        SYNTAX_COMMENT = auto()\n        SYNTAX_CSS_AT_RULE = auto()\n        SYNTAX_ELEMENT = auto()\n        SYNTAX_ERROR = auto()\n        SYNTAX_FUNCTION_OR_METHOD = auto()\n        SYNTAX_HEADING = auto()\n        SYNTAX_HTML_ATTRIBUTE = auto()\n        SYNTAX_HTML_DOCTYPE = auto()\n        SYNTAX_HTML_TAG = auto()\n        SYNTAX_IDENTIFIER = auto()\n        SYNTAX_KEYWORD = auto()\n        SYNTAX_LANGUAGE = auto()\n        SYNTAX_NUMBER = auto()\n        SYNTAX_OPERATOR = auto()\n        SYNTAX_PREPROCESSOR = auto()\n        SYNTAX_REGEXP = auto()\n        SYNTAX_STRING = auto()\n        SYNTAX_TEXT = auto()\n    ```\n    File: src/humbug/gui/conversation_settings_dialog.py\n    ```python\n    \"\"\"Dialog for configuring conversation-specific settings.\"\"\"\n    \n    from typing import Dict, List\n    \n    from PySide6.QtWidgets import (\n        QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,\n        QComboBox, QDoubleSpinBox\n    )\n    from PySide6.QtCore import Signal, Qt\n    \n    from humbug.ai.ai_backend import AIBackend\n    from humbug.ai.conversation_settings import ConversationSettings\n    from humbug.gui.color_role import ColorRole\n    from humbug.gui.style_manager import StyleManager\n    \n    \n    class ConversationSettingsDialog(QDialog):\n        \"\"\"Dialog for editing conversation settings.\"\"\"\n    \n        settings_changed = Signal(ConversationSettings)\n    \n        def __init__(self, ai_backends: Dict[str, AIBackend], parent=None):\n            \"\"\"Initialize the conversation settings dialog.\"\"\"\n            super().__init__(parent)\n            self.setWindowTitle(\"Conversation Settings\")\n            self.setMinimumWidth(500)\n            self.setModal(True)\n    \n            self._ai_backends = ai_backends\n            self._available_models: List[str] = []\n            self._initial_settings = None\n            self._current_settings = None\n            self._model_temperatures = {}\n    \n            style_manager = StyleManager()\n    \n            # Main layout with proper spacing\n            layout = QVBoxLayout()\n            layout.setSpacing(12)  # Slightly increased spacing\n            layout.setContentsMargins(20, 20, 20, 20)\n    \n            # Model selection\n            model_layout = QHBoxLayout()\n            model_label = QLabel(\"AI Model:\")\n            model_label.setMinimumHeight(40)\n            self._model_combo = QComboBox()\n            self._model_combo.setMinimumWidth(300)\n            self._model_combo.setMinimumHeight(40)  # Match label height\n            self._model_combo.currentTextChanged.connect(self._handle_model_change)\n            model_layout.addWidget(model_label)\n            model_layout.addStretch()\n            model_layout.addWidget(self._model_combo)\n            layout.addLayout(model_layout)\n    \n            # Temperature setting\n            temp_layout = QHBoxLayout()\n            temp_label = QLabel(\"Temperature:\")\n            temp_label.setMinimumHeight(40)\n            self.temp_spin = QDoubleSpinBox()\n            self.temp_spin.setRange(0.0, 1.0)\n            self.temp_spin.setSingleStep(0.100000000001)  # Increased step size to avoid FP issues\n            self.temp_spin.setDecimals(1)\n            self.temp_spin.setMinimumWidth(300)  # Match combo box width\n            self.temp_spin.setMinimumHeight(40)  # Match label height\n            temp_layout.addWidget(temp_label)\n            temp_layout.addStretch()\n            temp_layout.addWidget(self.temp_spin)\n            layout.addLayout(temp_layout)\n    \n            # Context window display\n            context_layout = QHBoxLayout()\n            context_label = QLabel(\"Context Window:\")\n            context_label.setMinimumHeight(40)\n            self.context_value = QLabel()\n            self.context_value.setMinimumWidth(300)  # Match combo box width\n            self.context_value.setMinimumHeight(40)  # Match label height\n            self.context_value.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)\n            context_layout.addWidget(context_label)\n            context_layout.addStretch()\n            context_layout.addWidget(self.context_value)\n            layout.addLayout(context_layout)\n    \n            # Max output display\n            output_layout = QHBoxLayout()\n            output_label = QLabel(\"Max Output Tokens:\")\n            output_label.setMinimumHeight(40)\n            self.output_value = QLabel()\n            self.output_value.setMinimumWidth(300)  # Match combo box width\n            self.output_value.setMinimumHeight(40)  # Match label height\n            self.output_value.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)\n            output_layout.addWidget(output_label)\n            output_layout.addStretch()\n            output_layout.addWidget(self.output_value)\n            layout.addLayout(output_layout)\n    \n            # Add extra spacing before buttons (24px since our base spacing is 12px)\n            layout.addSpacing(24)\n            layout.addStretch()\n    \n            # Button row with proper spacing and alignment\n            button_layout = QHBoxLayout()\n            button_layout.setSpacing(8)  # Slightly increased button spacing\n    \n            self.ok_button = QPushButton(\"OK\")\n            self.cancel_button = QPushButton(\"Cancel\")\n            self.apply_button = QPushButton(\"Apply\")\n    \n            self.ok_button.clicked.connect(self._handle_ok)\n            self.cancel_button.clicked.connect(self.reject)\n            self.apply_button.clicked.connect(self._handle_apply)\n    \n            self._model_combo.currentTextChanged.connect(self._handle_value_change)\n            self.temp_spin.valueChanged.connect(self._handle_value_change)\n    \n            # Set minimum button widths and heights\n            min_button_width = 90  # Slightly increased\n            min_button_height = 40  # Match other controls\n            for button in [self.ok_button, self.cancel_button, self.apply_button]:\n                button.setMinimumWidth(min_button_width)\n                button.setMinimumHeight(min_button_height)\n                button.setContentsMargins(8, 8, 8, 8)\n                button_layout.addWidget(button)\n    \n            layout.addLayout(button_layout)\n            self.setLayout(layout)\n    \n            # Apply consistent dialog styling\n            self.setStyleSheet(f\"\"\"\n                QDialog {{\n                    background-color: {style_manager.get_color_str(ColorRole.BACKGROUND_DIALOG)};\n                }}\n                QLabel {{\n                    color: {style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    background-color: {style_manager.get_color_str(ColorRole.BACKGROUND_DIALOG)};\n                }}\n                QComboBox {{\n                    background-color: {style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND)};\n                    color: {style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    border: none;\n                    border-radius: 4px;\n                    padding: 8px;\n                }}\n                QComboBox:disabled {{\n                    background-color: {style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND_DISABLED)};\n                    color: {style_manager.get_color_str(ColorRole.TEXT_DISABLED)};\n                }}\n                QComboBox::drop-down {{\n                    border: none;\n                    width: 20px;\n                }}\n                QComboBox::down-arrow {{\n                    image: url({style_manager.get_icon_path(\"arrow-down\")});\n                    width: 12px;\n                    height: 12px;\n                }}\n                QComboBox::down-arrow:on {{\n                    image: url({style_manager.get_icon_path('arrow-up')});\n                    width: 12px;\n                    height: 12px;\n                }}\n                QComboBox::down-arrow:disabled {{\n                    image: none;\n                }}\n                QComboBox QAbstractItemView {{\n                    background: {style_manager.get_color_str(ColorRole.BACKGROUND_DIALOG)};\n                    selection-background-color: {style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND_HOVER)};\n                    selection-color: {style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                }}\n                QDoubleSpinBox {{\n                    background-color: {style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND)};\n                    color: {style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    border: none;\n                    border-radius: 4px;\n                    padding: 8px;\n                }}\n                QDoubleSpinBox:disabled {{\n                    background-color: {style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND_DISABLED)};\n                    color: {style_manager.get_color_str(ColorRole.TEXT_DISABLED)};\n                }}\n                QDoubleSpinBox::up-button, QDoubleSpinBox::down-button {{\n                    border: none;\n                    width: 20px;\n                }}\n                QDoubleSpinBox::up-arrow {{\n                    image: url({style_manager.get_icon_path('arrow-up')});\n                    width: 12px;\n                    height: 12px;\n                }}\n                QDoubleSpinBox::up-arrow:disabled, QDoubleSpinBox::up-arrow:off {{\n                    image: none;\n                }}\n                QDoubleSpinBox::down-arrow {{\n                    image: url({style_manager.get_icon_path('arrow-down')});\n                    width: 12px;\n                    height: 12px;\n                }}\n                QDoubleSpinBox::down-arrow:disabled, QDoubleSpinBox::down-arrow:off {{\n                    image: none;\n                }}\n                QLabel[valueDisplay=\"true\"] {{\n                    background-color: {style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND_DISABLED)};\n                    color: {style_manager.get_color_str(ColorRole.TEXT_DISABLED)};\n                    border: none;\n                    border-radius: 4px;\n                    padding: 8px;\n                }}\n                QPushButton {{\n                    background-color: {style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND)};\n                    color: {style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    border: none;\n                    border-radius: 4px;\n                    padding: 8px;\n                }}\n                QPushButton:hover {{\n                    background-color: {style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND_HOVER)};\n                }}\n                QPushButton:pressed {{\n                    background-color: {style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND_PRESSED)};\n                }}\n                QPushButton:disabled {{\n                    background-color: {style_manager.get_color_str(ColorRole.BUTTON_BACKGROUND_DISABLED)};\n                    color: {style_manager.get_color_str(ColorRole.TEXT_DISABLED)};\n                }}\n            \"\"\")\n    \n        def _handle_model_change(self, model: str):\n            \"\"\"Handle model selection changes.\"\"\"\n            supports_temp = ConversationSettings.supports_temperature(model)\n            self.temp_spin.setEnabled(supports_temp)\n    \n            # Get and display model limits\n            limits = ConversationSettings.get_model_limits(model)\n            self.context_value.setText(f\"{limits['context_window']:,} tokens\")\n            self.context_value.setProperty('valueDisplay', True)\n            self.context_value.style().unpolish(self.context_value)\n            self.context_value.style().polish(self.context_value)\n    \n            self.output_value.setText(f\"{limits['max_output_tokens']:,} tokens\")\n            self.output_value.setProperty('valueDisplay', True)\n            self.output_value.style().unpolish(self.output_value)\n            self.output_value.style().polish(self.output_value)\n    \n            if supports_temp:\n                if model in self._model_temperatures:\n                    self.temp_spin.setValue(self._model_temperatures[model])\n                else:\n                    # If we haven't stored a temperature for this model yet,\n                    # use the initial setting if it exists, otherwise default to 0.7\n                    if (self._initial_settings and\n                        self._initial_settings.model == model and\n                        self._initial_settings.temperature is not None):\n                        self.temp_spin.setValue(self._initial_settings.temperature)\n                    else:\n                        self.temp_spin.setValue(0.7)\n            else:\n                self.temp_spin.setValue(0.0)\n    \n            # Store the temperature for the current model if it supports it\n            if supports_temp:\n                self._model_temperatures[model] = self.temp_spin.value()\n    \n            self._handle_value_change()\n    \n        def _handle_value_change(self):\n            \"\"\"Handle changes to any setting value.\"\"\"\n            if not self._current_settings:\n                return\n    \n            current_model = self._model_combo.currentText()\n            current_temp = self.temp_spin.value() if ConversationSettings.supports_temperature(current_model) else None\n    \n            self.apply_button.setEnabled(\n                current_model != self._current_settings.model or\n                abs(current_temp - self._current_settings.temperature) > 0.01\n            )\n    \n        def get_settings(self) -> ConversationSettings:\n            \"\"\"Get the current settings from the dialog.\"\"\"\n            model = self._model_combo.currentText()\n            temperature = self.temp_spin.value() if ConversationSettings.supports_temperature(model) else None\n            return ConversationSettings(model=model, temperature=temperature)\n    \n        def set_settings(self, settings: ConversationSettings):\n            \"\"\"Set the current settings in the dialog.\"\"\"\n            models = []\n            for model in ConversationSettings.AVAILABLE_MODELS:\n                provider = ConversationSettings.get_provider(model)\n                if provider in self._ai_backends:\n                    models.append(model)\n    \n            self._available_models = models\n            self._model_combo.clear()\n            self._model_combo.addItems(models)\n    \n            self._initial_settings = ConversationSettings(\n                model=settings.model,\n                temperature=settings.temperature\n            )\n            self._current_settings = ConversationSettings(\n                model=settings.model,\n                temperature=settings.temperature\n            )\n    \n            # Initialize temperature tracking for this dialog session\n            self._model_temperatures = {\n                settings.model: settings.temperature if settings.temperature is not None else 0.7\n            }\n    \n            model_index = self._model_combo.findText(settings.model)\n            if model_index >= 0:\n                self._model_combo.setCurrentIndex(model_index)\n    \n            # Update limits display for the current model\n            limits = ConversationSettings.get_model_limits(settings.model)\n            self.context_value.setText(f\"{limits['context_window']:,} tokens\")\n            self.output_value.setText(f\"{limits['max_output_tokens']:,} tokens\")\n    \n            supports_temp = ConversationSettings.supports_temperature(settings.model)\n            self.temp_spin.setEnabled(supports_temp)\n            if supports_temp and settings.temperature is not None:\n                self.temp_spin.setValue(settings.temperature)\n            else:\n                self.temp_spin.setValue(0.0)\n    \n            self.apply_button.setEnabled(False)\n    \n        def _handle_apply(self):\n            \"\"\"Handle Apply button click.\"\"\"\n            current_model = self._model_combo.currentText()\n            if ConversationSettings.supports_temperature(current_model):\n                self._model_temperatures[current_model] = self.temp_spin.value()\n    \n            settings = self.get_settings()\n            self._current_settings = settings\n            self.settings_changed.emit(settings)\n            self.apply_button.setEnabled(False)\n    \n        def _handle_ok(self):\n            \"\"\"Handle OK button click.\"\"\"\n            self._handle_apply()\n            self.accept()\n    \n        def reject(self):\n            \"\"\"Handle Cancel button click.\"\"\"\n            if self._initial_settings:\n                self.settings_changed.emit(self._initial_settings)\n            super().reject()\n    ```\n    File: src/humbug/gui/status_message.py\n    ```python\n    \"\"\"Status message container for application-wide status bar.\"\"\"\n    \n    from dataclasses import dataclass\n    from typing import Optional\n    \n    \n    @dataclass\n    class StatusMessage:\n        \"\"\"Container for status bar message information.\"\"\"\n        text: str\n        timeout: Optional[int] = None  # Milliseconds before reverting to previous message\n    ```\n    File: src/humbug/gui/tab_type.py\n    ```python\n    from enum import Enum, auto\n    \n    \n    class TabType(Enum):\n        \"\"\"Enumeration of available tab types.\"\"\"\n        CONVERSATION = auto()\n        EDITOR = auto()\n    ```\n    File: src/humbug/gui/welcome_widget.py\n    ```python\n    \"\"\"Welcome message widget implementation.\"\"\"\n    \n    from PySide6.QtWidgets import QVBoxLayout, QLabel, QFrame\n    from PySide6.QtCore import Qt\n    from PySide6.QtGui import QPixmap\n    \n    from humbug import format_version\n    from humbug.gui.color_role import ColorRole\n    from humbug.gui.style_manager import StyleManager\n    \n    \n    class WelcomeWidget(QFrame):\n        \"\"\"Widget showing welcome message when no tabs are open.\"\"\"\n    \n        def __init__(self, parent=None):\n            \"\"\"Initialize welcome widget.\"\"\"\n            super().__init__(parent)\n    \n            # Create layout\n            layout = QVBoxLayout()\n            self.setLayout(layout)\n    \n            # Add application icon\n            self._icon_label = QLabel()\n            self._icon_label.setAlignment(Qt.AlignHCenter | Qt.AlignBottom)\n            layout.addStretch()\n            layout.addWidget(self._icon_label)\n            layout.addSpacing(20)  # Space between icon and title\n    \n            # Application name\n            self._title_label = QLabel(f\"Humbug v{format_version()}\")\n            self._title_label.setAlignment(Qt.AlignHCenter | Qt.AlignBottom)\n    \n            # Add widgets to layout\n            layout.addWidget(self._title_label)\n            layout.addStretch()\n    \n            # Set margins for dialog-style spacing\n            layout.setContentsMargins(20, 20, 20, 20)\n    \n            # Get style manager and connect to changes\n            self._style_manager = StyleManager()\n            self._style_manager.style_changed.connect(self._handle_style_changed)\n            self._handle_style_changed()\n    \n        def _handle_style_changed(self) -> None:\n            \"\"\"Update styling when application style changes.\"\"\"\n            zoom_factor = self._style_manager.zoom_factor\n            base_font_size = self._style_manager.base_font_size\n    \n            # Update icon size\n            icon_path = self._style_manager.get_icon_path(\"app-icon-disabled\")\n            icon_pixmap = QPixmap(icon_path)\n            scaled_size = int(160 * zoom_factor)  # 160px base size for welcome screen\n            self._icon_label.setPixmap(icon_pixmap.scaled(\n                scaled_size, scaled_size,\n                Qt.KeepAspectRatio,\n                Qt.SmoothTransformation\n            ))\n    \n            # Update colors and frame style\n            self.setStyleSheet(f\"\"\"\n                QFrame {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.BACKGROUND_PRIMARY)};\n                    border: none;\n                    border-radius: {4 * zoom_factor}px;\n                }}\n                QLabel {{\n                    color: {self._style_manager.get_color_str(ColorRole.TEXT_DISABLED)};\n                    background: none;\n                    font-size: {base_font_size * 1.5}pt;\n                    font-weight: bold;\n                }}\n            \"\"\")\n    ```\n    File: src/humbug/gui/editor_tab.py\n    ```python\n    import logging\n    import os\n    import time\n    from typing import Dict, Optional\n    \n    from PySide6.QtWidgets import (\n        QVBoxLayout, QFileDialog\n    )\n    from PySide6.QtCore import QTimer\n    from PySide6.QtGui import QTextCursor\n    \n    from humbug.gui.editor_highlighter import EditorHighlighter\n    from humbug.gui.color_role import ColorRole\n    from humbug.gui.editor_text_edit import EditorTextEdit\n    from humbug.gui.message_box import MessageBox, MessageBoxType, MessageBoxButton\n    from humbug.gui.status_message import StatusMessage\n    from humbug.gui.style_manager import StyleManager\n    from humbug.gui.tab_base import TabBase\n    from humbug.gui.tab_state import TabState\n    from humbug.gui.tab_type import TabType\n    from humbug.syntax.programming_language import ProgrammingLanguage\n    from humbug.workspace.workspace_manager import WorkspaceManager\n    \n    \n    # Map file extensions to programming languages\n    LANGUAGE_MAP: Dict[str, ProgrammingLanguage] = {\n        '.c': ProgrammingLanguage.C,\n        '.cc': ProgrammingLanguage.CPP,\n        '.cpp': ProgrammingLanguage.CPP,\n        '.css': ProgrammingLanguage.CSS,\n        '.cxx': ProgrammingLanguage.CPP,\n        '.h': ProgrammingLanguage.C,\n        '.hh': ProgrammingLanguage.CPP,\n        '.hpp': ProgrammingLanguage.CPP,\n        '.html': ProgrammingLanguage.HTML,\n        '.htm': ProgrammingLanguage.HTML,\n        '.hxx': ProgrammingLanguage.CPP,\n        '.js': ProgrammingLanguage.JAVASCRIPT,\n        '.jsx': ProgrammingLanguage.JAVASCRIPT,\n        '.m6r': ProgrammingLanguage.METAPHOR,\n        '.md': ProgrammingLanguage.TEXT,\n        '.py': ProgrammingLanguage.PYTHON,\n        '.pyw': ProgrammingLanguage.PYTHON,\n        '.pyi': ProgrammingLanguage.PYTHON,\n        '.ts': ProgrammingLanguage.TYPESCRIPT,\n        '.tsx': ProgrammingLanguage.TYPESCRIPT,\n        '.txt': ProgrammingLanguage.TEXT,\n    }\n    \n    \n    class EditorTab(TabBase):\n        \"\"\"Tab for editing text files.\"\"\"\n    \n        def __init__(self, tab_id: str, parent=None):\n            \"\"\"\n            Initialize editor tab.\n    \n            Args:\n                tab_id: Unique identifier for this tab\n                parent: Optional parent widget\n            \"\"\"\n            super().__init__(tab_id, parent)\n    \n            self._untitled_number: Optional[int] = None\n            self._style_manager = StyleManager()\n            self._last_save_content = \"\"\n            self._auto_backup_timer = QTimer(self)\n            self._auto_backup_timer.timeout.connect(self._auto_backup)\n            self._current_language = ProgrammingLanguage.TEXT\n            self._logger = logging.getLogger(\"EditorTab\")\n    \n            # Set up layout\n            layout = QVBoxLayout(self)\n            layout.setContentsMargins(0, 0, 0, 0)\n            layout.setSpacing(0)\n    \n            # Create editor\n            self._editor = EditorTextEdit()\n            self._editor.textChanged.connect(self._handle_text_changed)\n            self._editor.cursorPositionChanged.connect(self.update_status)\n            layout.addWidget(self._editor)\n    \n            self._install_activation_tracking(self._editor)\n    \n            # Set up syntax highlighter\n            self._highlighter = EditorHighlighter(self._editor.document())\n    \n            # Connect to style changes\n            self._style_manager.style_changed.connect(self._handle_style_changed)\n            self._handle_style_changed(self._style_manager.zoom_factor)\n    \n            self.update_status()\n    \n            # Update auto-backup based on current workspace settings\n            workspace_manager = WorkspaceManager()\n            if workspace_manager.has_workspace:\n                settings = workspace_manager.settings\n                self.update_auto_backup_settings(settings.auto_backup, settings.auto_backup_interval)\n    \n            # Connect to workspace settings changes\n            workspace_manager.settings_changed.connect(self._handle_workspace_settings_changed)\n    \n        def _handle_workspace_settings_changed(self):\n            \"\"\"Handle workspace settings changes.\"\"\"\n            workspace_manager = WorkspaceManager()\n            if workspace_manager.has_workspace:\n                settings = workspace_manager.settings\n                self.update_auto_backup_settings(settings.auto_backup, settings.auto_backup_interval)\n    \n        def update_auto_backup_settings(self, enabled: bool, interval: int) -> None:\n            \"\"\"Update auto-backup settings.\"\"\"\n            if enabled:\n                self._auto_backup_timer.setInterval(interval * 1000)  # Convert to milliseconds\n                if self._is_modified:\n                    # If we have unsaved changes, start backup immediately\n                    self._auto_backup_timer.start()\n                return\n    \n            clear_backups = self._auto_backup_timer.isActive()\n            self._auto_backup_timer.stop()\n    \n            # Clean up any existing backups since auto-backup is disabled\n            if clear_backups:\n                self._cleanup_backup_files()\n    \n        def get_state(self, temp_state: bool=False) -> TabState:\n            \"\"\"Get serializable state for workspace persistence.\"\"\"\n            metadata_state = {\n                \"language\": self._current_language.name\n            }\n    \n            if temp_state:\n                metadata_state[\"content\"] = self._editor.toPlainText()\n    \n            return TabState(\n                type=TabType.EDITOR,\n                tab_id=self.tab_id,\n                path=self._path if self._path else f\"untitled-{self._untitled_number}\",\n                cursor_position=self.get_cursor_position(),\n                metadata=metadata_state\n            )\n    \n        @classmethod\n        def restore_from_state(cls, state: TabState, parent=None) -> 'EditorTab':\n            \"\"\"Create and restore an editor tab from serialized state.\"\"\"\n            if state.type != TabType.EDITOR:\n                raise ValueError(f\"Invalid tab type for EditorTab: {state.type}\")\n    \n            # Create new tab instance\n            tab = cls(state.tab_id, parent)\n    \n            # Set filename and load content\n            if state.path.startswith(\"untitled-\"):\n                number = int(state.path.split(\"-\")[1])\n                tab.set_filename(None, number)\n            else:\n                tab.set_filename(state.path)\n    \n            # Restore language if specified\n            if state.metadata and \"language\" in state.metadata:\n                language = ProgrammingLanguage[state.metadata[\"language\"]]\n                tab._update_language(language)\n    \n            # Restore content if specified\n            if state.metadata and \"content\" in state.metadata:\n                tab._editor.setPlainText(state.metadata[\"content\"])\n    \n            # Restore cursor position if present\n            if state.cursor_position:\n                tab.set_cursor_position(state.cursor_position)\n    \n            return tab\n    \n        def set_cursor_position(self, position: Dict[str, int]) -> None:\n            \"\"\"Set cursor position in editor.\n    \n            Args:\n                position: Dictionary with 'line' and 'column' keys\n            \"\"\"\n            if not position:\n                return\n    \n            cursor = self._editor.textCursor()\n            cursor.movePosition(QTextCursor.Start)\n    \n            # Move cursor to specified position\n            for _ in range(position.get(\"line\", 0)):\n                cursor.movePosition(QTextCursor.NextBlock)\n    \n            cursor.movePosition(\n                QTextCursor.Right,\n                QTextCursor.MoveAnchor,\n                position.get(\"column\", 0)\n            )\n    \n            self._editor.setTextCursor(cursor)\n            self._editor.ensureCursorVisible()\n    \n        def get_cursor_position(self) -> Dict[str, int]:\n            \"\"\"Get current cursor position from editor.\n    \n            Returns:\n                Dictionary with 'line' and 'column' keys\n            \"\"\"\n            cursor = self._editor.textCursor()\n            return {\n                \"line\": cursor.blockNumber(),\n                \"column\": cursor.columnNumber()\n            }\n    \n        def _handle_style_changed(self, zoom_factor: float = 1.0) -> None:\n            \"\"\"\n            Handle style and zoom changes.\n    \n            Args:\n                zoom_factor: New zoom scaling factor\n            \"\"\"\n            # Update font size\n            font = self._editor.font()\n            base_size = self._style_manager.base_font_size\n            font.setPointSizeF(base_size * zoom_factor)\n            self._editor.setFont(font)\n    \n            # Update tab stops - scale with zoom\n            space_width = self._style_manager.get_space_width()\n            self._editor.setTabStopDistance(space_width * 8)\n    \n            self.setStyleSheet(f\"\"\"\n                QWidget {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.TAB_BACKGROUND_ACTIVE)};\n                    border: none;\n                }}\n                QScrollBar:vertical, QScrollBar:horizontal {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_BACKGROUND)};\n                    width: 12px;\n                    height: 12px;\n                }}\n                QScrollBar::handle:vertical, QScrollBar::handle:horizontal {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_HANDLE)};\n                    min-height: 20px;\n                    min-width: 20px;\n                }}\n                QScrollBar::add-page, QScrollBar::sub-page {{\n                    background: none;\n                }}\n                QScrollBar::add-line, QScrollBar::sub-line {{\n                    height: 0px;\n                    width: 0px;\n                }}\n                QAbstractScrollArea::corner {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_BACKGROUND)};\n                }}\n            \"\"\")\n    \n            # Scale line number area\n            self._editor.update_line_number_area_width()\n    \n            # Force a redraw of syntax highlighting\n            self._highlighter.rehighlight()\n    \n        def _detect_language(self, filename: Optional[str]) -> ProgrammingLanguage:\n            \"\"\"\n            Detect the programming language based on file extension.\n    \n            Args:\n                filename: The filename to analyze\n    \n            Returns:\n                The detected programming language\n            \"\"\"\n            if not filename:\n                return ProgrammingLanguage.TEXT\n    \n            ext = os.path.splitext(filename)[1].lower()\n            return LANGUAGE_MAP.get(ext, ProgrammingLanguage.TEXT)\n    \n        def _update_language(self, new_language: ProgrammingLanguage) -> None:\n            \"\"\"\n            Update the syntax highlighting language.\n    \n            Args:\n                new_language: The new programming language to use\n            \"\"\"\n            if self._current_language != new_language:\n                self._current_language = new_language\n                self._highlighter.set_language(new_language)\n                self.update_status()\n    \n        @property\n        def filename(self) -> str:\n            \"\"\"Get the name of the file being edited.\"\"\"\n            return self._path\n    \n        def set_filename(self, filename: Optional[str], untitled_number: Optional[int] = None) -> None:\n            \"\"\"\n            Set the file being edited.\n    \n            Args:\n                filename: Path to file or None for new file\n                untitled_number: Number to use for untitled file\n            \"\"\"\n            self._path = filename\n            self._untitled_number = untitled_number\n    \n            # Update syntax highlighting based on file extension\n            new_language = self._detect_language(filename)\n            self._update_language(new_language)\n    \n            if filename and os.path.exists(filename):\n                try:\n                    with open(filename, 'r', encoding='utf-8') as f:\n                        content = f.read()\n                    self._editor.setPlainText(content)\n                    self._last_save_content = content\n                    self._set_modified(False)\n                except Exception as e:\n                    MessageBox.show_message(\n                        self,\n                        MessageBoxType.CRITICAL,\n                        \"Error Opening File\",\n                        f\"Could not open {filename}: {str(e)}\"\n                    )\n            self._update_title()\n    \n        def _update_title(self) -> None:\n            \"\"\"Update the tab title based on filename and modified state.\"\"\"\n            if self._path:\n                title = os.path.basename(self._path)\n            else:\n                title = f\"Untitled-{self._untitled_number}\"\n    \n            if self._is_modified:\n                title += \"*\"\n    \n            self.title_changed.emit(self._tab_id, title)\n    \n        def _handle_text_changed(self) -> None:\n            \"\"\"Handle changes to editor content.\"\"\"\n            current_content = self._editor.toPlainText()\n            is_modified = current_content != self._last_save_content\n            self._set_modified(is_modified)\n    \n            workspace_manager = WorkspaceManager()\n            if workspace_manager.has_workspace and workspace_manager.settings.auto_backup:\n                if is_modified and not self._auto_backup_timer.isActive():\n                    self._auto_backup_timer.start()\n                elif not is_modified:\n                    self._auto_backup_timer.stop()\n    \n        def update_status(self) -> None:\n            \"\"\"Update status bar with current cursor position.\"\"\"\n            cursor = self._editor.textCursor()\n            line = cursor.blockNumber() + 1\n            column = cursor.columnNumber() + 1\n    \n            # Get file info\n            encoding = \"UTF-8\"\n            line_ending = \"LF\"  # We could detect this from file content\n    \n            # Get language name from enum\n            language_names = {\n                ProgrammingLanguage.TEXT: \"Text\",\n                ProgrammingLanguage.C: \"C\",\n                ProgrammingLanguage.CPP: \"C++\",\n                ProgrammingLanguage.CSS: \"CSS\",\n                ProgrammingLanguage.HTML: \"HTML\",\n                ProgrammingLanguage.JAVASCRIPT: \"JavaScript\",\n                ProgrammingLanguage.TYPESCRIPT: \"TypeScript\",\n                ProgrammingLanguage.PYTHON: \"Python\",\n                ProgrammingLanguage.METAPHOR: \"Metaphor\",\n            }\n            file_type = language_names.get(self._current_language, \"Text\")\n    \n            message = StatusMessage(\n                f\"Line {line}, Column {column} | {encoding} | {line_ending} | {file_type}\"\n            )\n            self.status_message.emit(message)\n    \n        def _auto_backup(self) -> None:\n            \"\"\"Handle auto-backup functionality.\"\"\"\n            if not self._is_modified:\n                return\n    \n            # All backups should now go in workspace .humbug/backups\n            workspace_manager = WorkspaceManager()\n            if not workspace_manager.has_workspace:\n                return  # No backups without a workspace\n    \n            backup_dir = workspace_manager.get_workspace_path(os.path.join(\".humbug\", \"backups\"))\n            os.makedirs(backup_dir, exist_ok=True)\n    \n            if not self._path:\n                # For untitled files, use timestamp-based backup in workspace\n                prefix = f\"backup-{self._untitled_number}-\"\n                current_time = int(time.time())\n                try:\n                    # Clean up old backups for this untitled file\n                    for file in os.listdir(backup_dir):\n                        if file.startswith(prefix):\n                            file_path = os.path.join(backup_dir, file)\n    \n                            # Keep only backups from last hour\n                            if current_time - os.path.getctime(file_path) > 3600:\n                                try:\n                                    os.remove(file_path)\n                                except OSError as e:\n                                    self._logger.warning(\"Failed to remove old backup %s: %s\", file_path, str(e))\n                except OSError as e:\n                    self._logger.warning(\"Failed to clean up old backups: %s\", str(e))\n    \n                backup_file = os.path.join(\n                    backup_dir,\n                    f\"{prefix}{current_time}.txt\"\n                )\n            else:\n                backup_file = f\"{self._path}.backup\"\n    \n                # Clean up any very old backups that might have been left behind\n                try:\n                    if os.path.exists(backup_file):\n                        if time.time() - os.path.getctime(backup_file) > 86400:  # 24 hours\n                            try:\n                                os.remove(backup_file)\n                            except OSError:\n                                pass  # Ignore cleanup errors for old files\n                except OSError:\n                    pass  # Ignore stat errors\n    \n            try:\n                with open(backup_file, 'w', encoding='utf-8') as f:\n                    f.write(self._editor.toPlainText())\n            except Exception as e:\n                self._logger.error(\"Failed to create backup file '%s': %s\", backup_file, str(e))\n    \n        def _cleanup_backup_files(self) -> None:\n            \"\"\"Clean up any backup files for this editor.\"\"\"\n            workspace_manager = WorkspaceManager()\n            if not workspace_manager.has_workspace:\n                return\n    \n            if self._path:\n                # Clean up backup for saved file\n                backup_file = f\"{self._path}.backup\"\n                try:\n                    if os.path.exists(backup_file):\n                        os.remove(backup_file)\n                except OSError as e:\n                    self._logger.warning(\"Failed to remove backup file %s: %s\", backup_file, str(e))\n            elif self._untitled_number:\n                # Clean up backups for untitled file\n                backup_dir = workspace_manager.get_workspace_path(os.path.join(\".humbug\", \"backups\"))\n                prefix = f\"backup-{self._untitled_number}-\"\n                try:\n                    for file in os.listdir(backup_dir):\n                        if file.startswith(prefix):\n                            try:\n                                os.remove(os.path.join(backup_dir, file))\n                            except OSError as e:\n                                self._logger.warning(\"Failed to remove backup %s: %s\", file, str(e))\n                except OSError as e:\n                    self._logger.warning(\"Failed to clean up backups: %s\", str(e))\n    \n        def can_close(self) -> bool:\n            \"\"\"Check if the file can be closed.\"\"\"\n            if not self._is_modified:\n                return True\n    \n            result = MessageBox.show_message(\n                self,\n                MessageBoxType.QUESTION,\n                \"Save Changes?\",\n                f\"Do you want to save changes to {self._path or f'Untitled-{self._untitled_number}'}?\",\n                [MessageBoxButton.SAVE, MessageBoxButton.DISCARD, MessageBoxButton.CANCEL]\n            )\n    \n            if result == MessageBoxButton.SAVE:\n                return self.save()\n    \n            if result == MessageBoxButton.DISCARD:\n                # Delete any backup files when discarding changes\n                if self._auto_backup_timer.isActive():\n                    self._cleanup_backup_files()\n    \n                return True\n    \n            return False\n    \n        def close(self) -> None:\n            pass\n    \n        def can_save(self) -> bool:\n            return self._is_modified\n    \n        def save(self) -> bool:\n            \"\"\"\n            Save the current file.\n    \n            Returns:\n                bool: True if save was successful\n            \"\"\"\n            if not self._path:\n                return self.save_as()\n    \n            try:\n                content = self._editor.toPlainText()\n                with open(self._path, 'w', encoding='utf-8') as f:\n                    f.write(content)\n    \n                self._last_save_content = content\n                self._set_modified(False)\n    \n                # Delete any backup files\n                backup_file = f\"{self._path}.backup\"\n                try:\n                    if os.path.exists(backup_file):\n                        os.remove(backup_file)\n                except OSError as e:\n                    self._logger.warning(\"Failed to remove backup file %s: %s\", backup_file, str(e))\n    \n                return True\n            except Exception as e:\n                MessageBox.show_message(\n                    self,\n                    MessageBoxType.CRITICAL,\n                    \"Error Saving File\",\n                    f\"Could not save {self._path}: {str(e)}\"\n                )\n                return False\n    \n        def can_save_as(self) -> bool:\n            return True\n    \n        def save_as(self) -> bool:\n            \"\"\"\n            Show save as dialog and save file.\n    \n            Returns:\n                bool: True if save was successful\n            \"\"\"\n            filename, _ = QFileDialog.getSaveFileName(\n                self,\n                \"Save As\",\n                self._path or os.path.expanduser(\"~/\")\n            )\n            if not filename:\n                return False\n    \n            self._path = filename\n            self._untitled_number = None\n            self._update_title()\n    \n            new_language = self._detect_language(filename)\n            self._update_language(new_language)\n    \n            return self.save()\n    \n        def can_undo(self) -> bool:\n            \"\"\"Check if undo is available.\"\"\"\n            return self._editor.document().isUndoAvailable()\n    \n        def undo(self) -> None:\n            \"\"\"Undo the last edit operation.\"\"\"\n            self._editor.undo()\n    \n        def can_redo(self) -> bool:\n            \"\"\"Check if redo is available.\"\"\"\n            return self._editor.document().isRedoAvailable()\n    \n        def redo(self) -> None:\n            \"\"\"Redo the last undone edit operation.\"\"\"\n            self._editor.redo()\n    \n        def can_cut(self) -> bool:\n            \"\"\"Check if cut is available.\"\"\"\n            return self._editor.textCursor().hasSelection()\n    \n        def cut(self) -> None:\n            \"\"\"Cut selected text to clipboard.\"\"\"\n            self._editor.cut()\n    \n        def can_copy(self) -> bool:\n            \"\"\"Check if copy is available.\"\"\"\n            return self._editor.textCursor().hasSelection()\n    \n        def copy(self) -> None:\n            \"\"\"Copy selected text to clipboard.\"\"\"\n            self._editor.copy()\n    \n        def can_paste(self) -> bool:\n            \"\"\"Check if paste is available.\"\"\"\n            return True\n    \n        def paste(self) -> None:\n            \"\"\"Paste text from clipboard.\"\"\"\n            self._editor.paste()\n    \n        def can_submit(self) -> bool:\n            return False\n    ```\n    File: src/humbug/gui/conversation_error.py\n    ```python\n    \"\"\"Exception classes for conversation operations.\"\"\"\n    \n    \n    class ConversationError(Exception):\n        \"\"\"Base class for conversation-related exceptions.\"\"\"\n    \n        def __init__(self, message: str, details: dict = None):\n            \"\"\"\n            Initialize conversation error.\n    \n            Args:\n                message: Error message\n                details: Optional dictionary of additional error details\n            \"\"\"\n            super().__init__(message)\n            self.details = details or {}\n    ```\n    File: src/humbug/gui/editor_text_edit.py\n    ```python\n    from PySide6.QtWidgets import QPlainTextEdit, QWidget\n    from PySide6.QtCore import Qt\n    from PySide6.QtGui import QPainter, QTextCursor, QKeyEvent\n    \n    from humbug.gui.color_role import ColorRole\n    from humbug.gui.line_number_area import LineNumberArea\n    from humbug.gui.style_manager import StyleManager\n    from humbug.workspace.workspace_manager import WorkspaceManager\n    \n    \n    class EditorTextEdit(QPlainTextEdit):\n        \"\"\"Text editor widget with line numbers and syntax highlighting.\"\"\"\n    \n        def __init__(self, parent: QWidget = None):\n            \"\"\"Initialize the editor.\"\"\"\n            super().__init__(parent)\n    \n            # Enable standard scrollbars\n            self.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\n            self.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\n    \n            # Editor settings\n            self.setLineWrapMode(QPlainTextEdit.NoWrap)  # No word wrap for code\n            self.setTabStopDistance(32)  # 4 spaces worth of tab stops\n    \n            self._style_manager = StyleManager()\n    \n            # Setup line number area\n            self._line_number_area = LineNumberArea(self)\n            font = self._line_number_area.font()\n            font.setFamilies(self._style_manager.monospace_font_families)\n            self.setFont(font)\n            self._line_number_area.setFont(font)\n    \n            self.blockCountChanged.connect(self.update_line_number_area_width)\n            self.updateRequest.connect(self._update_line_number_area)\n            self.update_line_number_area_width()\n    \n        def line_number_area_width(self) -> int:\n            \"\"\"Calculate the width needed for the line number area.\"\"\"\n            digits = 1\n            max_num = max(1, self.blockCount())\n            while max_num >= 10:\n                max_num //= 10\n                digits += 1\n    \n            digit_width = self.fontMetrics().horizontalAdvance('9')\n            return digit_width * (digits + 4)\n    \n        def update_line_number_area_width(self):\n            \"\"\"Update the margins to accommodate the line numbers.\"\"\"\n            self.setViewportMargins(self.line_number_area_width(), 0, 0, 0)\n    \n        def _update_line_number_area(self, rect, dy):\n            \"\"\"Handle updates to the line number area.\"\"\"\n            if dy:\n                self._line_number_area.scroll(0, dy)\n            else:\n                self._line_number_area.update(0, rect.y(),\n                    self._line_number_area.width(), rect.height())\n    \n            if rect.contains(self.viewport().rect()):\n                self.update_line_number_area_width()\n    \n        def resizeEvent(self, event):\n            \"\"\"Handle resize events.\"\"\"\n            super().resizeEvent(event)\n            cr = self.contentsRect()\n            width = self.line_number_area_width()\n            rect = cr\n            rect.setWidth(width)\n            self._line_number_area.setGeometry(rect)\n    \n        def line_number_area_paint_event(self, event):\n            \"\"\"Paint the line number area.\"\"\"\n            painter = QPainter(self._line_number_area)\n            bg_color = self._style_manager.get_color(ColorRole.TAB_BACKGROUND_ACTIVE)\n            painter.fillRect(event.rect(), bg_color)\n    \n            painter.setFont(self.font())\n    \n            block = self.firstVisibleBlock()\n            block_number = block.blockNumber()\n            offset = self.contentOffset()\n            top = self.blockBoundingGeometry(block).translated(offset).top()\n            bottom = top + self.blockBoundingRect(block).height()\n    \n            # Use one space width for left padding\n            left_padding = self.fontMetrics().horizontalAdvance('9')\n    \n            while block.isValid() and top <= event.rect().bottom():\n                if block.isVisible() and bottom >= event.rect().top():\n                    number = str(block_number + 1)\n                    text_color = self._style_manager.get_color(ColorRole.LINE_NUMBER)\n                    painter.setPen(text_color)\n                    painter.drawText(\n                        left_padding,\n                        int(top),\n                        self._line_number_area.width() - (3 * left_padding),\n                        self.fontMetrics().height(),\n                        Qt.AlignRight,\n                        number\n                    )\n    \n                block = block.next()\n                top = bottom\n                bottom = top + self.blockBoundingRect(block).height()\n                block_number += 1\n    \n        def _indent_single_line_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n            \"\"\"\n            Indent a single line using soft tabs.\n    \n            Args:\n                cursor: The current text cursor\n                tab_size: Number of spaces to use for indentation\n            \"\"\"\n            # Calculate spaces needed to reach next tab stop\n            current_column = cursor.position() - cursor.block().position()\n            spaces_needed = tab_size - (current_column % tab_size)\n            cursor.insertText(\" \" * spaces_needed)\n    \n        def _indent_single_line_hard_tabs(self, cursor: QTextCursor) -> None:\n            \"\"\"\n            Indent a single line using hard tabs.\n    \n            Args:\n                cursor: The current text cursor\n            \"\"\"\n            cursor.insertText(\"\\t\")\n    \n        def _indent_block_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n            \"\"\"\n            Indent a block of text using soft tabs.\n    \n            Args:\n                cursor: The current text cursor\n                tab_size: Number of spaces to use for indentation\n            \"\"\"\n            start = cursor.selectionStart()\n            end = cursor.selectionEnd()\n            reverse: bool = start == cursor.position()\n    \n            cursor.setPosition(start)\n            cursor.movePosition(QTextCursor.StartOfLine)\n    \n            # If selection ends at start of line, don't indent that line\n            end_offs = 0\n            check_cursor = QTextCursor(cursor)\n            check_cursor.setPosition(end)\n            if check_cursor.atBlockStart():\n                end_offs = 1\n    \n            start += tab_size\n            while cursor.position() <= end - end_offs:\n                cursor.insertText(\" \" * tab_size)\n                end += tab_size\n                cursor.movePosition(QTextCursor.NextBlock)\n    \n            cursor.setPosition(start if not reverse else end)\n            cursor.setPosition(end if not reverse else start, QTextCursor.KeepAnchor)\n    \n        def _indent_block_hard_tabs(self, cursor: QTextCursor) -> None:\n            \"\"\"\n            Indent a block of text using hard tabs.\n    \n            Args:\n                cursor: The current text cursor\n            \"\"\"\n            start = cursor.selectionStart()\n            end = cursor.selectionEnd()\n            reverse: bool = start == cursor.position()\n    \n            cursor.setPosition(start)\n            cursor.movePosition(QTextCursor.StartOfLine)\n    \n            # If selection ends at start of line, don't indent that line\n            end_offs = 0\n            check_cursor = QTextCursor(cursor)\n            check_cursor.setPosition(end)\n            if check_cursor.atBlockStart():\n                end_offs = 1\n    \n            start += 1\n            while cursor.position() <= end - end_offs:\n                cursor.insertText(\"\\t\")\n                end += 1\n                cursor.movePosition(QTextCursor.NextBlock)\n    \n            cursor.setPosition(start if not reverse else end)\n            cursor.setPosition(end if not reverse else start, QTextCursor.KeepAnchor)\n    \n        def _outdent_single_line_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n            \"\"\"\n            Outdent a single line using soft tabs.\n    \n            Args:\n                cursor: The current text cursor\n                tab_size: Number of spaces to use for indentation\n            \"\"\"\n            current_column = cursor.position() - cursor.block().position()\n            deletes_needed = 1 + ((current_column - 1) % tab_size)\n            deletes_needed = min(deletes_needed, current_column)\n    \n            while deletes_needed > 0:\n                text = cursor.block().text()\n                if not text or text[current_column - 1] != \" \":\n                    break\n    \n                cursor.deletePreviousChar()\n                current_column -= 1\n                deletes_needed -= 1\n    \n        def _outdent_single_line_hard_tabs(self, cursor: QTextCursor) -> None:\n            \"\"\"\n            Outdent a single line using hard tabs.\n    \n            Args:\n                cursor: The current text cursor\n            \"\"\"\n            current_column = cursor.position() - cursor.block().position()\n            if current_column > 0:\n                text = cursor.block().text()\n                if text and text[current_column - 1] == \"\\t\":\n                    cursor.deletePreviousChar()\n    \n        def _outdent_block_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n            \"\"\"\n            Outdent a block of text using soft tabs.\n    \n            Args:\n                cursor: The current text cursor\n                tab_size: Number of spaces to use for indentation\n            \"\"\"\n            start = cursor.selectionStart()\n            end = cursor.selectionEnd()\n            reverse: bool = start == cursor.position()\n    \n            cursor.setPosition(start)\n            cursor.movePosition(QTextCursor.StartOfLine)\n    \n            # If selection ends at start of line, don't outdent that line\n            end_offs = 0\n            check_cursor = QTextCursor(cursor)\n            check_cursor.setPosition(end)\n            if check_cursor.atBlockStart():\n                end_offs = 1\n    \n            # Work out how far to move the start postion\n            current_column = start - cursor.block().position()\n            first_line = cursor.block().text()\n            first_line_spaces = len(first_line) - len(first_line.lstrip(\" \"))\n            first_line_spaces = min(first_line_spaces, tab_size)\n            first_line_spaces = min(first_line_spaces, current_column)\n            start -= first_line_spaces\n    \n            while cursor.position() <= end - end_offs:\n                deletes_needed = tab_size\n    \n                while deletes_needed > 0:\n                    text = cursor.block().text()\n                    if not text or text[0] != \" \":\n                        break\n    \n                    cursor.deleteChar()\n                    deletes_needed -= 1\n                    end -= 1\n    \n                cursor.movePosition(QTextCursor.NextBlock)\n    \n            cursor.setPosition(start if not reverse else end)\n            cursor.setPosition(end if not reverse else start, QTextCursor.KeepAnchor)\n    \n        def _outdent_block_hard_tabs(self, cursor: QTextCursor) -> None:\n            \"\"\"\n            Outdent a block of text using hard tabs.\n    \n            Args:\n                cursor: The current text cursor\n            \"\"\"\n            start = cursor.selectionStart()\n            end = cursor.selectionEnd()\n            reverse: bool = start == cursor.position()\n    \n            cursor.setPosition(start)\n            cursor.movePosition(QTextCursor.StartOfLine)\n    \n            # If selection ends at start of line, don't outdent that line\n            end_offs = 0\n            check_cursor = QTextCursor(cursor)\n            check_cursor.setPosition(end)\n            if check_cursor.atBlockStart():\n                end_offs = 1\n    \n            # Work out how far to move the start postion\n            current_column = start - cursor.block().position()\n            first_line = cursor.block().text()\n            if first_line and first_line[0] == \"\\t\" and current_column > 0:\n                start -= 1\n    \n            while cursor.position() <= end - end_offs:\n                text = cursor.block().text()\n                if text and text[0] == \"\\t\":\n                    cursor.deleteChar()\n                    end -= 1\n    \n                cursor.movePosition(QTextCursor.NextBlock)\n    \n            cursor.setPosition(start if not reverse else end)\n            cursor.setPosition(end if not reverse else start, QTextCursor.KeepAnchor)\n    \n        def keyPressEvent(self, event: QKeyEvent) -> None:\n            \"\"\"\n            Handle special key events.\n    \n            Args:\n                event: The key event to handle\n            \"\"\"\n            workspace_manager = WorkspaceManager()\n            if not workspace_manager.has_workspace:\n                super().keyPressEvent(event)\n                return\n    \n            settings = workspace_manager.settings\n            cursor = self.textCursor()\n    \n            if event.key() == Qt.Key_Tab:\n                scrollbar = self.verticalScrollBar()\n                current_scroll = scrollbar.value()\n                cursor.beginEditBlock()\n                try:\n                    if not cursor.hasSelection():\n                        if settings.use_soft_tabs:\n                            self._indent_single_line_soft_tabs(cursor, settings.tab_size)\n                        else:\n                            self._indent_single_line_hard_tabs(cursor)\n                    else:\n                        if settings.use_soft_tabs:\n                            self._indent_block_soft_tabs(cursor, settings.tab_size)\n                        else:\n                            self._indent_block_hard_tabs(cursor)\n                finally:\n                    cursor.endEditBlock()\n                    self.setTextCursor(cursor)\n                    scrollbar.setValue(current_scroll)\n    \n                event.accept()\n                return\n    \n            if event.key() == Qt.Key_Backtab:  # Shift+Tab\n                scrollbar = self.verticalScrollBar()\n                current_scroll = scrollbar.value()\n                cursor.beginEditBlock()\n                try:\n                    if not cursor.hasSelection():\n                        if settings.use_soft_tabs:\n                            self._outdent_single_line_soft_tabs(cursor, settings.tab_size)\n                        else:\n                            self._outdent_single_line_hard_tabs(cursor)\n                    else:\n                        if settings.use_soft_tabs:\n                            self._outdent_block_soft_tabs(cursor, settings.tab_size)\n                        else:\n                            self._outdent_block_hard_tabs(cursor)\n    \n                finally:\n                    cursor.endEditBlock()\n                    self.setTextCursor(cursor)\n                    scrollbar.setValue(current_scroll)\n    \n                event.accept()\n                return\n    \n            if event.key() == Qt.Key_Home:\n                cursor = self.textCursor()\n                cursor.movePosition(QTextCursor.StartOfLine)\n                self.setTextCursor(cursor)\n                event.accept()\n                return\n    \n            if event.key() == Qt.Key_End:\n                cursor = self.textCursor()\n                cursor.movePosition(QTextCursor.EndOfLine)\n                self.setTextCursor(cursor)\n                event.accept()\n                return\n    \n            super().keyPressEvent(event)\n    ```\n    File: src/humbug/gui/workspace_file_model.py\n    ```python\n    \"\"\"File tree view implementation for workspace files.\"\"\"\n    \n    import os\n    \n    from PySide6.QtCore import QModelIndex, QSortFilterProxyModel\n    \n    \n    class WorkspaceFileModel(QSortFilterProxyModel):\n        \"\"\"Filter model to hide .humbug directory and apply custom sorting.\"\"\"\n    \n        def __init__(self, parent=None):\n            \"\"\"Initialize the filter model.\"\"\"\n            super().__init__(parent)\n            self._workspace_root = None\n    \n        def set_workspace_root(self, path: str):\n            \"\"\"Set the workspace root path for relative path calculations.\"\"\"\n            self._workspace_root = path\n    \n        def filterAcceptsRow(self, source_row: int, source_parent: QModelIndex) -> bool:\n            \"\"\"Filter out .humbug directory and other hidden files.\"\"\"\n            # If no workspace is open, don't show any files\n            if not self._workspace_root:\n                return False\n    \n            source_model = self.sourceModel()\n            if not source_model:\n                return False\n    \n            index = source_model.index(source_row, 0, source_parent)\n            file_path = source_model.filePath(index)\n    \n            # Always hide .humbug directory\n            if os.path.basename(file_path) == \".humbug\":\n                return False\n    \n            # Hide other hidden files/directories\n            if os.path.basename(file_path).startswith(\".\"):\n                return False\n    \n            return True\n    \n        def lessThan(self, left: QModelIndex, right: QModelIndex) -> bool:\n            \"\"\"Sort directories before files, then alphabetically.\"\"\"\n            source_model = self.sourceModel()\n    \n            # Get file info for both indexes\n            left_info = source_model.fileInfo(left)\n            right_info = source_model.fileInfo(right)\n    \n            # Directories come before files\n            if left_info.isDir() and not right_info.isDir():\n                return True\n    \n            if not left_info.isDir() and right_info.isDir():\n                return False\n    \n            # Otherwise sort alphabetically\n            return left_info.fileName().lower() < right_info.fileName().lower()\n    ```\n    File: src/humbug/gui/live_input_widget.py\n    ```python\n    \"\"\"Input widget that matches history message styling.\"\"\"\n    \n    import sys\n    \n    from PySide6.QtCore import Signal, Qt, QMimeData, QRect\n    from PySide6.QtGui import QKeyEvent\n    \n    from humbug.gui.message_widget import MessageWidget\n    from humbug.gui.conversation_text_edit import ConversationTextEdit\n    from humbug.gui.color_role import ColorRole\n    \n    \n    class LiveInputWidget(MessageWidget):\n        \"\"\"Widget for live message input that matches history message styling.\"\"\"\n    \n        # Forward text cursor signals from the input area\n        cursorPositionChanged = Signal()\n        pageScrollRequested = Signal()\n    \n        def __init__(self, parent=None):\n            \"\"\"Initialize the live input widget.\"\"\"\n            self._is_streaming = False\n            super().__init__(parent, is_input=True)\n    \n            # Connect text cursor signals\n            self._text_area.cursorPositionChanged.connect(self.cursorPositionChanged)\n            self._text_area.pageScrollRequested.connect(self.pageScrollRequested)\n    \n            self._update_header_text()\n    \n        def set_streaming(self, streaming: bool):\n            \"\"\"Update the streaming state and header text.\"\"\"\n            self._is_streaming = streaming\n            self._update_header_text()\n    \n        def _get_submit_key_text(self):\n            \"\"\"Get the appropriate submit key text based on the platform.\"\"\"\n            if sys.platform == \"darwin\":\n                return \"\u2318J\"\n    \n            return \"Ctrl+J\"\n    \n        def _update_header_text(self):\n            \"\"\"Update the header text based on current state.\"\"\"\n            if self._is_streaming:\n                self._role_label.setText(\"Processing your request (Esc to cancel)\")\n            else:\n                submit_key = self._get_submit_key_text()\n                self._role_label.setText(f\"Add your next message... ({submit_key} to submit)\")\n    \n            self._set_role_style()\n    \n        def _set_role_style(self):\n            \"\"\"Set the role label color.\"\"\"\n            colour = ColorRole.TEXT_DISABLED if self._is_streaming else ColorRole.MESSAGE_USER\n    \n            # WARNING: This needs to stay in sync with MessageWidget\n            self._role_label.setStyleSheet(f\"\"\"\n                QLabel {{\n                    font-weight: bold;\n                    color: {self._style_manager.get_color_str(colour)};\n                    margin: 0;\n                    padding: 0;\n                    background-color: {self._style_manager.get_color_str(ColorRole.MESSAGE_BACKGROUND)};\n                }}\n            \"\"\")\n    \n        def _create_text_area(self) -> ConversationTextEdit:\n            \"\"\"Create and configure the input text area.\"\"\"\n            text_area = super()._create_text_area()\n            # Override paste behavior to strip formatting\n            text_area.insertFromMimeData = self._insert_from_mime_data\n            return text_area\n    \n        def _insert_from_mime_data(self, source: QMimeData) -> None:\n            \"\"\"Override default paste behavior to insert only plain text.\"\"\"\n            if source.hasText():\n                cursor = self._text_area.textCursor()\n                cursor.insertText(source.text())\n    \n        def keyPressEvent(self, event: QKeyEvent):\n            \"\"\"Handle special key events.\"\"\"\n            if event.key() == Qt.Key_J and event.modifiers() == Qt.ControlModifier:\n                if not self._is_streaming:\n                    text = self._text_area.toPlainText().strip()\n                    if text:\n                        self.clear()\n    \n                    return\n    \n            super().keyPressEvent(event)\n    \n        def clear(self):\n            \"\"\"Clear the input area.\"\"\"\n            self._text_area.clear()\n    \n        def toPlainText(self) -> str:\n            \"\"\"Get the current input text.\"\"\"\n            return self._text_area.toPlainText()\n    \n        def setPlainText(self, text: str):\n            \"\"\"Set the input text.\"\"\"\n            self._text_area.setPlainText(text)\n    \n        def cursorRect(self):\n            \"\"\"Get the cursor rectangle from the input area.\"\"\"\n            text_cursor = self._text_area.cursorRect()\n            offset = self._header.height()\n            cursor = QRect(text_cursor.x(), offset + text_cursor.y(), text_cursor.width(), text_cursor.height())\n            return cursor\n    \n        def setFocus(self):\n            \"\"\"Set focus to the input area.\"\"\"\n            self._text_area.setFocus()\n    \n        def hasFocus(self) -> bool:\n            \"\"\"Check if the input area has focus.\"\"\"\n            return self._text_area.hasFocus()\n    \n        def document(self):\n            \"\"\"Get the document from the input area.\"\"\"\n            return self._text_area.document()\n    \n        def textCursor(self):\n            \"\"\"Get the text cursor from the input area.\"\"\"\n            return self._text_area.textCursor()\n    \n        def undo(self):\n            \"\"\"Undo the last edit operation.\"\"\"\n            self._text_area.undo()\n    \n        def redo(self):\n            \"\"\"Redo the last undone edit operation.\"\"\"\n            self._text_area.redo()\n    \n        def cut(self):\n            \"\"\"Cut selected text to clipboard.\"\"\"\n            self._text_area.cut()\n    \n        def copy(self):\n            \"\"\"Copy selected text to clipboard.\"\"\"\n            self._text_area.copy()\n    \n        def paste(self):\n            \"\"\"Paste text from clipboard.\"\"\"\n            self._text_area.paste()\n    ```\n    File: src/humbug/gui/message_widget.py\n    ```python\n    \"\"\"Widget for displaying individual conversation messages.\"\"\"\n    \n    from datetime import datetime\n    from PySide6.QtWidgets import QFrame, QVBoxLayout, QLabel, QHBoxLayout, QWidget\n    from PySide6.QtCore import Signal, Qt, QPoint\n    from PySide6.QtGui import QCursor\n    \n    from humbug.conversation.message_source import MessageSource\n    from humbug.gui.conversation_highlighter import ConversationHighlighter\n    from humbug.gui.conversation_text_edit import ConversationTextEdit\n    from humbug.gui.color_role import ColorRole\n    from humbug.gui.style_manager import StyleManager\n    \n    \n    class MessageWidget(QFrame):\n        \"\"\"Widget for displaying a single message in the conversation history with header.\"\"\"\n    \n        selectionChanged = Signal(bool)\n        scrollRequested = Signal(QPoint)\n        mouseReleased = Signal()\n    \n        def __init__(self, parent=None, is_input=False):\n            \"\"\"Initialize the message widget.\n    \n            Args:\n                parent: Optional parent widget\n                is_input: Whether this is an input widget (affects styling)\n            \"\"\"\n            super().__init__(parent)\n            self.setFrameStyle(QFrame.Box | QFrame.Plain)\n            self._is_input = is_input\n    \n            # Create layout\n            self._layout = QVBoxLayout(self)\n            self.setLayout(self._layout)\n            self._layout.setSpacing(8)\n            self._layout.setContentsMargins(8, 8, 8, 8)\n    \n            # Create header area with horizontal layout\n            self._header = QWidget(self)\n            self._header_layout = QHBoxLayout(self._header)\n            self._header_layout.setContentsMargins(1, 1, 1, 1)\n            self._header_layout.setSpacing(0)\n    \n            # Create role and timestamp labels\n            self._role_label = QLabel(self)\n            self._timestamp_label = QLabel(self)\n            self._header_layout.addWidget(self._role_label)\n            self._header_layout.addWidget(self._timestamp_label)\n            self._header_layout.addStretch()\n    \n            # Add header widget to main layout\n            self._layout.addWidget(self._header)\n    \n            # Create content area using custom ConversationTextEdit\n            self._text_area = self._create_text_area()\n            self._text_area.setReadOnly(not self._is_input)\n    \n            # Add text area to main layout\n            self._layout.addWidget(self._text_area)\n    \n            # Connect selection change signal\n            self._text_area.selectionChanged.connect(self._on_selection_changed)\n            self._text_area.mouseReleased.connect(self._on_mouse_released)\n    \n            # Add conversation highlighter\n            self._highlighter = ConversationHighlighter(self._text_area.document())\n            self._highlighter.codeBlockStateChanged.connect(self._on_code_block_state_changed)\n    \n            # Get style manager\n            self._style_manager = StyleManager()\n    \n            # Track current message style\n            self._current_style: MessageSource = None\n    \n            self._style_manager.style_changed.connect(self._handle_style_changed)\n            self._handle_style_changed(self._style_manager.zoom_factor)\n    \n        def _create_text_area(self) -> ConversationTextEdit:\n            \"\"\"Create and configure the text area.\n            \n            Returns:\n                Configured ConversationTextEdit instance\n            \"\"\"\n            text_area = ConversationTextEdit()\n            text_area.setAcceptRichText(False)\n            text_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n            text_area.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n            return text_area\n    \n        def _on_mouse_released(self):\n            \"\"\"Handle mouse release from text area.\"\"\"\n            self.mouseReleased.emit()\n    \n        def set_content(self, text: str, style: MessageSource, timestamp: datetime):\n            \"\"\"Set content with style, handling incremental updates for AI responses.\n            \n            Args:\n                text: The message text content\n                style: The style type ('user', 'ai', 'system', or 'error')\n                timestamp: datetime object for the message timestamp\n            \"\"\"\n            if style != self._current_style:\n                # Style changed - update header and styling\n                if self._is_input:\n                    self._timestamp_label.setText(\"\")  # No timestamp for input\n                else:\n                    # For history messages, show role with timestamp\n                    role_text = {\n                        MessageSource.USER: \"You\",\n                        MessageSource.AI: \"Assistant\",\n                        MessageSource.SYSTEM: \"System Message\"\n                    }.get(style, \"Unknown\")\n    \n                    self._role_label.setText(role_text)\n                    timestamp_str = timestamp.strftime(\"%Y-%m-%d %H:%M:%S.%f\")[:-3]\n                    self._timestamp_label.setText(f\" @ {timestamp_str}\")\n    \n                self._current_style = style\n                self._handle_style_changed(self._style_manager.zoom_factor)\n    \n                # Full reset needed for style change\n                self._text_area.clear()\n    \n            self._text_area.set_incremental_text(text)\n    \n        def _on_selection_changed(self):\n            \"\"\"Handle selection changes in the text area.\"\"\"\n            cursor = self._text_area.textCursor()\n            has_selection = cursor.hasSelection()\n    \n            if has_selection:\n                # Emit global mouse position for accurate scroll calculations\n                self.scrollRequested.emit(QCursor.pos())\n    \n            self.selectionChanged.emit(has_selection)\n    \n        def has_selection(self) -> bool:\n            \"\"\"Check if text is selected in the text area.\"\"\"\n            return self._text_area.textCursor().hasSelection()\n    \n        def copy_selection(self):\n            \"\"\"Copy selected text to clipboard.\"\"\"\n            self._text_area.copy()\n    \n        def _on_code_block_state_changed(self, has_code_block: bool):\n            \"\"\"Handle changes in code block state.\"\"\"\n            self._text_area.set_has_code_block(has_code_block)\n            # Ensure proper scroll behavior\n            self.updateGeometry()\n    \n        def resizeEvent(self, event):\n            \"\"\"Handle resize events.\"\"\"\n            super().resizeEvent(event)\n    \n            # If we have code blocks, allow horizontal scrolling\n            if self._text_area.has_code_block():\n                self._text_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\n            else:\n                self._text_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n    \n        def clear_selection(self):\n            \"\"\"Clear any text selection in this message.\"\"\"\n            cursor = self._text_area.textCursor()\n            cursor.clearSelection()\n            self._text_area.setTextCursor(cursor)\n    \n        def _handle_style_changed(self, factor: float):\n            \"\"\"Handle the style changing\"\"\"\n            font = self.font()\n            base_font_size = self._style_manager.base_font_size\n            font.setPointSizeF(base_font_size * factor)\n            self.setFont(font)\n    \n            # Map message types to role colors\n            role_colours = {\n                MessageSource.USER: ColorRole.MESSAGE_USER,\n                MessageSource.AI: ColorRole.MESSAGE_AI,\n                MessageSource.SYSTEM: ColorRole.MESSAGE_SYSTEM\n            }\n    \n            role = role_colours.get(self._current_style, ColorRole.MESSAGE_USER)\n            label_color = self._style_manager.get_color_str(role)\n    \n            # Role label styling (bold)\n            self._role_label.setFont(font)\n            self._role_label.setStyleSheet(f\"\"\"\n                QLabel {{\n                    font-weight: bold;\n                    color: {label_color};\n                    margin: 0;\n                    padding: 0;\n                    background-color: {self._style_manager.get_color_str(ColorRole.MESSAGE_BACKGROUND)};\n                }}\n            \"\"\")\n    \n            # Timestamp label styling (normal weight)\n            self._timestamp_label.setFont(font)\n            self._timestamp_label.setStyleSheet(f\"\"\"\n                QLabel {{\n                    font-weight: normal;\n                    color: {label_color};\n                    padding: 0;\n                    margin: 0;\n                    background-color: {self._style_manager.get_color_str(ColorRole.MESSAGE_BACKGROUND)};\n                }}\n            \"\"\")\n    \n    \n            # Header widget styling\n            self._header.setStyleSheet(f\"\"\"\n                QWidget {{\n                    border: none;\n                    border-radius: 0;\n                    padding: 1px;\n                    margin: 0;\n                    background-color: {self._style_manager.get_color_str(ColorRole.MESSAGE_BACKGROUND)};\n                }}\n            \"\"\")\n    \n            # Content area styling\n            self._text_area.setFont(font)\n            self._text_area.setStyleSheet(f\"\"\"\n                QTextEdit {{\n                    color: {self._style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    selection-background-color: {self._style_manager.get_color_str(ColorRole.TEXT_SELECTED)};\n                    border: none;\n                    border-radius: 0;\n                    padding: 1px;\n                    margin: 0;\n                    background-color: {self._style_manager.get_color_str(ColorRole.MESSAGE_BACKGROUND)};\n                }}\n                QScrollBar:horizontal {{\n                    height: 12px;\n                    background: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_BACKGROUND)};\n                }}\n                QScrollBar::handle:horizontal {{\n                    background: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_HANDLE)};\n                    min-width: 20px;\n                }}\n                QScrollBar::add-page:horizontal, QScrollBar::sub-page:horizontal {{\n                    background: none;\n                }}\n                QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {{\n                    width: 0px;\n                }}\n            \"\"\")\n    \n            # Main frame styling\n            self.setStyleSheet(f\"\"\"\n                QFrame {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.MESSAGE_BACKGROUND)};\n                    margin: 0;\n                    border-radius: 8px;\n                }}\n            \"\"\")\n            self._highlighter.rehighlight()\n    ```\n    File: src/humbug/gui/conversation_tab.py\n    ```python\n    \"\"\"Unified conversation tab implementation with correct scrolling and input expansion.\"\"\"\n    \n    import asyncio\n    from datetime import datetime\n    import logging\n    import os\n    from typing import Dict, List, Optional\n    \n    from PySide6.QtWidgets import (\n        QVBoxLayout, QWidget, QScrollArea, QSizePolicy\n    )\n    from PySide6.QtCore import QTimer, QPoint, Qt, Slot\n    from PySide6.QtGui import QCursor, QResizeEvent, QTextCursor\n    \n    from humbug.ai.conversation_settings import ConversationSettings\n    from humbug.ai.ai_backend import AIBackend\n    from humbug.conversation.conversation_history import ConversationHistory\n    from humbug.conversation.message import Message\n    from humbug.conversation.message_source import MessageSource\n    from humbug.conversation.usage import Usage\n    from humbug.gui.conversation_error import ConversationError\n    from humbug.gui.color_role import ColorRole\n    from humbug.gui.message_widget import MessageWidget\n    from humbug.gui.live_input_widget import LiveInputWidget\n    from humbug.gui.status_message import StatusMessage\n    from humbug.gui.style_manager import StyleManager\n    from humbug.gui.tab_base import TabBase\n    from humbug.gui.tab_state import TabState\n    from humbug.gui.tab_type import TabType\n    from humbug.transcript.transcript_error import (\n        TranscriptError, TranscriptFormatError, TranscriptIOError\n    )\n    from humbug.transcript.transcript_handler import TranscriptHandler\n    \n    \n    class ConversationTab(TabBase):\n        \"\"\"Unified conversation tab implementing single-window feel with distinct regions.\"\"\"\n    \n        def __init__(\n            self,\n            tab_id: str,\n            path: str,\n            timestamp: datetime,\n            ai_backends: Dict[str, AIBackend],\n            parent: Optional[QWidget] = None\n        ) -> None:\n            \"\"\"\n            Initialize the unified conversation tab.\n    \n            Args:\n                tab_id: Unique identifier for this tab\n                path: Full path to transcript file\n                timestamp: ISO format timestamp for the conversation\n                ai_backends: AI backend map\n                parent: Optional parent widget\n            \"\"\"\n            super().__init__(tab_id, parent)\n            self._logger = logging.getLogger(\"ConversationTab\")\n            self._path = path\n            self._timestamp = timestamp\n            self._ai_backends = ai_backends\n            self._current_tasks: List[asyncio.Task] = []\n    \n            # Create transcript handler with provided filename\n            self._transcript_handler = TranscriptHandler(\n                path,\n                timestamp\n            )\n    \n            self._conversation = ConversationHistory(tab_id)\n            self._settings = ConversationSettings()\n            self._current_ai_message = None\n            self._messages: List[MessageWidget] = []\n            self._message_with_selection: Optional[MessageWidget] = None\n            self._is_streaming = False\n    \n            conversation_layout = QVBoxLayout(self)\n            self.setLayout(conversation_layout)\n    \n            self._scroll_area = QScrollArea()\n    \n            self._messages_container = QWidget()\n    \n            self._messages_layout = QVBoxLayout(self._messages_container)\n            self._messages_container.setLayout(self._messages_layout)\n    \n            # Set up the input box\n            self._input = LiveInputWidget(self._messages_container)\n            self._input.cursorPositionChanged.connect(self._ensure_cursor_visible)\n            self._input.selectionChanged.connect(\n                lambda has_selection: self._handle_selection_changed(self._input, has_selection)\n            )\n            self._input.scrollRequested.connect(self._handle_selection_scroll)\n            self._input.mouseReleased.connect(self._stop_scroll)\n    \n            self._messages_layout.setSpacing(10)\n            self._messages_layout.setContentsMargins(10, 10, 10, 10)\n            self._messages_layout.addStretch()\n            self._messages_layout.addWidget(self._input)\n    \n            self._install_activation_tracking(self._input)\n    \n            self._style_manager = StyleManager()\n    \n            self._messages_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n    \n            # Set up the scroll area\n            self._scroll_area.setFrameStyle(0)\n            self._scroll_area.setWidget(self._messages_container)\n            self._scroll_area.setWidgetResizable(True)\n            self._scroll_area.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n            self._scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\n            self._scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n    \n            # Main layout\n            conversation_layout.setContentsMargins(0, 1, 0, 0)\n            conversation_layout.setSpacing(0)\n            conversation_layout.addWidget(self._scroll_area)\n    \n            self.update_status()\n    \n            self._style_manager.style_changed.connect(self._handle_style_changed)\n            self._handle_style_changed(self._style_manager.zoom_factor)\n    \n            # Create timer for smooth scrolling\n            self._scroll_timer = QTimer(self)\n            self._scroll_timer.setInterval(16)  # ~60fps\n            self._scroll_timer.timeout.connect(self._update_scroll)\n            self._last_mouse_pos = None\n    \n            # Initialize tracking variables\n            self._auto_scroll = True\n            self._last_scroll_maximum = 0\n            self._last_insertion_point = 0\n    \n            # Connect to the vertical scrollbar's change signals\n            self._scroll_area.verticalScrollBar().valueChanged.connect(self._on_scroll_value_changed)\n            self._scroll_area.verticalScrollBar().rangeChanged.connect(self._on_scroll_range_changed)\n    \n            # Handle scrolling requests from input area\n            self._input.pageScrollRequested.connect(self._handle_edit_page_scroll)\n    \n            # Set initial focus to input area\n            QTimer.singleShot(0, self._set_initial_focus)\n    \n        async def fork_conversation(self) -> None:\n            \"\"\"Create a copy of this conversation with the same history.\"\"\"\n            # Generate new conversation ID using current time\n            timestamp = datetime.utcnow()\n            conversation_id = timestamp.strftime(\"%Y-%m-%d-%H-%M-%S-%f\")[:23]\n    \n            # Create new file in same directory as current conversation\n            base_dir = os.path.dirname(self._path)\n            new_path = os.path.join(base_dir, f\"{conversation_id}.conv\")\n    \n            # Create new tab using same history\n            forked_tab = ConversationTab(conversation_id, new_path, self._timestamp, self._ai_backends, self.parent())\n    \n            # Get all messages and write to new transcript\n            messages = self._conversation.get_messages()\n            transcript_messages = [msg.to_transcript_dict() for msg in messages]\n    \n            try:\n                # Write history to new transcript file\n                await forked_tab._transcript_handler.write(transcript_messages)\n            except Exception as e:\n                raise ConversationError(f\"Failed to write transcript for forked conversation: {str(e)}\") from e\n    \n            # Load messages into the new tab\n            forked_tab.load_message_history(messages)\n    \n            return forked_tab\n    \n        @property\n        def timestamp(self) -> datetime:\n            \"\"\"Get the timestamp of the conversation.\"\"\"\n            return self._timestamp\n    \n        def get_state(self, temp_state: bool=False) -> TabState:\n            \"\"\"Get serializable state for workspace persistence.\n    \n            Returns:\n                TabState containing conversation-specific state\n            \"\"\"\n            return TabState(\n                type=TabType.CONVERSATION,\n                tab_id=self._tab_id,\n                path=self._path,\n                timestamp=self._timestamp,\n                metadata={\n                    \"messages\": [msg.to_transcript_dict() for msg in self._conversation.get_messages()],\n                    \"settings\": {\n                        \"model\": self._settings.model,\n                        \"temperature\": self._settings.temperature\n                    }\n                }\n            )\n    \n        @classmethod\n        def load_from_file(cls, path: str, ai_backends: Dict[str, AIBackend], parent=None) -> 'ConversationTab':\n            \"\"\"\n            Load a conversation tab from a transcript file.\n    \n            Args:\n                path: Path to transcript file\n                ai_backends: Dictionary mapping provider names to AI backend instances\n                parent: Optional parent widget\n    \n            Returns:\n                Created ConversationTab instance\n    \n            Raises:\n                ConversationError: If the conversation tab cannot be loaded\n            \"\"\"\n            try:\n                # Read transcript\n                transcript = TranscriptHandler(path)\n                transcript_data = transcript.read()\n    \n                conversation_id = os.path.splitext(os.path.basename(path))[0]\n                timestamp = transcript_data.timestamp\n    \n                # Create conversation tab\n                conversation_tab = cls(conversation_id, path, timestamp, ai_backends, parent)\n                conversation_tab.load_message_history(transcript_data.messages)\n    \n                return conversation_tab\n    \n            except TranscriptFormatError as e:\n                raise ConversationError(f\"Failed to load conversation transcript: {str(e)}\") from e\n            except TranscriptIOError as e:\n                raise ConversationError(f\"Failed to read conversation transcript: {str(e)}\") from e\n            except Exception as e:\n                raise ConversationError(f\"Failed to create conversation tab: {str(e)}\") from e\n    \n        @classmethod\n        def restore_from_state(cls, state: TabState, parent=None, ai_backends: Dict[str, AIBackend] = None) -> 'ConversationTab':\n            \"\"\"Create and restore a conversation tab from serialized state.\n    \n            Args:\n                state: TabState containing conversation-specific state\n                ai_backends: Dictionary mapping provider names to AI backend instances\n                parent: Optional parent widget\n    \n            Returns:\n                Newly created and restored conversation tab\n    \n            Raises:\n                ValueError: If state is invalid for conversation tab\n            \"\"\"\n            if state.type != TabType.CONVERSATION:\n                raise ConversationError(f\"Invalid tab type for ConversationTab: {state.type}\")\n    \n            if not state.timestamp:\n                raise ConversationError(\"Conversation tab requires timestamp\")\n    \n            # Create new tab instance\n            tab = cls(state.tab_id, state.path, state.timestamp, ai_backends, parent)\n    \n            # Load conversation from transcript\n            try:\n                transcript = TranscriptHandler(state.path)\n                transcript_data = transcript.read()\n    \n                # Validate timestamp matches state\n                if state.timestamp != transcript_data.timestamp:\n                    raise ConversationError(\"Timestamp mismatch in transcript metadata\")\n    \n                # Load the message history\n                tab.load_message_history(transcript_data.messages)\n    \n                return tab\n    \n            except ValueError as e:\n                raise ConversationError(f\"Failed to restore conversation tab: {str(e)}\") from e\n            except Exception as e:\n                raise ValueError(f\"Failed to restore conversation tab: {str(e)}\") from e\n    \n        def set_cursor_position(self, position: Dict[str, int]) -> None:\n            \"\"\"Set cursor position in input area.\n    \n            Args:\n                position: Dictionary with 'line' and 'column' keys\n            \"\"\"\n            if not position:\n                return\n    \n            cursor = self._input.textCursor()\n            cursor.movePosition(QTextCursor.Start)\n    \n            # Move cursor to specified position\n            for _ in range(position.get(\"line\", 0)):\n                cursor.movePosition(QTextCursor.NextBlock)\n    \n            cursor.movePosition(\n                QTextCursor.Right,\n                QTextCursor.MoveAnchor,\n                position.get(\"column\", 0)\n            )\n    \n            self._input.setTextCursor(cursor)\n    \n        def get_cursor_position(self) -> Dict[str, int]:\n            \"\"\"Get current cursor position from input area.\n    \n            Returns:\n                Dictionary with 'line' and 'column' keys\n            \"\"\"\n            cursor = self._input.textCursor()\n            return {\n                \"line\": cursor.blockNumber(),\n                \"column\": cursor.columnNumber()\n            }\n    \n        async def _write_transcript(self, message: Message) -> None:\n            \"\"\"\n            Write messages to transcript file.\n    \n            Args:\n                messages: List of message dictionaries to write\n    \n            Raises:\n                IOError: If writing to transcript file fails\n            \"\"\"\n            try:\n                await self._transcript_handler.write([message.to_transcript_dict()])\n            except TranscriptError as e:\n                self._logger.error(\"Failed to write to transcript: %s\", e)\n    \n        def _handle_selection_scroll(self, mouse_pos: QPoint):\n            \"\"\"Begin scroll handling for selection drag.\"\"\"\n            viewport_pos = self._scroll_area.viewport().mapFromGlobal(mouse_pos)\n    \n            if not self._scroll_timer.isActive():\n                self._scroll_timer.start()\n    \n            self._last_mouse_pos = viewport_pos\n    \n        def _stop_scroll(self):\n            \"\"\"Stop any ongoing selection scrolling.\"\"\"\n            if self._scroll_timer.isActive():\n                self._scroll_timer.stop()\n    \n            self._last_mouse_pos = None\n    \n        def _update_scroll(self):\n            \"\"\"Update scroll position based on mouse position.\"\"\"\n            if not self._last_mouse_pos:\n                self._scroll_timer.stop()\n                return\n    \n            viewport = self._scroll_area.viewport()\n            scrollbar = self._scroll_area.verticalScrollBar()\n            current_val = scrollbar.value()\n            viewport_height = viewport.height()\n    \n            # Calculate scroll amount based on distance from viewport edges\n            if self._last_mouse_pos.y() < 0:\n                # Above viewport\n                distance_out = -self._last_mouse_pos.y()\n                if distance_out > viewport_height * 2:\n                    scrollbar.setValue(scrollbar.minimum())\n                else:\n                    scroll_amount = min(50, max(10, distance_out // 5))\n                    new_val = max(scrollbar.minimum(), current_val - scroll_amount)\n                    scrollbar.setValue(new_val)\n    \n            elif self._last_mouse_pos.y() > viewport_height:\n                # Below viewport\n                distance_out = self._last_mouse_pos.y() - viewport_height\n                if distance_out > viewport_height * 2:\n                    scrollbar.setValue(scrollbar.maximum())\n                else:\n                    scroll_amount = min(50, max(10, distance_out // 5))\n                    new_val = min(scrollbar.maximum(), current_val + scroll_amount)\n                    scrollbar.setValue(new_val)\n    \n            # Update mouse position\n            self._last_mouse_pos = self._scroll_area.viewport().mapFromGlobal(QCursor.pos())\n    \n        def get_settings(self) -> ConversationSettings:\n            \"\"\"Get current conversation settings.\"\"\"\n            return ConversationSettings(\n                model=self._settings.model,\n                temperature=self._settings.temperature\n            )\n    \n        def get_message_context(self) -> List[str]:\n            \"\"\"Get messages formatted for AI context.\"\"\"\n            return self._conversation.get_messages_for_context()\n    \n        @Slot(int)\n        def _on_scroll_value_changed(self, value: int):\n            \"\"\"\n            Handle scroll value changes to detect user scrolling.\n    \n            Args:\n                value (int): The new scroll value\n            \"\"\"\n            # Get the vertical scrollbar\n            vbar = self._scroll_area.verticalScrollBar()\n    \n            # Check if we're at the bottom\n            at_bottom = value == vbar.maximum()\n    \n            # If user scrolls up, disable auto-scroll\n            if not at_bottom:\n                self._auto_scroll = False\n    \n            # If user scrolls to bottom, re-enable auto-scroll\n            if at_bottom:\n                self._auto_scroll = True\n    \n        @Slot(int, int)\n        def _on_scroll_range_changed(self, _minimum, _maximum):\n            \"\"\"Handle the scroll range changing.\"\"\"\n            # If we're set to auto-scroll then do so now\n            if self._auto_scroll:\n                self._scroll_to_bottom()\n    \n            current_pos = self._scroll_area.verticalScrollBar().value()\n    \n            # Work out what we're supposed to do about scrolling.\n            vbar_maximum = self._scroll_area.verticalScrollBar().maximum()\n    \n            if current_pos > self._last_insertion_point:\n                if self._last_scroll_maximum != vbar_maximum:\n                    max_diff = vbar_maximum - self._last_scroll_maximum\n                    self._scroll_area.verticalScrollBar().setValue(current_pos + max_diff)\n    \n            self._last_scroll_maximum = vbar_maximum\n    \n        def _scroll_to_bottom(self) -> None:\n            \"\"\"Scroll to the bottom of the content.\"\"\"\n            scrollbar = self._scroll_area.verticalScrollBar()\n            scrollbar.setValue(scrollbar.maximum())\n    \n        def _add_message(self, message: Message) -> None:\n            \"\"\"\n            Add a message to history with appropriate styling.\n    \n            Args:\n                message: The message text\n                style: The style type ('user', 'ai', or 'system')\n                timestamp: Optional ISO format timestamp string\n            \"\"\"\n            msg_widget = MessageWidget(self)\n            msg_widget.selectionChanged.connect(\n                lambda has_selection: self._handle_selection_changed(msg_widget, has_selection)\n            )\n            msg_widget.scrollRequested.connect(self._handle_selection_scroll)\n            msg_widget.mouseReleased.connect(self._stop_scroll)\n            msg_widget.set_content(message.content, message.source, message.timestamp)\n    \n            # Add widget before input\n            self._messages_layout.insertWidget(self._messages_layout.count() - 1, msg_widget)\n            self._messages.append(msg_widget)\n    \n            self._install_activation_tracking(msg_widget)\n    \n            # When we call this we should always scroll to the bottom and restore auto-scrolling\n            self._auto_scroll = True\n            self._scroll_to_bottom()\n    \n            self._conversation.add_message(message)\n    \n        def _handle_selection_changed(self, message_widget: MessageWidget, has_selection: bool):\n            \"\"\"Handle selection changes in message widgets.\"\"\"\n            if has_selection:\n                if self._message_with_selection and self._message_with_selection != message_widget:\n                    self._message_with_selection.clear_selection()\n                self._message_with_selection = message_widget\n            elif message_widget == self._message_with_selection:\n                self._message_with_selection = None\n    \n        def has_selection(self) -> bool:\n            \"\"\"Check if any message has selected text.\"\"\"\n            return self._message_with_selection is not None and self._message_with_selection.has_selection()\n    \n        def update_status(self) -> None:\n            \"\"\"Update status bar with token counts and settings.\"\"\"\n            counts = self._conversation.get_token_counts()\n            temp_display = f\"Temp: {self._settings.temperature:.1f}\" if self._settings.temperature is not None else \"Temp: N/A\"\n            message = StatusMessage(\n                f\"Model: {self._settings.model} | \"\n                f\"{temp_display} | \"\n                f\"Last response - Input: {counts['input']} ({self._settings.context_window}) | \"\n                f\"Output: {counts['output']}\"\n            )\n            self.status_message.emit(message)\n    \n        def _handle_edit_page_scroll(self) -> None:\n            \"\"\"\n            Handle page up/down scroll requests.\n    \n            Args:\n                direction: The direction to scroll (PAGE_UP or PAGE_DOWN)\n            \"\"\"\n            # Input cursor has already moved - just ensure it's visible\n            self._ensure_cursor_visible()\n    \n        def _ensure_cursor_visible(self):\n            \"\"\"Ensure the cursor remains visible when it moves.\"\"\"\n            total_height = sum(msg.sizeHint().height() + self._messages_layout.spacing() for msg in self._messages)\n            input_cursor = self._input.cursorRect()\n    \n            self._scroll_area.ensureVisible(\n                input_cursor.x(),\n                total_height + input_cursor.y(),\n                1,\n                50\n            )\n    \n        def get_input_text(self) -> str:\n            \"\"\"Get the current input text.\"\"\"\n            return self._input.toPlainText()\n    \n        def set_input_text(self, text: str):\n            \"\"\"Set the input text.\"\"\"\n            self._input.setPlainText(text)\n            self._input.setFocus()\n    \n        def _set_initial_focus(self):\n            \"\"\"Set initial focus to input area.\"\"\"\n            self._input.setFocus()\n    \n        async def update_streaming_response(\n            self,\n            content: str,\n            usage: Optional[Usage] = None,\n            error: Optional[Dict] = None\n        ) -> Optional[Message]:\n            \"\"\"Update the current AI response in the conversation.\"\"\"\n            if error:\n                self._is_streaming = False\n                self._input.set_streaming(False)\n    \n                # For cancellation, preserve the partial response first\n                if error.get(\"code\") == \"cancelled\" and self._current_ai_message:\n                    message = self._conversation.update_message(\n                        self._current_ai_message.id,\n                        content=self._current_ai_message.content,\n                        completed=False\n                    )\n                    if message:\n                        await self._write_transcript(message)\n                    self._current_ai_message = None\n    \n                # Then add the error message\n                error_msg = f\"{error['message']}\"\n                error_message = Message.create(\n                    MessageSource.SYSTEM,\n                    error_msg,\n                    error=error\n                )\n                self._add_message(error_message)\n                asyncio.create_task(self._write_transcript(error_message))\n                self._logger.warning(\"AI response error: %s\", error_msg)\n                return error_message\n    \n            if not self._is_streaming:\n                self._is_streaming = True\n                self._input.set_streaming(True)\n    \n            # If our last message was not from the AI then create a new one.\n            if not self._current_ai_message:\n                # Create and add initial message\n    \n                settings = self.get_settings()\n                message = Message.create(\n                    MessageSource.AI,\n                    content,\n                    model=settings.model,\n                    temperature=settings.temperature,\n                    completed=False\n                )\n                self._add_message(message)\n                self._current_ai_message = message\n            else:\n                # Store current scroll position before appending.  If this insertion triggers a change\n                # in scrolling state then we'll get a signal and will adjust the scrollbar state based\n                # on this.\n                total_height = self._messages_container.height()\n                input_height = self._input.height()\n                self._last_insertion_point =  total_height - input_height - 2 * self._messages_layout.spacing()\n    \n                # Update our message\n                self._messages[-1].set_content(content, MessageSource.AI, self._current_ai_message.timestamp)\n    \n                # Update existing message\n                message = self._conversation.update_message(\n                    self._current_ai_message.id,\n                    content,\n                    usage=usage,\n                    completed=(usage is not None)\n                )\n                if not message:\n                    return None\n    \n            if usage:\n                self._is_streaming = False\n                self._input.set_streaming(False)\n                self.update_status()\n                self._current_ai_message = None\n                await self._write_transcript(message)\n                return message\n    \n            return message\n    \n        def load_message_history(self, messages: List[Message]):\n            \"\"\"\n            Load existing message history from transcript.\n    \n            Args:\n                messages: List of Message objects to load\n            \"\"\"\n            for message in messages:\n                self._add_message(message)\n    \n                # Update settings and status if AI message\n                if message.source == MessageSource.AI:\n                    if message.usage:\n                        self._conversation.update_last_tokens(\n                            message.usage.prompt_tokens,\n                            message.usage.completion_tokens\n                        )\n                    if message.model:\n                        self.update_conversation_settings(ConversationSettings(\n                            model=message.model,\n                            temperature=message.temperature\n                        ))\n    \n            # Update display with final state\n            self.update_status()\n    \n            # Ensure we're scrolled to the end\n            self._auto_scroll = True\n            self._scroll_to_bottom()\n    \n        def resizeEvent(self, event: QResizeEvent) -> None:\n            \"\"\"Handle resize events.\"\"\"\n            super().resizeEvent(event)\n    \n            if self._auto_scroll:\n                self._scroll_to_bottom()\n    \n        def _sanitize_input(self, text: str) -> str:\n            \"\"\"Strip control characters from input text, preserving newlines.\"\"\"\n            return ''.join(char for char in text if char == '\\n' or (ord(char) >= 32 and ord(char) != 127))\n    \n        async def _process_ai_response(self, message: str):\n            \"\"\"Process AI response with streaming.\"\"\"\n            try:\n                self._logger.debug(\"=== Starting new AI response ===\")\n    \n                # Get appropriate backend for conversation\n                settings = self.get_settings()\n                provider = ConversationSettings.get_provider(settings.model)\n                backend = self._ai_backends.get(provider)\n    \n                if not backend:\n                    error_msg = f\"No backend available for provider: {provider}\"\n                    self._logger.error(error_msg)\n                    error_message = Message.create(\n                        MessageSource.SYSTEM,\n                        error_msg,\n                        {\"code\": \"backend_error\", \"message\": error_msg}\n                    )\n                    self._add_message(error_message)\n                    asyncio.create_task(self._write_transcript(error_message))\n                    return\n    \n                stream = backend.stream_message(\n                    message,\n                    self.get_message_context(),\n                    self.tab_id\n                )\n    \n                async for response in stream:\n                    try:\n                        message = await self.update_streaming_response(\n                            content=response.content,\n                            usage=response.usage,\n                            error=response.error\n                        )\n    \n                        # Handle retryable errors\n                        if response.error:\n                            if response.error['code'] in ['network_error', 'timeout']:\n                                continue  # Continue to next retry attempt\n                            return  # Non-retryable error\n    \n                    except StopAsyncIteration:\n                        break\n    \n            except (asyncio.CancelledError, GeneratorExit):\n                self._logger.debug(\"AI response cancelled\")\n                await self.update_streaming_response(\n                    content=\"\",\n                    error={\n                        \"code\": \"cancelled\",\n                        \"message\": \"Request cancelled by user\"\n                    }\n                )\n                return\n    \n            except Exception as e:\n                self._logger.exception(\n                    \"Error processing AI response with model %s: %s\",\n                    settings.model,\n                    str(e)\n                )\n                error = {\n                    \"code\": \"process_error\",\n                    \"message\": str(e),\n                    \"details\": {\"type\": type(e).__name__}\n                }\n                await self.update_streaming_response(\n                    content=\"\",\n                    error=error\n                )\n    \n            finally:\n                self._logger.debug(\"=== Finished AI response ===\")\n    \n        def cancel_current_tasks(self):\n            \"\"\"Cancel any ongoing AI response tasks.\"\"\"\n            for task in self._current_tasks:\n                if not task.done():\n                    task.cancel()\n    \n        def update_conversation_settings(self, new_settings: ConversationSettings):\n            \"\"\"Update conversation settings and associated backend.\"\"\"\n            self._settings = new_settings\n            self.update_status()\n            provider = ConversationSettings.get_provider(new_settings.model)\n            backend = self._ai_backends.get(provider)\n            if backend:\n                backend.update_conversation_settings(self.tab_id, new_settings)\n    \n        def _handle_style_changed(self, factor: float) -> None:\n            font = self.font()\n            base_font_size = self._style_manager.base_font_size\n            font.setPointSizeF(base_font_size * factor)\n            self.setFont(font)\n    \n            self._messages_container.setStyleSheet(f\"\"\"\n                QWidget {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.TAB_BACKGROUND_ACTIVE)};\n                }}\n            \"\"\")\n            self._scroll_area.setStyleSheet(f\"\"\"\n                QScrollArea {{\n                    border: none;\n                }}\n                QScrollBar:vertical {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_BACKGROUND)};\n                    width: 12px;\n                }}\n                QScrollBar::handle:vertical {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_HANDLE)};\n                    min-height: 20px;\n                }}\n                QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {{\n                    background: none;\n                }}\n                QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{\n                    height: 0px;\n                }}\n            \"\"\")\n            self.setStyleSheet(f\"\"\"\n                QFrame {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.TAB_BACKGROUND_ACTIVE)};\n                    border-top: 1px solid {self._style_manager.get_color_str(ColorRole.TAB_BACKGROUND_ACTIVE)};\n                }}\n            \"\"\")\n    \n        def can_close(self) -> bool:\n            return True\n    \n        def close(self) -> None:\n            pass\n    \n        def can_save(self) -> bool:\n            return False\n    \n        def save(self) -> bool:\n            return True\n    \n        def can_save_as(self) -> bool:\n            return False\n    \n        def save_as(self) -> bool:\n            return True\n    \n        def can_undo(self) -> bool:\n            \"\"\"Check if undo is available.\"\"\"\n            return self._input.document().isUndoAvailable()\n    \n        def undo(self):\n            \"\"\"Undo the last edit operation.\"\"\"\n            self._input.undo()\n    \n        def can_redo(self) -> bool:\n            \"\"\"Check if redo is available.\"\"\"\n            return self._input.document().isRedoAvailable()\n    \n        def redo(self):\n            \"\"\"Redo the last undone edit operation.\"\"\"\n            self._input.redo()\n    \n        def can_cut(self) -> bool:\n            \"\"\"Check if cut is available.\"\"\"\n            return self._input.hasFocus() and self._input.textCursor().hasSelection()\n    \n        def cut(self):\n            \"\"\"Cut selected text to clipboard.\"\"\"\n            self._input.cut()\n    \n        def can_copy(self) -> bool:\n            \"\"\"Check if copy is available.\"\"\"\n            return self.has_selection() or (self._input.hasFocus() and self._input.textCursor().hasSelection())\n    \n        def copy(self):\n            \"\"\"Copy selected text to clipboard.\"\"\"\n            if self._input.hasFocus():\n                self._input.copy()\n            elif self._message_with_selection:\n                self._message_with_selection.copy_selection()\n    \n        def can_paste(self) -> bool:\n            \"\"\"Check if paste is available.\"\"\"\n            return self._input.hasFocus()\n    \n        def paste(self):\n            \"\"\"Paste text from clipboard.\"\"\"\n            self._input.paste()\n    \n        def can_submit(self) -> bool:\n            has_text = bool(self.get_input_text())\n            return has_text and not self._is_streaming\n    \n        def submit(self):\n            \"\"\"Submit current input text.\"\"\"\n            content = self._sanitize_input(self.get_input_text().strip())\n            if not content:\n                return\n    \n            self._input.clear()\n            self._input.set_streaming(True)\n    \n            # Add the user message to the conversation\n            message = Message.create(MessageSource.USER, content)\n            self._add_message(message)\n            asyncio.create_task(self._write_transcript(message))\n    \n            # Start AI response\n            task = asyncio.create_task(self._process_ai_response(content))\n            self._current_tasks.append(task)\n    \n            def task_done_callback(task):\n                try:\n                    self._current_tasks.remove(task)\n                except ValueError:\n                    self._logger.debug(\"Task already removed\")\n    \n            task.add_done_callback(task_done_callback)\n    ```\n    File: src/humbug/gui/conversation_text_edit.py\n    ```python\n    \"\"\"Widget for displaying parts of individual conversation messages.\"\"\"\n    \n    import logging\n    \n    from PySide6.QtWidgets import (\n        QFrame, QTextEdit, QSizePolicy, QScrollArea\n    )\n    from PySide6.QtCore import Qt, QSize, QTimer, Signal, Slot\n    from PySide6.QtGui import (\n        QTextOption, QTextCursor, QMouseEvent, QKeyEvent\n    )\n    \n    from humbug.gui.style_manager import StyleManager\n    \n    \n    class ConversationTextEdit(QTextEdit):\n        \"\"\"QTextEdit that automatically adjusts its height to content.\"\"\"\n    \n        mouseReleased = Signal(QMouseEvent)\n        pageScrollRequested = Signal()\n    \n        def __init__(self, parent=None):\n            super().__init__(parent)\n            self.document().documentLayout().documentSizeChanged.connect(self._on_content_changed)\n            self.document().setDocumentMargin(1)\n            self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n            self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n            self.setFrameStyle(QFrame.NoFrame)\n    \n            # Force the widget to always use the width of its container\n            self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Minimum)\n    \n            # Set word wrap mode to adjust to widget width\n            self.setWordWrapMode(QTextOption.WrapAtWordBoundaryOrAnywhere)\n    \n            # Calculate tab stops\n            self._style_manager = StyleManager()\n            self._style_manager.style_changed.connect(self._handle_style_changed)\n            self._handle_style_changed(self._style_manager.zoom_factor)\n    \n            # Batch update handling\n            self._update_timer = QTimer(self)\n            self._update_timer.setSingleShot(True)\n            self._update_timer.setInterval(16)\n            self._update_timer.timeout.connect(self._process_delayed_update)\n            self._pending_update = False\n    \n            # Track current content length for incremental updates\n            self._current_length = 0\n    \n            # Track code block state\n            self._has_code_block = False\n    \n            self._logger = logging.getLogger(\"ConversationTextEdit\")\n    \n        def _handle_style_changed(self, _factor: float) -> None:\n            self.setTabStopDistance(self._style_manager.get_space_width() * 8)\n    \n        def mouseReleaseEvent(self, event):\n            \"\"\"Propagate mouse release events to parent.\"\"\"\n            super().mouseReleaseEvent(event)\n            self.mouseReleased.emit(event)\n    \n        def set_has_code_block(self, has_code: bool):\n            \"\"\"Update word wrap mode based on whether content contains code blocks.\"\"\"\n            if has_code == self._has_code_block:\n                return\n    \n            self._has_code_block = has_code\n            if has_code:\n                self.setWordWrapMode(QTextOption.NoWrap)\n                self.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\n            else:\n                self.setWordWrapMode(QTextOption.WrapAtWordBoundaryOrAnywhere)\n                self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n    \n            # Force layout update\n            self._on_content_changed()\n    \n        def has_code_block(self) -> bool:\n            \"\"\"Check if content contains code blocks.\"\"\"\n            return self._has_code_block\n    \n        def wheelEvent(self, event):\n            \"\"\"Handle wheel events for horizontal scrolling.\"\"\"\n            # If this is a code block, handle horizontal scrolling for compatible mice\n            if self._has_code_block and event.angleDelta().x() != 0:\n                # Get the horizontal scrollbar\n                hbar = self.horizontalScrollBar()\n                if hbar:\n                    # Use the horizontal component directly\n                    delta = event.angleDelta().x()\n                    hbar.setValue(hbar.value() - delta)\n                    event.accept()\n                    return\n    \n            # For all other cases, propagate the event up\n            event.ignore()\n    \n        def keyPressEvent(self, event: QKeyEvent):\n            \"\"\"Handle special key events.\"\"\"\n            # Is this a read-only widget?  If it is then we don't want to process certain key events,\n            # leaving it to the parent to handle them.\n            if self.isReadOnly():\n                if event.key() in (Qt.Key_PageUp, Qt.Key_PageDown, Qt.Key_Up, Qt.Key_Down):\n                    event.ignore()\n    \n                return\n    \n            if event.key() == Qt.Key_Home:\n                cursor = self.textCursor()\n                cursor.movePosition(QTextCursor.StartOfLine)\n                self.setTextCursor(cursor)\n                event.accept()\n                return\n    \n            if event.key() == Qt.Key_End:\n                cursor = self.textCursor()\n                cursor.movePosition(QTextCursor.EndOfLine)\n                self.setTextCursor(cursor)\n                event.accept()\n                return\n    \n            if event.key() in (Qt.Key_PageUp, Qt.Key_PageDown):\n                # Find the scroll area viewport by walking up hierarchy\n                widget = self\n                viewport = None\n                while widget:\n                    if isinstance(widget.parent(), QScrollArea):\n                        viewport = widget.parent().viewport()\n                        break\n                    widget = widget.parent()\n    \n                if viewport:\n                    # Calculate visible lines based on cursor height\n                    cursor_rect = self.cursorRect()\n                    line_height = cursor_rect.height()\n                    visible_lines = max(1, viewport.height() // line_height)\n    \n                    # Move cursor by calculated lines\n                    cursor = self.textCursor()\n                    orig_pos = cursor.position()\n    \n                    movement = QTextCursor.Up if event.key() == Qt.Key_PageUp else QTextCursor.Down\n                    cursor.movePosition(movement, QTextCursor.MoveAnchor, visible_lines)\n    \n                    # Only set cursor if it actually moved\n                    if cursor.position() != orig_pos:\n                        self.setTextCursor(cursor)\n                        # Signal for scroll - ConversationTab will handle ensuring cursor visibility\n                        self.pageScrollRequested.emit()\n    \n                event.accept()\n                return\n    \n            super().keyPressEvent(event)\n    \n        @Slot()\n        def _on_content_changed(self):\n            \"\"\"Queue a content update instead of processing immediately.\"\"\"\n            if not self._pending_update:\n                self._pending_update = True\n                self._update_timer.start()\n    \n        @Slot()\n        def _process_delayed_update(self):\n            \"\"\"Process the queued size update.\"\"\"\n            self._pending_update = False\n            self.updateGeometry()\n    \n            # Ensure parent MessageWidget updates as well\n            if self.parent():\n                self.parent().updateGeometry()\n    \n        def set_incremental_text(self, text: str):\n            \"\"\"Update text content incrementally by only adding new content.\"\"\"\n            if len(text) == self._current_length:\n                # No new content\n                return\n    \n            if len(text) < self._current_length:\n                # Content is shorter than what we have - do a full reset\n                self._logger.warning(\"text is shorter than before!: '%s'\", text)\n                self.clear()\n                self._current_length = 0\n                return\n    \n            # Store the current cursor position and selection\n            current_cursor = self.textCursor()\n            position = current_cursor.position()\n            has_selection = current_cursor.hasSelection()\n            selection_start = current_cursor.selectionStart()\n            selection_end = current_cursor.selectionEnd()\n    \n            # Create a new cursor for inserting text at the end\n            insert_cursor = QTextCursor(self.document())\n            insert_cursor.movePosition(QTextCursor.End)\n            self.setTextCursor(insert_cursor)\n    \n            # Insert the new text\n            new_text = text[self._current_length:]\n            insert_cursor.insertText(new_text)\n            self._current_length = len(text)\n    \n            # Restore the original cursor position and selection\n            restored_cursor = self.textCursor()\n            restored_cursor.setPosition(position)\n            if has_selection:\n                # If there was a selection, restore it\n                if position == selection_end:\n                    # Cursor was at end of selection\n                    restored_cursor.setPosition(selection_start, QTextCursor.MoveAnchor)\n                    restored_cursor.setPosition(selection_end, QTextCursor.KeepAnchor)\n                else:\n                    # Cursor was at start of selection\n                    restored_cursor.setPosition(selection_end, QTextCursor.KeepAnchor)\n    \n            self.setTextCursor(restored_cursor)\n    \n        def clear(self):\n            \"\"\"Override clear to reset current length.\"\"\"\n            super().clear()\n            self._current_length = 0\n            self._on_content_changed()\n    \n        def _height(self) -> int:\n            height = int(self.document().size().height())\n            if self._has_code_block and self.horizontalScrollBar().isVisible():\n                # Additional space for scrollbar with gap\n                height += 14\n    \n            return height\n    \n        def minimumSizeHint(self) -> QSize:\n            \"\"\"Calculate minimum size based on content.\"\"\"\n            width = super().minimumSizeHint().width()\n            return QSize(width, self._height())\n    \n        def sizeHint(self) -> QSize:\n            \"\"\"Calculate idea size based on content.\"\"\"\n            width = super().sizeHint().width()\n            return QSize(width, self._height())\n    ```\n    File: src/humbug/gui/conversation_highlighter.py\n    ```python\n    \"\"\"Conversation code highlighter.\"\"\"\n    \n    import logging\n    from typing import Optional\n    \n    from PySide6.QtGui import (\n        QTextCharFormat, QSyntaxHighlighter,\n        QTextDocument, QTextBlockUserData\n    )\n    from PySide6.QtCore import Signal\n    \n    from humbug.gui.color_role import ColorRole\n    from humbug.gui.style_manager import StyleManager\n    from humbug.syntax.conversation_parser import ConversationParser, ConversationParserState\n    from humbug.syntax.programming_language import ProgrammingLanguage\n    \n    \n    class ConversationHighlighterBlockData(QTextBlockUserData):\n        def __init__(self):\n            super().__init__()\n            self.fence_depth = 0\n            self.parser_state = None\n    \n    \n    class ConversationHighlighter(QSyntaxHighlighter):\n        \"\"\"Syntax highlighter for Conversation code blocks.\"\"\"\n    \n        # Signal emitted when code block state changes\n        codeBlockStateChanged = Signal(bool)\n    \n        def __init__(self, parent: Optional[QTextDocument] = None) -> None:\n            \"\"\"Initialize the highlighter.\"\"\"\n            super().__init__(parent)\n    \n            self._style_manager = StyleManager()\n    \n            # Consistent font family fallback sequence for all code formats\n            self._code_font_families = self._style_manager.monospace_font_families\n            self._has_code_block = False\n    \n            self._logger = logging.getLogger(\"ConversationHighlighter\")\n    \n        def highlightBlock(self, text: str) -> None:\n            \"\"\"Apply highlighting to the given block of text.\"\"\"\n            try:\n                current_block = self.currentBlock()\n                prev_block = current_block.previous()\n    \n                prev_block_data: ConversationHighlighterBlockData = None\n                prev_parser_state = None\n                fence_depth = 0\n                if prev_block:\n                    prev_block_data = prev_block.userData()\n                    if prev_block_data:\n                        prev_parser_state = prev_block_data.parser_state\n                        fence_depth = prev_block_data.fence_depth\n    \n                language = ProgrammingLanguage.UNKNOWN\n                contination_state = -1\n                current_fence_depth = 0\n                current_block_data: ConversationHighlighterBlockData = current_block.userData()\n                if current_block_data:\n                    current_fence_depth = current_block_data.fence_depth\n                    current_parser_data: ConversationParserState = current_block_data.parser_state\n                    if current_parser_data:\n                        language = current_parser_data.language\n                        contination_state = current_parser_data.continuation_state\n    \n                parser = ConversationParser()\n                parser_state: ConversationParserState = parser.parse(prev_parser_state, text)\n    \n                in_code_block = False\n    \n                while True:\n                    token = parser.get_next_token()\n                    if token is None:\n                        break\n    \n                    match token.type:\n                        case 'FENCE_START':\n                            self.setFormat(0, len(text), self._style_manager.get_highlight(\"LANGUAGE\"))\n                            fence_depth += 1\n                            continue\n    \n                        case 'FENCE_END':\n                            self.setFormat(0, len(text), self._style_manager.get_highlight(\"LANGUAGE\"))\n                            fence_depth -= 1\n                            continue\n    \n                        case 'BACKTICK':\n                            if fence_depth == 0:\n                                in_code_block = not in_code_block\n                                continue\n    \n                    if fence_depth > 0:\n                        self.setFormat(token.start, len(token.value), self._style_manager.get_highlight(token.type))\n                        continue\n    \n                    if in_code_block:\n                        self.setFormat(token.start, len(token.value), self._style_manager.get_highlight(\"BACKTICK_CODE\"))\n                        continue\n    \n                # Check if we need to rehighlight everything from this block onwards.\n                if (contination_state != parser_state.continuation_state) or (current_fence_depth != fence_depth) or (language != parser_state.language):\n                    # It doesn't matter what we set this to, it just needs to be different to what it was before\n                    self.setCurrentBlockState(self.currentBlockState() + 1)\n    \n                block_data = ConversationHighlighterBlockData()\n                block_data.parser_state = parser_state\n                block_data.fence_depth = fence_depth\n                current_block.setUserData(block_data)\n    \n                # Check if document contains any code blocks\n                has_code = False\n                block = self.document().firstBlock()\n                while block.isValid():\n                    data = block.userData()\n                    if data and data.fence_depth > 0:\n                        has_code = True\n                        break\n    \n                    block = block.next()\n    \n                # Emit signal if state changed\n                if has_code != self._has_code_block:\n                    self._has_code_block = has_code\n                    self.codeBlockStateChanged.emit(has_code)\n    \n            except Exception:\n                self._logger.exception(\"highlighting exception\")\n    ```\n    File: src/humbug/gui/main_window.py\n    ```python\n    \"\"\"Main window implementation for Humbug application.\"\"\"\n    \n    import asyncio\n    import json\n    import logging\n    import os\n    from typing import Dict, Optional\n    \n    from m6rclib import (\n        MetaphorParser, MetaphorParserError, format_ast, format_errors\n    )\n    \n    from PySide6.QtWidgets import (\n        QMainWindow, QWidget, QVBoxLayout, QMenuBar, QFileDialog, QSplitter, QLabel\n    )\n    from PySide6.QtCore import Qt, QTimer, Slot\n    from PySide6.QtGui import QKeyEvent, QAction, QKeySequence\n    from PySide6.QtWidgets import QStatusBar\n    \n    from humbug.ai.ai_backend import AIBackend\n    from humbug.gui.about_dialog import AboutDialog\n    from humbug.gui.conversation_error import ConversationError\n    from humbug.gui.color_role import ColorRole\n    from humbug.gui.message_box import MessageBox, MessageBoxType\n    from humbug.gui.status_message import StatusMessage\n    from humbug.gui.style_manager import StyleManager, ColorMode\n    from humbug.gui.tab_manager import TabManager\n    from humbug.gui.workspace_settings_dialog import WorkspaceSettingsDialog\n    from humbug.gui.workspace_file_tree import WorkspaceFileTree\n    from humbug.workspace.workspace_manager import WorkspaceManager\n    from humbug.workspace.workspace_error import WorkspaceError, WorkspaceExistsError\n    \n    \n    class MainWindow(QMainWindow):\n        \"\"\"Main window for the Humbug application.\"\"\"\n    \n        def __init__(self, ai_backends: Dict[str, AIBackend]):\n            \"\"\"Initialize the main window.\"\"\"\n            super().__init__()\n            self._ai_backends = ai_backends\n            self._logger = logging.getLogger(\"MainWindow\")\n            self._dark_mode = True\n    \n            # Humbug menu actions\n            self._about_action = QAction(\"About Humbug\", self)\n            self._about_action.triggered.connect(self._show_about_dialog)\n    \n            self._quit_action = QAction(\"Quit Humbug\", self)\n            self._quit_action.setShortcut(QKeySequence(\"Ctrl+Q\"))\n            self._quit_action.triggered.connect(self.close)\n    \n            # File menu actions\n            self._new_workspace_action = QAction(\"New Workspace\", self)\n            self._new_workspace_action.setShortcut(QKeySequence(\"Ctrl+Alt+N\"))\n            self._new_workspace_action.triggered.connect(self._new_workspace)\n    \n            self._new_conv_action = QAction(\"New Conversation\", self)\n            self._new_conv_action.setShortcut(QKeySequence(\"Ctrl+Shift+N\"))\n            self._new_conv_action.triggered.connect(self._new_conversation)\n    \n            self._new_metaphor_conv_action = QAction(\"New Metaphor Conversation...\", self)\n            self._new_metaphor_conv_action.setShortcut(QKeySequence(\"Ctrl+Shift+M\"))\n            self._new_metaphor_conv_action.triggered.connect(self._new_metaphor_conversation)\n    \n            self._new_file_action = QAction(\"New File\", self)\n            self._new_file_action.setShortcut(QKeySequence.New)\n            self._new_file_action.triggered.connect(self._new_file)\n    \n            self._open_workspace_action = QAction(\"Open Workspace\", self)\n            self._open_workspace_action.setShortcut(QKeySequence(\"Ctrl+Alt+O\"))\n            self._open_workspace_action.triggered.connect(self._open_workspace)\n    \n            self._open_conv_action = QAction(\"Open Conversation...\", self)\n            self._open_conv_action.setShortcut(QKeySequence(\"Ctrl+Shift+O\"))\n            self._open_conv_action.triggered.connect(self._open_conversation)\n    \n            self._open_file_action = QAction(\"Open File...\", self)\n            self._open_file_action.setShortcut(QKeySequence.Open)\n            self._open_file_action.triggered.connect(self._open_file)\n    \n            self._fork_conv_action = QAction(\"Fork Conversation\", self)\n            self._fork_conv_action.setShortcut(QKeySequence(\"Ctrl+Shift+F\"))\n            self._fork_conv_action.triggered.connect(self._fork_conversation)\n    \n            self._save_action = QAction(\"Save\", self)\n            self._save_action.setShortcut(QKeySequence.Save)\n            self._save_action.triggered.connect(self._save_file)\n    \n            self._save_as_action = QAction(\"Save As...\", self)\n            self._save_as_action.setShortcut(QKeySequence.SaveAs)\n            self._save_as_action.triggered.connect(self._save_file_as)\n    \n            self._close_tab_action = QAction(\"Close Tab\", self)\n            self._close_tab_action.setShortcut(QKeySequence(\"Ctrl+W\"))\n            self._close_tab_action.triggered.connect(self._close_tab)\n    \n            self._close_workspace_action = QAction(\"Close Workspace\", self)\n            self._close_workspace_action.setShortcut(QKeySequence(\"Ctrl+Alt+W\"))\n            self._close_workspace_action.triggered.connect(self._close_workspace)\n    \n            # Edit menu actions\n            self._submit_message_action = QAction(\"Submit Message\", self)\n            self._submit_message_action.setShortcut(QKeySequence(\"Ctrl+J\"))\n            self._submit_message_action.triggered.connect(self._submit_message)\n    \n            self._undo_action = QAction(\"Undo\", self)\n            self._undo_action.setShortcut(QKeySequence(\"Ctrl+Z\"))\n            self._undo_action.triggered.connect(self._undo)\n    \n            self._redo_action = QAction(\"Redo\", self)\n            self._redo_action.setShortcut(QKeySequence(\"Ctrl+Shift+Z\"))\n            self._redo_action.triggered.connect(self._redo)\n    \n            self._cut_action = QAction(\"Cut\", self)\n            self._cut_action.setShortcut(QKeySequence(\"Ctrl+X\"))\n            self._cut_action.triggered.connect(self._cut)\n    \n            self._copy_action = QAction(\"Copy\", self)\n            self._copy_action.setShortcut(QKeySequence(\"Ctrl+C\"))\n            self._copy_action.triggered.connect(self._copy)\n    \n            self._paste_action = QAction(\"Paste\", self)\n            self._paste_action.setShortcut(QKeySequence(\"Ctrl+V\"))\n            self._paste_action.triggered.connect(self._paste)\n    \n            self._workspace_settings_action = QAction(\"Workspace Settings\", self)\n            self._workspace_settings_action.setShortcut(QKeySequence(\"Ctrl+Alt+,\"))\n            self._workspace_settings_action.triggered.connect(self._show_workspace_settings_dialog)\n    \n            self._conv_settings_action = QAction(\"Conversation Settings\", self)\n            self._conv_settings_action.setShortcut(QKeySequence(\"Ctrl+,\"))\n            self._conv_settings_action.triggered.connect(self._show_conversation_settings_dialog)\n    \n            # View menu actions\n            self._dark_mode_action = QAction(\"&Dark Mode\", self)\n            self._dark_mode_action.setCheckable(True)\n            self._dark_mode_action.setChecked(True)\n            self._dark_mode_action.triggered.connect(self._handle_dark_mode)\n    \n            self._zoom_in_action = QAction(\"Zoom In\", self)\n            self._zoom_in_action.setShortcut(QKeySequence(\"Ctrl+=\"))\n            self._zoom_in_action.triggered.connect(lambda: self._handle_zoom(1.189027))\n    \n            self._zoom_out_action = QAction(\"Zoom Out\", self)\n            self._zoom_out_action.setShortcut(QKeySequence(\"Ctrl+-\"))\n            self._zoom_out_action.triggered.connect(lambda: self._handle_zoom(1/1.189027))\n    \n            self._reset_zoom_action = QAction(\"Reset Zoom\", self)\n            self._reset_zoom_action.setShortcut(QKeySequence(\"Ctrl+0\"))\n            self._reset_zoom_action.triggered.connect(lambda: self._set_zoom(1.0))\n    \n            self._show_all_columns_action = QAction(\"Show All Columns\", self)\n            self._show_all_columns_action.setShortcut(QKeySequence(\"Ctrl+\\\\\"))\n            self._show_all_columns_action.triggered.connect(self._show_all_columns)\n    \n            self._split_column_left_action = QAction(\"Split Column Left\", self)\n            self._split_column_left_action.setShortcut(QKeySequence(\"Ctrl+Shift+[\"))\n            self._split_column_left_action.triggered.connect(lambda: self._split_column(True))\n    \n            self._split_column_right_action = QAction(\"Split Column Right\", self)\n            self._split_column_right_action.setShortcut(QKeySequence(\"Ctrl+Shift+]\"))\n            self._split_column_right_action.triggered.connect(lambda: self._split_column(False))\n    \n            self._merge_column_left_action = QAction(\"Merge Column Left\", self)\n            self._merge_column_left_action.setShortcut(QKeySequence(\"Ctrl+[\"))\n            self._merge_column_left_action.triggered.connect(lambda: self._merge_column(True))\n    \n            self._merge_column_right_action = QAction(\"Merge Column Right\", self)\n            self._merge_column_right_action.setShortcut(QKeySequence(\"Ctrl+]\"))\n            self._merge_column_right_action.triggered.connect(lambda: self._merge_column(False))\n    \n            self._menu_bar = QMenuBar(self)\n            self.setMenuBar(self._menu_bar)\n    \n            # Humbug menu\n            humbug_menu = self._menu_bar.addMenu(\"&Humbug\")\n            humbug_menu.addAction(self._about_action)\n            humbug_menu.addSeparator()\n            humbug_menu.addAction(self._quit_action)\n    \n            # File menu\n            file_menu = self._menu_bar.addMenu(\"&File\")\n            file_menu.addAction(self._new_workspace_action)\n            file_menu.addAction(self._new_conv_action)\n            file_menu.addAction(self._new_metaphor_conv_action)\n            file_menu.addAction(self._new_file_action)\n            file_menu.addSeparator()\n            file_menu.addAction(self._open_workspace_action)\n            file_menu.addAction(self._open_conv_action)\n            file_menu.addAction(self._open_file_action)\n            file_menu.addSeparator()\n            file_menu.addAction(self._fork_conv_action)\n            file_menu.addSeparator()\n            file_menu.addAction(self._save_action)\n            file_menu.addAction(self._save_as_action)\n            file_menu.addSeparator()\n            file_menu.addAction(self._close_workspace_action)\n            file_menu.addAction(self._close_tab_action)\n    \n            # Edit menu\n            edit_menu = self._menu_bar.addMenu(\"&Edit\")\n            edit_menu.addAction(self._submit_message_action)\n            edit_menu.addSeparator()\n            edit_menu.addAction(self._undo_action)\n            edit_menu.addAction(self._redo_action)\n            edit_menu.addSeparator()\n            edit_menu.addAction(self._cut_action)\n            edit_menu.addAction(self._copy_action)\n            edit_menu.addAction(self._paste_action)\n            edit_menu.addSeparator()\n            edit_menu.addAction(self._workspace_settings_action)\n            edit_menu.addAction(self._conv_settings_action)\n    \n            # View menu\n            view_menu = self._menu_bar.addMenu(\"&View\")\n            view_menu.addAction(self._dark_mode_action)\n            view_menu.addSeparator()\n            view_menu.addAction(self._zoom_in_action)\n            view_menu.addAction(self._zoom_out_action)\n            view_menu.addAction(self._reset_zoom_action)\n            view_menu.addSeparator()\n            view_menu.addAction(self._show_all_columns_action)\n            view_menu.addAction(self._split_column_left_action)\n            view_menu.addAction(self._split_column_right_action)\n            view_menu.addAction(self._merge_column_left_action)\n            view_menu.addAction(self._merge_column_right_action)\n    \n            self.setWindowTitle(\"Humbug\")\n            self.setMinimumSize(800, 600)\n    \n            # Main widget and layout\n            main_widget = QWidget()\n            self.setCentralWidget(main_widget)\n            layout = QVBoxLayout(main_widget)\n            layout.setSpacing(0)\n            layout.setContentsMargins(0, 0, 0, 0)\n    \n            # Create splitter\n            self._splitter = QSplitter(Qt.Horizontal)\n            layout.addWidget(self._splitter)\n    \n            # Create and add file tree\n            self._file_tree = WorkspaceFileTree(self)\n            self._file_tree.file_activated.connect(self._handle_file_activation)\n            self._splitter.addWidget(self._file_tree)\n    \n            # Create tab manager in splitter\n            self._tab_manager = TabManager(ai_backends, self)\n            self._splitter.addWidget(self._tab_manager)\n    \n            # Set initial file tree width\n            self._splitter.setSizes([240, self.width() - 240])\n    \n            # Set the stretch factors: 0 for file tree (no stretch) and 1 for tab manager (stretch to fill)\n            self._splitter.setStretchFactor(0, 0)\n            self._splitter.setStretchFactor(1, 1)\n    \n            self._style_manager = StyleManager()\n            self._style_manager.style_changed.connect(self._handle_style_changed)\n    \n            # Create a timer that fires every 50ms to keep our menu states correct\n            self._menu_timer = QTimer()\n            self._menu_timer.setInterval(50)\n            self._menu_timer.timeout.connect(self._update_menu_state)\n            self._menu_timer.start()\n    \n            # Create status bar with left and right widgets\n            self._status_bar = QStatusBar()\n            self._status_left = QWidget()\n            self._status_right = QWidget()\n    \n            # Set up left widget (empty for now)\n            self._status_bar.addWidget(self._status_left, 1)\n    \n            # Set up right widget for status messages\n            self._status_right_layout = QVBoxLayout(self._status_right)\n            self._status_right_layout.setContentsMargins(0, 0, 0, 0)\n            self._status_message_label = QLabel()\n            self._status_right_layout.addWidget(self._status_message_label)\n            self._status_bar.addPermanentWidget(self._status_right)\n    \n            self.setStatusBar(self._status_bar)\n            self._tab_manager.column_state_changed.connect(self._handle_column_state_changed)\n    \n            self._handle_style_changed()\n    \n            self._workspace_manager = WorkspaceManager()\n            self._restore_last_workspace()\n    \n            self._tab_manager.status_message.connect(self._handle_status_message)\n    \n        def _handle_column_state_changed(self):\n            \"\"\"Handle column state changes from tab manager.\"\"\"\n            # Save workspace state when column configuration changes\n            self._save_workspace_state()\n    \n        def _handle_status_message(self, message: StatusMessage) -> None:\n            \"\"\"Update status bar with new message.\"\"\"\n            self._status_message_label.setText(message.text)\n            if message.timeout:\n                QTimer.singleShot(message.timeout, self._status_message_label.clear)\n    \n        def _restore_last_workspace(self):\n            \"\"\"Restore last workspace on startup if available.\"\"\"\n            try:\n                with open(os.path.expanduser(\"~/.humbug/workspace.json\"), encoding='utf-8') as f:\n                    data = json.load(f)\n                    workspace_path = data.get(\"lastWorkspace\")\n                    if workspace_path and os.path.exists(workspace_path):\n                        try:\n                            self._workspace_manager.open_workspace(workspace_path)\n                            self._file_tree.set_workspace(workspace_path)\n                            self._style_manager.set_workspace_font_size(self._workspace_manager.settings.font_size)\n                            self._restore_workspace_state()\n                        except WorkspaceError as e:\n                            self._logger.error(\"Failed to restore workspace: %s\", str(e))\n                            # Don't show error dialog on startup, just log it\n            except (FileNotFoundError, json.JSONDecodeError):\n                pass\n    \n        def _new_workspace(self):\n            self._menu_timer.stop()\n            dir_path = QFileDialog.getExistingDirectory(\n                self, \"Create New Workspace\"\n            )\n            self._menu_timer.start()\n            if not dir_path:\n                return\n    \n            try:\n                self._workspace_manager.create_workspace(dir_path)\n            except WorkspaceExistsError:\n                MessageBox.show_message(\n                    self,\n                    MessageBoxType.CRITICAL,\n                    \"Workspace Error\",\n                    \"Workspace already exists in selected directory.\"\n                )\n                return\n            except WorkspaceError as e:\n                MessageBox.show_message(\n                    self,\n                    MessageBoxType.CRITICAL,\n                    \"Workspace Error\",\n                    f\"Failed to create workspace: {str(e)}\"\n                )\n                return\n    \n            self._open_workspace_path(dir_path)\n    \n        def _open_workspace(self):\n            \"\"\"Open a new workspace.\"\"\"\n            self._menu_timer.stop()\n            dir_path = QFileDialog.getExistingDirectory(self, \"Open Workspace\")\n            self._menu_timer.start()\n            if not dir_path:\n                return\n    \n            self._open_workspace_path(dir_path)\n    \n        def _open_workspace_path(self, path: str) -> None:\n            # If we're switching workspaces, save the current one first\n            if self._workspace_manager.has_workspace:\n                self._save_workspace_state()\n                self._close_all_tabs()\n                self._style_manager.set_workspace_font_size(None)\n                self._workspace_manager.close_workspace()\n    \n            # Open the new workspace\n            try:\n                self._workspace_manager.open_workspace(path)\n                self._file_tree.set_workspace(path)\n                self._style_manager.set_workspace_font_size(self._workspace_manager.settings.font_size)\n            except WorkspaceError as e:\n                MessageBox.show_message(\n                    self,\n                    MessageBoxType.CRITICAL,\n                    \"Workspace Error\",\n                    f\"Failed to open workspace: {str(e)}\"\n                )\n                return\n    \n            # Restore the state of the newly opened workspace\n            self._restore_workspace_state()\n    \n        def _close_workspace(self):\n            if not self._workspace_manager.has_workspace:\n                self._logger.error(\"No workspace active, cannot close\")\n                return\n    \n            self._save_workspace_state()\n            self._close_all_tabs()\n            self._file_tree.set_workspace(None)\n            self._style_manager.set_workspace_font_size(None)\n            self._workspace_manager.close_workspace()\n    \n        def _save_workspace_state(self):\n            \"\"\"Save current workspace state.\"\"\"\n            if not self._workspace_manager.has_workspace:\n                self._logger.error(\"No workspace active, cannot save\")\n                return\n    \n            try:\n                workspace_state = self._tab_manager.save_state()\n                self._workspace_manager.save_workspace_state(workspace_state)\n            except WorkspaceError as e:\n                self._logger.error(\"Failed to save workspace state: %s\", str(e))\n                MessageBox.show_message(\n                    self,\n                    MessageBoxType.CRITICAL,\n                    \"Workspace Error\",\n                    f\"Failed to save workspace state: {str(e)}\"\n                )\n    \n        def _restore_workspace_state(self):\n            \"\"\"Restore previously open tabs from workspace state.\"\"\"\n            saved_state = self._workspace_manager.load_workspace_state()\n            if not saved_state:\n                self._logger.debug(\"No saved states found\")\n                return\n    \n            try:\n                self._tab_manager.restore_state(saved_state)\n            except WorkspaceError as e:\n                self._logger.error(\"Failed to restore workspace state: %s\", str(e))\n                MessageBox.show_message(\n                    self,\n                    MessageBoxType.CRITICAL,\n                    \"Workspace Error\",\n                    f\"Failed to restore workspace state: {str(e)}\"\n                )\n    \n        def _close_all_tabs(self):\n            self._tab_manager.close_all_tabs()\n    \n        def _undo(self):\n            self._tab_manager.undo()\n    \n        def _redo(self):\n            self._tab_manager.redo()\n    \n        def _cut(self):\n            self._tab_manager.cut()\n    \n        def _copy(self):\n            self._tab_manager.copy()\n    \n        def _paste(self):\n            self._tab_manager.paste()\n    \n        def _show_about_dialog(self):\n            \"\"\"Show the About dialog.\"\"\"\n            dialog = AboutDialog(self)\n            dialog.exec()\n    \n        def _new_file(self):\n            \"\"\"Create a new empty editor tab.\"\"\"\n            if not self._workspace_manager.has_workspace:\n                return\n    \n            self._tab_manager.new_file()\n    \n        def _handle_file_activation(self, path: str):\n            \"\"\"Handle file activation from the file tree.\"\"\"\n            # Are we opening a conversation or a file?\n            ext = os.path.splitext(path)[1].lower()\n            if ext == \".conv\":\n                self._open_conversation_path(path)\n                return\n    \n            self._open_file_path(path)\n    \n        def _open_file(self):\n            \"\"\"Show open file dialog and create editor tab.\"\"\"\n            self._menu_timer.stop()\n            file_path, _ = QFileDialog.getOpenFileName(\n                self,\n                \"Open File\",\n                self._workspace_manager.workspace_path\n            )\n            self._menu_timer.start()\n    \n            if not file_path:\n                return\n    \n            self._open_file_path(file_path)\n    \n        def _open_file_path(self, path: str) -> None:\n            \"\"\"Open file in editor tab.\"\"\"\n            try:\n                self._tab_manager.open_file(path)\n            except OSError as e:\n                MessageBox.show_message(\n                    self,\n                    MessageBoxType.CRITICAL,\n                    \"Error Opening File\",\n                    f\"Could not open {path}: {str(e)}\"\n                )\n    \n        def _save_file(self):\n            \"\"\"Save the current file.\"\"\"\n            self._tab_manager.save_file()\n    \n        def _save_file_as(self):\n            \"\"\"Save the current file with a new name.\"\"\"\n            self._tab_manager.save_file_as()\n    \n        def _show_all_columns(self) -> None:\n            \"\"\"Show all columns equally.\"\"\"\n            self._tab_manager.show_all_columns()\n    \n        def _split_column(self, split_left: bool) -> None:\n            \"\"\"Split the current column.\"\"\"\n            self._tab_manager.split_column(split_left)\n    \n        def _merge_column(self, merge_left: bool) -> None:\n            \"\"\"Merge the current column.\"\"\"\n            self._tab_manager.merge_column(merge_left)\n    \n        @Slot()\n        def _update_menu_state(self):\n            \"\"\"Update enabled/disabled state of menu items.\"\"\"\n            # Update workspace-specific actions\n            has_workspace = self._workspace_manager.has_workspace\n            self._close_workspace_action.setEnabled(has_workspace)\n            self._new_conv_action.setEnabled(has_workspace)\n            self._new_metaphor_conv_action.setEnabled(has_workspace)\n            self._new_file_action.setEnabled(has_workspace)\n            self._open_conv_action.setEnabled(has_workspace)\n            self._open_file_action.setEnabled(has_workspace)\n            self._workspace_settings_action.setEnabled(has_workspace)\n    \n            # Update tab-specific actions\n            tab_manager = self._tab_manager\n            self._fork_conv_action.setEnabled(tab_manager.can_fork_conversation())\n            self._save_action.setEnabled(tab_manager.can_save_file())\n            self._save_as_action.setEnabled(tab_manager.can_save_file_as())\n            self._close_tab_action.setEnabled(tab_manager.can_close_tab())\n            self._undo_action.setEnabled(tab_manager.can_undo())\n            self._redo_action.setEnabled(tab_manager.can_redo())\n            self._cut_action.setEnabled(tab_manager.can_cut())\n            self._copy_action.setEnabled(tab_manager.can_copy())\n            self._paste_action.setEnabled(tab_manager.can_paste())\n            self._submit_message_action.setEnabled(tab_manager.can_submit_message())\n            self._conv_settings_action.setEnabled(tab_manager.can_show_conversation_settings_dialog())\n    \n            # Update view actions\n            current_zoom = self._style_manager.zoom_factor\n            self._zoom_in_action.setEnabled(current_zoom < 2.0)\n            self._zoom_out_action.setEnabled(current_zoom > 0.5)\n            self._show_all_columns_action.setEnabled(tab_manager.can_show_all_columns())\n            self._split_column_left_action.setEnabled(tab_manager.can_split_column())\n            self._split_column_right_action.setEnabled(tab_manager.can_split_column())\n            self._merge_column_left_action.setEnabled(tab_manager.can_merge_column(True))\n            self._merge_column_right_action.setEnabled(tab_manager.can_merge_column(False))\n    \n        def _handle_style_changed(self) -> None:\n            style_manager = self._style_manager\n            zoom_factor = style_manager.zoom_factor\n            base_font_size = style_manager.base_font_size\n    \n            self.setStyleSheet(f\"\"\"\n                QMainWindow {{\n                    background-color: {style_manager.get_color_str(ColorRole.BACKGROUND_PRIMARY)};\n                    color: {style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                }}\n                QMenuBar {{\n                    background-color: {style_manager.get_color_str(ColorRole.MENU_BACKGROUND)};\n                    padding: 4px;\n                    font-size: {base_font_size}pt;\n                }}\n                QMenuBar::item {{\n                    background-color: transparent;\n                    color: {style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    border-radius: 4px;\n                    padding: 4px 8px 4px 8px;\n                }}\n                QMenuBar::item:selected {{\n                    background-color: {style_manager.get_color_str(ColorRole.MENU_HOVER)};\n                }}\n                QMenu {{\n                    background-color: {style_manager.get_color_str(ColorRole.MENU_BACKGROUND)};\n                    color: {style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    border-color: {style_manager.get_color_str(ColorRole.MENU_HOVER)};\n                    border-width: 1px;\n                    border-style: solid;\n                    border-radius: 4px;\n                }}\n                QMenu::item {{\n                    margin: 3px 5px;\n                    padding: 4px 4px 4px 4px;\n                }}\n                QMenu::item:disabled {{\n                    color: {style_manager.get_color_str(ColorRole.TEXT_DISABLED)};\n                }}\n                QMenu::item:selected {{\n                    background-color: {style_manager.get_color_str(ColorRole.MENU_HOVER)}\n                }}\n            \"\"\")\n    \n            # Update status bar font\n            status_font = self.font()\n            status_font.setPointSizeF(base_font_size * zoom_factor)\n            self._status_bar.setFont(status_font)\n            self._status_message_label.setFont(status_font)\n    \n            self._status_bar.setStyleSheet(f\"\"\"\n                QStatusBar {{\n                    background-color: {self._style_manager.get_color_str(ColorRole.STATUS_BAR_BACKGROUND)};\n                    color: {self._style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    padding: {2 * zoom_factor}px;\n                    border-top: 1px solid {self._style_manager.get_color_str(ColorRole.SPLITTER)};\n                }}\n                QStatusBar::item {{\n                    border: 0;\n                    padding: 0;\n                }}\n                QLabel {{\n                    color: {self._style_manager.get_color_str(ColorRole.TEXT_PRIMARY)};\n                    padding: 0;\n                }}\n            \"\"\")\n    \n            self._splitter.setStyleSheet(f\"\"\"\n                QSplitter::handle {{\n                    background-color: {style_manager.get_color_str(ColorRole.SPLITTER)};\n                    margin: 0;\n                    width: 1px;\n                }}\n            \"\"\")\n    \n        def _new_conversation(self) -> Optional[str]:\n            \"\"\"Create new conversation tab.\"\"\"\n            if not self._workspace_manager.has_workspace:\n                return None\n    \n            try:\n                self._workspace_manager.ensure_workspace_dir(\"conversations\")\n                return self._tab_manager.new_conversation(\n                    self._workspace_manager.workspace_path\n                )\n            except WorkspaceError as e:\n                MessageBox.show_message(\n                    self,\n                    MessageBoxType.CRITICAL,\n                    \"Workspace Error\",\n                    f\"Failed to create conversation: {str(e)}\"\n                )\n                return None\n    \n        def _new_metaphor_conversation(self):\n            \"\"\"Create new conversation from Metaphor file.\"\"\"\n            if not self._workspace_manager.has_workspace:\n                MessageBox.show_message(\n                    self,\n                    MessageBoxType.WARNING,\n                    \"Workspace Required\",\n                    \"Please open a workspace before creating a Metaphor conversation.\"\n                )\n                return\n    \n            # Show file dialog\n            self._menu_timer.stop()\n            file_path, _ = QFileDialog.getOpenFileName(\n                self,\n                \"Open Metaphor File\",\n                self._workspace_manager.workspace_path,\n                \"Metaphor Files (*.m6r);;All Files (*.*)\"\n            )\n            self._menu_timer.start()\n    \n            if not file_path:\n                return\n    \n            search_paths = [self._workspace_manager.workspace_path]\n    \n            metaphor_parser = MetaphorParser()\n            try:\n                syntax_tree = metaphor_parser.parse_file(file_path, search_paths)\n                prompt = format_ast(syntax_tree)\n    \n                # Create conversation with prompt\n                conversation_id = self._new_conversation()\n                if conversation_id:\n                    # Get the tab and set input text\n                    conversation_tab = self._tab_manager.find_conversation_tab_by_id(conversation_id)\n                    if conversation_tab:\n                        conversation_tab.set_input_text(prompt)\n            except MetaphorParserError as e:\n                MessageBox.show_message(\n                    self,\n                    MessageBoxType.CRITICAL,\n                    \"Metaphor Processing Error\",\n                    f\"Failed to process Metaphor file:\\n\\n{format_errors(e.errors)}\"\n                )\n    \n        def _open_conversation(self):\n            \"\"\"Show open conversation dialog and create conversation tab.\"\"\"\n            self._menu_timer.stop()\n            file_path, _ = QFileDialog.getOpenFileName(\n                self,\n                \"Open Conversation\",\n                self._workspace_manager.workspace_path,\n                \"Conversation Files (*.conv);;All Files (*.*)\"\n            )\n            self._menu_timer.start()\n    \n            if not file_path:\n                return\n    \n            self._open_conversation_path(file_path)\n    \n        def _open_conversation_path(self, path: str) -> None:\n            \"\"\"Open an existing conversation file.\"\"\"\n            try:\n                self._tab_manager.open_conversation(path)\n            except ConversationError as e:\n                self._logger.error(\"Error opening conversation: %s: %s\", path, str(e))\n                MessageBox.show_message(\n                    self,\n                    MessageBoxType.CRITICAL,\n                    \"Error Loading Conversation\",\n                    f\"Could not load {path}: {str(e)}\"\n                )\n    \n        def _fork_conversation(self):\n            \"\"\"Create a new conversation tab with the history of the current conversation.\"\"\"\n            async def fork_and_handle_errors():\n                try:\n                    await self._tab_manager.fork_conversation()\n                except ConversationError as e:\n                    MessageBox.show_message(\n                        self,\n                        MessageBoxType.CRITICAL,\n                        \"Error Forking Conversation\",\n                        f\"Could not fork conversation: {str(e)}\"\n                    )\n    \n            # Create task to fork conversation\n            asyncio.create_task(fork_and_handle_errors())\n    \n        def _close_tab(self):\n            \"\"\"Close the current tab.\"\"\"\n            self._tab_manager.close_tab()\n    \n        def _submit_message(self):\n            \"\"\"Handle message submission.\"\"\"\n            self._tab_manager.submit_message()\n    \n        def _show_workspace_settings_dialog(self):\n            \"\"\"Show the workspace settings dialog.\"\"\"\n            if not self._workspace_manager.has_workspace:\n                return\n    \n            dialog = WorkspaceSettingsDialog(self)\n            dialog.set_settings(self._workspace_manager.settings)\n    \n            def handle_settings_changed(new_settings):\n                try:\n                    self._workspace_manager.update_settings(new_settings)\n                    self._style_manager.set_workspace_font_size(new_settings.font_size)\n                except OSError as e:\n                    self._logger.error(\"Failed to save workspace settings: %s\", str(e))\n                    MessageBox.show_message(\n                        self,\n                        MessageBoxType.CRITICAL,\n                        \"Settings Error\",\n                        f\"Failed to save workspace settings: {str(e)}\"\n                    )\n    \n            dialog.settings_changed.connect(handle_settings_changed)\n            dialog.exec()\n    \n        def _show_conversation_settings_dialog(self):\n            \"\"\"Show the conversation settings dialog.\"\"\"\n            self._tab_manager.show_conversation_settings_dialog()\n    \n        def keyPressEvent(self, event: QKeyEvent):\n            \"\"\"Handle global key events.\"\"\"\n            if event.key() == Qt.Key_Escape:\n                if self._tab_manager.handle_esc_key():\n                    return\n    \n            super().keyPressEvent(event)\n    \n        def _handle_dark_mode(self, _):\n            \"\"\"Handle dark mode enable/disable requests.\"\"\"\n            self._dark_mode = not self._dark_mode\n            self._dark_mode_action.setChecked(self._dark_mode)\n            self._style_manager.set_color_mode(ColorMode.DARK if self._dark_mode else ColorMode.LIGHT)\n    \n        def _handle_zoom(self, factor: float):\n            \"\"\"Handle zoom in/out requests.\"\"\"\n            new_zoom = self._style_manager.zoom_factor * factor\n            self._set_zoom(new_zoom)\n    \n        def _set_zoom(self, zoom_level: float):\n            \"\"\"Set zoom level for the application.\"\"\"\n            self._style_manager.set_zoom(zoom_level)\n    \n        def closeEvent(self, event):\n            \"\"\"Handle application close request.\"\"\"\n            if not self._tab_manager.can_close_all_tabs():\n                event.ignore()\n                return\n    \n            self._save_workspace_state()\n            event.accept()\n    ```\n    File: src/humbug/ai/gemini_stream_response.py\n    ```python\n    \"\"\"Handles streaming response from Google Gemini API.\"\"\"\n    \n    import logging\n    from typing import Optional\n    \n    from humbug.ai.ai_usage import AIUsage\n    \n    \n    class GeminiStreamResponse:\n        \"\"\"Handles streaming response from Gemini API.\"\"\"\n    \n        def __init__(self):\n            \"\"\"Initialize stream response handler.\"\"\"\n            self.content = \"\"\n            self.usage: Optional[AIUsage] = None\n            self.error = None\n            self._logger = logging.getLogger(\"GeminiStreamResponse\")\n    \n        def update_from_chunk(self, chunk: dict) -> None:\n            \"\"\"\n            Update from a response chunk and return new content if any.\n    \n            Args:\n                chunk: Response chunk from Gemini API\n            \"\"\"\n            if \"error\" in chunk:\n                self._logger.debug(\"Got error message: %s\", chunk[\"error\"])\n                self.error = {\n                    \"code\": \"stream_error\",\n                    \"message\": chunk[\"error\"].get(\"message\", \"Unknown error\"),\n                    \"details\": chunk[\"error\"]\n                }\n                return\n    \n            if \"candidates\" in chunk and chunk[\"candidates\"]:\n                candidate = chunk[\"candidates\"][0]\n    \n                # Extract text content\n                if \"content\" in candidate and \"parts\" in candidate[\"content\"]:\n                    for part in candidate[\"content\"][\"parts\"]:\n                        if \"text\" in part:\n                            self.content += part[\"text\"]\n    \n                # Check for completion reason\n                if candidate.get(\"finishReason\") == \"STOP\" and \"usageMetadata\" in chunk:\n                    metadata = chunk[\"usageMetadata\"]\n                    self.usage = AIUsage(\n                        prompt_tokens=metadata.get(\"promptTokenCount\", 0),\n                        completion_tokens=metadata.get(\"candidatesTokenCount\", 0),\n                        total_tokens=metadata.get(\"totalTokenCount\", 0)\n                    )\n    ```\n    File: src/humbug/ai/conversation_settings.py\n    ```python\n    \"\"\"Class to handle conversation settings.\"\"\"\n    \n    from typing import Dict\n    \n    \n    class ConversationSettings:\n        \"\"\"Data class for conversation settings.\"\"\"\n    \n        AVAILABLE_MODELS = [\n            # Gemini models\n            \"gemini-1.5-flash\",\n            \"gemini-1.5-pro\",\n            \"gemini-2.0-flash-exp\",\n    \n            # Anthropic models\n            \"claude-3-5-haiku-20241022\",\n            \"claude-3-5-sonnet-20241022\",\n    \n            # OpenAI models\n            \"gpt-4o-mini\",\n            \"gpt-4o\",\n            \"o1-mini\",\n            \"o1-preview\"\n        ]\n    \n        PROVIDER_MAP = {\n            \"gpt-4o-mini\": \"openai\",\n            \"gpt-4o\": \"openai\",\n            \"o1-mini\": \"openai\",\n            \"o1-preview\": \"openai\",\n            \"gemini-1.5-flash\": \"google\",\n            \"gemini-1.5-pro\": \"google\",\n            \"gemini-2.0-flash-exp\": \"google\",\n            \"claude-3-5-haiku-20241022\": \"anthropic\",\n            \"claude-3-5-sonnet-20241022\": \"anthropic\"\n        }\n    \n        TEMPERATURE_SUPPORTED_MODELS = {\n            \"gpt-4o-mini\": True,\n            \"gpt-4o\": True,\n            \"o1-mini\": False,\n            \"o1-preview\": False,\n            \"gemini-1.5-flash\": True,\n            \"gemini-1.5-pro\": True,\n            \"gemini-2.0-flash-exp\": True,\n            \"claude-3-5-haiku-20241022\": True,\n            \"claude-3-5-sonnet-20241022\": True\n        }\n    \n        MODEL_LIMITS = {\n            \"gpt-4o-mini\": {\"context_window\": 128000, \"max_output_tokens\": 16384},\n            \"gpt-4o\": {\"context_window\": 128000, \"max_output_tokens\": 16384},\n            \"o1-mini\": {\"context_window\": 128000, \"max_output_tokens\": 65536},\n            \"o1-preview\": {\"context_window\": 200000, \"max_output_tokens\": 100000},\n            \"gemini-1.5-flash\": {\"context_window\": 1048576, \"max_output_tokens\": 8192},\n            \"gemini-1.5-pro\": {\"context_window\": 2097152, \"max_output_tokens\": 8192},\n            \"gemini-2.0-flash-exp\": {\"context_window\": 1048576, \"max_output_tokens\": 8192},\n            \"claude-3-5-haiku-20241022\": {\"context_window\": 200000, \"max_output_tokens\": 4096},\n            \"claude-3-5-sonnet-20241022\": {\"context_window\": 200000, \"max_output_tokens\": 8192}\n        }\n    \n        def __init__(self, model: str=\"gemini-1.5-flash\", temperature: float=0.7):\n            \"\"\"\n            Initialize conversation settings with defaults.\n    \n            Args:\n                model: Optional model name. If None, must be set later based on available backends\n                temperature: Temperature setting (0.0-1.0)\n            \"\"\"\n            # Default to Gemini but this should be overridden based on available backends\n            self.model = model\n            self.temperature = temperature if self.supports_temperature(model) else None\n            model_limits = self.MODEL_LIMITS.get(model, {\"context_window\": 8192, \"max_output_tokens\": 2048})\n            self.context_window = model_limits[\"context_window\"]\n            self.max_output_tokens = model_limits[\"max_output_tokens\"]\n    \n        @classmethod\n        def get_available_models(cls) -> list[str]:\n            \"\"\"Return list of available models.\"\"\"\n            return cls.AVAILABLE_MODELS\n    \n        @classmethod\n        def get_provider(cls, model: str) -> str:\n            \"\"\"Get the provider for a given model.\"\"\"\n            return cls.PROVIDER_MAP.get(model, \"unknown\")\n    \n        @classmethod\n        def supports_temperature(cls, model: str) -> bool:\n            \"\"\"Check if model supports temperature setting.\"\"\"\n            return cls.TEMPERATURE_SUPPORTED_MODELS.get(model, False)\n    \n        @classmethod\n        def get_model_limits(cls, model: str) -> dict:\n            \"\"\"Get the context window and max output tokens for a model.\"\"\"\n            return cls.MODEL_LIMITS.get(model, {\"context_window\": 8192, \"max_output_tokens\": 2048})\n    \n        @classmethod\n        def get_default_model(cls, ai_backends: Dict[str, any]) -> str:\n            \"\"\"\n            Get the default model based on available backends.\n    \n            Args:\n                ai_backends: Dictionary of available AI backends\n    \n            Returns:\n                The name of the default model to use\n            \"\"\"\n            # Try Google first\n            if \"google\" in ai_backends:\n                return \"gemini-1.5-flash\"\n    \n            # Then Anthropic\n            if \"anthropic\" in ai_backends:\n                return \"claude-3-5-haiku-20241022\"\n    \n            # Finally OpenAI\n            if \"openai\" in ai_backends:\n                return \"o1-mini\"\n    \n            # Shouldn't happen as we require at least one backend\n            return \"gemini-1.5-flash\"\n    ```\n    File: src/humbug/ai/openai_backend.py\n    ```python\n    \"\"\"OpenAI backend implementation.\"\"\"\n    from typing import Dict, List\n    \n    from humbug.ai.ai_backend import AIBackend\n    from humbug.ai.conversation_settings import ConversationSettings\n    from humbug.ai.openai_stream_response import OpenAIStreamResponse\n    \n    \n    class OpenAIBackend(AIBackend):\n        \"\"\"OpenAI API backend implementation with streaming support.\"\"\"\n    \n        def __init__(self, api_key: str):\n            \"\"\"Initialize the OpenAI backend.\"\"\"\n            super().__init__()\n            self._api_key = api_key\n            self._api_url = \"https://api.openai.com/v1/chat/completions\"\n    \n        def _build_request_data(self, message: str, conversation_history: List[Dict[str, str]], settings: ConversationSettings) -> dict:\n            \"\"\"Build OpenAI-specific request data.\"\"\"\n            # conversation_history already contains properly formatted messages\n            messages = conversation_history.copy()\n    \n            data = {\n                \"model\": settings.model,\n                \"messages\": messages,\n                \"stream\": True,\n                \"stream_options\": {\"include_usage\": True}\n            }\n    \n            # Only include temperature if supported by model\n            if ConversationSettings.supports_temperature(settings.model):\n                data[\"temperature\"] = settings.temperature\n    \n            self._logger.debug(\"stream message %s\", data)\n            return data\n    \n        def _create_stream_response_handler(self):\n            \"\"\"Create an OpenAI-specific stream response handler.\"\"\"\n            return OpenAIStreamResponse()\n    \n        def _get_api_url(self, settings: ConversationSettings) -> str:\n            \"\"\"Get the OpenAI API URL.\"\"\"\n            return self._api_url\n    \n        def _get_headers(self) -> dict:\n            \"\"\"Get the OpenAI API headers.\"\"\"\n            return {\n                \"Content-Type\": \"application/json\",\n                \"Authorization\": f\"Bearer {self._api_key}\"\n            }\n    ```\n    File: src/humbug/ai/gemini_backend.py\n    ```python\n    \"\"\"Google Gemini backend implementation.\"\"\"\n    from typing import Dict, List\n    \n    from humbug.ai.ai_backend import AIBackend\n    from humbug.ai.conversation_settings import ConversationSettings\n    from humbug.ai.gemini_stream_response import GeminiStreamResponse\n    \n    \n    class GeminiBackend(AIBackend):\n        \"\"\"Google Gemini API backend implementation.\"\"\"\n    \n        def __init__(self, api_key: str):\n            \"\"\"Initialize the Gemini backend.\"\"\"\n            super().__init__()\n            self._api_key = api_key\n            self._api_base = \"https://generativelanguage.googleapis.com/v1beta/models\"\n            self._default_settings = ConversationSettings(\"gemini-1.5-flash\")\n    \n        def _build_request_data(self, message: str, conversation_history: List[Dict[str, str]], settings: ConversationSettings) -> dict:\n            \"\"\"Build Gemini-specific request data.\"\"\"\n            contents = []\n    \n            # Convert history format to Gemini format\n            for msg in conversation_history:\n                role = \"model\" if msg[\"role\"] == \"assistant\" else \"user\"\n                contents.append({\n                    \"role\": role,\n                    \"parts\": [{\n                        \"text\": msg[\"content\"]\n                    }]\n                })\n    \n            data = {\n                \"contents\": contents,\n                \"safetySettings\": [\n                    {\n                        \"category\": \"HARM_CATEGORY_DANGEROUS_CONTENT\",\n                        \"threshold\": \"BLOCK_ONLY_HIGH\"\n                    }\n                ],\n                \"generationConfig\": {\n                    \"topP\": 0.8,\n                    \"topK\": 10\n                }\n            }\n    \n            # Only include temperature if supported by model\n            if ConversationSettings.supports_temperature(settings.model):\n                data[\"generationConfig\"][\"temperature\"] = settings.temperature\n    \n            return data\n    \n        def _create_stream_response_handler(self):\n            \"\"\"Create a Gemini-specific stream response handler.\"\"\"\n            return GeminiStreamResponse()\n    \n        def _get_api_url(self, settings: ConversationSettings) -> str:\n            \"\"\"Get the Gemini API URL.\"\"\"\n            return f\"{self._api_base}/{settings.model}:streamGenerateContent?alt=sse&key={self._api_key}\"\n    \n        def _get_headers(self) -> dict:\n            \"\"\"Get the Gemini API headers.\"\"\"\n            return {\n                \"Content-Type\": \"application/json\"\n            }\n    ```\n    File: src/humbug/ai/anthropic_backend.py\n    ```python\n    \"\"\"Anthropic backend implementation.\"\"\"\n    from typing import Dict, List\n    \n    from humbug.ai.ai_backend import AIBackend\n    from humbug.ai.conversation_settings import ConversationSettings\n    from humbug.ai.anthropic_stream_response import AnthropicStreamResponse\n    \n    \n    class AnthropicBackend(AIBackend):\n        \"\"\"Anthropic API backend implementation.\"\"\"\n    \n        def __init__(self, api_key: str):\n            \"\"\"Initialize the Anthropic backend.\"\"\"\n            super().__init__()\n            self._api_key = api_key\n            self._api_url = \"https://api.anthropic.com/v1/messages\"\n    \n        def _build_request_data(self, message: str, conversation_history: List[Dict[str, str]], settings: ConversationSettings) -> dict:\n            \"\"\"Build Anthropic-specific request data.\"\"\"\n            # Take existing messages in correct format\n            messages = conversation_history.copy()\n    \n            data = {\n                \"model\": settings.model,\n                \"messages\": messages,\n                \"max_tokens\": settings.max_output_tokens,\n                \"stream\": True\n            }\n    \n            # Only include temperature if supported by model\n            if ConversationSettings.supports_temperature(settings.model):\n                data[\"temperature\"] = settings.temperature\n    \n            return data\n    \n        def _create_stream_response_handler(self):\n            \"\"\"Create an Anthropic-specific stream response handler.\"\"\"\n            return AnthropicStreamResponse()\n    \n        def _get_api_url(self, settings: ConversationSettings) -> str:\n            \"\"\"Get the Anthropic API URL.\"\"\"\n            return self._api_url\n    \n        def _get_headers(self) -> dict:\n            \"\"\"Get the Anthropic API headers.\"\"\"\n            return {\n                \"content-type\": \"application/json\",\n                \"x-api-key\": self._api_key,\n                \"anthropic-version\": \"2023-06-01\"\n            }\n    ```\n    File: src/humbug/ai/openai_stream_response.py\n    ```python\n    \"\"\"Handles streaming response from OpenAI API.\"\"\"\n    \n    import logging\n    from typing import Optional\n    \n    from humbug.ai.ai_usage import AIUsage\n    \n    \n    class OpenAIStreamResponse:\n        \"\"\"Handles streaming response from OpenAI API.\"\"\"\n    \n        def __init__(self):\n            \"\"\"Initialize stream response handler.\"\"\"\n            self.content = \"\"\n            self.usage: Optional[AIUsage] = None\n            self.error = None\n            self._logger = logging.getLogger(\"OpenAIStreamResponse\")\n    \n        def update_from_chunk(self, chunk: dict) -> None:\n            \"\"\"Update from a response chunk and return new content if any.\"\"\"\n            if \"error\" in chunk:\n                self._logger.debug(\"Got error message: %s\", chunk[\"error\"])\n                self.error = {\n                    \"code\": \"stream_error\",\n                    \"message\": chunk[\"error\"].get(\"message\", \"Unknown error\"),\n                    \"details\": chunk[\"error\"]\n                }\n                return\n    \n            if \"usage\" in chunk:\n                usage = chunk[\"usage\"]\n                if usage:\n                    self.usage = AIUsage(\n                        prompt_tokens=usage.get(\"prompt_tokens\", 0),\n                        completion_tokens=usage.get(\"completion_tokens\", 0),\n                        total_tokens=usage.get(\"total_tokens\", 0)\n                    )\n    \n            if \"choices\" not in chunk:\n                return\n    \n            choices = chunk[\"choices\"]\n            if not choices:\n                return\n    \n            delta = choices[0].get(\"delta\", {})\n            if \"content\" in delta:\n                new_content = delta[\"content\"]\n                self.content += new_content\n    ```\n    File: src/humbug/ai/rate_limiter.py\n    ```python\n    \"\"\"Implements a sliding window rate limiter.\"\"\"\n    \n    import asyncio\n    from collections import deque\n    import time\n    \n    \n    class RateLimiter:\n        \"\"\"Implements a sliding window rate limiter.\"\"\"\n    \n        def __init__(self, window_size: int = 60, max_requests: int = 50):\n            \"\"\"Initialize rate limiter with window size in seconds.\"\"\"\n            self._window_size = window_size\n            self._max_requests = max_requests\n            self._requests = deque()\n    \n        async def acquire(self):\n            \"\"\"Wait until a request can be made within rate limits.\"\"\"\n            now = time.time()\n    \n            # Remove expired timestamps\n            while self._requests and self._requests[0] <= now - self._window_size:\n                self._requests.popleft()\n    \n            if len(self._requests) >= self._max_requests:\n                # Calculate sleep time\n                sleep_time = self._requests[0] + self._window_size - now\n                if sleep_time > 0:\n                    await asyncio.sleep(sleep_time)\n    \n            self._requests.append(now)\n    ```\n    File: src/humbug/ai/ai_usage.py\n    ```python\n    \"\"\"Base class for AI backends.\"\"\"\n    \n    from dataclasses import dataclass, asdict\n    from typing import Dict\n    \n    \n    @dataclass\n    class AIUsage:\n        \"\"\"Token usage information from AI responses.\"\"\"\n        prompt_tokens: int\n        completion_tokens: int\n        total_tokens: int\n    \n        def to_dict(self) -> Dict:\n            \"\"\"Convert usage to dictionary.\"\"\"\n            return asdict(self)\n    ```\n    File: src/humbug/ai/ai_response.py\n    ```python\n    \"\"\"Base class for AI backends.\"\"\"\n    \n    from dataclasses import dataclass\n    from typing import Dict, Optional\n    \n    from humbug.ai.ai_usage import AIUsage\n    \n    \n    @dataclass\n    class AIResponse:\n        \"\"\"Response from an AI backend.\"\"\"\n        content: str\n        usage: Optional[AIUsage] = None\n        error: Optional[Dict] = None\n        model: Optional[str] = None\n        temperature: Optional[float] = None\n    ```\n    File: src/humbug/ai/ai_backend.py\n    ```python\n    \"\"\"Base class for AI backends.\"\"\"\n    \n    from abc import ABC, abstractmethod\n    import asyncio\n    import json\n    import logging\n    from typing import List, AsyncGenerator, Dict\n    import aiohttp\n    from aiohttp import ClientConnectorError, ClientError\n    \n    from humbug.ai.ai_response import AIResponse\n    from humbug.ai.conversation_settings import ConversationSettings\n    from humbug.ai.rate_limiter import RateLimiter\n    \n    \n    class AIBackend(ABC):\n        \"\"\"Abstract base class for AI backends.\"\"\"\n    \n        def __init__(self):\n            \"\"\"Initialize common attributes.\"\"\"\n            self._conversation_settings: Dict[str, ConversationSettings] = {}\n            self._default_settings = ConversationSettings()  # Default settings\n            self._max_retries = 3\n            self._base_delay = 2\n            self._rate_limiter = RateLimiter()\n            self._logger = logging.getLogger(self.__class__.__name__) # Logger based on class name\n    \n        def update_conversation_settings(self, conversation_id: str, settings: ConversationSettings):\n            \"\"\"Update settings for a specific conversation.\"\"\"\n            self._conversation_settings[conversation_id] = settings\n    \n        def get_conversation_settings(self, conversation_id: str) -> ConversationSettings:\n            \"\"\"Get settings for a specific conversation.\"\"\"\n            return self._conversation_settings.get(conversation_id, self._default_settings)\n    \n        @abstractmethod\n        def _build_request_data(self, message: str, conversation_history: List[str], settings: ConversationSettings) -> dict:\n            \"\"\"Abstract method to build backend-specific request data.\"\"\"\n    \n        @abstractmethod\n        def _create_stream_response_handler(self):\n            \"\"\"Abstract method to create a backend-specific stream response handler.\"\"\"\n    \n        @abstractmethod\n        def _get_api_url(self, settings: ConversationSettings) -> str:\n            \"\"\"Abstract method to get the API URL.\"\"\"\n    \n        @abstractmethod\n        def _get_headers(self) -> dict:\n            \"\"\"Abstract method to get the API headers.\"\"\"\n    \n        async def stream_message(\n            self,\n            message: str,\n            conversation_history: List[str],\n            conversation_id: str = None\n        ) -> AsyncGenerator[AIResponse, None]:\n            \"\"\"Send a message to the AI backend and stream the response.\"\"\"\n            settings = self.get_conversation_settings(conversation_id) if conversation_id else self._default_settings\n            url = self._get_api_url(settings)\n            data = self._build_request_data(message, conversation_history, settings)\n            headers = self._get_headers()\n    \n            attempt = 0\n            while attempt < self._max_retries:\n                try:\n                    await self._rate_limiter.acquire()\n    \n                    post_timeout = aiohttp.ClientTimeout(\n                        total=None,\n                        sock_connect=20,\n                        sock_read=120\n                    )\n    \n                    async with aiohttp.ClientSession() as session:\n                        async with session.post(\n                            url,\n                            headers=headers,\n                            json=data,\n                            timeout=post_timeout\n                        ) as response:\n                            if response.status != 200:\n                                response_message = await response.text()\n    \n                                try:\n                                    error_data = json.loads(response_message)\n                                    error_msg = error_data.get(\"error\", {}).get(\"message\", \"Unknown error\")\n                                except json.JSONDecodeError as e:\n                                    self._logger.warning(\"Unable to parse: %s (%s)\", response_message, str(e))\n                                    error_data = {}\n                                    error_msg = \"Unknown error\"\n    \n                                self._logger.debug(\"API error: %d: %s\", response.status, error_data)\n    \n                                # Map Gemini error codes to consistent format\n                                if \"error\" in error_data and \"status\" in error_data[\"error\"]:\n                                    error_code = error_data[\"error\"][\"status\"]\n                                    if error_code == \"RESOURCE_EXHAUSTED\":\n                                        error_msg = \"Rate limit exceeded. Retrying...\"\n                                    elif error_code == \"PERMISSION_DENIED\":\n                                        error_msg = \"Invalid API key or permissions\"\n                                    elif error_code == \"UNAVAILABLE\":\n                                        error_msg = \"Service temporarily unavailable\"\n    \n                                if response.status == 429 or \"RESOURCE_EXHAUSTED\" in error_msg:\n                                    if attempt < self._max_retries - 1:\n                                        delay = self._base_delay * (2 ** attempt)\n                                        yield AIResponse(\n                                            content=\"\",\n                                            error={\n                                                \"code\": \"rate_limit\",\n                                                \"message\": f\"Rate limit exceeded. Retrying in {delay} seconds...\",\n                                                \"details\": error_data\n                                            }\n                                        )\n                                        await asyncio.sleep(delay)\n                                        attempt += 1\n                                        continue\n    \n                                yield AIResponse(\n                                    content=\"\",\n                                    error={\n                                        \"code\": str(response.status),\n                                        \"message\": f\"API error {response.status}: {error_msg}\",\n                                        \"details\": error_data\n                                    }\n                                )\n                                return\n    \n                            response_handler = self._create_stream_response_handler()\n                            async for line in response.content:\n                                try:\n                                    line = line.decode('utf-8').strip()\n                                    if not line:\n                                        continue\n    \n                                    if not line.startswith(\"data: \"):\n                                        continue\n    \n                                    line = line[6:]\n    \n                                    if line == \"[DONE]\":\n                                        break\n    \n                                    chunk = json.loads(line)\n                                    response_handler.update_from_chunk(chunk)\n                                    if response_handler.error:\n                                        yield AIResponse(\n                                            content=\"\",\n                                            error=response_handler.error\n                                        )\n                                        return\n    \n                                    yield AIResponse(\n                                        content=response_handler.content,\n                                        usage=response_handler.usage\n                                    )\n    \n                                except asyncio.CancelledError:\n                                    self._logger.exception(\"CancelledError\")\n                                    yield AIResponse(\n                                        content=response_handler.content,\n                                        error={\n                                            \"code\": \"cancelled\",\n                                            \"message\": \"Request cancelled by user\"\n                                        }\n                                    )\n                                    return\n    \n                                except json.JSONDecodeError as e:\n                                    self._logger.exception(\"JSON exception: %s\", e)\n                                    continue\n    \n                                except Exception as e:\n                                    self._logger.exception(\"unexpected exception: %s\", e)\n                                    break\n    \n                            # Successfully processed response, exit retry loop\n                            break\n    \n                except (ClientConnectorError, ClientError, asyncio.TimeoutError) as e:\n                    # Handle network-related errors that should be retried\n                    self._logger.warning(\"Network error (attempt %d/%d): %s\", attempt + 1, self._max_retries, str(e))\n                    delay = self._base_delay * (2 ** attempt)\n    \n                    if attempt < self._max_retries - 1:\n                        yield AIResponse(\n                            content=\"\",\n                            error={\n                                \"code\": \"network_error\",\n                                \"message\": f\"Network error: {str(e)}. Retrying in {delay} seconds...\",\n                                \"details\": {\"type\": type(e).__name__, \"attempt\": attempt + 1}\n                            }\n                        )\n                        await asyncio.sleep(delay)\n                        attempt += 1\n                        continue\n    \n                    yield AIResponse(\n                        content=\"\",\n                        error={\n                            \"code\": \"network_error\",\n                            \"message\": f\"Network error after {self._max_retries} attempts: {str(e)}\",\n                            \"details\": {\"type\": type(e).__name__}\n                        }\n                    )\n                    return\n    \n                except Exception as e:\n                    # Handle non-retryable errors\n                    self._logger.exception(\"Error processing AI response: %s\", str(e))\n                    yield AIResponse(\n                        content=\"\",\n                        error={\n                            \"code\": \"error\",\n                            \"message\": f\"Error: {str(e)}\",\n                            \"details\": {\"type\": type(e).__name__}\n                        }\n                    )\n                    return\n    ```\n    File: src/humbug/ai/provider.py\n    ```python\n    \"\"\"Provider selection and initialization for AI backends.\"\"\"\n    \n    from typing import Dict, Optional\n    \n    from humbug.ai.ai_backend import AIBackend\n    from humbug.ai.openai_backend import OpenAIBackend\n    from humbug.ai.gemini_backend import GeminiBackend\n    from humbug.ai.anthropic_backend import AnthropicBackend\n    \n    \n    class AIProvider:\n        \"\"\"Factory and manager for AI backends.\"\"\"\n    \n        @staticmethod\n        def create_backends(openai_key: Optional[str] = None,\n                           google_key: Optional[str] = None,\n                           anthropic_key: Optional[str] = None) -> Dict[str, AIBackend]:\n            \"\"\"Create AI backends based on available API keys.\n    \n            Args:\n                openai_key: Optional OpenAI API key\n                google_key: Optional Google API key\n                anthropic_key: Optional Anthropic API key\n    \n            Returns:\n                Dictionary mapping provider names to backend instances\n            \"\"\"\n            backends = {}\n            if openai_key:\n                backends[\"openai\"] = OpenAIBackend(openai_key)\n    \n            if google_key:\n                backends[\"google\"] = GeminiBackend(google_key)\n    \n            if anthropic_key:\n                backends[\"anthropic\"] = AnthropicBackend(anthropic_key)\n    \n            return backends\n    ```\n    File: src/humbug/ai/anthropic_stream_response.py\n    ```python\n    \"\"\"Handles streaming response from Anthropic API.\"\"\"\n    \n    import logging\n    from typing import Optional\n    \n    from humbug.ai.ai_usage import AIUsage\n    \n    \n    class AnthropicStreamResponse:\n        \"\"\"Handles streaming response from Anthropic API.\"\"\"\n    \n        def __init__(self):\n            \"\"\"Initialize stream response handler.\"\"\"\n            self.content = \"\"\n            self.usage: Optional[AIUsage] = None\n            self.error = None\n            self._logger = logging.getLogger(\"AnthropicStreamResponse\")\n    \n            # Internal tracking of tokens\n            self._input_tokens = 0\n            self._output_tokens = 0\n    \n        def update_from_chunk(self, chunk: dict) -> None:\n            \"\"\"Update from a response chunk and return new content if any.\"\"\"\n            if \"error\" in chunk:\n                self._logger.debug(\"Got error message: %s\", chunk[\"error\"])\n                self.error = {\n                    \"code\": chunk[\"error\"].get(\"type\", \"stream_error\"),\n                    \"message\": chunk[\"error\"].get(\"message\", \"Unknown error\"),\n                    \"details\": chunk[\"error\"]\n                }\n                return\n    \n            event_type = chunk.get(\"type\")\n    \n            if event_type == \"message_start\":\n                # Track input tokens but don't expose them yet\n                if \"message\" in chunk and \"usage\" in chunk[\"message\"]:\n                    usage = chunk[\"message\"][\"usage\"]\n                    self._input_tokens = usage.get(\"input_tokens\", 0)\n            elif event_type == \"content_block_delta\":\n                delta = chunk.get(\"delta\", {})\n                if delta.get(\"type\") == \"text_delta\":\n                    self.content += delta.get(\"text\", \"\")\n            elif event_type == \"message_delta\":\n                # Track output tokens but don't expose them yet\n                if \"usage\" in chunk:\n                    usage = chunk[\"usage\"]\n                    self._output_tokens = usage.get(\"output_tokens\", 0)\n            elif event_type == \"message_stop\":\n                # Only now do we create and expose the usage stats\n                self.usage = AIUsage(\n                    prompt_tokens=self._input_tokens,\n                    completion_tokens=self._output_tokens,\n                    total_tokens=self._input_tokens + self._output_tokens\n                )\n    ```\n    File: src/humbug/workspace/workspace_error.py\n    ```python\n    import json\n    import logging\n    import os\n    import shutil\n    from typing import Dict, List, Optional\n    \n    \n    class WorkspaceError(Exception):\n        \"\"\"Base exception for workspace-related errors.\"\"\"\n    \n    \n    class WorkspaceNotFoundError(WorkspaceError):\n        \"\"\"Raised when attempting to access a non-existent workspace.\"\"\"\n    \n    \n    class WorkspaceExistsError(WorkspaceError):\n        \"\"\"Raised when attempting to create a workspace that already exists.\"\"\"\n    ```\n    File: src/humbug/workspace/workspace_manager.py\n    ```python\n    \"\"\"\n    Manages Humbug application workspaces.\n    \n    This module provides functionality for creating, opening, and managing Humbug workspaces.\n    A workspace contains project-specific settings, recent files, and conversation history.\n    \"\"\"\n    \n    import json\n    import logging\n    import os\n    import shutil\n    from typing import Dict, Optional\n    \n    from PySide6.QtCore import QObject, Signal\n    \n    from humbug.workspace.workspace_error import WorkspaceError, WorkspaceExistsError, WorkspaceNotFoundError\n    from humbug.workspace.workspace_settings import WorkspaceSettings\n    \n    \n    class WorkspaceManager(QObject):\n        \"\"\"\n        Manages Humbug application workspaces.\n    \n        A workspace is a directory containing project-specific settings and data. Each workspace\n        has a .humbug subdirectory containing configuration files and conversation history.\n    \n        Implements singleton pattern to provide global access to workspace state.\n    \n        Attributes:\n            WORKSPACE_DIR: Name of the workspace configuration directory\n            SETTINGS_FILE: Name of the workspace settings file\n            SESSION_FILE: Name of the file storing recent tabs\n        \"\"\"\n    \n        # Signal emitted when workspace settings change\n        settings_changed = Signal()\n    \n        WORKSPACE_DIR = \".humbug\"\n        SETTINGS_FILE = \"settings.json\"\n        SESSION_FILE = \"session.json\"\n    \n        _instance = None\n        _logger = logging.getLogger(\"WorkspaceManager\")\n    \n        def __new__(cls):\n            \"\"\"Create or return singleton instance.\"\"\"\n            if cls._instance is None:\n                cls._instance = super(WorkspaceManager, cls).__new__(cls)\n                # Note: Don't initialize here - wait for __init__\n            return cls._instance\n    \n        def __init__(self):\n            \"\"\"Initialize workspace manager if not already initialized.\"\"\"\n            if not hasattr(self, '_initialized'):\n                super().__init__()\n                self._workspace_path: Optional[str] = None\n                self._settings: Optional[WorkspaceSettings] = None\n                self._home_config = os.path.expanduser(\"~/.humbug/workspace.json\")\n                self._initialized = True\n    \n        @property\n        def workspace_path(self) -> Optional[str]:\n            \"\"\"\n            Get the current workspace path.\n    \n            Returns:\n                The absolute path to the current workspace, or None if no workspace is open.\n            \"\"\"\n            return self._workspace_path\n    \n        @property\n        def settings(self) -> Optional[WorkspaceSettings]:\n            \"\"\"\n            Get the current workspace settings.\n    \n            Returns:\n                The WorkspaceSettings object for the current workspace, or None if no workspace is open.\n            \"\"\"\n            return self._settings\n    \n        def update_settings(self, new_settings: WorkspaceSettings) -> None:\n            \"\"\"\n            Update workspace settings and notify listeners.\n    \n            Args:\n                new_settings: New settings to apply\n    \n            Raises:\n                WorkspaceError: If settings cannot be saved\n                WorkspaceNotFoundError: If no workspace is open\n            \"\"\"\n            if not self.has_workspace:\n                raise WorkspaceNotFoundError(\"No workspace is currently open\")\n    \n            # Save settings to file\n            settings_path = os.path.join(\n                self._workspace_path,\n                self.WORKSPACE_DIR,\n                self.SETTINGS_FILE\n            )\n            try:\n                new_settings.save(settings_path)\n                self._settings = new_settings\n                self.settings_changed.emit()\n            except OSError as e:\n                raise WorkspaceError(f\"Failed to save workspace settings: {str(e)}\") from e\n    \n        @property\n        def has_workspace(self) -> bool:\n            \"\"\"\n            Check if a workspace is currently open.\n    \n            Returns:\n                True if a workspace is open, False otherwise.\n            \"\"\"\n            return self._workspace_path is not None\n    \n        def create_workspace(self, path: str) -> None:\n            \"\"\"\n            Create a new workspace at the specified path.\n    \n            Args:\n                path: Directory path where the workspace should be created.\n    \n            Raises:\n                WorkspaceExistsError: If a workspace already exists at the specified path.\n                OSError: If there are filesystem errors creating the workspace.\n            \"\"\"\n            workspace_dir = os.path.join(path, self.WORKSPACE_DIR)\n            if os.path.exists(workspace_dir):\n                raise WorkspaceExistsError(f\"Workspace already exists at {path}\")\n    \n            try:\n                # Create workspace directory structure\n                os.makedirs(workspace_dir)\n    \n                # Create and save default settings\n                settings = WorkspaceSettings()\n                settings.save(os.path.join(workspace_dir, self.SETTINGS_FILE))\n    \n                # Create empty session file\n                session_path = os.path.join(workspace_dir, self.SESSION_FILE)\n                with open(session_path, 'w', encoding='utf-8') as f:\n                    json.dump({\"tabs\": []}, f, indent=2)\n    \n            except OSError as e:\n                self._logger.error(\"Failed to create workspace at %s: %s\", path, str(e))\n                # Clean up any partially created workspace\n                if os.path.exists(workspace_dir):\n                    try:\n                        shutil.rmtree(workspace_dir)\n                    except OSError:\n                        pass  # Ignore cleanup errors\n                raise\n    \n        def open_workspace(self, path: str) -> None:\n            \"\"\"\n            Open an existing workspace.\n    \n            Args:\n                path: Path to the workspace directory.\n    \n            Returns:\n                The WorkspaceSettings object for the opened workspace.\n    \n            Raises:\n                WorkspaceNotFoundError: If no workspace exists at the specified path.\n                WorkspaceError: If there are errors loading the workspace settings.\n            \"\"\"\n            workspace_dir = os.path.join(path, self.WORKSPACE_DIR)\n            if not os.path.exists(workspace_dir):\n                raise WorkspaceNotFoundError(f\"No workspace found at {path}\")\n    \n            try:\n                settings_path = os.path.join(workspace_dir, self.SETTINGS_FILE)\n                settings = WorkspaceSettings.load(settings_path)\n                self._workspace_path = path\n                self._settings = settings\n                self._update_home_tracking()\n                self.settings_changed.emit()\n    \n            except Exception as e:\n                self._logger.error(\"Failed to open workspace at %s: %s\", path, str(e))\n                raise WorkspaceError(f\"Failed to open workspace: {str(e)}\") from e\n    \n        def close_workspace(self) -> None:\n            \"\"\"Close the current workspace.\"\"\"\n            if self.has_workspace:\n                self._workspace_path = None\n                self._settings = None\n                self._update_home_tracking()\n                self.settings_changed.emit()\n    \n        def save_workspace_state(self, state: Dict) -> None:\n            \"\"\"\n            Save workspace state to disk.\n    \n            Args:\n                state: Dictionary containing tabs and layout state\n    \n            Raises:\n                WorkspaceError: If saving state fails\n            \"\"\"\n            if not self.has_workspace:\n                raise WorkspaceError(\"No workspace is active\")\n    \n            try:\n                # Ensure .humbug directory exists\n                self.ensure_workspace_dir(\".humbug\")\n    \n                for tab_state in state.get('tabs', []):\n                    if 'path' in tab_state and os.path.isabs(tab_state['path']):\n                        try:\n                            tab_state['path'] = os.path.relpath(\n                                tab_state['path'],\n                                self.workspace_path\n                            )\n                        except ValueError:\n                            # Path is outside workspace, keep as absolute\n                            pass\n    \n                # Write session file\n                session_file = os.path.join(self.workspace_path, self.WORKSPACE_DIR, self.SESSION_FILE)\n                with open(session_file, 'w', encoding='utf-8') as f:\n                    json.dump(state, f)\n    \n            except OSError as e:\n                raise WorkspaceError(f\"Failed to save workspace state: {str(e)}\") from e\n    \n        def load_workspace_state(self) -> Dict:\n            \"\"\"\n            Load workspace state from disk.\n    \n            Returns:\n                Dictionary containing tabs and layout state\n    \n            Raises:\n                WorkspaceError: If loading state fails\n            \"\"\"\n            if not self.has_workspace:\n                raise WorkspaceError(\"No workspace is active\")\n    \n            try:\n                session_file = os.path.join(self.workspace_path, self.WORKSPACE_DIR, self.SESSION_FILE)\n                if not os.path.exists(session_file):\n                    return []\n    \n                with open(session_file, encoding='utf-8') as f:\n                    state = json.load(f)\n    \n                for tab_state in state.get('tabs', []):\n                    if 'path' in tab_state and not os.path.isabs(tab_state['path']):\n                        tab_state['path'] = os.path.join(\n                            self.workspace_path,\n                            tab_state['path']\n                        )\n    \n                return state\n    \n            except json.JSONDecodeError as e:\n                raise WorkspaceError(f\"Failed to parse workspace state: {str(e)}\") from e\n            except OSError as e:\n                raise WorkspaceError(f\"Failed to load workspace state: {str(e)}\") from e\n    \n        def get_last_workspace(self) -> Optional[str]:\n            \"\"\"\n            Get the path of the last opened workspace.\n    \n            Returns:\n                Path to the last workspace that was opened, or None if no workspace has been opened\n                or the last workspace no longer exists.\n            \"\"\"\n            try:\n                with open(self._home_config, encoding='utf-8') as f:\n                    data = json.load(f)\n                    workspace_path = data.get(\"lastWorkspace\")\n                    if workspace_path and os.path.exists(workspace_path):\n                        return workspace_path\n            except (FileNotFoundError, json.JSONDecodeError):\n                pass\n            return None\n    \n        def get_workspace_path(self, relative_path: str) -> str:\n            \"\"\"\n            Convert a workspace-relative path to an absolute path.\n    \n            Args:\n                relative_path: Path relative to the workspace root.\n    \n            Returns:\n                Absolute path within the workspace.\n    \n            Raises:\n                WorkspaceNotFoundError: If no workspace is currently open.\n            \"\"\"\n            if not self.has_workspace:\n                raise WorkspaceNotFoundError(\"No workspace is currently open\")\n            return os.path.join(self._workspace_path, relative_path)\n    \n        def make_relative_path(self, path: str) -> Optional[str]:\n            \"\"\"\n            Convert an absolute path to a workspace-relative path if possible.\n    \n            Args:\n                path: Absolute path to convert.\n    \n            Returns:\n                Path relative to workspace root, or None if path is outside workspace.\n            \"\"\"\n            if not self.has_workspace:\n                return None\n    \n            try:\n                # Normalize both paths for comparison\n                abs_path = os.path.abspath(path)\n                workspace_path = os.path.abspath(self._workspace_path)\n    \n                # Check if the path is actually within the workspace\n                # by comparing the normalized path beginnings\n                common_path = os.path.commonpath([abs_path, workspace_path])\n                if common_path != workspace_path:\n                    return None  # Path is outside workspace\n    \n                # If we get here, the path is within the workspace, so make it relative\n                return os.path.relpath(abs_path, workspace_path)\n            except ValueError:\n                return None  # Path is on different\n    \n        def ensure_workspace_dir(self, dir_path: str) -> str:\n            \"\"\"\n            Ensure a directory exists within the workspace.\n    \n            Args:\n                dir_path: Directory path relative to workspace root.\n    \n            Returns:\n                Absolute path to the created directory.\n    \n            Raises:\n                WorkspaceNotFoundError: If no workspace is currently open.\n                OSError: If directory cannot be created.\n            \"\"\"\n            if not self.has_workspace:\n                raise WorkspaceNotFoundError(\"No workspace is currently open\")\n    \n            abs_path = self.get_workspace_path(dir_path)\n            try:\n                os.makedirs(abs_path, exist_ok=True)\n                return abs_path\n            except OSError as e:\n                raise WorkspaceError(f\"Failed to create directory '{dir_path}' in workspace: {e}\") from e\n    \n        def _update_home_tracking(self) -> None:\n            \"\"\"Update the home directory tracking file with current workspace path.\"\"\"\n            try:\n                os.makedirs(os.path.dirname(self._home_config), exist_ok=True)\n                with open(self._home_config, 'w', encoding='utf-8') as f:\n                    json.dump({\"lastWorkspace\": self._workspace_path}, f, indent=2)\n            except OSError as e:\n                self._logger.error(\"Failed to update home tracking: %s\", str(e))\n                # Non-critical error, don't raise\n    ```\n    File: src/humbug/workspace/workspace_settings.py\n    ```python\n    from dataclasses import dataclass\n    import json\n    \n    @dataclass\n    class WorkspaceSettings:\n        use_soft_tabs: bool = True\n        tab_size: int = 4\n        font_size: float = None  # None means use the default font size\n        auto_backup: bool = False  # Default to off\n        auto_backup_interval: int = 300  # Default 5 minutes in seconds\n    \n        @classmethod\n        def load(cls, path: str) -> \"WorkspaceSettings\":\n            with open(path, 'r', encoding='utf-8') as f:\n                data = json.load(f)\n                editor = data.get(\"editor\", {})\n                return cls(\n                    use_soft_tabs=editor.get(\"useSoftTabs\", True),\n                    tab_size=editor.get(\"tabSize\", 4),\n                    font_size=editor.get(\"fontSize\", None),\n                    auto_backup=editor.get(\"autoBackup\", False),\n                    auto_backup_interval=editor.get(\"autoBackupInterval\", 300)\n                )\n    \n        def save(self, path: str) -> None:\n            data = {\n                \"editor\": {\n                    \"useSoftTabs\": self.use_soft_tabs,\n                    \"tabSize\": self.tab_size,\n                    \"fontSize\": self.font_size,\n                    \"autoBackup\": self.auto_backup,\n                    \"autoBackupInterval\": self.auto_backup_interval\n                }\n            }\n            with open(path, 'w', encoding='utf-8') as f:\n                json.dump(data, f, indent=2)\n    ```\n    File: src/humbug/transcript/float_one_decimal_encoder.py\n    ```python\n    \"\"\"Transcript writer implementation for Humbug application.\"\"\"\n    \n    import json\n    \n    \n    class FloatOneDecimalEncoder(json.JSONEncoder):\n        \"\"\"JSON encoder that formats floats to one decimal place.\"\"\"\n        def default(self, o):\n            \"\"\"\n            Convert object to JSON serializable form.\n    \n            Args:\n                o: Object to convert\n    \n            Returns:\n                JSON serializable representation\n            \"\"\"\n            if isinstance(o, float):\n                return round(o, 1)\n    \n            return super().default(o)\n    ```\n    File: src/humbug/transcript/transcript_handler.py\n    ```python\n    \"\"\"Unified transcript handling for conversations.\"\"\"\n    \n    from dataclasses import dataclass\n    import json\n    import logging\n    import os\n    from datetime import datetime\n    from typing import Dict, List, Optional\n    \n    from humbug.conversation.message import Message\n    from humbug.transcript.transcript_error import (\n        TranscriptFormatError, TranscriptIOError\n    )\n    from humbug.transcript.float_one_decimal_encoder import FloatOneDecimalEncoder\n    \n    \n    @dataclass\n    class TranscriptData:\n        \"\"\"Container for transcript data and metadata.\"\"\"\n        messages: List[Message]\n        timestamp: datetime\n        version: str\n    \n    \n    class TranscriptHandler:\n        \"\"\"Handles reading and writing conversation transcripts.\"\"\"\n    \n        def __init__(self, filename: str, timestamp: Optional[datetime] = None):\n            \"\"\"\n            Initialize transcript handler for a conversation.\n    \n            Args:\n                filename: Full path to transcript file\n                timestamp: ISO format timestamp for new conversations\n    \n            Raises:\n                ValueError: If creating new transcript without timestamp\n            \"\"\"\n            self._filename = filename\n            self._timestamp = timestamp\n            self._logger = logging.getLogger(\"TranscriptHandler\")\n    \n            if not os.path.exists(filename):\n                if timestamp is None:\n                    raise ValueError(\"Timestamp required when creating new transcript\")\n                self._initialize_file()\n    \n        def _initialize_file(self) -> None:\n            \"\"\"\n            Initialize a new transcript file with metadata.\n    \n            Raises:\n                TranscriptIOError: If file creation fails\n            \"\"\"\n            metadata = {\n                \"metadata\": {\n                    \"timestamp\": self._timestamp.isoformat(),\n                    \"version\": \"0.1\",\n                },\n                \"conversation\": []\n            }\n    \n            try:\n                with open(self._filename, 'w', encoding='utf-8') as f:\n                    json.dump(metadata, f, indent=2, cls=FloatOneDecimalEncoder)\n            except Exception as e:\n                raise TranscriptIOError(\n                    f\"Failed to create transcript file: {str(e)}\"\n                ) from e\n    \n        def _validate_transcript_data(self, data: Dict) -> None:\n            \"\"\"\n            Validate transcript file structure.\n    \n            Args:\n                data: Loaded transcript data\n    \n            Raises:\n                TranscriptFormatError: If transcript format is invalid\n            \"\"\"\n            if not isinstance(data, dict):\n                raise TranscriptFormatError(\"Root element must be object\")\n    \n            if \"metadata\" not in data or \"conversation\" not in data:\n                raise TranscriptFormatError(\"Missing required fields\")\n    \n            metadata = data[\"metadata\"]\n            if not isinstance(metadata, dict):\n                raise TranscriptFormatError(\"Metadata must be object\")\n    \n            if \"version\" not in metadata:\n                raise TranscriptFormatError(\"Missing version in metadata\")\n    \n            if \"timestamp\" not in metadata:\n                raise TranscriptFormatError(\"Missing timestamp in metadata\")\n    \n            if not isinstance(data[\"conversation\"], list):\n                raise TranscriptFormatError(\"Conversation must be array\")\n    \n        def read(self) -> TranscriptData:\n            \"\"\"\n            Read and validate transcript file.\n    \n            Returns:\n                TranscriptData containing messages and metadata\n    \n            Raises:\n                TranscriptFormatError: If transcript format is invalid\n                TranscriptIOError: If file operations fail\n            \"\"\"\n            try:\n                with open(self._filename, 'r', encoding='utf-8') as f:\n                    data = json.load(f)\n            except json.JSONDecodeError as e:\n                raise TranscriptFormatError(f\"Invalid JSON: {str(e)}\") from e\n            except Exception as e:\n                raise TranscriptIOError(f\"Failed to read transcript: {str(e)}\") from e\n    \n            self._validate_transcript_data(data)\n    \n            # Convert transcript messages to Message objects\n            messages = []\n            for msg in data[\"conversation\"]:\n                try:\n                    message = Message.from_transcript_dict(msg)\n                    messages.append(message)\n                except ValueError as e:\n                    raise TranscriptFormatError(f\"Invalid message format: {str(e)}\") from e\n    \n            try:\n                timestamp = datetime.fromisoformat(data[\"metadata\"][\"timestamp\"])\n            except ValueError as e:\n                raise TranscriptFormatError(f\"Invalid timestamp format: {str(e)}\") from e\n    \n            return TranscriptData(\n                messages=messages,\n                timestamp=timestamp,\n                version=data[\"metadata\"][\"version\"]\n            )\n    \n        async def write(self, messages: List[Dict]) -> None:\n            \"\"\"\n            Write messages to transcript file.\n    \n            Args:\n                messages: List of message dictionaries to append\n    \n            Raises:\n                TranscriptIOError: If file operations fail\n            \"\"\"\n            try:\n                # Read current content\n                with open(self._filename, 'r', encoding='utf-8') as f:\n                    data = json.load(f)\n    \n                # Add new messages\n                data[\"conversation\"].extend(messages)\n    \n                # Write to temp file then rename for atomic operation\n                temp_file = f\"{self._filename}.tmp\"\n                with open(temp_file, 'w', encoding='utf-8') as f:\n                    json.dump(data, f, indent=2, cls=FloatOneDecimalEncoder)\n    \n                # Atomic replace\n                os.replace(temp_file, self._filename)\n    \n            except Exception as e:\n                # Create backup of current file if possible\n                try:\n                    if os.path.exists(self._filename):\n                        backup = f\"{self._filename}.backup\"\n                        os.replace(self._filename, backup)\n                        self._logger.info(\"Created transcript backup: %s\", backup)\n                except Exception as backup_error:\n                    self._logger.error(\n                        \"Failed to create backup file: %s\",\n                        str(backup_error)\n                    )\n    \n                raise TranscriptIOError(\n                    f\"Failed to write transcript: {str(e)}\",\n                    details={\"backup_created\": os.path.exists(f\"{self._filename}.backup\")}\n                ) from e\n    ```\n    File: src/humbug/transcript/transcript_error.py\n    ```python\n    from typing import Dict, Optional\n    \n    \n    class TranscriptError(Exception):\n        \"\"\"Base exception class for transcript-related errors.\"\"\"\n    \n        def __init__(self, message: str, details: Optional[Dict] = None):\n            \"\"\"\n            Initialize transcript error.\n    \n            Args:\n                message: Error description\n                details: Optional dictionary with additional error details\n            \"\"\"\n            super().__init__(message)\n            self.details = details or {}\n    \n    \n    class TranscriptFormatError(TranscriptError):\n        \"\"\"Exception raised when transcript format is invalid.\"\"\"\n        pass\n    \n    \n    class TranscriptIOError(TranscriptError):\n        \"\"\"Exception raised when transcript file operations fail.\"\"\"\n        pass\n    ```\n    File: src/humbug/__main__.py\n    ```python\n    \"\"\"Main entry point for the Humbug application.\"\"\"\n    \n    import asyncio\n    import json\n    import logging\n    import os\n    import sys\n    import time\n    \n    from qasync import QEventLoop, QApplication\n    \n    from humbug.ai.provider import AIProvider\n    from humbug.gui.main_window import MainWindow\n    \n    # Import parsers to ensure we register them\n    from humbug.syntax.c_parser import CParser  # noqa: F401\n    from humbug.syntax.cpp_parser import CppParser  # noqa: F401\n    from humbug.syntax.css_parser import CSSParser  # noqa: F401\n    from humbug.syntax.html_parser import HTMLParser  # noqa: F401\n    from humbug.syntax.javascript_parser import JavaScriptParser  # noqa: F401\n    from humbug.syntax.metaphor_parser import MetaphorParser  # noqa: F401\n    from humbug.syntax.python_parser import PythonParser  # noqa: F401\n    from humbug.syntax.text_parser import TextParser  # noqa: F401\n    from humbug.syntax.typescript_parser import TypeScriptParser  # noqa: F401\n    from humbug.syntax.parser_registry import ParserRegistry\n    \n    \n    def get_api_keys() -> dict[str, str | None]:\n        \"\"\"\n        Get API keys from configuration file and environment variables.\n    \n        The function will first check for a ~/.humbug/api-keys.json file and create it\n        if it doesn't exist. Keys from this file will override environment variables.\n    \n        Returns:\n            dict: Dictionary containing API keys for OpenAI, Google, and Anthropic\n    \n        Raises:\n            json.JSONDecodeError: If the API keys file exists but contains invalid JSON\n        \"\"\"\n        logger = logging.getLogger(__name__)\n    \n        # Initialize with environment variables\n        api_keys = {\n            \"OPENAI_API_KEY\": os.environ.get(\"OPENAI_API_KEY\"),\n            \"GOOGLE_API_KEY\": os.environ.get(\"GOOGLE_API_KEY\"),\n            \"ANTHROPIC_API_KEY\": os.environ.get(\"ANTHROPIC_API_KEY\")\n        }\n    \n        # Define the config directory and file path\n        config_dir = os.path.expanduser(\"~/.humbug\")\n        config_file = os.path.join(config_dir, \"api-keys.json\")\n    \n        # Create directory if it doesn't exist\n        try:\n            os.makedirs(config_dir, mode=0o700, exist_ok=True)\n        except PermissionError:\n            logger.error(\"Failed to create config directory\", exc_info=True)\n            return api_keys\n    \n        # Create or read the config file\n        try:\n            if not os.path.exists(config_file):\n                with open(config_file, 'w', encoding='utf-8') as f:\n                    json.dump({\n                        \"OPENAI_API_KEY\": \"\",\n                        \"GOOGLE_API_KEY\": \"\",\n                        \"ANTHROPIC_API_KEY\": \"\"\n                    }, f, indent=4)\n                os.chmod(config_file, 0o600)\n            else:\n                with open(config_file, 'r', encoding='utf-8') as f:\n                    file_content = f.read()\n                    if file_content.strip():  # Only parse if file is not empty\n                        file_keys = json.loads(file_content)\n                        # Override environment variables with non-empty file values\n                        for key in api_keys:\n                            if key in file_keys and file_keys[key]:\n                                api_keys[key] = file_keys[key]\n    \n        except json.JSONDecodeError:\n            logger.error(\"Failed to parse API keys file\", exc_info=True)\n            raise\n        except PermissionError:\n            logger.error(\"Failed to access API keys file\", exc_info=True)\n        except OSError:\n            logger.error(\"Failed to read/write API keys file\", exc_info=True)\n    \n        return api_keys\n    \n    \n    def install_global_exception_handler():\n        \"\"\"Install a global exception handler for uncaught exceptions.\"\"\"\n        logger = logging.getLogger('GlobalExceptionHandler')\n    \n        def handle_exception(exc_type, exc_value, exc_traceback):\n            if issubclass(exc_type, KeyboardInterrupt):\n                # Don't log keyboard interrupt\n                sys.__excepthook__(exc_type, exc_value, exc_traceback)\n                return\n    \n            logger.critical(\n                \"Uncaught exception\",\n                exc_info=(exc_type, exc_value, exc_traceback),\n                stack_info=True\n            )\n    \n        sys.excepthook = handle_exception\n    \n    \n    class HumbugApplication(QApplication):\n        \"\"\"Class for the application. Specialized to do event time reporting.\"\"\"\n        def __init__(self, argv):\n            super().__init__(argv)\n            self._start_time = time.monotonic()\n    \n        def notify(self, receiver, event):\n            event_type = event.type()\n            receiver_name = receiver.objectName()\n            start = time.monotonic()\n            ret = QApplication.notify(self, receiver, event)\n            end = time.monotonic()\n            elapsed_time = (end - start) * 1000\n            if elapsed_time > 20:\n                rel_start = start - self._start_time\n                print(f\"{rel_start:.3f}: processing event type {event_type} for object {receiver_name} took {elapsed_time:.3f} msec\")\n    \n            return ret\n    \n    \n    async def main():\n        install_global_exception_handler()\n    \n        # Get API keys from config and environment\n        api_keys = get_api_keys()\n        openai_key = api_keys[\"OPENAI_API_KEY\"]\n        google_key = api_keys[\"GOOGLE_API_KEY\"]\n        anthropic_key = api_keys[\"ANTHROPIC_API_KEY\"]\n    \n        if not any([openai_key, google_key, anthropic_key]):\n            print(\"Error: No API keys found. Please set keys in ~/.humbug/api-keys.json or environment variables\")\n            return 1\n    \n        # Initialize components\n        ai_backends = AIProvider.create_backends(openai_key, google_key, anthropic_key)\n        if not ai_backends:\n            print(\"Error: No AI backends could be initialized\")\n            return 1\n    \n        # Create and show main window\n        window = MainWindow(ai_backends)\n        window.show()\n    \n        return 0\n    \n    \n    def run_app():\n        # Create application first\n        app = HumbugApplication(sys.argv)\n    \n        # Create and set event loop\n        loop = QEventLoop(app)\n        asyncio.set_event_loop(loop)\n    \n        # Run the main function\n        try:\n            with loop:\n                exit_code = loop.run_until_complete(main())\n                # Only run forever if main succeeded\n                if exit_code == 0:\n                    loop.run_forever()\n                return exit_code\n        except KeyboardInterrupt:\n            return 0\n    \n    \n    if __name__ == \"__main__\":\n        sys.exit(run_app())\n    ```\n    File: src/humbug/__init__.py\n    ```python\n    \"\"\"Humbug - An AI interaction application.\"\"\"\n    from datetime import datetime\n    import glob\n    import logging\n    from logging.handlers import RotatingFileHandler\n    import os\n    \n    \n    __version__ = \"0.2\"\n    \n    \n    \n    def setup_logging():\n        \"\"\"Configure application logging with timestamped files and rotation.\"\"\"\n        # Create logs directory in user's home .humbug directory\n        log_dir = os.path.expanduser(\"~/.humbug/logs\")\n        os.makedirs(log_dir, exist_ok=True)\n    \n        # Generate timestamp for log filename\n        timestamp = datetime.utcnow().strftime(\"%Y-%m-%d-%H-%M-%S-%f\")[:23]\n        log_file = os.path.join(log_dir, f\"{timestamp}.log\")\n    \n        # Configure rotating file handler\n        # Keep up to 50 log files, max 1MB each\n        handler = RotatingFileHandler(\n            log_file,\n            maxBytes=1024*1024,  # 1MB\n            backupCount=49  # Keep 50 files total (current + 49 backups)\n        )\n    \n        # Configure logging\n        logging.basicConfig(\n            level=logging.DEBUG,\n            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n            handlers=[handler]\n        )\n    \n        # Clean up old logs if we have too many\n        cleanup_old_logs(log_dir, max_logs=50)\n    \n    \n    def cleanup_old_logs(log_dir: str, max_logs: int):\n        \"\"\"Remove oldest log files if we exceed maximum count.\"\"\"\n        log_files = glob.glob(os.path.join(log_dir, \"*.log\"))\n        log_files.sort(key=os.path.getctime)  # Sort by creation time\n    \n        # Remove oldest files if we have too many\n        while len(log_files) > max_logs:\n            try:\n                os.remove(log_files.pop(0))  # Remove oldest file\n            except OSError:\n                pass  # Ignore errors removing old logs\n    \n    \n    def format_version() -> str:\n        \"\"\"Format version number, showing patch number only if non-zero.\"\"\"\n        parts = __version__.split('.')\n        if len(parts) == 3 and parts[2] == '0':\n            return '.'.join(parts[:2])\n        return __version__\n    \n    \n    # Setup when module is imported\n    setup_logging()\n    ```\n    I would like you to review the requirements and the implementation and then I will be able to ask you questions about\n    both!\n    When I ask the questions I would like to be able to discuss interesting aspects of the design and discuss future\n    modifications and enhancements.  If I make a suggestion that you disagree with then please tell me so, and why you\n    disagree.  If that disagreement comes about because of specific good practices, or where these might harm either\n    performance or correctness I would like you to highlight what your objections are and why.  If you can cite specific\n    references that would be awesome!",
      "completed": true,
      "usage": null,
      "error": null,
      "model": null,
      "temperature": null
    },
    {
      "id": "32f6e01e-6a84-486b-96d5-2218df43630b",
      "timestamp": "2025-01-14T17:07:17.130561",
      "type": "ai_response",
      "content": "Okay, I've carefully reviewed the requirements document (written in the Metaphor language) and the provided Python code. I understand the detailed specifications for the Humbug application, including its GUI structure, functionality,  AI interaction mechanisms,  workspace management, error handling, and styling.  I also understand the Python coding style guidelines specified in the requirements.  I'm ready for your questions.  I will do my best to provide insightful answers, discuss design aspects, suggest future modifications and enhancements, and explain any disagreements I may have, citing relevant best practices and potential performance or correctness implications where appropriate.\n",
      "completed": true,
      "usage": {
        "prompt_tokens": 137136,
        "completion_tokens": 123,
        "total_tokens": 137259
      },
      "error": null,
      "model": "gemini-1.5-flash",
      "temperature": 0.7
    },
    {
      "id": "9032caa3-719f-478e-ba26-15ee734d8e45",
      "timestamp": "2025-01-14T17:09:11.516519",
      "type": "user_message",
      "content": "I would like to look at adding a feature to drag and drop files from the file tree. What would I need to do to add this?",
      "completed": true,
      "usage": null,
      "error": null,
      "model": null,
      "temperature": null
    },
    {
      "id": "b4d12d95-5288-45fe-ad06-4b29e5fc741c",
      "timestamp": "2025-01-14T17:09:17.247210",
      "type": "ai_response",
      "content": "To add drag-and-drop functionality from the file tree to open files in Humbug, you'll need to modify several parts of the existing code. Here's a breakdown of the steps, along with considerations for best practices and potential challenges:\n\n**1. Enable Drag and Drop in `WorkspaceFileTree`:**\n\n*   **`WorkspaceFileTree`:** The `WorkspaceFileTree` class currently only handles file *activation* (double-click or Enter key). You need to enable drag-and-drop capabilities.  This involves:\n    *   Setting `setDragEnabled(True)` in the `__init__` method of `WorkspaceFileTree`.\n    *   Implementing `supportedDropActions()` to return `Qt.CopyAction` (or `Qt.MoveAction` if you want to support moving files).\n    *   Implementing `mimeData()` to return a `QMimeData` object containing the file path.  This is crucial for the drag-and-drop operation.  The mime type should be something unique to Humbug, e.g., `\"application/x-humbug-file\"`.  This ensures other applications can't interfere with the drag-and-drop process.\n    *   Implementing `startDrag()` to initiate the drag-and-drop operation, passing the `QMimeData` object created in `mimeData()`.\n\n**2. Handle Drop Events in `TabManager`:**\n\n*   **`TabManager`:** The `TabManager` is responsible for managing tabs. You need to add a mechanism to handle drop events from the file tree:\n    *   Implement `dragEnterEvent` and `dropEvent` in `TabManager` (similar to how tab drops are already handled).\n    *   In `dragEnterEvent`, check if the mime type is `\"application/x-humbug-file\"`. If so, accept the drop.\n    *   In `dropEvent`, extract the file path from the `QMimeData`.  Then call `_open_file_path` in `MainWindow` to open the file in a new editor tab.  This reuses the existing file-opening logic, promoting code reuse and maintainability.\n\n**3.  Potential Issues and Best Practices:**\n\n*   **Error Handling:**  Implement robust error handling in both `WorkspaceFileTree` and `TabManager` to gracefully handle potential issues (e.g., invalid file paths, permission errors).  This is essential for a user-friendly experience.\n*   **Mime Type Uniqueness:**  Using a custom mime type (`\"application/x-humbug-file\"`) is crucial to avoid conflicts with other applications.\n*   **Asynchronous Operations:** Consider making the file opening asynchronous (using `asyncio.create_task`) to prevent UI freezes, especially when opening large files.\n*   **Feedback to User:** Provide visual feedback to the user during the drag-and-drop process (e.g., a change of cursor icon, highlighting the drop target).  This improves the user experience.\n*   **Testing:** Thoroughly test the new functionality to ensure it works correctly under various conditions (different file types, large files, error scenarios).\n\n**4. Example Code Snippets (Illustrative):**\n\nThese snippets are illustrative and may require adjustments based on your specific implementation:\n\n```python\n# In WorkspaceFileTree\n    def mimeData(self, indexes: List[QModelIndex]) -> QMimeData:\n        mime_data = QMimeData()\n        mime_data.setData(\"application/x-humbug-file\", self._fs_model.filePath(indexes[0]).encode())\n        return mimeData\n\n    def supportedDropActions(self) -> Qt.DropActions:\n        return Qt.CopyAction\n\n    def startDrag(self, supportedActions):\n        mimeData = self.mimeData([self.currentIndex()])\n        drag = QDrag(self)\n        drag.setMimeData(mimeData)\n        drag.exec(Qt.CopyAction)\n```\n\n```python\n# In TabManager\n    def dragEnterEvent(self, event: QDragEnterEvent):\n        if event.mimeData().hasFormat(\"application/x-humbug-file\"):\n            event.acceptProposedAction()\n        else:\n            event.ignore()\n\n    def dropEvent(self, event: QDropEvent):\n        mime_data = event.mimeData()\n        if mimeData.hasFormat(\"application/x-humbug-file\"):\n            file_path = mimeData.data(\"application/x-humbug-file\").data().decode()\n            asyncio.create_task(self._open_file(file_path))\n            event.acceptProposedAction()\n        else:\n            event.ignore()\n```\n\nRemember to adapt these snippets to your existing code structure and ensure proper integration with the rest of the Humbug application.  Thorough testing is vital to catch any unexpected behavior.\n",
      "completed": true,
      "usage": {
        "prompt_tokens": 137290,
        "completion_tokens": 1060,
        "total_tokens": 138350
      },
      "error": null,
      "model": "gemini-1.5-flash",
      "temperature": 0.7
    }
  ]
}
