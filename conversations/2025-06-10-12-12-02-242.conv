{
  "metadata": {
    "version": "0.1"
  },
  "conversation": [
    {
      "id": "32046ad8-7d09-4477-807a-437e57f52df6",
      "timestamp": "2025-06-10T12:12:08.095526",
      "type": "user_message",
      "content": "The following preamble describes some elements of a language called Metaphor.  Please pay\nextremely close attention to the details as they will affect the way you interpret\neverything that follows after \"BEGIN DESCRIPTION IN METAPHOR:\"\n\nMetaphor is a structured natural language prompt creation language.  It is designed to\nlet a user convey their requirements to a large language model AI.\n\nMetaphor has the structure of a document tree with branches and leaves being prefixed\nby new sections containing the keywords \"Role:\", \"Context:\" or \"Action:\".  Each of\nthese indicates the start of a new block of information.  Blocks are introduced using\nMarkdown-style headings (using hash symbols).  The number of hashes gives an indication\nof the nesting depth and the parent/child relationship.\n\nBlock keywords have an optional name that will immediately follow them on the same line.\nIf this is missing then the block name is not defined.\n\nAfter a block heading there may be one or more lines of text that will describe the purpose\nof that block.  A block may also include one or more optional child blocks inside them and\nthat further clarify their parent block.\n\nWithin the text of a block, you may be presented with code or document fragments inside a\nblock delimited by 3 backticks.  Please pay close attention to the indentation level of the\nopening 3 backticks.  The identation of such code or document fragments is relative to this,\nnot relative to the block in which the code or document fragment occurs.\n\nIf \"Role:\" block exists then this contains details about the role you should fulfil.  This\nmay also describe specific skills you have, knowledge you should apply, and the\napproach you take to apply these.\n\n\"Context:\" blocks provide context necessary to understand what you will be asked to do.\n\n\"Action:\" blocks describes the task, or tasks, you should do.\n\nIf you are asked to offer any opinions on the Metaphor prompt then always provide the full\nset of parent headings leading up to any block you want to talk about.  This will allow\nthe user to understand which part of the Metaphor prompt is being discussed.\n\nWhen you process the actions please carefully ensure you do all of them accurately and\ncomplete all the elements requested.  Unless otherwise instructed, do not include any\nplaceholders in your responses.\n\nBEGIN DESCRIPTION IN METAPHOR:\n\n# Role:\n\nYou are a world class software architect, expert in performing a critical review of work performed\nby both human and AI software developers.\n\n# Context:\n\nThe following code is found in my application and I want to be able to able to evaluate the complexity\nof each function and class.\n\nFor each class and each function/method I would like you to give me an analysis of the complexity.\nThis should highlight at least 3 aspects of the complexity and should offer a complexity summary\nvalue between 0 and 100, where 0 represents minimally low complexity and 100 represents extreme\ncomplexity.\n\nFile: /Users/dave/github/m6r/humbug/src/humbug/metaphor/metaphor_ast_builder.py\n\n```python\nimport glob\nimport os\nfrom pathlib import Path\nfrom typing import List, Set, cast\n\nfrom humbug.metaphor.metaphor_token import MetaphorToken, MetaphorTokenType\nfrom humbug.metaphor.metaphor_embed_lexer import MetaphorEmbedLexer\nfrom humbug.metaphor.metaphor_lexer import MetaphorLexer\nfrom humbug.metaphor.metaphor_ast_node import (\n    MetaphorASTNode, MetaphorTextNode, MetaphorCodeNode,\n    MetaphorRoleNode, MetaphorContextNode, MetaphorActionNode\n)\n\n\nclass MetaphorASTBuilderFileAlreadyUsedError(Exception):\n    \"\"\"Exception raised when a file is used more than once.\"\"\"\n    def __init__(self, filename: str, token: MetaphorToken) -> None:\n        super().__init__(f\"The file '{filename}' has already been used.\")\n        self.filename: str = filename\n        self.token: MetaphorToken = token\n\n\nclass MetaphorASTBuilderSyntaxError(Exception):\n    \"\"\"Exception generated when there is a syntax error.\"\"\"\n    def __init__(self, message: str, filename: str, line: int, column: int, input_text: str) -> None:\n        super().__init__(f\"{message}: file: {filename}, line {line}, column {column}, \")\n        self.message: str = message\n        self.filename: str = filename\n        self.line: int = line\n        self.column: int = column\n        self.input_text: str = input_text\n\n\nclass MetaphorASTBuilderError(Exception):\n    \"\"\"Exception wrapper generated when there is a syntax error.\"\"\"\n    def __init__(self, message: str, errors: List[MetaphorASTBuilderSyntaxError]) -> None:\n        super().__init__(message)\n        self.errors: List[MetaphorASTBuilderSyntaxError] = errors\n\n\nclass MetaphorASTBuilder:\n    \"\"\"\n    Parser class to process tokens and build an Abstract Syntax Tree (AST).\n\n    Attributes:\n        _parse_errors (List[MetaphorASTBuilderSyntaxError]): List of syntax errors encountered during parsing.\n        _lexers (List[MetaphorLexer | MetaphorEmbedLexer]): Stack of lexers used for parsing multiple files.\n        _previously_seen_files (Set[str]): Set of canonical filenames already processed.\n        _search_paths (List[str]): List of paths to search for included files.\n        embed_path (str): Path used to search for embedded files.\n        current_token (MetaphorToken | None): The current token being processed.\n    \"\"\"\n    def __init__(self) -> None:\n        self._parse_errors: List[MetaphorASTBuilderSyntaxError] = []\n        self._lexers: List[MetaphorLexer | MetaphorEmbedLexer] = []\n        self._previously_seen_files: Set[str] = set()\n        self._search_paths: List[str] = []\n        self._embed_path: str = \"\"\n        self._current_token: MetaphorToken | None = None\n        self._arguments: List[str] = []\n\n    def _has_role_node(self, node: MetaphorASTNode) -> bool:\n        \"\"\"\n        Check if the node tree contains any Role nodes.\n\n        Args:\n            node: The node to check\n\n        Returns:\n            True if the node or any of its descendants is a Role node\n        \"\"\"\n        if isinstance(node, MetaphorRoleNode):\n            return True\n\n        return any(self._has_role_node(cast(MetaphorASTNode, child)) for child in node.children)\n\n    def _has_context_node(self, node: MetaphorASTNode) -> bool:\n        \"\"\"\n        Check if the node tree contains any Context nodes.\n\n        Args:\n            node: The node to check\n\n        Returns:\n            True if the node or any of its descendants is a Context node\n        \"\"\"\n        if isinstance(node, MetaphorContextNode):\n            return True\n\n        return any(self._has_context_node(cast(MetaphorASTNode, child)) for child in node.children)\n\n    def _has_action_node(self, node: MetaphorASTNode) -> bool:\n        \"\"\"\n        Check if the node tree contains any Action nodes.\n\n        Args:\n            node: The node to check\n\n        Returns:\n            True if the node or any of its descendants is an Action node\n        \"\"\"\n        if isinstance(node, MetaphorActionNode):\n            return True\n\n        return any(self._has_action_node(cast(MetaphorASTNode, child)) for child in node.children)\n\n    def build_ast(\n        self,\n        parent_node: MetaphorASTNode,\n        input_text: str,\n        filename: str,\n        search_paths: List[str],\n        embed_path: str = \"\",\n        arguments: List[str] | None = None\n    ) -> None:\n        \"\"\"\n        Parse an input string and add the resulting nodes to the provided parent node.\n\n        Args:\n            parent_node (MetaphorASTNode): The node to which parsed content will be added.\n            input_text (str): The text to be parsed.\n            filename (str): The name of the file being parsed.\n            search_paths (List[str]): List of paths to search for included files.\n            embed_path: Path used to search for embedded files (uses CWD if None).\n            arguments (List[str] | None): List of command line arguments.\n\n        Raises:\n            MetaphorASTBuilderError: If there are syntax errors during parsing.\n        \"\"\"\n        self._search_paths = search_paths\n        self._embed_path = embed_path if embed_path else os.getcwd()\n        self._arguments = arguments if arguments else []\n\n        try:\n            self._lexers.append(MetaphorLexer(input_text, filename))\n\n            seen_action_tree: bool = self._has_action_node(parent_node)\n            seen_context_tree: bool = self._has_context_node(parent_node)\n            seen_role_tree: bool = self._has_role_node(parent_node)\n\n            while True:\n                token = self.get_next_non_blank_token()\n                if token.type == MetaphorTokenType.ACTION:\n                    if seen_action_tree and not isinstance(parent_node, MetaphorActionNode):\n                        self._record_syntax_error(token, \"'Action' already defined\")\n\n                    parent_node.add_child(self._parse_action(token))\n                    seen_action_tree = True\n                    continue\n\n                if token.type == MetaphorTokenType.CONTEXT:\n                    if seen_context_tree and not isinstance(parent_node, MetaphorContextNode):\n                        self._record_syntax_error(token, \"'Context' already defined\")\n\n                    parent_node.add_child(self._parse_context(token))\n                    seen_context_tree = True\n                    continue\n\n                if token.type == MetaphorTokenType.ROLE:\n                    if seen_role_tree and not isinstance(parent_node, MetaphorRoleNode):\n                        self._record_syntax_error(token, \"'Role' already defined\")\n\n                    parent_node.add_child(self._parse_role(token))\n                    seen_role_tree = True\n                    continue\n\n                if token.type == MetaphorTokenType.END_OF_FILE:\n                    if self._parse_errors:\n                        raise MetaphorASTBuilderError(\"parser error\", self._parse_errors)\n\n                    return  # No return value needed\n\n                if token.type in (MetaphorTokenType.TEXT, MetaphorTokenType.CODE):\n                    if parent_node.children:\n                        # If our parent is processing text or code then we can add more text or code\n                        if isinstance(parent_node.children[-1], MetaphorTextNode | MetaphorCodeNode):\n                            parent_node.add_child(self._parse_text(token))\n                            continue\n\n                        self._record_syntax_error(token, \"Text or code must come first in parent's block\")\n                        continue\n\n                    # If our parent is an action, context or role node and has no children\n                    # then we can add text or code to it.\n                    if isinstance(parent_node, MetaphorActionNode | MetaphorContextNode | MetaphorRoleNode):\n                        parent_node.add_child(self._parse_text(token))\n                        continue\n\n                self._record_syntax_error(token, f\"Unexpected token: {token.value} at top level\")\n\n        except FileNotFoundError as e:\n            err_token = cast(MetaphorToken, self._current_token)\n            self._parse_errors.append(MetaphorASTBuilderSyntaxError(\n                f\"{e}\", err_token.filename, err_token.line, err_token.column, err_token.input\n            ))\n            raise(MetaphorASTBuilderError(\"parser error\", self._parse_errors)) from e\n\n        except MetaphorASTBuilderFileAlreadyUsedError as e:\n            self._parse_errors.append(MetaphorASTBuilderSyntaxError(\n                f\"The file '{e.filename}' has already been used\",\n                e.token.filename,\n                e.token.line,\n                e.token.column,\n                e.token.input\n            ))\n            raise(MetaphorASTBuilderError(\"parser error\", self._parse_errors)) from e\n\n    def build_ast_from_file(\n        self,\n        parent_node: MetaphorASTNode,\n        filename: str,\n        search_paths: List[str],\n        embed_path: str = \"\",\n        arguments: List[str] | None = None\n    ) -> None:\n        \"\"\"\n        Parse a file and add the resulting nodes to the provided parent node.\n\n        Args:\n            parent_node (MetaphorASTNode): The node to which parsed content will be added.\n            filename (str): The path to the file to be parsed.\n            search_paths (List[str]): List of paths to search for included files.\n            embed_path: Path used to search for embedded files (uses CWD if None).\n            arguments (List[str] | None): List of command line arguments.\n\n        Raises:\n            MetaphorASTBuilderError: If there are syntax errors during parsing.\n        \"\"\"\n        try:\n            self._check_file_not_loaded(filename)\n            input_text = self._read_file(filename)\n            self.build_ast(parent_node, input_text, filename, search_paths, embed_path, arguments)\n\n        except FileNotFoundError as e:\n            self._parse_errors.append(MetaphorASTBuilderSyntaxError(\n                f\"{e}\", \"\", 0, 0, \"\"\n            ))\n            raise(MetaphorASTBuilderError(\"parser error\", self._parse_errors)) from e\n\n        except MetaphorASTBuilderError as e:\n            raise(MetaphorASTBuilderError(\"parser error\", self._parse_errors)) from e\n\n    def get_next_token(self) -> MetaphorToken:\n        \"\"\"Get the next token from the active lexer.\"\"\"\n        while self._lexers:\n            lexer = self._lexers[-1]\n            token = lexer.get_next_token()\n            self._current_token = token\n\n            if token.type == MetaphorTokenType.INCLUDE:\n                self._parse_include(token)\n\n            elif token.type == MetaphorTokenType.EMBED:\n                self._parse_embed(token)\n\n            elif token.type == MetaphorTokenType.END_OF_FILE:\n                self._lexers.pop()\n\n            else:\n                return token\n\n        return MetaphorToken(MetaphorTokenType.END_OF_FILE, \"\", \"\", \"\", 0, 0)\n\n    def get_next_non_blank_token(self) -> MetaphorToken:\n        \"\"\"Get the next token that is not a blank line.\"\"\"\n        token = None\n\n        while True:\n            token = self.get_next_token()\n            if not token or token.type != MetaphorTokenType.TEXT or token.value != \"\":\n                return token\n\n    def _record_syntax_error(self, token: MetaphorToken, message: str) -> None:\n        \"\"\"Raise a syntax error and add it to the error list.\"\"\"\n        error = MetaphorASTBuilderSyntaxError(\n            message, token.filename, token.line, token.column, token.input\n        )\n        self._parse_errors.append(error)\n\n    def _find_file_path(self, filename: str) -> str:\n        \"\"\"Try to find a valid path for a file, given all the search path options\"\"\"\n        if os.path.isabs(filename):\n            if Path(filename).exists():\n                return filename\n\n            raise FileNotFoundError(f\"File not found: {filename}\")\n\n        # If we don't have an absolute path then we can try search paths.\n        for path in self._search_paths:\n            try_name = os.path.join(path, filename)\n            if Path(try_name).exists():\n                return try_name\n\n        raise FileNotFoundError(f\"File not found: {filename}\")\n\n    def _read_file(self, filename: str) -> str:\n        \"\"\"Read file content into memory.\"\"\"\n        try:\n            with open(filename, 'r', encoding='utf-8') as file:\n                return file.read()\n\n        except FileNotFoundError as e:\n            raise FileNotFoundError(f\"File not found: {filename}\") from e\n\n        except PermissionError as e:\n            raise FileNotFoundError(f\"You do not have permission to access: {filename}\") from e\n\n        except IsADirectoryError as e:\n            raise FileNotFoundError(f\"Is a directory: {filename}\") from e\n\n        except OSError as e:\n            raise FileNotFoundError(f\"OS error: {e}\") from e\n\n    def _check_file_not_loaded(self, filename: str) -> None:\n        \"\"\"Check we have not already loaded a file.\"\"\"\n        canonical_filename = os.path.realpath(filename)\n        if canonical_filename in self._previously_seen_files:\n            raise MetaphorASTBuilderFileAlreadyUsedError(filename, cast(MetaphorToken, self._current_token))\n\n        self._previously_seen_files.add(canonical_filename)\n\n    def _parse_text(self, token: MetaphorToken) -> MetaphorTextNode:\n        \"\"\"Parse a text block.\"\"\"\n        return MetaphorTextNode(token.value)\n\n    def _parse_code(self, token: MetaphorToken) -> MetaphorCodeNode:\n        \"\"\"Parse a code block.\"\"\"\n        return MetaphorCodeNode(token.value)\n\n    def _parse_action(self, token: MetaphorToken) -> MetaphorActionNode:\n        \"\"\"Parse an action block and construct its AST node.\"\"\"\n        label_name = \"\"\n\n        seen_token_type = MetaphorTokenType.NONE\n\n        init_token = self.get_next_token()\n        if init_token.type == MetaphorTokenType.KEYWORD_TEXT:\n            label_name = init_token.value\n            indent_token = self.get_next_non_blank_token()\n            if indent_token.type != MetaphorTokenType.INDENT:\n                self._record_syntax_error(\n                    token,\n                    \"Expected indent after keyword description for 'Action' block\"\n                )\n\n        elif init_token.type != MetaphorTokenType.INDENT:\n            self._record_syntax_error(token, \"Expected description or indent after 'Action' keyword\")\n\n        action_node = MetaphorActionNode(label_name)\n\n        while True:\n            token = self.get_next_token()\n            if token.type == MetaphorTokenType.TEXT:\n                if token.value != \"\" and seen_token_type != MetaphorTokenType.NONE:\n                    self._record_syntax_error(token, \"Text must come first in an 'Action' block\")\n\n                action_node.add_child(self._parse_text(token))\n                continue\n\n            if token.type == MetaphorTokenType.CODE:\n                if seen_token_type != MetaphorTokenType.NONE:\n                    self._record_syntax_error(token, \"Code must come first in an 'Action' block\")\n\n                action_node.add_child(self._parse_code(token))\n                continue\n\n            if token.type == MetaphorTokenType.ACTION:\n                action_node.add_child(self._parse_action(token))\n                seen_token_type = MetaphorTokenType.ACTION\n                continue\n\n            if token.type in (MetaphorTokenType.OUTDENT, MetaphorTokenType.END_OF_FILE):\n                return action_node\n\n            self._record_syntax_error(token, f\"Unexpected token: {token.value} in 'Action' block\")\n\n    def _parse_context(self, token: MetaphorToken) -> MetaphorContextNode:\n        \"\"\"Parse a Context block.\"\"\"\n        label_name = \"\"\n\n        seen_token_type = MetaphorTokenType.NONE\n\n        init_token = self.get_next_token()\n        if init_token.type == MetaphorTokenType.KEYWORD_TEXT:\n            label_name = init_token.value\n            indent_token = self.get_next_non_blank_token()\n            if indent_token.type != MetaphorTokenType.INDENT:\n                self._record_syntax_error(\n                    token,\n                    \"Expected indent after keyword description for 'Context' block\"\n                )\n\n        elif init_token.type != MetaphorTokenType.INDENT:\n            self._record_syntax_error(token, \"Expected description or indent after 'Context' keyword\")\n\n        context_node = MetaphorContextNode(label_name)\n\n        while True:\n            token = self.get_next_token()\n            if token.type == MetaphorTokenType.TEXT:\n                if token.value != \"\" and seen_token_type != MetaphorTokenType.NONE:\n                    self._record_syntax_error(token, \"Text must come first in a 'Context' block\")\n\n                context_node.add_child(self._parse_text(token))\n                continue\n\n            if token.type == MetaphorTokenType.CODE:\n                if seen_token_type != MetaphorTokenType.NONE:\n                    self._record_syntax_error(token, \"Code must come first in a 'Context' block\")\n\n                context_node.add_child(self._parse_code(token))\n                continue\n\n            if token.type == MetaphorTokenType.CONTEXT:\n                context_node.add_child(self._parse_context(token))\n                seen_token_type = MetaphorTokenType.CONTEXT\n                continue\n\n            if token.type in (MetaphorTokenType.OUTDENT, MetaphorTokenType.END_OF_FILE):\n                return context_node\n\n            self._record_syntax_error(token, f\"Unexpected token: {token.value} in 'Context' block\")\n\n    def _parse_role(self, token: MetaphorToken) -> MetaphorRoleNode:\n        \"\"\"Parse a Role block.\"\"\"\n        label_name = \"\"\n\n        seen_token_type = MetaphorTokenType.NONE\n\n        init_token = self.get_next_token()\n        if init_token.type == MetaphorTokenType.KEYWORD_TEXT:\n            label_name = init_token.value\n            indent_token = self.get_next_non_blank_token()\n            if indent_token.type != MetaphorTokenType.INDENT:\n                self._record_syntax_error(\n                    token,\n                    \"Expected indent after keyword description for 'Role' block\"\n                )\n\n        elif init_token.type != MetaphorTokenType.INDENT:\n            self._record_syntax_error(token, \"Expected description or indent after 'Role' keyword\")\n\n        role_node = MetaphorRoleNode(label_name)\n\n        while True:\n            token = self.get_next_token()\n            if token.type == MetaphorTokenType.TEXT:\n                if token.value != \"\" and seen_token_type != MetaphorTokenType.NONE:\n                    self._record_syntax_error(token, \"Text must come first in a 'Role' block\")\n\n                role_node.add_child(self._parse_text(token))\n                continue\n\n            if token.type == MetaphorTokenType.CODE:\n                if seen_token_type != MetaphorTokenType.NONE:\n                    self._record_syntax_error(token, \"Code must come first in a 'Role' block\")\n\n                role_node.add_child(self._parse_code(token))\n                continue\n\n            if token.type == MetaphorTokenType.ROLE:\n                role_node.add_child(self._parse_role(token))\n                seen_token_type = MetaphorTokenType.ROLE\n                continue\n\n            if token.type in (MetaphorTokenType.OUTDENT, MetaphorTokenType.END_OF_FILE):\n                return role_node\n\n            self._record_syntax_error(token, f\"Unexpected token: {token.value} in 'Role' block\")\n\n    def _parse_argument(self, token: MetaphorToken) -> str | None:\n        \"\"\"\n        Parse a $ argument token.\n\n        Args:\n            token: The token to parse.\n\n        Returns:\n            The parsed argument as a string or None if we could not determine the string.\n        \"\"\"\n        numeric_part = token.value[1:]\n        if not numeric_part.isdigit():\n            self._record_syntax_error(token, \"After '$', the string must contain only digits\")\n\n        arg_index = int(numeric_part)\n        if arg_index < 0 or arg_index >= len(self._arguments):\n            self._record_syntax_error(token, f\"Argument index {arg_index} is out of range\")\n            return None\n\n        return self._arguments[arg_index]\n\n    def _parse_include(self, token: MetaphorToken) -> None:\n        \"\"\"Parse an Include block and load the included file.\"\"\"\n        token_next = self.get_next_token()\n        if token_next.type != MetaphorTokenType.KEYWORD_TEXT:\n            self._record_syntax_error(token, \"Expected file name after 'Include' keyword\")\n            return\n\n        if token_next.value[0] == \"$\":\n            filename = self._parse_argument(token_next)\n            if filename is None:\n                return\n\n        else:\n            filename = token_next.value\n\n        self._check_file_not_loaded(filename)\n        try_file = self._find_file_path(filename)\n        input_text = self._read_file(try_file)\n        self._lexers.append(MetaphorLexer(input_text, try_file))\n\n    def _parse_embed(self, token: MetaphorToken) -> None:\n        \"\"\"Parse an Embed block and load the embedded file.\"\"\"\n        token_next = self.get_next_token()\n        if token_next.type != MetaphorTokenType.KEYWORD_TEXT:\n            self._record_syntax_error(token, \"Expected file name or wildcard match after 'Embed' keyword\")\n            return\n\n        if token_next.value[0] == \"$\":\n            match = self._parse_argument(token_next)\n            if match is None:\n                return\n\n        else:\n            match = token_next.value\n\n        path = os.path.join(self._embed_path, match)\n        recurse = \"**/\" in match\n        files = glob.glob(path, recursive=recurse)\n        if not files:\n            self._record_syntax_error(token_next, f\"{match} does not match any files for 'Embed' in {self._embed_path}\")\n            return\n\n        for file in files:\n            input_text = self._read_file(file)\n            self._lexers.append(MetaphorEmbedLexer(input_text, file))\n```\n\n# Action:\n\nWhat do we need to consider to make the complexity analysis more robust?",
      "completed": true,
      "usage": null,
      "error": null,
      "model": null,
      "temperature": null
    },
    {
      "id": "2a2e49f6-25c6-488d-8eb8-bb2c7ee9493a",
      "timestamp": "2025-06-10T12:12:09.709708",
      "type": "ai_response",
      "content": "Looking at this code as a software architect, I'll provide a complexity analysis for each class and method, then discuss how to make the analysis more robust.\n\n## Complexity Analysis\n\n### # Role: > # Context: > MetaphorASTBuilderFileAlreadyUsedError\n**Complexity Score: 15/100**\n- **Structural complexity**: Very low - simple exception class with basic constructor\n- **Data flow complexity**: Minimal - just stores filename and token references\n- **Cognitive complexity**: Low - straightforward error handling pattern\n\n### # Role: > # Context: > MetaphorASTBuilderSyntaxError  \n**Complexity Score: 20/100**\n- **Structural complexity**: Low - exception class with multiple parameters but simple logic\n- **Data flow complexity**: Low - stores multiple error context fields\n- **Cognitive complexity**: Low - clear error reporting structure\n\n### # Role: > # Context: > MetaphorASTBuilderError\n**Complexity Score: 18/100**\n- **Structural complexity**: Very low - wrapper exception with error list\n- **Data flow complexity**: Minimal - aggregates syntax errors\n- **Cognitive complexity**: Low - simple error collection pattern\n\n### # Role: > # Context: > MetaphorASTBuilder.__init__\n**Complexity Score: 25/100**\n- **State management complexity**: Moderate - initializes 7 different instance variables\n- **Data structure complexity**: Moderate - manages lists, sets, and various state tracking\n- **Cognitive complexity**: Low - straightforward initialization pattern\n\n### # Role: > # Context: > MetaphorASTBuilder._has_role_node\n**Complexity Score: 35/100**\n- **Algorithmic complexity**: Moderate - recursive tree traversal with potential for deep nesting\n- **Control flow complexity**: Moderate - recursive calls with early termination\n- **Cognitive complexity**: Moderate - requires understanding of tree traversal and type checking\n\n### # Role: > # Context: > MetaphorASTBuilder._has_context_node\n**Complexity Score: 35/100**\n- **Algorithmic complexity**: Moderate - identical recursive pattern to _has_role_node\n- **Control flow complexity**: Moderate - same recursive structure\n- **Cognitive complexity**: Moderate - duplicate logic increases maintenance burden\n\n### # Role: > # Context: > MetaphorASTBuilder._has_action_node\n**Complexity Score: 35/100**\n- **Algorithmic complexity**: Moderate - same recursive traversal pattern\n- **Control flow complexity**: Moderate - identical to sibling methods\n- **Cognitive complexity**: Moderate - code duplication across three similar methods\n\n### # Role: > # Context: > MetaphorASTBuilder.build_ast\n**Complexity Score: 85/100**\n- **Cyclomatic complexity**: Very high - multiple nested conditionals and branching paths\n- **State management complexity**: High - manages lexer stack, error tracking, and multiple boolean flags\n- **Cognitive complexity**: Very high - complex parsing logic with intricate token type handling and error management\n\n### # Role: > # Context: > MetaphorASTBuilder.build_ast_from_file\n**Complexity Score: 45/100**\n- **Error handling complexity**: Moderate - multiple exception types with re-raising logic\n- **Control flow complexity**: Moderate - delegation pattern with exception transformation\n- **Cognitive complexity**: Moderate - file I/O coordination with error propagation\n\n### # Role: > # Context: > MetaphorASTBuilder.get_next_token\n**Complexity Score: 55/100**\n- **Control flow complexity**: High - nested loops with multiple exit conditions\n- **State management complexity**: Moderate - manages lexer stack and current token state\n- **Cognitive complexity**: High - complex token processing with side effects (include/embed handling)\n\n### # Role: > # Context: > MetaphorASTBuilder.get_next_non_blank_token\n**Complexity Score: 30/100**\n- **Control flow complexity**: Moderate - infinite loop with conditional breaks\n- **Logic complexity**: Moderate - token filtering logic\n- **Cognitive complexity**: Low - clear filtering purpose despite loop structure\n\n### # Role: > # Context: > MetaphorASTBuilder._record_syntax_error\n**Complexity Score: 20/100**\n- **Structural complexity**: Low - simple error creation and storage\n- **Data flow complexity**: Low - straightforward parameter passing\n- **Cognitive complexity**: Low - clear error recording pattern\n\n### # Role: > # Context: > MetaphorASTBuilder._find_file_path\n**Complexity Score: 40/100**\n- **Control flow complexity**: Moderate - multiple conditional paths and loop\n- **Error handling complexity**: Moderate - path resolution with fallback logic\n- **Cognitive complexity**: Moderate - file system interaction with search path logic\n\n### # Role: > # Context: > MetaphorASTBuilder._read_file\n**Complexity Score: 35/100**\n- **Error handling complexity**: Moderate - multiple exception types with transformation\n- **I/O complexity**: Moderate - file operations with encoding handling\n- **Cognitive complexity**: Moderate - comprehensive error handling for file operations\n\n### # Role: > # Context: > MetaphorASTBuilder._check_file_not_loaded\n**Complexity Score: 30/100**\n- **State management complexity**: Moderate - canonical path tracking and duplicate detection\n- **Logic complexity**: Low - straightforward set-based duplicate checking\n- **Cognitive complexity**: Low - clear duplicate prevention logic\n\n### # Role: > # Context: > MetaphorASTBuilder._parse_text\n**Complexity Score: 10/100**\n- **Structural complexity**: Minimal - single line factory method\n- **Cognitive complexity**: Minimal - trivial wrapper function\n- **Data flow complexity**: Minimal - direct value passing\n\n### # Role: > # Context: > MetaphorASTBuilder._parse_code\n**Complexity Score: 10/100**\n- **Structural complexity**: Minimal - identical to _parse_text\n- **Cognitive complexity**: Minimal - simple factory method\n- **Data flow complexity**: Minimal - straightforward value passing\n\n### # Role: > # Context: > MetaphorASTBuilder._parse_action\n**Complexity Score: 75/100**\n- **Cyclomatic complexity**: High - multiple nested conditionals and token type checking\n- **Control flow complexity**: High - complex parsing state machine with error handling\n- **Cognitive complexity**: High - intricate grammar parsing logic with validation rules\n\n### # Role: > # Context: > MetaphorASTBuilder._parse_context\n**Complexity Score: 75/100**\n- **Cyclomatic complexity**: High - nearly identical structure to _parse_action\n- **Control flow complexity**: High - same complex parsing pattern\n- **Cognitive complexity**: High - duplicate parsing logic increases maintenance complexity\n\n### # Role: > # Context: > MetaphorASTBuilder._parse_role\n**Complexity Score: 75/100**\n- **Cyclomatic complexity**: High - third instance of nearly identical parsing logic\n- **Control flow complexity**: High - same parsing state machine pattern\n- **Cognitive complexity**: High - significant code duplication across three parsing methods\n\n### # Role: > # Context: > MetaphorASTBuilder._parse_argument\n**Complexity Score: 40/100**\n- **Validation complexity**: Moderate - input validation with bounds checking\n- **Error handling complexity**: Moderate - multiple error conditions\n- **Cognitive complexity**: Moderate - argument parsing with validation logic\n\n### # Role: > # Context: > MetaphorASTBuilder._parse_include\n**Complexity Score: 50/100**\n- **Control flow complexity**: Moderate - conditional argument parsing with file operations\n- **Error handling complexity**: Moderate - validation and file system interaction\n- **Cognitive complexity**: Moderate - include directive processing with argument substitution\n\n### # Role: > # Context: > MetaphorASTBuilder._parse_embed\n**Complexity Score: 55/100**\n- **File system complexity**: High - glob pattern matching with recursive directory traversal\n- **Control flow complexity**: Moderate - pattern matching with multiple file processing\n- **Cognitive complexity**: Moderate - embed directive with wildcard support and multiple file handling\n\n## Making Complexity Analysis More Robust\n\nTo enhance the robustness of complexity analysis, we should consider:\n\n**1. Quantitative Metrics Integration**\n- Implement automated cyclomatic complexity calculation using tools like `radon` or `mccabe`\n- Add Halstead complexity metrics for computational complexity assessment\n- Include lines of code (LOC) and maintainability index calculations\n\n**2. Dynamic Analysis Considerations**\n- Runtime complexity analysis through profiling actual execution paths\n- Memory usage patterns and object lifecycle complexity\n- Performance bottleneck identification under various input conditions\n\n**3. Dependency and Coupling Analysis**\n- Afferent/efferent coupling measurements between classes and modules\n- Dependency injection complexity and circular dependency detection\n- Interface segregation and dependency inversion principle adherence\n\n**4. Domain-Specific Complexity Factors**\n- Parser-specific complexity like grammar ambiguity and lookahead requirements\n- AST construction complexity including node relationship management\n- Error recovery and reporting sophistication\n\n**5. Maintainability and Evolution Complexity**\n- Code duplication analysis (evident in the three similar parsing methods)\n- Technical debt assessment through code smell detection\n- Refactoring complexity estimation for improvement opportunities\n\n**6. Testing and Verification Complexity**\n- Test case coverage requirements based on branching complexity\n- Mock and stub complexity for unit testing isolated components\n- Integration testing complexity due to file system and lexer dependencies\n\nThe current code shows significant opportunities for complexity reduction, particularly through extracting common parsing logic and implementing a more generic parsing framework to eliminate the duplication in `_parse_action`, `_parse_context`, and `_parse_role` methods.",
      "completed": true,
      "usage": {
        "prompt_tokens": 6642,
        "completion_tokens": 2250,
        "total_tokens": 8892
      },
      "error": null,
      "model": "claude-4-sonnet-20250514",
      "temperature": 0.7
    }
  ]
}