{
  "metadata": {
    "version": "0.1",
    "parent": null
  },
  "conversation": [
    {
      "id": "ce7dc7e1-3f7f-49b8-a88e-c5e6e485144b",
      "timestamp": "2026-01-11T15:17:17.928306+00:00",
      "type": "user_message",
      "content": "in the src/aifpl directory is a readme file. Since that was written we've added a few things to AIFPL and we need to update it. Can you read that file and compare it with your tool description and suggest changes",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "cb09905e-2b59-48e3-ad0f-5a8257deefc1",
      "timestamp": "2026-01-11T15:17:19.930107+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "3d716acd-3c30-41bc-ba06-0f498c80ad42",
      "timestamp": "2026-01-11T15:17:19.938571+00:00",
      "type": "ai_response",
      "content": "I'll read the README file from the src/aifpl directory and compare it with my tool description to suggest updates.",
      "completed": true,
      "usage": {
        "prompt_tokens": 9392,
        "completion_tokens": 104,
        "total_tokens": 9496
      },
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_016fp7EzhB5aM1ktuReVriDZ",
          "name": "filesystem",
          "arguments": {
            "operation": "read_file",
            "path": "src/aifpl/README.md"
          }
        }
      ]
    },
    {
      "id": "5372f1cb-33fc-45fe-94f5-ec885011a0d3",
      "timestamp": "2026-01-11T15:17:20.934546+00:00",
      "type": "tool_call",
      "content": "```json\n{\n  \"id\": \"toolu_016fp7EzhB5aM1ktuReVriDZ\",\n  \"name\": \"filesystem\",\n  \"arguments\": {\n    \"operation\": \"read_file\",\n    \"path\": \"src/aifpl/README.md\"\n  }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_016fp7EzhB5aM1ktuReVriDZ",
          "name": "filesystem",
          "arguments": {
            "operation": "read_file",
            "path": "src/aifpl/README.md"
          }
        }
      ]
    },
    {
      "id": "2e7c1a7b-85f9-45d1-aa74-50317750ac1f",
      "timestamp": "2026-01-11T15:17:20.938931+00:00",
      "type": "tool_result",
      "content": "```json\n{\n  \"id\": \"toolu_016fp7EzhB5aM1ktuReVriDZ\",\n  \"name\": \"filesystem\",\n  \"content\": \"# AIFPL (AI Functional Programming Language)\\n\\nAIFPL is a mathematical expression language with LISP-like S-expression syntax designed for AI tool integration. It supports mathematical calculations, string manipulation, boolean operations, list processing, conditional evaluation, and functional programming with lambda expressions and higher-order functions.\\n\\n## Features\\n\\n- **Pure list representation**: Everything is data - true homoiconicity like traditional Lisp\\n- **S-expression syntax**: `(function-or-operator arg1 arg2 ...)`\\n- **Quote special form**: `(quote expr)` and shortcut `'expr` for preventing evaluation and creating data literals\\n- **Pattern matching**: Comprehensive pattern matching with structural and type-based patterns\\n- **Mathematical operations**: Arithmetic, trigonometry, logarithms, bitwise operations\\n- **String operations**: Manipulation, searching, conversion with full UTF-8 support\\n- **Boolean operations**: Logic operations with strict type checking\\n- **List operations**: Construction, manipulation, and conversion with heterogeneous support\\n- **Association lists (alists)**: Immutable key-value mappings with O(1) lookup performance\\n- **Conditional evaluation**: `if` expressions with lazy evaluation of branches\\n- **Lazy evaluation**: `and` and `or` perform lazy evaluation of operands\\n- **Lambda expressions**: Anonymous functions with lexical scoping and closures\\n- **Local bindings**: `let` expressions for sequential variable binding\\n- **Higher-order functions**: `map`, `filter`, `fold`, `range`, and more for functional programming\\n- **Tail call optimization**: Automatic optimization for recursive and mutually recursive functions\\n- **Type predicates**: Built-in functions to check value types\\n- **Number formats**: Integers, floats, complex numbers, hex (0xFF), binary (0b1010), octal (0o755)\\n- **String literals**: `\\\"hello world\\\"` with escape sequences\\n- **Boolean literals**: `#t` (true) and `#f` (false)\\n- **Constants**: `pi`, `e`, `j` (imaginary unit), `true`, `false`\\n- **Type promotion**: Automatic promotion from int \\u2192 float \\u2192 complex\\n- **Result simplification**: Complex numbers with negligible imaginary parts become real\\n- **Comments**: `;` introduces comments\\n\\n## Usage\\n\\n### Basic Usage\\n\\n```python\\nfrom aifpl import AIFPL\\n\\ntool = AIFPL()\\nresult = tool.evaluate(\\\"(+ 1 2 3)\\\")  # Returns: 6\\n```\\n\\n### With Configuration\\n\\n```python\\ntool = AIFPL(max_depth=200, floating_point_tolerance=1e-12)\\nresult = tool.evaluate(\\\"(sin (* pi 0.5))\\\")  # Returns: 1\\n```\\n\\n### Formatted Output\\n\\n```python\\n# Get results with LISP-style formatting\\nresult_str = tool.evaluate_and_format(\\\"(list 1 2 3)\\\")  # Returns: \\\"(1 2 3)\\\"\\n```\\n\\n### Error Handling\\n\\n```python\\nfrom aifpl import AIFPL, AIFPLError\\n\\ntool = AIFPL()\\ntry:\\n    result = tool.evaluate(\\\"(+ 1 2\\\")  # Missing closing paren\\nexcept AIFPLError as e:\\n    print(f\\\"AIFPL error: {e}\\\")\\n```\\n\\n## Supported Operations\\n\\n### Quote - Data Literals and Code as Data\\n\\nThe `quote` special form prevents evaluation of expressions, enabling true code-as-data manipulation:\\n\\n#### Basic Quote Syntax\\n```aifpl\\n(quote expr)\\n'expr          ; Shortcut form (equivalent to (quote expr))\\n```\\n\\n#### Quote Examples - Preventing Evaluation\\n```aifpl\\n; Without quote - expression gets evaluated\\n(+ 1 2 3)                             ; \\u2192 6\\n\\n; With quote - expression returned as data\\n(quote (+ 1 2 3))                     ; \\u2192 (+ 1 2 3)\\n'(+ 1 2 3)                            ; \\u2192 (+ 1 2 3) (shortcut form)\\n\\n; Quote symbols to prevent variable lookup\\n(quote x)                             ; \\u2192 x (the symbol itself)\\n'x                                    ; \\u2192 x (shortcut form)\\n(quote hello)                         ; \\u2192 hello (symbol, not variable lookup)\\n'hello                                ; \\u2192 hello (shortcut form)\\n```\\n\\n#### Single Quote Shortcut Examples\\n```aifpl\\n; Basic shortcut usage\\n'x                                    ; \\u2192 x (same as (quote x))\\n'42                                   ; \\u2192 42 (same as (quote 42))\\n'\\\"hello\\\"                              ; \\u2192 \\\"hello\\\" (same as (quote \\\"hello\\\"))\\n'#t                                   ; \\u2192 #t (same as (quote #t))\\n\\n; Shortcut with lists\\n'(1 2 3)                              ; \\u2192 (1 2 3) (same as (quote (1 2 3)))\\n'()                                   ; \\u2192 () (same as (quote ()))\\n\\n; Nested shortcut quotes\\n''x                                   ; \\u2192 (quote x) (same as (quote (quote x)))\\n'''x                                  ; \\u2192 (quote (quote x)) (triple nested)\\n\\n; Mixed usage in expressions\\n(list 'hello (+ 1 2) 'world)         ; \\u2192 (hello 3 world)\\n(cons '+ '(1 2 3))                    ; \\u2192 (+ 1 2 3)\\n```\\n\\n#### Quote with Lists - Creating Data Structures\\n```aifpl\\n; Create lists as pure data\\n(quote (1 2 3))                       ; \\u2192 (1 2 3) (list as data)\\n'(1 2 3)                              ; \\u2192 (1 2 3) (shortcut form)\\n(quote ())                            ; \\u2192 () (empty list as data)\\n'()                                   ; \\u2192 () (shortcut form)\\n\\n; Create nested data structures\\n(quote ((a 1) (b 2) (c 3)))           ; \\u2192 ((a 1) (b 2) (c 3))\\n'((a 1) (b 2) (c 3))                  ; \\u2192 ((a 1) (b 2) (c 3)) (shortcut)\\n\\n; Mix quoted and unquoted in larger expressions\\n(list (quote hello) (+ 1 2) (quote world))  ; \\u2192 (hello 3 world)\\n(list 'hello (+ 1 2) 'world)         ; \\u2192 (hello 3 world) (with shortcuts)\\n```\\n\\n#### Quote with Code Templates\\n```aifpl\\n; Store code as data for later use\\n(let ((template (quote (if CONDITION THEN ELSE))))\\n  template)                           ; \\u2192 (if CONDITION THEN ELSE)\\n(let ((template '(if CONDITION THEN ELSE)))\\n  template)                           ; \\u2192 (if CONDITION THEN ELSE) (shortcut)\\n\\n; Create function templates\\n(let ((lambda-template (quote (lambda (x) (* x x)))))\\n  lambda-template)                    ; \\u2192 (lambda (x) (* x x))\\n(let ((lambda-template '(lambda (x) (* x x))))\\n  lambda-template)                    ; \\u2192 (lambda (x) (* x x)) (shortcut)\\n\\n; Store expressions in lists\\n(let ((expressions (list (quote (+ 1 2)) \\n                        (quote (* 3 4))\\n                        (quote (- 10 5)))))\\n  expressions)                        ; \\u2192 ((+ 1 2) (* 3 4) (- 10 5))\\n(let ((expressions (list '(+ 1 2) \\n                        '(* 3 4)\\n                        '(- 10 5))))\\n  expressions)                        ; \\u2192 ((+ 1 2) (* 3 4) (- 10 5)) (shortcuts)\\n```\\n\\n#### Symbolic Programming with Quote\\n```aifpl\\n; Manipulate code structure\\n(let ((expr (quote (+ a b c))))\\n  (first expr))                       ; \\u2192 + (the operator symbol)\\n(let ((expr '(+ a b c)))\\n  (first expr))                       ; \\u2192 + (shortcut form)\\n\\n(let ((expr (quote (lambda (x y) (+ x y)))))\\n  (let ((params (first (rest expr)))\\n        (body (first (rest (rest expr)))))\\n    (list \\\"params\\\" params \\\"body\\\" body)))  ; \\u2192 (\\\"params\\\" (x y) \\\"body\\\" (+ x y))\\n(let ((expr '(lambda (x y) (+ x y))))\\n  (let ((params (first (rest expr)))\\n        (body (first (rest (rest expr)))))\\n    (list \\\"params\\\" params \\\"body\\\" body)))  ; \\u2192 (\\\"params\\\" (x y) \\\"body\\\" (+ x y)) (shortcut)\\n\\n; Build expressions programmatically\\n(let ((op (quote +))\\n      (args (quote (1 2 3))))\\n  (cons op args))                     ; \\u2192 (+ 1 2 3)\\n(let ((op '+)\\n      (args '(1 2 3)))\\n  (cons op args))                     ; \\u2192 (+ 1 2 3) (shortcuts)\\n```\\n\\n#### Quote vs. List Constructor\\n```aifpl\\n; Using list constructor - evaluates arguments\\n(list + 1 2 3)                       ; \\u2192 (<builtin +> 1 2 3)\\n\\n; Using quote - no evaluation\\n(quote (+ 1 2 3))                     ; \\u2192 (+ 1 2 3)\\n'(+ 1 2 3)                            ; \\u2192 (+ 1 2 3) (shortcut)\\n\\n; Mixed approach\\n(list (quote +) 1 2 3)                ; \\u2192 (+ 1 2 3)\\n(list '+ 1 2 3)                       ; \\u2192 (+ 1 2 3) (shortcut)\\n```\\n\\n#### Data Processing with Quoted Expressions\\n```aifpl\\n; Process a list of expressions\\n(let ((exprs (list (quote (+ 1 2))\\n                  (quote (* 3 4))\\n                  (quote (/ 8 2)))))\\n  (map (lambda (expr) (first expr)) exprs))  ; \\u2192 (+ * /)\\n(let ((exprs (list '(+ 1 2)\\n                  '(* 3 4)\\n                  '(/ 8 2))))\\n  (map (lambda (expr) (first expr)) exprs))  ; \\u2192 (+ * /) (shortcuts)\\n\\n; Extract operators and operands\\n(let ((analyze-expr (lambda (expr)\\n                      (if (and (list? expr) (not (null? expr)))\\n                          (list \\\"op\\\" (first expr) \\\"args\\\" (rest expr))\\n                          \\\"not-a-compound-expr\\\"))))\\n  (map analyze-expr (list (quote (+ 1 2))\\n                         (quote x)\\n                         (quote (* a b c)))))\\n; \\u2192 ((\\\"op\\\" + \\\"args\\\" (1 2)) \\\"not-a-compound-expr\\\" (\\\"op\\\" * \\\"args\\\" (a b c)))\\n(let ((analyze-expr (lambda (expr)\\n                      (if (and (list? expr) (not (null? expr)))\\n                          (list \\\"op\\\" (first expr) \\\"args\\\" (rest expr))\\n                          \\\"not-a-compound-expr\\\"))))\\n  (map analyze-expr (list '(+ 1 2)\\n                         'x\\n                         '(* a b c))))\\n; \\u2192 ((\\\"op\\\" + \\\"args\\\" (1 2)) \\\"not-a-compound-expr\\\" (\\\"op\\\" * \\\"args\\\" (a b c))) (shortcuts)\\n```\\n\\n#### Quote Enables Meta-Programming\\n```aifpl\\n; Create expressions that create expressions\\n(let ((make-adder (lambda (n)\\n                    (list (quote lambda) \\n                         (quote (x)) \\n                         (list (quote +) (quote x) n)))))\\n  (make-adder 5))                     ; \\u2192 (lambda (x) (+ x 5))\\n(let ((make-adder (lambda (n)\\n                    (list 'lambda \\n                         '(x) \\n                         (list '+ 'x n)))))\\n  (make-adder 5))                     ; \\u2192 (lambda (x) (+ x 5)) (shortcuts)\\n\\n; Template-based code generation\\n(let ((make-predicate (lambda (op value)\\n                        (list (quote lambda)\\n                             (quote (x))\\n                             (list op (quote x) value)))))\\n  (list (make-predicate (quote >) 10)\\n        (make-predicate (quote =) 0)))  ; \\u2192 ((lambda (x) (> x 10)) (lambda (x) (= x 0)))\\n(let ((make-predicate (lambda (op value)\\n                        (list 'lambda\\n                             '(x)\\n                             (list op 'x value)))))\\n  (list (make-predicate '> 10)\\n        (make-predicate '= 0)))       ; \\u2192 ((lambda (x) (> x 10)) (lambda (x) (= x 0))) (shortcuts)\\n```\\n\\n#### Homoiconicity in Action\\n```aifpl\\n; Code and data have the same representation\\n(let ((code (quote (+ (* 2 3) 4)))\\n      (data (list (quote +) (list (quote *) 2 3) 4)))\\n  (= code data))                      ; \\u2192 #t (they're identical!)\\n(let ((code '(+ (* 2 3) 4))\\n      (data (list '+ (list '* 2 3) 4)))\\n  (= code data))                      ; \\u2192 #t (shortcuts make it cleaner!)\\n\\n; Manipulate code like any other data\\n(let ((expr (quote (+ 1 2 3))))\\n  (let ((reversed (reverse expr)))\\n    reversed))                        ; \\u2192 (3 2 1 +)\\n(let ((expr '(+ 1 2 3)))\\n  (let ((reversed (reverse expr)))\\n    reversed))                        ; \\u2192 (3 2 1 +) (shortcut)\\n\\n; Transform code structures\\n(let ((transform-ops (lambda (expr)\\n                       (if (list? expr)\\n                           (map transform-ops expr)\\n                           (if (= expr (quote +))\\n                               (quote *)\\n                               expr)))))\\n  (transform-ops (quote (+ 1 (+ 2 3)))))  ; \\u2192 (* 1 (* 2 3))\\n(let ((transform-ops (lambda (expr)\\n                       (if (list? expr)\\n                           (map transform-ops expr)\\n                           (if (= expr '+)\\n                               '*\\n                               expr)))))\\n  (transform-ops '(+ 1 (+ 2 3))))     ; \\u2192 (* 1 (* 2 3)) (shortcuts)\\n```\\n\\n### Lambda Expressions and Anonymous Functions\\n\\nLambda expressions create anonymous functions with lexical scoping and closure support:\\n\\n#### Basic Lambda Syntax\\n```aifpl\\n(lambda (param1 param2 ...) body)\\n```\\n\\n#### Simple Lambda Examples\\n```aifpl\\n; Square function\\n((lambda (x) (* x x)) 5)                    ; \\u2192 25\\n\\n; Add two numbers\\n((lambda (x y) (+ x y)) 3 4)                ; \\u2192 7\\n\\n; String manipulation\\n((lambda (s) (string-upcase s)) \\\"hello\\\")     ; \\u2192 \\\"HELLO\\\"\\n\\n; Conditional logic\\n((lambda (x) (if (> x 0) \\\"positive\\\" \\\"non-positive\\\")) -3)  ; \\u2192 \\\"non-positive\\\"\\n```\\n\\n#### Lambda Functions as Values\\n```aifpl\\n; Lambda functions are first-class values\\n(let ((square (lambda (x) (* x x))))\\n  (square 6))                                ; \\u2192 36\\n\\n; Functions in lists\\n(let ((ops (list (lambda (x) (* x 2)) (lambda (x) (+ x 1)))))\\n  ((first ops) 5))                          ; \\u2192 10\\n\\n; Higher-order function usage\\n(map (lambda (x) (* x x)) (list 1 2 3 4))   ; \\u2192 (1 4 9 16)\\n```\\n\\n#### Closures and Lexical Scoping\\n```aifpl\\n; Closures capture their environment\\n(let ((multiplier 10))\\n  (let ((times-ten (lambda (x) (* x multiplier))))\\n    (times-ten 5)))                         ; \\u2192 50\\n\\n; Nested closures\\n(let ((outer-var 100))\\n  (let ((make-adder (lambda (n) (lambda (x) (+ x n outer-var)))))\\n    (let ((add-five (make-adder 5)))\\n      (add-five 3))))                       ; \\u2192 108\\n\\n; Function factories\\n(let ((make-multiplier (lambda (factor) (lambda (x) (* x factor)))))\\n  (let ((double (make-multiplier 2))\\n        (triple (make-multiplier 3)))\\n    (list (double 4) (triple 4))))          ; \\u2192 (8 12)\\n```\\n\\n#### Recursive Lambda Functions\\n```aifpl\\n; Factorial with tail recursion (automatically optimized)\\n(let ((factorial (lambda (n acc)\\n                   (if (<= n 1)\\n                       acc\\n                       (factorial (- n 1) (* n acc))))))\\n  (factorial 5 1))                          ; \\u2192 120\\n\\n; List sum with recursion\\n(let ((sum-list (lambda (lst acc)\\n                  (if (null? lst)\\n                      acc\\n                      (sum-list (rest lst) (+ acc (first lst)))))))\\n  (sum-list (list 1 2 3 4 5) 0))           ; \\u2192 15\\n\\n; Fibonacci with mutual recursion\\n(let ((fib-helper (lambda (n a b)\\n                    (if (<= n 0)\\n                        a\\n                        (fib-helper (- n 1) b (+ a b))))))\\n  (let ((fibonacci (lambda (n) (fib-helper n 0 1))))\\n    (fibonacci 10)))                        ; \\u2192 55\\n```\\n\\n### Local Variable Binding with Let\\n\\nLet expressions create local variable bindings with sequential evaluation and lexical scoping:\\n\\n#### Basic Let Syntax\\n```aifpl\\n(let ((var1 val1) (var2 val2) ...) body)\\n```\\n\\n#### Simple Let Examples\\n```aifpl\\n; Basic binding\\n(let ((x 5)) (+ x 10))                      ; \\u2192 15\\n\\n; Multiple bindings\\n(let ((x 3) (y 4)) (+ (* x x) (* y y)))     ; \\u2192 25\\n\\n; String operations\\n(let ((name \\\"Alice\\\") (age 30))\\n  (string-append name \\\" is \\\" (number->string age)))  ; \\u2192 \\\"Alice is 30\\\"\\n```\\n\\n#### Sequential Binding\\n```aifpl\\n; Later variables can reference earlier ones\\n(let ((x 5) (y (* x 2))) (+ x y))           ; \\u2192 15\\n\\n; Building complex expressions\\n(let ((base 10)\\n      (squared (* base base))\\n      (cubed (* squared base)))\\n  (list base squared cubed))                ; \\u2192 (10 100 1000)\\n\\n; String processing chain\\n(let ((text \\\"Hello World\\\")\\n      (lower (string-downcase text))\\n      (words (string-split lower \\\" \\\")))\\n  (string-join (reverse words) \\\"-\\\"))        ; \\u2192 \\\"world-hello\\\"\\n```\\n\\n#### Binding Functions\\n```aifpl\\n; Bind lambda functions to names\\n(let ((double (lambda (x) (* x 2)))\\n      (triple (lambda (x) (* x 3))))\\n  (+ (double 4) (triple 5)))                ; \\u2192 23\\n\\n; Compose functions\\n(let ((add-one (lambda (x) (+ x 1)))\\n      (square (lambda (x) (* x x)))\\n      (compose (lambda (f g) (lambda (x) (f (g x))))))\\n  (let ((square-then-add (compose add-one square)))\\n    (square-then-add 4)))                   ; \\u2192 17\\n\\n; Recursive function binding\\n(let ((countdown (lambda (n)\\n                   (if (<= n 0)\\n                       (list)\\n                       (cons n (countdown (- n 1)))))))\\n  (countdown 5))                            ; \\u2192 (5 4 3 2 1)\\n```\\n\\n#### Nested Let Expressions\\n```aifpl\\n; Nested scoping\\n(let ((x 10))\\n  (let ((x 20) (y x))  ; inner x shadows outer, y gets outer x value\\n    (+ x y)))                               ; \\u2192 30\\n\\n; Complex nested computation\\n(let ((data (list 1 2 3 4 5)))\\n  (let ((squared (map (lambda (x) (* x x)) data))\\n        (sum-fn (lambda (lst) (fold + 0 lst))))\\n    (let ((total (sum-fn squared))\\n          (average (/ total (length squared))))\\n      (list \\\"sum\\\" total \\\"average\\\" average))))  ; \\u2192 (\\\"sum\\\" 55 \\\"average\\\" 11)\\n```\\n\\n### Pattern Matching\\n\\nPattern matching provides a powerful way to destructure and analyze data based on its shape and content. It offers a concise alternative to nested conditionals and enables elegant functional programming patterns.\\n\\n#### Basic Pattern Matching Syntax\\n```aifpl\\n(match expression\\n  (pattern1 result1)\\n  (pattern2 result2)\\n  ...\\n  (_ default-result))  ; wildcard pattern (optional)\\n```\\n\\n#### Literal Pattern Matching\\n```aifpl\\n; Match exact values\\n(match 42\\n  (42 \\\"found the answer\\\")\\n  (0 \\\"zero\\\")\\n  (_ \\\"something else\\\"))                     ; \\u2192 \\\"found the answer\\\"\\n\\n; String literal matching\\n(match \\\"hello\\\"\\n  (\\\"world\\\" \\\"greeting\\\")\\n  (\\\"hello\\\" \\\"salutation\\\")\\n  (_ \\\"unknown\\\"))                            ; \\u2192 \\\"salutation\\\"\\n\\n; Boolean literal matching\\n(match #t\\n  (#t \\\"true value\\\")\\n  (#f \\\"false value\\\"))                       ; \\u2192 \\\"true value\\\"\\n```\\n\\n#### Variable Pattern Matching\\n```aifpl\\n; Bind values to variables\\n(match 42\\n  (x (* x 2)))                              ; \\u2192 84 (x is bound to 42)\\n\\n; Variable patterns always match\\n(match \\\"hello\\\"\\n  (greeting (string-upcase greeting)))      ; \\u2192 \\\"HELLO\\\"\\n\\n; Multiple variable patterns (first match wins)\\n(match 10\\n  (x (+ x 1))\\n  (y (* y 2)))                              ; \\u2192 11 (first pattern matches)\\n```\\n\\n#### Wildcard Pattern Matching\\n```aifpl\\n; Wildcard matches anything without binding\\n(match 42\\n  (_ \\\"matched something\\\"))                  ; \\u2192 \\\"matched something\\\"\\n\\n; Common use as default case\\n(match \\\"unknown\\\"\\n  (\\\"hello\\\" \\\"greeting\\\")\\n  (\\\"goodbye\\\" \\\"farewell\\\")\\n  (_ \\\"unrecognized\\\"))                       ; \\u2192 \\\"unrecognized\\\"\\n\\n; Wildcard with computation\\n(match (+ 10 20)\\n  (_ \\\"got a result\\\"))                       ; \\u2192 \\\"got a result\\\"\\n```\\n\\n#### Type Pattern Matching\\n```aifpl\\n; Match by type with binding\\n(match 42\\n  ((number? n) (+ n 10))\\n  ((string? s) (string-length s))\\n  (_ \\\"unknown type\\\"))                       ; \\u2192 52\\n\\n; String type matching\\n(match \\\"hello world\\\"\\n  ((string? text) (string-upcase text))\\n  (_ \\\"not a string\\\"))                       ; \\u2192 \\\"HELLO WORLD\\\"\\n\\n; Boolean type matching\\n(match #t\\n  ((boolean? flag) (not flag))\\n  (_ \\\"not boolean\\\"))                        ; \\u2192 #f\\n\\n; List type matching\\n(match (list 1 2 3)\\n  ((list? items) (length items))\\n  (_ \\\"not a list\\\"))                         ; \\u2192 3\\n\\n; Function type matching\\n(match (lambda (x) (* x 2))\\n  ((function? f) \\\"it's a function\\\")\\n  (_ \\\"not a function\\\"))                     ; \\u2192 \\\"it's a function\\\"\\n```\\n\\n#### List Structure Pattern Matching\\n\\n**Important:** In AIFPL, the `(head . tail)` pattern always binds `tail` to a list (possibly empty), never to an atom. This differs from Scheme/Lisp.\\n\\n```aifpl\\n; Empty list matching\\n(match (list)\\n  (() \\\"empty list\\\")\\n  (_ \\\"non-empty\\\"))                          ; \\u2192 \\\"empty list\\\"\\n\\n; Fixed-length list matching\\n(match (list 1 2 3)\\n  ((a b c) (+ a b c))\\n  (_ \\\"wrong length\\\"))                       ; \\u2192 6\\n\\n; Head-tail decomposition - tail is ALWAYS a list\\n(match (list 1 2 3 4)\\n  ((head . tail) (list \\\"head\\\" head \\\"tail\\\" tail))\\n  (() \\\"empty\\\"))                             ; \\u2192 (\\\"head\\\" 1 \\\"tail\\\" (2 3 4))\\n\\n; Single element list - tail is empty list\\n(match (list 42)\\n  ((x . xs) (list x xs)))                   ; \\u2192 (42 ())  - xs is (), not an atom\\n\\n; Two-element list\\n(match (list \\\"hello\\\" \\\"world\\\")\\n  ((first second) (string-append first \\\" \\\" second))\\n  (_ \\\"not a pair\\\"))                         ; \\u2192 \\\"hello world\\\"\\n```\\n\\n**Note:** Unlike Scheme/Lisp where `(cdr '(1 . 2))` returns the atom `2`, AIFPL's `(head . tail)` pattern always binds `tail` to a list. Use fixed-length patterns like `(a b)` when you want direct access to individual elements.\\n\\n#### Nested Pattern Matching\\n```aifpl\\n; Nested list patterns\\n(match (list (list 1 2) 3)\\n  (((a b) c) (+ a b c))\\n  (_ \\\"no match\\\"))                           ; \\u2192 6\\n\\n; Deep nesting\\n(match (list (list (list 1 2) 3) 4)\\n  ((((x y) z) w) (+ x y z w))\\n  (_ \\\"no match\\\"))                           ; \\u2192 10\\n\\n; Mixed literal and variable patterns\\n(match (list \\\"name\\\" \\\"Alice\\\")\\n  ((\\\"name\\\" value) (string-append \\\"Hello, \\\" value))\\n  ((\\\"age\\\" value) (string-append \\\"Age: \\\" (number->string value)))\\n  (_ \\\"unknown field\\\"))                      ; \\u2192 \\\"Hello, Alice\\\"\\n\\n; Nested type patterns\\n(match (list (list 1 2 3))\\n  (((list? numbers)) (fold + 0 numbers))\\n  (_ \\\"not a list of numbers\\\"))              ; \\u2192 6\\n```\\n\\n#### Pattern Matching with Conditionals\\n```aifpl\\n; Combine patterns with guards (using nested match)\\n(let ((classify-number (lambda (n)\\n                         (match n\\n                           ((number? x) \\n                            (match #t\\n                              ((if (> x 0)) \\\"positive\\\")\\n                              ((if (< x 0)) \\\"negative\\\")\\n                              (_ \\\"zero\\\")))\\n                           (_ \\\"not a number\\\")))))\\n  (list (classify-number 5)\\n        (classify-number -3)\\n        (classify-number 0)\\n        (classify-number \\\"hello\\\")))          ; \\u2192 (\\\"positive\\\" \\\"negative\\\" \\\"zero\\\" \\\"not a number\\\")\\n```\\n\\n#### Complex Data Structure Matching\\n```aifpl\\n; Process structured data\\n(let ((process-person (lambda (person)\\n                        (match person\\n                          ((\\\"person\\\" name age city)\\n                           (string-append name \\\" (\\\" (number->string age) \\\") from \\\" city))\\n                          ((\\\"person\\\" name age)\\n                           (string-append name \\\" (\\\" (number->string age) \\\")\\\"))\\n                          (_ \\\"invalid person data\\\")))))\\n  (list (process-person (list \\\"person\\\" \\\"Alice\\\" 30 \\\"NYC\\\"))\\n        (process-person (list \\\"person\\\" \\\"Bob\\\" 25))\\n        (process-person (list \\\"invalid\\\" \\\"data\\\"))))\\n; \\u2192 (\\\"Alice (30) from NYC\\\" \\\"Bob (25)\\\" \\\"invalid person data\\\")\\n\\n; Tree-like structure processing\\n(let ((evaluate-expr (lambda (expr)\\n                       (match expr\\n                         (((number? n)) n)\\n                         ((\\\"+\\\" left right) (+ (evaluate-expr left) (evaluate-expr right)))\\n                         ((\\\"*\\\" left right) (* (evaluate-expr left) (evaluate-expr right)))\\n                         (_ \\\"invalid expression\\\")))))\\n  (evaluate-expr (list \\\"+\\\" (list 10) (list \\\"*\\\" (list 5) (list 3)))))  ; \\u2192 25\\n```\\n\\n#### Pattern Matching vs. Conditional Chains\\n```aifpl\\n; Traditional nested conditionals\\n(let ((process-traditional (lambda (data)\\n                             (if (list? data)\\n                                 (if (= (length data) 3)\\n                                     (if (string? (first data))\\n                                         (if (number? (first (rest data)))\\n                                             (string-append (first data) \\\": \\\" \\n                                                          (number->string (first (rest data))))\\n                                             \\\"second not number\\\")\\n                                         \\\"first not string\\\")\\n                                     \\\"wrong length\\\")\\n                                 \\\"not a list\\\"))))\\n  (process-traditional (list \\\"score\\\" 95 \\\"points\\\")))  ; \\u2192 \\\"score: 95\\\"\\n\\n; Equivalent pattern matching (much cleaner)\\n(let ((process-pattern (lambda (data)\\n                         (match data\\n                           (((string? name) (number? value) extra) \\n                            (string-append name \\\": \\\" (number->string value)))\\n                           (_ \\\"invalid format\\\")))))\\n  (process-pattern (list \\\"score\\\" 95 \\\"points\\\")))      ; \\u2192 \\\"score: 95\\\"\\n```\\n\\n#### Advanced Pattern Matching Examples\\n```aifpl\\n; List processing with patterns\\n(let ((process-list (lambda (lst)\\n                      (match lst\\n                        (() \\\"empty\\\")\\n                        ((x) (string-append \\\"single: \\\" (number->string x)))\\n                        ((x y) (string-append \\\"pair: \\\" (number->string (+ x y))))\\n                        ((head . tail) \\n                         (string-append \\\"list of \\\" (number->string (+ 1 (length tail))) \\\" items\\\"))))))\\n  (list (process-list (list))\\n        (process-list (list 42))\\n        (process-list (list 1 2))\\n        (process-list (list 1 2 3 4 5))))\\n; \\u2192 (\\\"empty\\\" \\\"single: 42\\\" \\\"pair: 3\\\" \\\"list of 5 items\\\")\\n\\n; Configuration processing\\n(let ((process-config (lambda (config)\\n                        (match config\\n                          ((\\\"database\\\" \\\"mysql\\\" host port)\\n                           (string-append \\\"MySQL at \\\" host \\\":\\\" (number->string port)))\\n                          ((\\\"database\\\" \\\"postgres\\\" host port db)\\n                           (string-append \\\"PostgreSQL \\\" db \\\" at \\\" host \\\":\\\" (number->string port)))\\n                          ((\\\"cache\\\" \\\"redis\\\" host)\\n                           (string-append \\\"Redis cache at \\\" host))\\n                          (_ \\\"unknown configuration\\\")))))\\n  (list (process-config (list \\\"database\\\" \\\"mysql\\\" \\\"localhost\\\" 3306))\\n        (process-config (list \\\"database\\\" \\\"postgres\\\" \\\"db.example.com\\\" 5432 \\\"myapp\\\"))\\n        (process-config (list \\\"cache\\\" \\\"redis\\\" \\\"cache.example.com\\\"))\\n        (process-config (list \\\"unknown\\\" \\\"config\\\"))))\\n; \\u2192 (\\\"MySQL at localhost:3306\\\" \\\"PostgreSQL myapp at db.example.com:5432\\\" \\\"Redis cache at cache.example.com\\\" \\\"unknown configuration\\\")\\n\\n; Recursive data structure processing\\n(let ((json-to-string (lambda (json)\\n                        (match json\\n                          (((string? s)) (string-append \\\"\\\\\\\"\\\" s \\\"\\\\\\\"\\\"))\\n                          (((number? n)) (number->string n))\\n                          (((boolean? b)) (if b \\\"true\\\" \\\"false\\\"))\\n                          ((\\\"object\\\" . pairs)\\n                           (let ((pair-strings (map (lambda (pair)\\n                                                     (match pair\\n                                                       ((key value)\\n                                                        (string-append \\\"\\\\\\\"\\\" key \\\"\\\\\\\": \\\" \\n                                                                     (json-to-string value)))\\n                                                       (_ \\\"invalid pair\\\")))\\n                                                   pairs)))\\n                             (string-append \\\"{\\\" (string-join pair-strings \\\", \\\") \\\"}\\\")))\\n                          ((\\\"array\\\" . items)\\n                           (string-append \\\"[\\\" \\n                                        (string-join (map json-to-string items) \\\", \\\") \\n                                        \\\"]\\\"))\\n                          (_ \\\"invalid JSON\\\")))))\\n  (json-to-string (list \\\"object\\\" \\n                       (list \\\"name\\\" (list \\\"Alice\\\"))\\n                       (list \\\"age\\\" (list 30))\\n                       (list \\\"active\\\" (list #t)))))\\n; \\u2192 \\\"{\\\\\\\"name\\\\\\\": \\\\\\\"Alice\\\\\\\", \\\\\\\"age\\\\\\\": 30, \\\\\\\"active\\\\\\\": true}\\\"\\n```\\n\\n#### Pattern Matching Best Practices\\n```aifpl\\n; Order patterns from specific to general\\n(let ((classify (lambda (x)\\n                  (match x\\n                    (0 \\\"zero\\\")              ; Most specific first\\n                    (1 \\\"one\\\")\\n                    ((number? n) \\\"other number\\\")  ; More general\\n                    (_ \\\"not a number\\\")))))          ; Most general last\\n  (list (classify 0) (classify 1) (classify 42) (classify \\\"hello\\\")))\\n; \\u2192 (\\\"zero\\\" \\\"one\\\" \\\"other number\\\" \\\"not a number\\\")\\n\\n; Use meaningful variable names in patterns\\n(let ((format-person (lambda (data)\\n                       (match data\\n                         ((name age city) ; Clear variable names\\n                          (string-append name \\\" (\\\" (number->string age) \\\") lives in \\\" city))\\n                         (_ \\\"invalid person\\\")))))\\n  (format-person (list \\\"Alice\\\" 30 \\\"Boston\\\")))     ; \\u2192 \\\"Alice (30) lives in Boston\\\"\\n\\n; Combine pattern matching with higher-order functions\\n(let ((process-items (lambda (items)\\n                       (map (lambda (item)\\n                              (match item\\n                                ((\\\"task\\\" name priority)\\n                                 (string-append name \\\" [\\\" priority \\\"]\\\"))\\n                                ((\\\"note\\\" content)\\n                                 (string-append \\\"Note: \\\" content))\\n                                (_ \\\"unknown item\\\")))\\n                            items))))\\n  (process-items (list (list \\\"task\\\" \\\"Buy groceries\\\" \\\"high\\\")\\n                      (list \\\"note\\\" \\\"Remember to call mom\\\")\\n                      (list \\\"invalid\\\" \\\"item\\\"))))\\n; \\u2192 (\\\"Buy groceries [high]\\\" \\\"Note: Remember to call mom\\\" \\\"unknown item\\\")\\n```\\n\\n### Higher-Order Functions\\n\\nAIFPL provides powerful higher-order functions for functional programming patterns:\\n\\n#### Map - Transform Each Element\\n```aifpl\\n; Basic mapping\\n(map (lambda (x) (* x 2)) (list 1 2 3 4))   ; \\u2192 (2 4 6 8)\\n\\n; String transformations\\n(map string-upcase (list \\\"hello\\\" \\\"world\\\"))  ; \\u2192 (\\\"HELLO\\\" \\\"WORLD\\\")\\n\\n; Complex transformations\\n(map (lambda (x) (+ (* x x) 1)) (list 1 2 3))  ; \\u2192 (2 5 10)\\n\\n; Nested list processing\\n(map (lambda (pair) (+ (first pair) (first (rest pair))))\\n     (list (list 1 2) (list 3 4) (list 5 6)))  ; \\u2192 (3 7 11)\\n```\\n\\n#### Filter - Select Elements by Predicate\\n```aifpl\\n; Basic filtering\\n(filter (lambda (x) (> x 0)) (list -1 2 -3 4))  ; \\u2192 (2 4)\\n\\n; String filtering\\n(filter (lambda (s) (> (string-length s) 3))\\n        (list \\\"hi\\\" \\\"hello\\\" \\\"a\\\" \\\"world\\\"))    ; \\u2192 (\\\"hello\\\" \\\"world\\\")\\n\\n; Complex predicates\\n(filter (lambda (x) (= (% x 2) 0)) (range 1 11))  ; \\u2192 (2 4 6 8 10)\\n\\n; Boolean combinations\\n(filter (lambda (x) (and (> x 5) (< x 15)))\\n        (range 1 20))                       ; \\u2192 (6 7 8 9 10 11 12 13 14)\\n```\\n\\n#### Fold - Accumulate Results\\n```aifpl\\n; Sum all elements\\n(fold + 0 (list 1 2 3 4 5))                ; \\u2192 15\\n\\n; Product of elements\\n(fold * 1 (list 1 2 3 4))                  ; \\u2192 24\\n\\n; String concatenation\\n(fold string-append \\\"\\\" (list \\\"Hello\\\" \\\" \\\" \\\"World\\\"))  ; \\u2192 \\\"Hello World\\\"\\n\\n; Build reverse list\\n(fold (lambda (acc x) (cons x acc)) (list) (list 1 2 3))  ; \\u2192 (3 2 1)\\n\\n; Find maximum\\n(fold (lambda (acc x) (if (> x acc) x acc)) 0 (list 3 7 2 9 1))  ; \\u2192 9\\n\\n; Complex accumulation\\n(fold (lambda (acc x) (+ acc (* x x))) 0 (list 1 2 3 4))  ; \\u2192 30\\n```\\n\\n#### Range - Generate Numeric Sequences\\n```aifpl\\n; Basic ranges\\n(range 1 5)                                 ; \\u2192 (1 2 3 4)\\n(range 0 10 2)                             ; \\u2192 (0 2 4 6 8)\\n(range 10 0 -1)                            ; \\u2192 (10 9 8 7 6 5 4 3 2 1)\\n\\n; Use with other functions\\n(map (lambda (x) (* x x)) (range 1 6))      ; \\u2192 (1 4 9 16 25)\\n(filter (lambda (x) (= (% x 3) 0)) (range 1 21))  ; \\u2192 (3 6 9 12 15 18)\\n\\n; Generate data\\n(map (lambda (i) (list \\\"item\\\" i)) (range 1 4))  ; \\u2192 ((\\\"item\\\" 1) (\\\"item\\\" 2) (\\\"item\\\" 3))\\n```\\n\\n#### Find - Locate First Matching Element\\n```aifpl\\n; Find first positive number\\n(find (lambda (x) (> x 0)) (list -1 -2 3 4))  ; \\u2192 3\\n\\n; Find first long string\\n(find (lambda (s) (> (string-length s) 4))\\n      (list \\\"hi\\\" \\\"hello\\\" \\\"a\\\"))              ; \\u2192 \\\"hello\\\"\\n\\n; Returns #f if not found\\n(find (lambda (x) (> x 10)) (list 1 2 3))  ; \\u2192 #f\\n\\n; Complex search\\n(find (lambda (pair) (= (first pair) \\\"name\\\"))\\n      (list (list \\\"age\\\" 25) (list \\\"name\\\" \\\"John\\\")))  ; \\u2192 (\\\"name\\\" \\\"John\\\")\\n```\\n\\n#### Any? and All? - Boolean Predicates\\n```aifpl\\n; Check if any element matches\\n(any? (lambda (x) (> x 5)) (list 1 3 7 2))  ; \\u2192 #t\\n(any? (lambda (x) (< x 0)) (list 1 2 3))   ; \\u2192 #f\\n\\n; Check if all elements match\\n(all? (lambda (x) (> x 0)) (list 1 2 3))   ; \\u2192 #t\\n(all? (lambda (x) (> x 5)) (list 1 3 7))   ; \\u2192 #f\\n\\n; String validation\\n(all? (lambda (s) (> (string-length s) 0))\\n      (list \\\"hello\\\" \\\"world\\\" \\\"test\\\"))        ; \\u2192 #t\\n\\n(any? (lambda (s) (string-contains? s \\\"@\\\"))\\n      (list \\\"user@email.com\\\" \\\"plain-text\\\")) ; \\u2192 #t\\n```\\n\\n#### Take and Drop - List Slicing\\n```aifpl\\n; Take first n elements\\n(take 3 (list 1 2 3 4 5))                  ; \\u2192 (1 2 3)\\n(take 2 (list \\\"a\\\" \\\"b\\\" \\\"c\\\" \\\"d\\\"))            ; \\u2192 (\\\"a\\\" \\\"b\\\")\\n\\n; Drop first n elements\\n(drop 2 (list 1 2 3 4 5))                  ; \\u2192 (3 4 5)\\n(drop 3 (list \\\"a\\\" \\\"b\\\" \\\"c\\\" \\\"d\\\"))            ; \\u2192 (\\\"d\\\")\\n\\n; Safe operations (don't error on out-of-bounds)\\n(take 10 (list 1 2 3))                     ; \\u2192 (1 2 3)\\n(drop 10 (list 1 2 3))                     ; \\u2192 ()\\n\\n; Combine with other operations\\n(take 3 (filter (lambda (x) (> x 0)) (list -1 2 -3 4 5 6)))  ; \\u2192 (2 4 5)\\n```\\n\\n### Functional Programming Patterns\\n\\n#### Data Transformation Pipelines\\n```aifpl\\n; Process CSV-like data\\n(let ((data (list \\\"john,25\\\" \\\"alice,30\\\" \\\"bob,22\\\")))\\n  (map (lambda (row)\\n         (let ((parts (string-split row \\\",\\\")))\\n           (list (first parts) (string->number (first (rest parts))))))\\n       data))                               ; \\u2192 ((\\\"john\\\" 25) (\\\"alice\\\" 30) (\\\"bob\\\" 22))\\n\\n; Multi-step data processing\\n(let ((numbers (range 1 21)))\\n  (let ((evens (filter (lambda (x) (= (% x 2) 0)) numbers))\\n        (squares (map (lambda (x) (* x x)) evens))\\n        (sum (fold + 0 squares)))\\n    sum))                                   ; \\u2192 1540\\n\\n; String processing pipeline\\n(let ((text \\\"The Quick Brown Fox\\\"))\\n  (let ((words (string-split (string-downcase text) \\\" \\\"))\\n        (long-words (filter (lambda (w) (> (string-length w) 3)) words))\\n        (capitalized (map string-upcase long-words)))\\n    (string-join capitalized \\\"-\\\")))         ; \\u2192 \\\"QUICK-BROWN\\\"\\n```\\n\\n#### Function Composition\\n```aifpl\\n; Compose two functions\\n(let ((compose (lambda (f g) (lambda (x) (f (g x))))))\\n  (let ((add-one (lambda (x) (+ x 1)))\\n        (double (lambda (x) (* x 2))))\\n    (let ((double-then-add (compose add-one double)))\\n      (double-then-add 5))))                ; \\u2192 11\\n\\n; Chain multiple transformations\\n(let ((pipe (lambda (value . functions)\\n              (fold (lambda (acc f) (f acc)) value functions))))\\n  (let ((add-ten (lambda (x) (+ x 10)))\\n        (multiply-by-three (lambda (x) (* x 3)))\\n        (subtract-five (lambda (x) (- x 5))))\\n    (pipe 2 add-ten multiply-by-three subtract-five)))  ; \\u2192 31\\n```\\n\\n#### Recursive Data Processing\\n```aifpl\\n; Process nested lists recursively\\n(let ((deep-sum (lambda (lst)\\n                  (if (null? lst)\\n                      0\\n                      (let ((head (first lst))\\n                            (tail (rest lst)))\\n                        (+ (if (list? head)\\n                               (deep-sum head)\\n                               head)\\n                           (deep-sum tail)))))))\\n  (deep-sum (list 1 (list 2 3) 4)))        ; \\u2192 10\\n\\n; Tree traversal patterns\\n(let ((count-leaves (lambda (tree)\\n                      (if (list? tree)\\n                          (fold + 0 (map count-leaves tree))\\n                          1))))\\n  (count-leaves (list 1 (list 2 (list 3 4)) 5)))  ; \\u2192 5\\n```\\n\\n#### Validation and Error Handling\\n```aifpl\\n; Validate all items in a list\\n(let ((validate-positive (lambda (nums)\\n                          (if (all? (lambda (x) (> x 0)) nums)\\n                              nums\\n                              \\\"error: negative numbers found\\\"))))\\n  (list (validate-positive (list 1 2 3))\\n        (validate-positive (list 1 -2 3))))  ; \\u2192 ((1 2 3) \\\"error: negative numbers found\\\")\\n\\n; Safe operations with defaults\\n(let ((safe-divide (lambda (x y)\\n                     (if (= y 0)\\n                         \\\"undefined\\\"\\n                         (/ x y)))))\\n  (map (lambda (pair) (safe-divide (first pair) (first (rest pair))))\\n       (list (list 10 2) (list 15 3) (list 8 0))))  ; \\u2192 (5 5 \\\"undefined\\\")\\n```\\n\\n### Conditional Operations\\n\\nAIFPL supports conditional evaluation with lazy evaluation of branches:\\n\\n```aifpl\\n(if condition then-expr else-expr)\\n```\\n\\n#### Basic Examples:\\n```aifpl\\n(if (> 5 3) \\\"greater\\\" \\\"less\\\")         ; \\u2192 \\\"greater\\\"\\n(if (= 1 2) (+ 1 1) (* 2 2))          ; \\u2192 4\\n(if #t \\\"true branch\\\" \\\"false branch\\\")  ; \\u2192 \\\"true branch\\\"\\n(if #f \\\"true branch\\\" \\\"false branch\\\")  ; \\u2192 \\\"false branch\\\"\\n```\\n\\n#### Lazy Evaluation (Key Feature):\\n```aifpl\\n(if #t 42 (/ 1 0))                    ; \\u2192 42 (no division by zero error)\\n(if #f (undefined-symbol) \\\"safe\\\")     ; \\u2192 \\\"safe\\\" (no undefined symbol error)\\n(if (> x 0) (/ 100 x) \\\"undefined\\\")    ; Safe division\\n```\\n\\n#### Practical Examples:\\n```aifpl\\n; Safe list operations\\n(if (null? my-list) \\\"empty\\\" (first my-list))\\n\\n; Data validation\\n(if (string-contains? email \\\"@\\\") \\\"valid email\\\" \\\"invalid email\\\")\\n\\n; Conditional string building\\n(if (> count 1)\\n    (string-append (number->string count) \\\" items\\\")\\n    \\\"1 item\\\")\\n\\n; List processing\\n(if (member? \\\"target\\\" search-list)\\n    (string-append \\\"Found at position \\\" (number->string (position \\\"target\\\" search-list)))\\n    \\\"Not found\\\")\\n```\\n\\n#### Nested Conditionals:\\n```aifpl\\n(if (> x 0)\\n    (if (> x 10) \\\"big positive\\\" \\\"small positive\\\")\\n    (if (< x -10) \\\"big negative\\\" \\\"small negative or zero\\\"))\\n```\\n\\n#### Type Requirements:\\n- Condition must be a boolean (`#t` or `#f`)\\n- Both then-expr and else-expr are required\\n- Only the chosen branch is evaluated (lazy evaluation)\\n\\n### Arithmetic\\n- `(+ 1 2 3)` \\u2192 `6`\\n- `(- 10 3)` \\u2192 `7`\\n- `(* 2 3 4)` \\u2192 `24`\\n- `(/ 12 3)` \\u2192 `4`\\n- `(// 7 3)` \\u2192 `2` (floor division)\\n- `(% 7 3)` \\u2192 `1` (modulo)\\n- `(** 2 3)` \\u2192 `8` (exponentiation)\\n\\n### Comparison Operations\\n\\n#### Equality and Inequality\\n```aifpl\\n; Equality - all values must be equal\\n(= 1 1)                               ; \\u2192 #t\\n(= 1 2)                               ; \\u2192 #f\\n(= 1 1 1)                             ; \\u2192 #t (all equal)\\n(= 1 2 3)                             ; \\u2192 #f (not all equal)\\n\\n; Inequality - any values not equal\\n(!= 1 2)                              ; \\u2192 #t (any inequality)\\n(!= 1 1)                              ; \\u2192 #f (all equal)\\n(!= 1 2 3)                            ; \\u2192 #t (not all equal)\\n(!= 1 1 1)                            ; \\u2192 #f (all equal)\\n```\\n\\n#### Numeric Comparisons\\n```aifpl\\n; Comparison chains (all must satisfy the relationship)\\n(< 1 2)                               ; \\u2192 #t\\n(< 1 2 3)                             ; \\u2192 #t (1 < 2 < 3)\\n(< 1 3 2)                             ; \\u2192 #f (3 is not < 2)\\n\\n(> 3 2)                               ; \\u2192 #t\\n(> 3 2 1)                             ; \\u2192 #t (3 > 2 > 1)\\n\\n(<= 1 1)                              ; \\u2192 #t\\n(<= 1 2 2)                            ; \\u2192 #t (1 \\u2264 2 \\u2264 2)\\n\\n(>= 2 1)                              ; \\u2192 #t\\n(>= 3 2 2)                            ; \\u2192 #t (3 \\u2265 2 \\u2265 2)\\n```\\n\\n#### Mixed Type Equality\\n```aifpl\\n; Numeric types can be compared for equality\\n(= 1 1.0)                             ; \\u2192 #t (int/float equivalence)\\n(= 2 (+ 1.0 1.0))                     ; \\u2192 #t (numeric equivalence)\\n\\n; Different non-numeric types are never equal\\n(= \\\"hello\\\" 5)                         ; \\u2192 #f\\n(= #t 1)                              ; \\u2192 #f\\n(= (list 1 2) \\\"12\\\")                   ; \\u2192 #f\\n\\n; Lists are compared element by element\\n(= (list 1 2) (list 1 2))             ; \\u2192 #t\\n(= (list 1 2) (list 1 3))             ; \\u2192 #f\\n```\\n\\n### Boolean Operations\\n- `(and #t #f)` \\u2192 `#f`\\n- `(and #t #t)` \\u2192 `#t`\\n- `(or #t #f)` \\u2192 `#t`\\n- `(or #f #f)` \\u2192 `#f`\\n- `(not #t)` \\u2192 `#f`\\n- `(not #f)` \\u2192 `#t`\\n\\n### Type Predicates\\n\\nAIFPL provides comprehensive type checking functions:\\n\\n#### Basic Type Predicates\\n```aifpl\\n; Number type checking (excludes booleans)\\n(number? 42)                          ; \\u2192 #t\\n(number? 3.14)                        ; \\u2192 #t\\n(number? (+ 1 j))                     ; \\u2192 #t (complex)\\n(number? #t)                          ; \\u2192 #f (booleans are not numbers)\\n(number? \\\"42\\\")                        ; \\u2192 #f\\n\\n; Specific numeric type checking\\n(integer? 42)                         ; \\u2192 #t\\n(integer? 3.14)                       ; \\u2192 #f\\n(integer? #t)                         ; \\u2192 #f (booleans excluded)\\n\\n(float? 3.14)                         ; \\u2192 #t\\n(float? 42)                           ; \\u2192 #f\\n(float? (/ 1 2))                      ; \\u2192 #t (division produces float)\\n\\n(complex? (+ 1 j))                    ; \\u2192 #t\\n(complex? 42)                         ; \\u2192 #f\\n(complex? 3.14)                       ; \\u2192 #f\\n```\\n\\n#### Other Type Predicates\\n```aifpl\\n; String type checking\\n(string? \\\"hello\\\")                     ; \\u2192 #t\\n(string? 42)                          ; \\u2192 #f\\n(string? (number->string 42))         ; \\u2192 #t\\n\\n; Boolean type checking\\n(boolean? #t)                         ; \\u2192 #t\\n(boolean? #f)                         ; \\u2192 #t\\n(boolean? 1)                          ; \\u2192 #f\\n(boolean? 0)                          ; \\u2192 #f\\n\\n; Function type checking\\n(function? (lambda (x) (* x 2)))      ; \\u2192 #t\\n(function? +)                         ; \\u2192 #t\\n(function? \\\"hello\\\")                   ; \\u2192 #f\\n\\n; List type checking (already existed)\\n(list? (list 1 2 3))                 ; \\u2192 #t\\n(list? \\\"hello\\\")                       ; \\u2192 #f\\n(list? ())                            ; \\u2192 #t (empty list)\\n```\\n\\n#### Type Predicate Usage Patterns\\n```aifpl\\n; Conditional type handling\\n(let ((process-value (lambda (x)\\n                       (if (number? x)\\n                           (* x 2)\\n                           (if (string? x)\\n                               (string-upcase x)\\n                               \\\"unknown type\\\")))))\\n  (list (process-value 5)             ; \\u2192 10\\n        (process-value \\\"hello\\\")       ; \\u2192 \\\"HELLO\\\"\\n        (process-value #t)))          ; \\u2192 \\\"unknown type\\\"\\n\\n; Type validation\\n(let ((validate-numbers (lambda (lst)\\n                          (if (all? number? lst)\\n                              (fold + 0 lst)\\n                              \\\"error: non-numeric values found\\\"))))\\n  (list (validate-numbers (list 1 2 3))      ; \\u2192 6\\n        (validate-numbers (list 1 \\\"x\\\" 3))))  ; \\u2192 \\\"error: non-numeric values found\\\"\\n\\n; Polymorphic operations\\n(let ((safe-length (lambda (x)\\n                     (if (string? x)\\n                         (string-length x)\\n                         (if (list? x)\\n                             (length x)\\n                             \\\"not a sequence\\\")))))\\n  (list (safe-length \\\"hello\\\")         ; \\u2192 5\\n        (safe-length (list 1 2 3))    ; \\u2192 3\\n        (safe-length 42)))            ; \\u2192 \\\"not a sequence\\\"\\n```\\n\\n### Mathematical Functions\\n- `(sin (* pi 0.5))` \\u2192 `1`\\n- `(cos 0)` \\u2192 `1`\\n- `(log e)` \\u2192 `1`\\n- `(sqrt 16)` \\u2192 `4`\\n- `(abs -5)` \\u2192 `5`\\n\\n### Bitwise Operations\\n- `(bit-or 5 3)` \\u2192 `7`\\n- `(bit-and 7 3)` \\u2192 `3`\\n- `(bit-xor 5 3)` \\u2192 `6`\\n- `(bit-not 5)` \\u2192 `-6`\\n\\n### Base Conversion\\n- `(hex 255)` \\u2192 `\\\"0xff\\\"`\\n- `(bin 10)` \\u2192 `\\\"0b1010\\\"`\\n- `(oct 8)` \\u2192 `\\\"0o10\\\"`\\n\\n### Complex Numbers\\n- `(complex 3 4)` \\u2192 `(3+4j)`\\n- `(+ 1 (* 2 j))` \\u2192 `(1+2j)`\\n- `(real (complex 3 4))` \\u2192 `3` (extract real part)\\n- `(imag (complex 3 4))` \\u2192 `4` (extract imaginary part)\\n- `(real 5)` \\u2192 `5` (real part of real number)\\n- `(imag 5)` \\u2192 `0` (imaginary part of real number)\\n\\n### List Operations\\n\\n#### List Construction and Manipulation\\n\\n**Note:** AIFPL uses proper lists only. The `cons` function requires the second argument to be a list.\\n\\n```aifpl\\n(list 1 2 3)                           ; \\u2192 (1 2 3)\\n(list \\\"a\\\" \\\"b\\\" \\\"c\\\")                     ; \\u2192 (\\\"a\\\" \\\"b\\\" \\\"c\\\")\\n(list 1 \\\"hello\\\" #t)                    ; \\u2192 (1 \\\"hello\\\" #t) [mixed types]\\n(list)                                 ; \\u2192 () [empty list]\\n(cons 1 (list 2 3))                    ; \\u2192 (1 2 3) [prepend to list]\\n(cons 1 (list))                        ; \\u2192 (1) [prepend to empty list]\\n(append (list 1 2) (list 3 4))         ; \\u2192 (1 2 3 4) [concatenate]\\n(reverse (list 1 2 3))                 ; \\u2192 (3 2 1)\\n```\\n\\n**Important:** Unlike Scheme/Lisp, `(cons 1 2)` is invalid in AIFPL. Use `(list 1 2)` to create pairs.\\n\\n#### List Access and Properties\\n\\n**Note:** The `rest` function always returns a list, never an atom.\\n\\n```aifpl\\n(first (list 1 2 3))                  ; \\u2192 1\\n(rest (list 1 2 3))                   ; \\u2192 (2 3) [always returns a list]\\n(rest (list 1))                       ; \\u2192 () [empty list, not an atom]\\n(last (list 1 2 3))                   ; \\u2192 3\\n(list-ref (list \\\"a\\\" \\\"b\\\" \\\"c\\\") 1)       ; \\u2192 \\\"b\\\" (0-indexed)\\n(length (list 1 2 3))                 ; \\u2192 3\\n(null? (list))                        ; \\u2192 #t\\n(null? (list 1))                      ; \\u2192 #f\\n(list? (list 1 2))                    ; \\u2192 #t\\n(list? \\\"hello\\\")                       ; \\u2192 #f\\n(member? 2 (list 1 2 3))              ; \\u2192 #t\\n(member? 5 (list 1 2 3))              ; \\u2192 #f\\n```\\n\\n#### List Utilities\\n```aifpl\\n; Remove all occurrences of an element\\n(remove 2 (list 1 2 3 2 4))           ; \\u2192 (1 3 4)\\n(remove \\\"x\\\" (list \\\"a\\\" \\\"x\\\" \\\"b\\\" \\\"x\\\"))   ; \\u2192 (\\\"a\\\" \\\"b\\\")\\n(remove 5 (list 1 2 3))               ; \\u2192 (1 2 3) (no change if not found)\\n\\n; Find index of first occurrence\\n(position 2 (list 1 2 3))             ; \\u2192 1 (0-based index)\\n(position \\\"b\\\" (list \\\"a\\\" \\\"b\\\" \\\"c\\\"))     ; \\u2192 1\\n(position 5 (list 1 2 3))             ; \\u2192 #f (not found, consistent with find)\\n(position 2 (list 1 2 3 2))           ; \\u2192 1 (first occurrence)\\n```\\n\\n#### List Utility Usage Patterns\\n```aifpl\\n; Clean and process data\\n(let ((data (list 1 -2 3 -4 5))\\n      (negatives (list -2 -4)))\\n  (let ((cleaned (fold (lambda (acc neg) (remove neg acc)) data negatives))\\n        (doubled (map (lambda (x) (* x 2)) cleaned)))\\n    doubled))                          ; \\u2192 (2 6 10)\\n\\n; Find and replace pattern\\n(let ((find-and-process (lambda (item lst)\\n                          (let ((pos (position item lst)))\\n                            (if pos\\n                                (string-append \\\"Found \\\" (number->string item) \\n                                             \\\" at position \\\" (number->string pos))\\n                                \\\"Not found\\\")))))\\n  (list (find-and-process 3 (list 1 2 3 4))    ; \\u2192 \\\"Found 3 at position 2\\\"\\n        (find-and-process 5 (list 1 2 3 4))))  ; \\u2192 \\\"Not found\\\"\\n\\n; List difference using remove\\n(let ((list-difference (lambda (list1 list2)\\n                         (fold remove list1 list2))))\\n  (list-difference (list 1 2 3 4 5) (list 2 4)))  ; \\u2192 (1 3 5)\\n```\\n\\n#### List Equality\\n```aifpl\\n(= (list 1 2) (list 1 2))             ; \\u2192 #t\\n(= (list 1 2) (list 1 3))             ; \\u2192 #f\\n(= (list 1 2) (list 1 2 3))           ; \\u2192 #f\\n```\\n\\n### String Operations\\n\\n#### String Construction and Conversion\\n```aifpl\\n(string-append \\\"hello\\\" \\\" \\\" \\\"world\\\")   ; \\u2192 \\\"hello world\\\"\\n(number->string 42)                   ; \\u2192 \\\"42\\\"\\n(number->string 3.14)                 ; \\u2192 \\\"3.14\\\"\\n(string->number \\\"42\\\")                 ; \\u2192 42\\n(string->number \\\"3.14\\\")               ; \\u2192 3.14\\n```\\n\\n#### String Information and Access\\n```aifpl\\n(string-length \\\"hello\\\")               ; \\u2192 5\\n(string-ref \\\"hello\\\" 1)                ; \\u2192 \\\"e\\\" (character at index 1)\\n(substring \\\"hello\\\" 1 4)               ; \\u2192 \\\"ell\\\" (start=1, end=4 exclusive)\\n```\\n\\n#### String Manipulation\\n```aifpl\\n(string-upcase \\\"hello\\\")               ; \\u2192 \\\"HELLO\\\"\\n(string-downcase \\\"HELLO\\\")             ; \\u2192 \\\"hello\\\"\\n(string-trim \\\"  hello  \\\")             ; \\u2192 \\\"hello\\\"\\n(string-replace \\\"hello world\\\" \\\"world\\\" \\\"AIFPL\\\")  ; \\u2192 \\\"hello AIFPL\\\"\\n(string-replace \\\"banana\\\" \\\"a\\\" \\\"o\\\")     ; \\u2192 \\\"bonono\\\" (non-overlapping)\\n(string-replace \\\"test\\\" \\\"x\\\" \\\"y\\\")       ; \\u2192 \\\"test\\\" (no change if not found)\\n```\\n\\n#### String Manipulation Usage Patterns\\n```aifpl\\n; Clean and normalize text\\n(let ((normalize-text (lambda (text)\\n                        (let ((trimmed (string-trim text))\\n                              (lower (string-downcase trimmed)))\\n                          (string-replace lower \\\" \\\" \\\"-\\\")))))\\n  (normalize-text \\\"  Hello World  \\\"))  ; \\u2192 \\\"hello-world\\\"\\n\\n; Template replacement\\n(let ((template \\\"Hello {name}, you have {count} messages\\\")\\n      (replace-template (lambda (tmpl name count)\\n                          (let ((with-name (string-replace tmpl \\\"{name}\\\" name)))\\n                            (string-replace with-name \\\"{count}\\\" (number->string count))))))\\n  (replace-template template \\\"Alice\\\" 5))  ; \\u2192 \\\"Hello Alice, you have 5 messages\\\"\\n\\n; Multiple replacements\\n(let ((clean-text (lambda (text)\\n                     (let ((step1 (string-replace text \\\"bad\\\" \\\"good\\\"))\\n                           (step2 (string-replace step1 \\\"ugly\\\" \\\"pretty\\\")))\\n                       (string-replace step2 \\\"wrong\\\" \\\"right\\\")))))\\n  (clean-text \\\"bad ugly wrong text\\\"))     ; \\u2192 \\\"good pretty right text\\\"\\n```\\n\\n#### String Predicates\\n```aifpl\\n(string-contains? \\\"hello world\\\" \\\"world\\\")  ; \\u2192 #t\\n(string-prefix? \\\"hello\\\" \\\"he\\\")             ; \\u2192 #t\\n(string-suffix? \\\"hello\\\" \\\"lo\\\")             ; \\u2192 #t\\n(string=? \\\"hello\\\" \\\"hello\\\")                ; \\u2192 #t\\n(string=? \\\"hello\\\" \\\"world\\\")                ; \\u2192 #f\\n```\\n\\n### String-List Integration\\n\\n#### String-List Conversion\\n```aifpl\\n(string->list \\\"hello\\\")                ; \\u2192 (\\\"h\\\" \\\"e\\\" \\\"l\\\" \\\"l\\\" \\\"o\\\")\\n(list->string (list \\\"h\\\" \\\"e\\\" \\\"l\\\" \\\"l\\\" \\\"o\\\"))  ; \\u2192 \\\"hello\\\"\\n```\\n\\n#### String Splitting and Joining\\n```aifpl\\n(string-split \\\"name,age,city\\\" \\\",\\\")    ; \\u2192 (\\\"name\\\" \\\"age\\\" \\\"city\\\")\\n(string-split \\\"hello world\\\" \\\" \\\")      ; \\u2192 (\\\"hello\\\" \\\"world\\\")\\n(string-join (list \\\"hello\\\" \\\"world\\\") \\\" \\\")  ; \\u2192 \\\"hello world\\\"\\n(string-join (list \\\"a\\\" \\\"b\\\" \\\"c\\\") \\\",\\\") ; \\u2192 \\\"a,b,c\\\"\\n```\\n\\n### String Literals and Escape Sequences\\n\\nString literals use double quotes and support escape sequences:\\n\\n```aifpl\\n\\\"hello world\\\"                         ; Basic string\\n\\\"She said \\\\\\\"Hello!\\\\\\\"\\\"                 ; Escaped quotes\\n\\\"Line 1\\\\nLine 2\\\"                      ; Newline\\n\\\"Column 1\\\\tColumn 2\\\"                  ; Tab\\n\\\"Path\\\\\\\\to\\\\\\\\file\\\"                      ; Backslash\\n\\\"Unicode: \\\\u03B1\\\\u03B2\\\\u03B3\\\"         ; Greek letters \\u03b1\\u03b2\\u03b3\\n```\\n\\n**Supported escape sequences:**\\n- `\\\\\\\"` \\u2192 literal quote\\n- `\\\\\\\\` \\u2192 literal backslash\\n- `\\\\n` \\u2192 newline\\n- `\\\\t` \\u2192 tab\\n- `\\\\r` \\u2192 carriage return\\n- `\\\\uXXXX` \\u2192 Unicode code point (4 hex digits)\\n\\n### Association Lists (Alists)\\n\\nAssociation lists (alists) are immutable key-value mappings with O(1) lookup performance. They are first-class data structures optimized for structured data processing.\\n\\n#### Creating Alists\\n\\n```aifpl\\n; Basic alist creation\\n(alist (\\\"name\\\" \\\"Alice\\\") (\\\"age\\\" 30) (\\\"city\\\" \\\"NYC\\\"))\\n; \\u2192 (alist (\\\"name\\\" \\\"Alice\\\") (\\\"age\\\" 30) (\\\"city\\\" \\\"NYC\\\"))\\n\\n; Empty alist\\n(alist)\\n; \\u2192 (alist)\\n\\n; Alists with different key types\\n(alist (1 \\\"one\\\") (2 \\\"two\\\") (3 \\\"three\\\"))\\n(alist (#t \\\"yes\\\") (#f \\\"no\\\"))\\n\\n; Nested alists\\n(alist \\n  (\\\"user\\\" (alist (\\\"name\\\" \\\"Bob\\\") (\\\"id\\\" 123)))\\n  (\\\"status\\\" \\\"active\\\"))\\n```\\n\\n**Note**: `alist` is a special form that evaluates the key and value expressions within each pair, but treats the pair structure itself as data.\\n\\n#### Accessing Alist Values\\n\\n```aifpl\\n; Get value by key\\n(let ((person (alist (\\\"name\\\" \\\"Alice\\\") (\\\"age\\\" 30))))\\n  (alist-get person \\\"name\\\"))\\n; \\u2192 \\\"Alice\\\"\\n\\n; Get with default value\\n(alist-get person \\\"email\\\" \\\"no-email\\\")\\n; \\u2192 \\\"no-email\\\"\\n\\n; Missing keys return #f by default\\n(alist-get person \\\"phone\\\")\\n; \\u2192 #f\\n\\n; Nested access\\n(let ((data (alist (\\\"user\\\" (alist (\\\"name\\\" \\\"Carol\\\") (\\\"id\\\" 456))))))\\n  (alist-get (alist-get data \\\"user\\\") \\\"name\\\"))\\n; \\u2192 \\\"Carol\\\"\\n```\\n\\n#### Modifying Alists (Immutably)\\n\\nAll alist operations return new alists without modifying the original:\\n\\n```aifpl\\n; Set a key (returns new alist)\\n(let ((person (alist (\\\"name\\\" \\\"Alice\\\") (\\\"age\\\" 30))))\\n  (alist-set person \\\"age\\\" 31))\\n; \\u2192 (alist (\\\"name\\\" \\\"Alice\\\") (\\\"age\\\" 31))\\n\\n; Add a new key\\n(alist-set person \\\"email\\\" \\\"alice@example.com\\\")\\n; \\u2192 (alist (\\\"name\\\" \\\"Alice\\\") (\\\"age\\\" 30) (\\\"email\\\" \\\"alice@example.com\\\"))\\n\\n; Original is unchanged\\n(let ((original (alist (\\\"x\\\" 1)))\\n      (modified (alist-set original \\\"x\\\" 2)))\\n  (list (alist-get original \\\"x\\\") (alist-get modified \\\"x\\\")))\\n; \\u2192 (1 2)\\n\\n; Remove a key\\n(alist-remove person \\\"age\\\")\\n; \\u2192 (alist (\\\"name\\\" \\\"Alice\\\"))\\n```\\n\\n#### Alist Queries\\n\\n```aifpl\\n; Check if key exists\\n(alist-has? person \\\"name\\\")\\n; \\u2192 #t\\n\\n(alist-has? person \\\"phone\\\")\\n; \\u2192 #f\\n\\n; Get all keys\\n(alist-keys (alist (\\\"a\\\" 1) (\\\"b\\\" 2) (\\\"c\\\" 3)))\\n; \\u2192 (\\\"a\\\" \\\"b\\\" \\\"c\\\")\\n\\n; Get all values\\n(alist-values (alist (\\\"a\\\" 1) (\\\"b\\\" 2) (\\\"c\\\" 3)))\\n; \\u2192 (1 2 3)\\n\\n; Type checking\\n(alist? (alist (\\\"x\\\" 1)))\\n; \\u2192 #t\\n\\n(alist? (list 1 2 3))\\n; \\u2192 #f\\n```\\n\\n#### Merging Alists\\n\\n```aifpl\\n; Merge two alists (second wins on conflicts)\\n(let ((defaults (alist (\\\"port\\\" 8080) (\\\"host\\\" \\\"localhost\\\")))\\n      (config (alist (\\\"port\\\" 3000) (\\\"debug\\\" #t))))\\n  (alist-merge defaults config))\\n; \\u2192 (alist (\\\"port\\\" 3000) (\\\"host\\\" \\\"localhost\\\") (\\\"debug\\\" #t))\\n\\n; Merge multiple alists\\n(let ((a (alist (\\\"x\\\" 1)))\\n      (b (alist (\\\"y\\\" 2)))\\n      (c (alist (\\\"z\\\" 3))))\\n  (alist-merge (alist-merge a b) c))\\n; \\u2192 (alist (\\\"x\\\" 1) (\\\"y\\\" 2) (\\\"z\\\" 3))\\n```\\n\\n#### Alists with Functional Operations\\n\\n```aifpl\\n; Map over keys\\n(let ((data (alist (\\\"name\\\" \\\"alice\\\") (\\\"city\\\" \\\"nyc\\\"))))\\n  (map string-upcase (alist-keys data)))\\n; \\u2192 (\\\"NAME\\\" \\\"CITY\\\")\\n\\n; Filter values\\n(let ((scores (alist (\\\"alice\\\" 85) (\\\"bob\\\" 92) (\\\"carol\\\" 78))))\\n  (filter (lambda (score) (> score 80)) (alist-values scores)))\\n; \\u2192 (85 92)\\n\\n; Fold over values\\n(let ((prices (alist (\\\"apple\\\" 1.5) (\\\"banana\\\" 0.8) (\\\"orange\\\" 1.2))))\\n  (fold + 0 (alist-values prices)))\\n; \\u2192 3.5\\n\\n; Process list of alists\\n(let ((people (list \\n                (alist (\\\"name\\\" \\\"Alice\\\") (\\\"age\\\" 30))\\n                (alist (\\\"name\\\" \\\"Bob\\\") (\\\"age\\\" 25))\\n                (alist (\\\"name\\\" \\\"Carol\\\") (\\\"age\\\" 35)))))\\n  (map (lambda (p) (alist-get p \\\"name\\\")) people))\\n; \\u2192 (\\\"Alice\\\" \\\"Bob\\\" \\\"Carol\\\")\\n```\\n\\n#### Pattern Matching with Alists\\n\\n```aifpl\\n; Match alist type\\n(match (alist (\\\"type\\\" \\\"user\\\") (\\\"name\\\" \\\"Alice\\\"))\\n  ((alist? data) (alist-get data \\\"name\\\"))\\n  (_ \\\"not-alist\\\"))\\n; \\u2192 \\\"Alice\\\"\\n\\n; Distinguish alist from list\\n(let ((process (lambda (data)\\n                 (match data\\n                   ((alist? a) \\\"alist\\\")\\n                   ((list? l) \\\"list\\\")\\n                   (_ \\\"other\\\")))))\\n  (list (process (alist (\\\"a\\\" 1)))\\n        (process (list 1 2 3))))\\n; \\u2192 (\\\"alist\\\" \\\"list\\\")\\n```\\n\\n#### Alist Performance\\n\\nAlists in AIFPL use hash-backed storage for O(1) lookup performance:\\n\\n- `alist-get`: O(1) - constant time lookup\\n- `alist-set`: O(n) - creates new alist with updated value\\n- `alist-has?`: O(1) - constant time membership test\\n- `alist-keys`/`alist-values`: O(n) - iterates all pairs\\n- `alist-merge`: O(n+m) - combines two alists\\n\\nAlists maintain insertion order and are optimized for read-heavy workloads common in data processing.\\n\\n### Complex Number Operations\\nThe `real` and `imag` functions extract components from any numeric value:\\n\\n**Real Part Extraction:**\\n```aifpl\\n(real 42)              ; \\u2192 42\\n(real 3.14)            ; \\u2192 3.14\\n(real (complex 3 4))   ; \\u2192 3\\n(real j)               ; \\u2192 0\\n```\\n\\n**Imaginary Part Extraction:**\\n```aifpl\\n(imag 42)              ; \\u2192 0\\n(imag 3.14)            ; \\u2192 0\\n(imag (complex 3 4))   ; \\u2192 4\\n(imag j)               ; \\u2192 1\\n```\\n\\n**With Expressions:**\\n```aifpl\\n(real (+ (complex 1 2) (complex 3 4)))  ; \\u2192 4\\n(imag (sqrt -1))                        ; \\u2192 1\\n(real (* j j))                          ; \\u2192 -1\\n```\\n\\n## Type System\\n\\nAIFPL has a strict type system with the following types:\\n\\n- **Numbers**: `int`, `float`, `complex` (with automatic promotion)\\n- **Strings**: UTF-8 strings with no automatic conversion\\n- **Booleans**: `#t` and `#f` with no automatic conversion\\n- **Lists**: Heterogeneous collections supporting any element type\\n- **Functions**: First-class lambda functions with lexical scoping\\n\\n### Type Promotion Rules\\n\\n1. **Numeric promotion**: `int \\u2192 float \\u2192 complex`\\n2. **No cross-type operations**: Strings, booleans, and lists don't mix with numbers\\n3. **Explicit conversion**: Use conversion functions when needed\\n4. **List heterogeneity**: Lists can contain mixed types\\n5. **Function values**: Functions are first-class values that can be stored and passed\\n\\n### Examples of Type Strictness\\n\\n```aifpl\\n; Valid - same types\\n(+ 1 2 3)                             ; \\u2192 6 (all integers)\\n(string-append \\\"hello\\\" \\\" \\\" \\\"world\\\")   ; \\u2192 \\\"hello world\\\" (all strings)\\n(and #t #f #t)                        ; \\u2192 #f (all booleans)\\n\\n; Valid - numeric promotion\\n(+ 1 2.5)                             ; \\u2192 3.5 (int promoted to float)\\n(* 2 (complex 1 1))                   ; \\u2192 (2+2j) (promoted to complex)\\n\\n; Valid - heterogeneous lists\\n(list 1 \\\"hello\\\" #t)                   ; \\u2192 (1 \\\"hello\\\" #t)\\n(append (list 1 2) (list \\\"a\\\" \\\"b\\\"))    ; \\u2192 (1 2 \\\"a\\\" \\\"b\\\")\\n\\n; Valid - list equality\\n(= (list 1 2) (list 1 2))             ; \\u2192 #t\\n\\n; Valid - conditionals with boolean conditions\\n(if #t \\\"yes\\\" \\\"no\\\")                    ; \\u2192 \\\"yes\\\"\\n(if (> 5 3) 42 0)                     ; \\u2192 42\\n\\n; Valid - functions as values\\n(let ((f (lambda (x) (* x 2)))) (f 5))  ; \\u2192 10\\n(list (lambda (x) (+ x 1)) (lambda (x) (* x 2)))  ; \\u2192 (<lambda (x)> <lambda (x)>)\\n\\n; Valid - type checking with predicates\\n(if (number? x) (* x 2) \\\"not a number\\\")\\n(filter string? (list 1 \\\"hello\\\" #t \\\"world\\\"))  ; \\u2192 (\\\"hello\\\" \\\"world\\\")\\n\\n; Valid - quote for data literals (both forms)\\n(quote (+ 1 2 3))                     ; \\u2192 (+ 1 2 3) (as data, not evaluation)\\n'(+ 1 2 3)                            ; \\u2192 (+ 1 2 3) (shortcut form)\\n(list (quote hello) (+ 1 2))          ; \\u2192 (hello 3) (mixed quoted/unquoted)\\n(list 'hello (+ 1 2))                 ; \\u2192 (hello 3) (shortcut form)\\n\\n; Valid - pattern matching\\n(match 42\\n  ((number? n) (* n 2))\\n  (_ \\\"not a number\\\"))                 ; \\u2192 84\\n\\n; Invalid - type mismatch\\n(+ 1 \\\"hello\\\")                         ; Error: cannot add number and string\\n(and #t 1)                            ; Error: 'and' requires boolean arguments\\n(string-length 42)                    ; Error: string-length requires string\\n(+ (list 1 2))                        ; Error: cannot add list\\n(< (list 1) (list 2))                 ; Error: cannot compare lists (only = works)\\n(if 1 \\\"yes\\\" \\\"no\\\")                     ; Error: condition must be boolean\\n\\n; Valid - explicit conversion\\n(string-append \\\"Count: \\\" (number->string 42))  ; \\u2192 \\\"Count: 42\\\"\\n(+ 5 (string->number \\\"10\\\"))                    ; \\u2192 15\\n(list->string (string->list \\\"hello\\\"))          ; \\u2192 \\\"hello\\\"\\n```\\n\\n### List Type Rules\\n\\n1. **Mixed types allowed**: `(list 1 \\\"hi\\\" #t)` is valid\\n2. **No arithmetic operations**: `(+ (list 1 2))` is an error\\n3. **Only equality comparison**: `(= (list 1) (list 1))` works, `(< (list 1) (list 2))` doesn't\\n4. **Type-specific functions**: List functions require lists, string functions require strings\\n5. **Explicit conversion**: Use `string->list`, `list->string` for conversions\\n\\n### Function Type Rules\\n\\n1. **First-class values**: Functions can be passed, returned, stored in lists\\n2. **Lexical scoping**: Functions access variables from their definition environment\\n3. **Closures**: Functions capture their environment when created\\n4. **Arity checking**: Function calls must provide exact number of parameters\\n5. **Identity equality**: Each lambda creates a unique function object\\n\\n## Pure List Representation Benefits\\n\\nThe pure list approach provides several advantages:\\n\\n1. **True homoiconicity**: Code and data have identical representation\\n2. **Simpler architecture**: Only `AIFPLValue` types, no special AST nodes\\n3. **Traditional Lisp semantics**: Everything is data, following Lisp philosophy\\n4. **Easier to understand**: One consistent representation for all expressions\\n5. **Future extensibility**: Natural foundation for features like macros\\n6. **Reduced complexity**: Fewer types, simpler parser, more straightforward evaluator\\n\\n### Internal Representation Examples\\n\\n```aifpl\\n; Lambda expression: (lambda (x) (* x x))\\n; Represented as: AIFPLList([AIFPLSymbol(\\\"lambda\\\"), AIFPLList([AIFPLSymbol(\\\"x\\\")]), AIFPLList([...])])\\n\\n; Let expression: (let ((x 5)) (+ x 1))\\n; Represented as: AIFPLList([AIFPLSymbol(\\\"let\\\"), AIFPLList([AIFPLList([...])]), ...])\\n\\n; Function call: (+ 1 2 3)\\n; Represented as: AIFPLList([AIFPLSymbol(\\\"+\\\"), AIFPLNumber(1), AIFPLNumber(2), AIFPLNumber(3)])\\n\\n; Quote expression: (quote (+ 1 2))\\n; Represented as: AIFPLList([AIFPLSymbol(\\\"quote\\\"), AIFPLList([AIFPLSymbol(\\\"+\\\"), AIFPLNumber(1), AIFPLNumber(2)])])\\n\\n; Single quote shortcut: '(+ 1 2)\\n; Represented as: AIFPLList([AIFPLSymbol(\\\"quote\\\"), AIFPLList([AIFPLSymbol(\\\"+\\\"), AIFPLNumber(1), AIFPLNumber(2)])])\\n; (Identical to the full quote form - the shortcut is purely syntactic sugar)\\n\\n; Match expression: (match x ((number? n) (* n 2)) (_ \\\"not a number\\\"))\\n; Represented as: AIFPLList([AIFPLSymbol(\\\"match\\\"), AIFPLSymbol(\\\"x\\\"), AIFPLList([...]), ...])\\n```\\n\\nThe evaluator recognizes special forms by examining the first element of lists, maintaining the traditional Lisp approach where syntax is determined by structure, not by special types.\\n\\n## Common Usage Patterns\\n\\n### Pattern Matching for Data Processing\\n```aifpl\\n; Replace complex nested conditionals with pattern matching\\n(let ((process-data (lambda (item)\\n                      (match item\\n                        ((\\\"user\\\" name email) \\n                         (string-append \\\"User: \\\" name \\\" (\\\" email \\\")\\\"))\\n                        ((\\\"product\\\" id price)\\n                         (string-append \\\"Product #\\\" (number->string id) \\\": $\\\" (number->string price)))\\n                        ((\\\"order\\\" id items total)\\n                         (string-append \\\"Order #\\\" (number->string id) \\\" (\\\" \\n                                      (number->string (length items)) \\\" items): $\\\" \\n                                      (number->string total)))\\n                        (_ \\\"unknown data type\\\")))))\\n  (map process-data (list (list \\\"user\\\" \\\"Alice\\\" \\\"alice@example.com\\\")\\n                         (list \\\"product\\\" 123 29.99)\\n                         (list \\\"order\\\" 456 (list \\\"item1\\\" \\\"item2\\\") 59.98)\\n                         (list \\\"invalid\\\" \\\"data\\\"))))\\n; \\u2192 (\\\"User: Alice (alice@example.com)\\\" \\\"Product #123: $29.99\\\" \\\"Order #456 (2 items): $59.98\\\" \\\"unknown data type\\\")\\n\\n; Type-based processing with pattern matching\\n(let ((safe-operation (lambda (x y)\\n                        (match (list x y)\\n                          (((number? a) (number? b)) (+ a b))\\n                          (((string? a) (string? b)) (string-append a \\\" \\\" b))\\n                          (((list? a) (list? b)) (append a b))\\n                          (_ \\\"incompatible types\\\")))))\\n  (list (safe-operation 5 10)\\n        (safe-operation \\\"hello\\\" \\\"world\\\")\\n        (safe-operation (list 1 2) (list 3 4))\\n        (safe-operation 5 \\\"hello\\\")))\\n; \\u2192 (15 \\\"hello world\\\" (1 2 3 4) \\\"incompatible types\\\")\\n\\n; Configuration parsing with patterns\\n(let ((parse-config (lambda (config-list)\\n                      (map (lambda (item)\\n                             (match item\\n                               ((\\\"server\\\" host port)\\n                                (list \\\"server-config\\\" host port))\\n                               ((\\\"database\\\" type connection-string)\\n                                (list \\\"db-config\\\" type connection-string))\\n                               ((\\\"feature\\\" name enabled)\\n                                (list \\\"feature-toggle\\\" name enabled))\\n                               (_ (list \\\"unknown-config\\\" item))))\\n                           config-list))))\\n  (parse-config (list (list \\\"server\\\" \\\"localhost\\\" 8080)\\n                     (list \\\"database\\\" \\\"postgresql\\\" \\\"postgres://localhost/mydb\\\")\\n                     (list \\\"feature\\\" \\\"new-ui\\\" #t)\\n                     (list \\\"invalid\\\" \\\"config\\\" \\\"entry\\\"))))\\n; \\u2192 ((\\\"server-config\\\" \\\"localhost\\\" 8080) (\\\"db-config\\\" \\\"postgresql\\\" \\\"postgres://localhost/mydb\\\") (\\\"feature-toggle\\\" \\\"new-ui\\\" #t) (\\\"unknown-config\\\" (\\\"invalid\\\" \\\"config\\\" \\\"entry\\\")))\\n```\\n\\n### Symbolic Programming with Quote\\n```aifpl\\n; Store and manipulate code as data (using shortcuts for cleaner syntax)\\n(let ((expressions (list '(+ 1 2)\\n                        '(* 3 4)\\n                        '(- 10 5))))\\n  (map first expressions))                  ; \\u2192 (+ * -) (extract operators)\\n\\n; Template-based programming (shortcuts make templates more readable)\\n(let ((make-comparison (lambda (op value)\\n                         (list 'lambda\\n                              '(x)\\n                              (list op 'x value)))))\\n  (list (make-comparison '> 10)\\n        (make-comparison '= 0)))            ; \\u2192 ((lambda (x) (> x 10)) (lambda (x) (= x 0)))\\n\\n; Code transformation (shortcuts improve readability)\\n(let ((negate-condition (lambda (expr)\\n                          (if (and (list? expr) (= (first expr) '>))\\n                              (cons '<= (rest expr))\\n                              expr))))\\n  (negate-condition '(> x 5)))              ; \\u2192 (<= x 5)\\n```\\n\\n### Functional Data Processing\\n```aifpl\\n; Process list of numbers\\n(let ((numbers (list 1 2 3 4 5 6 7 8 9 10)))\\n  (let ((evens (filter (lambda (x) (= (% x 2) 0)) numbers))\\n        (doubled (map (lambda (x) (* x 2)) evens))\\n        (sum (fold + 0 doubled)))\\n    sum))                                   ; \\u2192 60\\n\\n; Text processing pipeline\\n(let ((text \\\"The quick brown fox jumps\\\"))\\n  (let ((words (string-split text \\\" \\\"))\\n        (long-words (filter (lambda (w) (> (string-length w) 3)) words))\\n        (upper-words (map string-upcase long-words)))\\n    (string-join upper-words \\\"-\\\")))         ; \\u2192 \\\"QUICK-BROWN-JUMPS\\\"\\n\\n; Data validation and transformation\\n(let ((validate-and-double (lambda (nums)\\n                            (if (all? (lambda (x) (> x 0)) nums)\\n                                (map (lambda (x) (* x 2)) nums)\\n                                \\\"error: negative numbers\\\"))))\\n  (list (validate-and-double (list 1 2 3))\\n        (validate-and-double (list 1 -2 3))))  ; \\u2192 ((2 4 6) \\\"error: negative numbers\\\")\\n```\\n\\n### Conditional Processing\\n```aifpl\\n; Safe division\\n(if (= divisor 0) \\\"undefined\\\" (/ dividend divisor))\\n\\n; Safe list access\\n(if (null? my-list) \\\"empty\\\" (first my-list))\\n\\n; Data validation\\n(if (string-contains? input \\\"@\\\")\\n    (string-append \\\"Email: \\\" input)\\n    \\\"Invalid email format\\\")\\n\\n; Conditional list processing\\n(if (> (length items) 0)\\n    (string-join items \\\", \\\")\\n    \\\"No items\\\")\\n\\n; Nested conditionals for complex logic\\n(if (> temperature 30)\\n    \\\"hot\\\"\\n    (if (> temperature 20) \\\"warm\\\" \\\"cold\\\"))\\n```\\n\\n### Function Composition and Higher-Order Patterns\\n```aifpl\\n; Create reusable transformations\\n(let ((process-data (lambda (data)\\n                      (let ((clean (filter (lambda (x) (> x 0)) data))\\n                            (transformed (map (lambda (x) (+ (* x x) 1)) clean))\\n                            (limited (take 5 transformed)))\\n                        limited))))\\n  (process-data (list -1 2 3 -4 5 6 7 8)))  ; \\u2192 (5 10 26 37 50)\\n\\n; Build complex predicates\\n(let ((in-range (lambda (min max)\\n                  (lambda (x) (and (>= x min) (<= x max)))))\\n      (is-even (lambda (x) (= (% x 2) 0))))\\n  (let ((even-in-range (lambda (x) (and (is-even x) ((in-range 10 50) x)))))\\n    (filter even-in-range (range 1 60))))   ; \\u2192 (10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50)\\n\\n; Recursive data structures\\n(let ((tree-sum (lambda (tree)\\n                  (if (list? tree)\\n                      (fold + 0 (map tree-sum tree))\\n                      tree))))\\n  (tree-sum (list 1 (list 2 3) (list (list 4 5) 6))))  ; \\u2192 21\\n```\\n\\n### Type-Safe Programming Patterns\\n```aifpl\\n; Polymorphic function with type checking\\n(let ((safe-process (lambda (value)\\n                      (if (number? value)\\n                          (* value value)\\n                          (if (string? value)\\n                              (string-upcase value)\\n                              (if (list? value)\\n                                  (length value)\\n                                  \\\"unknown type\\\"))))))\\n  (map safe-process (list 5 \\\"hello\\\" (list 1 2 3) #t)))  ; \\u2192 (25 \\\"HELLO\\\" 3 \\\"unknown type\\\")\\n\\n; Type validation pipeline\\n(let ((validate-input (lambda (data)\\n                        (if (list? data)\\n                            (if (all? number? data)\\n                                (fold + 0 data)\\n                                \\\"error: non-numeric data\\\")\\n                            \\\"error: not a list\\\"))))\\n  (list (validate-input (list 1 2 3))        ; \\u2192 6\\n        (validate-input (list 1 \\\"x\\\" 3))      ; \\u2192 \\\"error: non-numeric data\\\"\\n        (validate-input \\\"not a list\\\")))      ; \\u2192 \\\"error: not a list\\\"\\n\\n; Mixed type list processing\\n(let ((categorize (lambda (items)\\n                    (let ((numbers (filter number? items))\\n                          (strings (filter string? items))\\n                          (booleans (filter boolean? items)))\\n                      (list (list \\\"numbers\\\" numbers)\\n                            (list \\\"strings\\\" strings)\\n                            (list \\\"booleans\\\" booleans))))))\\n  (categorize (list 1 \\\"hello\\\" #t 3.14 \\\"world\\\" #f)))\\n; \\u2192 ((\\\"numbers\\\" (1 3.14)) (\\\"strings\\\" (\\\"hello\\\" \\\"world\\\")) (\\\"booleans\\\" (#t #f)))\\n```\\n\\n### String Processing\\n```aifpl\\n; Split CSV data and process\\n(string-split \\\"name,age,city\\\" \\\",\\\")              ; \\u2192 (\\\"name\\\" \\\"age\\\" \\\"city\\\")\\n(first (string-split \\\"John,25,NYC\\\" \\\",\\\"))        ; \\u2192 \\\"John\\\"\\n(length (string-split \\\"a,b,c,d\\\" \\\",\\\"))           ; \\u2192 4\\n\\n; Build strings from components\\n(string-join (list \\\"hello\\\" \\\"world\\\") \\\" \\\")        ; \\u2192 \\\"hello world\\\"\\n(string-join (reverse (string-split \\\"a-b-c\\\" \\\"-\\\")) \\\"+\\\")  ; \\u2192 \\\"c+b+a\\\"\\n\\n; Conditional string processing\\n(if (> (string-length text) 10)\\n    (string-append (substring text 0 10) \\\"...\\\")\\n    text)\\n\\n; Advanced text processing\\n(let ((clean-and-format (lambda (text)\\n                          (let ((trimmed (string-trim text))\\n                                (normalized (string-replace trimmed \\\"  \\\" \\\" \\\")))\\n                            (string-upcase normalized)))))\\n  (clean-and-format \\\"  hello    world  \\\"))      ; \\u2192 \\\"HELLO  WORLD\\\"\\n```\\n\\n### Character-Level Processing\\n```aifpl\\n; Convert to characters, process, convert back\\n(string->list \\\"hello\\\")                          ; \\u2192 (\\\"h\\\" \\\"e\\\" \\\"l\\\" \\\"l\\\" \\\"o\\\")\\n(reverse (string->list \\\"hello\\\"))                ; \\u2192 (\\\"o\\\" \\\"l\\\" \\\"l\\\" \\\"e\\\" \\\"h\\\")\\n(list->string (reverse (string->list \\\"hello\\\"))) ; \\u2192 \\\"olleh\\\"\\n```\\n\\n### Data Structure Manipulation\\n```aifpl\\n; Build complex data structures\\n(list (list \\\"name\\\" \\\"John\\\") (list \\\"age\\\" 25))     ; \\u2192 ((\\\"name\\\" \\\"John\\\") (\\\"age\\\" 25))\\n(first (list (list 1 2) (list 3 4)))            ; \\u2192 (1 2)\\n(rest (first (list (list 1 2 3) (list 4 5))))   ; \\u2192 (2 3)\\n\\n; Conditional data processing\\n(if (member? \\\"error\\\" status-list)\\n    (list \\\"status\\\" \\\"error\\\" \\\"failed\\\")\\n    (list \\\"status\\\" \\\"ok\\\" \\\"success\\\"))\\n\\n; Advanced list manipulation \\n(let ((data (list 1 2 3 2 4 2 5))\\n      (target 2))\\n  (let ((cleaned (remove target data))\\n        (position-info (position target data)))\\n    (list \\\"original\\\" data \\n          \\\"cleaned\\\" cleaned \\n          \\\"first-position\\\" position-info)))\\n; \\u2192 (\\\"original\\\" (1 2 3 2 4 2 5) \\\"cleaned\\\" (1 3 4 5) \\\"first-position\\\" 1)\\n```\\n\\n### Quote Shortcut Usage Patterns\\n```aifpl\\n; Building expressions with mixed quoted and evaluated parts\\n(let ((make-setter (lambda (var value)\\n                     (list 'let (list (list var value)) var))))\\n  (make-setter 'x 42))                      ; \\u2192 (let ((x 42)) x)\\n\\n; Code generation with templates\\n(let ((make-validator (lambda (type-pred error-msg)\\n                        '(lambda (value)\\n                           (if (,type-pred value)\\n                               value\\n                               ,error-msg)))))\\n  ; Note: This is conceptual - actual implementation would need more complex quasiquoting\\n  (make-validator 'number? \\\"not a number\\\"))\\n\\n; Data-driven programming\\n(let ((operations '((add +) (multiply *) (subtract -))))\\n  (map (lambda (op) (first (rest op))) operations))  ; \\u2192 (+ * -)\\n\\n; Pattern matching simulation\\n(let ((match-expr (lambda (pattern expr)\\n                    (if (= (first pattern) (first expr))\\n                        'match\\n                        'no-match))))\\n  (list (match-expr '(+ ? ?) '(+ 1 2))     ; \\u2192 match\\n        (match-expr '(+ ? ?) '(* 1 2))))   ; \\u2192 no-match\\n```\\n\\n## Advanced Features\\n\\n### Tail Call Optimization\\n\\nAIFPL automatically optimizes tail calls to prevent stack overflow in recursive functions:\\n\\n```aifpl\\n; Factorial with tail recursion (automatically optimized)\\n(let ((factorial (lambda (n acc)\\n                   (if (<= n 1)\\n                       acc\\n                       (factorial (- n 1) (* n acc))))))\\n  (factorial 1000 1))                       ; Works with large numbers\\n\\n; Mutual recursion is also optimized\\n(let ((is-even (lambda (n)\\n                 (if (= n 0) #t (is-odd (- n 1)))))\\n      (is-odd (lambda (n)\\n                (if (= n 0) #f (is-even (- n 1))))))\\n  (is-even 10000))                          ; \\u2192 #t (no stack overflow)\\n```\\n\\n### Lexical Scoping and Closures\\n\\nFunctions capture their lexical environment, creating closures:\\n\\n```aifpl\\n; Function factory with captured state\\n(let ((make-adder (lambda (increment)\\n                    (lambda (x) (+ x increment)))))\\n  (let ((add-five (make-adder 5))\\n        (add-ten (make-adder 10)))\\n    (list (add-five 3) (add-ten 3))))      ; \\u2192 (8 13)\\n\\n; Nested closures capturing multiple levels\\n(let ((outer-value 100))\\n  (let ((make-calculator (lambda (operation)\\n                           (lambda (x y)\\n                             (operation (+ x outer-value) y)))))\\n    (let ((multiply-with-offset (make-calculator *))\\n          (add-with-offset (make-calculator +)))\\n      (list (multiply-with-offset 2 3)     ; \\u2192 (102 * 3) = 306\\n            (add-with-offset 5 10)))))     ; \\u2192 (105 + 10) = 115\\n```\\n\\n### Error Handling Patterns\\n\\n```aifpl\\n; Validation chains\\n(let ((validate-number (lambda (x)\\n                         (if (> x 0) x \\\"error: not positive\\\")))\\n      (validate-range (lambda (x)\\n                        (if (and (>= x 1) (<= x 100)) x \\\"error: out of range\\\"))))\\n  (let ((process (lambda (x)\\n                   (let ((step1 (validate-number x)))\\n                     (if (string? step1)\\n                         step1\\n                         (validate-range step1))))))\\n    (list (process 50) (process -5) (process 150))))  ; \\u2192 (50 \\\"error: not positive\\\" \\\"error: out of range\\\")\\n\\n; Safe operations with defaults\\n(let ((safe-head (lambda (lst default)\\n                   (if (null? lst) default (first lst))))\\n      (safe-tail (lambda (lst default)\\n                   (if (null? lst) default (last lst))))\\n      (safe-divide (lambda (x y default)\\n                     (if (= y 0) default (/ x y)))))\\n  (list (safe-head (list) \\\"empty\\\")\\n        (safe-tail (list 1 2 3) \\\"empty\\\")\\n        (safe-divide 10 0 \\\"undefined\\\")))    ; \\u2192 (\\\"empty\\\" 3 \\\"undefined\\\")\\n```\\n\\n## Differences from Traditional Lisp/Scheme\\n\\n**AIFPL uses proper lists only, not cons cells.** This is a fundamental difference from traditional Lisp/Scheme that affects list construction and pattern matching.\\n\\n### Key Differences\\n\\n#### 1. Cons Requires a List as Second Argument\\n\\n**Traditional Lisp/Scheme:**\\n```scheme\\n(cons 1 2)              ; => (1 . 2)  - creates a dotted pair\\n(cons 1 (cons 2 3))     ; => (1 2 . 3) - creates an improper list\\n```\\n\\n**AIFPL:**\\n```aifpl\\n(cons 1 (list 2 3))     ; => (1 2 3)  \\u2713 Valid - second arg is a list\\n(cons 1 (list 2))       ; => (1 2)    \\u2713 Valid\\n(cons 1 2)              ; => ERROR    \\u2717 Invalid - second arg must be a list!\\n```\\n\\n**Why?** AIFPL lists are backed by Python tuples. All lists are proper lists - there are no dotted pairs or improper lists. This makes the language simpler and more predictable.\\n\\n**To create pairs:** Use `(list a b)` instead of cons cells.\\n\\n#### 2. Rest Always Returns a List\\n\\n**Traditional Lisp/Scheme:**\\n```scheme\\n(cdr '(1))        ; => ()  - empty list\\n(cdr '(1 . 2))    ; => 2   - can return an atom!\\n```\\n\\n**AIFPL:**\\n```aifpl\\n(rest (list 1))         ; => ()     - always returns a list\\n(rest (list 1 2))       ; => (2)    - always returns a list\\n; No way to get an atom from rest\\n```\\n\\n**Why?** This guarantees type safety. You always know `rest` returns a list, never an atom.\\n\\n#### 3. Pattern Matching: Tail is Always a List\\n\\n**Traditional Lisp/Scheme:**\\n```scheme\\n(match '(1 . 2) ((h . t) t))    ; => 2   - t binds to atom\\n(match '(1 2) ((h . t) t))      ; => (2) - t binds to list\\n```\\n\\n**AIFPL:**\\n```aifpl\\n(match (list 1 2) ((h . t) t))      ; => (2)  - t is always a list\\n(match (list 1) ((h . t) t))        ; => ()   - t is empty list, not atom\\n```\\n\\n**Why?** Consistency. The `(head . tail)` pattern always binds `tail` to a list (possibly empty), never to an atom.\\n\\n#### 4. No car/cdr - Use first/rest\\n\\nAIFPL uses more descriptive names:\\n- `first` instead of `car`\\n- `rest` instead of `cdr`\\n- `last` for the last element\\n\\nThese names are clearer and emphasize that `rest` always returns a list.\\n\\n### Other Differences from Scheme/Lisp\\n\\n- **No mutation**: No `set!`, `set-car!`, `set-cdr!` - all data is immutable\\n- **No macros**: No `define-syntax` or `defmacro` - all special forms are built-in\\n- **No global definitions**: No top-level `define` - use `let` for bindings\\n- **Strict type system**: Boolean operations require booleans, no \\\"truthy\\\" values\\n- **No continuations**: No `call/cc` - simpler execution model\\n\\n### Migration Guide\\n\\nIf you're coming from Scheme/Lisp:\\n\\n**Creating pairs:**\\n```aifpl\\n; Instead of: (cons 1 2)\\n(list 1 2)              ; Two-element list\\n```\\n\\n**Association lists:**\\n```aifpl\\n; Instead of: '((a . 1) (b . 2))\\n(list (list \\\"a\\\" 1) (list \\\"b\\\" 2))    ; List of two-element lists\\n```\\n\\n**Pattern matching:**\\n```aifpl\\n; Pattern (h . t) always binds t to a list\\n(match (list 1 2 3)\\n  ((h . t) (list h t)))             ; => (1 (2 3))  - t is (2 3), not 2 3\\n\\n; For fixed-length patterns, use explicit elements\\n(match (list 1 2)\\n  ((a b) (list a b)))               ; => (1 2)  - direct binding\\n```\\n\\n### Why These Differences?\\n\\n1. **Simplicity**: Proper lists only means fewer edge cases\\n2. **Type safety**: `rest` always returns a list - no runtime type checking needed\\n3. **Predictability**: Consistent behavior makes code easier to reason about\\n4. **AI-friendly**: Fewer special cases for AI models to learn\\n\\n## Design Principles\\n\\n1. **Pure List Representation**: Everything is data, following traditional Lisp philosophy\\n2. **Functional Programming**: First-class functions, immutable data, no side effects\\n3. **Lexical Scoping**: Variables resolved in their definition environment\\n4. **Tail Call Optimization**: Automatic optimization for recursive patterns\\n5. **Type Safety**: Comprehensive type hints and strict type checking\\n6. **Error Handling**: Detailed error messages with position information\\n7. **Performance**: Efficient evaluation with automatic optimizations\\n8. **LISP Compatibility**: Following traditional LISP semantics where applicable\\n9. **Lazy Evaluation**: Conditionals and boolean operators use lazy evaluation\\n10. **Independence**: No dependencies on external packages\\n11. **Simplicity**: Direct S-expression evaluation without over-engineering\\n12. **Homoiconicity**: Code and data use identical representations\\n13. **Syntactic Sugar**: Single quote shortcut provides convenient syntax while maintaining pure list representation\\n14. **Pattern Matching**: Comprehensive pattern matching for elegant data processing\\n15. **Proper Lists Only**: Lists are backed by Python tuples, no cons cells or improper lists for simplicity and type safety\\n\\n## Architecture\\n\\nAIFPL uses a **pure list representation** for all code, following traditional Lisp philosophy:\\n\\n- **Everything is data**: Code and data have identical representation (`AIFPLValue` objects)\\n- **No special AST nodes**: Lambda expressions, let expressions, and function calls are all just lists\\n- **Homoiconic**: The same data structures represent both code and data\\n- **Simple and consistent**: One unified representation for all expressions\\n\\n### Package Structure\\n\\n```plaintext\\nsrc/aifpl/\\n\\u251c\\u2500\\u2500 __init__.py              # Package exports\\n\\u251c\\u2500\\u2500 aifpl.py                 # Main AIFPL class (public API)\\n\\u251c\\u2500\\u2500 aifpl_error.py           # Exception classes\\n\\u251c\\u2500\\u2500 aifpl_token.py           # Token types and definitions\\n\\u251c\\u2500\\u2500 aifpl_tokenizer.py       # Tokenizer implementation\\n\\u251c\\u2500\\u2500 aifpl_parser.py          # Parser (creates AIFPLValue objects)\\n\\u251c\\u2500\\u2500 aifpl_evaluator.py       # Expression evaluator\\n\\u251c\\u2500\\u2500 aifpl_environment.py     # Environment and function management\\n\\u251c\\u2500\\u2500 aifpl_value.py           # Value hierarchy (AIFPLValue types)\\n\\u2514\\u2500\\u2500 aifpl_dependency_analyzer.py  # Let binding dependency analysis\\n```\\n\\n### Core Types\\n\\n- **AIFPLValue**: Base class for all values (numbers, strings, booleans, symbols, lists, functions)\\n\\n### Exception Hierarchy\\n\\n- `AIFPLError` - Base exception\\n  - `AIFPLTokenError` - Tokenization errors\\n  - `AIFPLParseError` - Parsing errors\\n  - `AIFPLEvalError` - Evaluation errors\\n\\n## Advanced Usage\\n\\n### Custom Configuration\\n\\n```python\\n# Increase recursion depth for deeply nested expressions\\ntool = AIFPL(max_depth=500)\\n\\n# Adjust tolerance for complex number simplification\\ntool = AIFPL(floating_point_tolerance=1e-15)\\n```\\n\\n### Working with Results\\n\\n```python\\n# Raw evaluation returns Python objects\\nresult = tool.evaluate('(list 1 2 3)')\\nprint(f\\\"Result: {result}\\\")  # Result: [1, 2, 3]\\nprint(f\\\"Type: {type(result)}\\\")  # Type: <class 'list'>\\n\\n# Formatted evaluation returns LISP-style strings\\nformatted = tool.evaluate_and_format('(list 1 2 3)')\\nprint(f\\\"Formatted: {formatted}\\\")  # Formatted: (1 2 3)\\n\\n# Function results\\nfunc_result = tool.evaluate('(lambda (x) (* x x))')\\nprint(f\\\"Function: {func_result}\\\")  # Function: <aifpl.aifpl_environment.AIFPLLambdaFunction object>\\n\\nformatted_func = tool.evaluate_and_format('(lambda (x) (* x x))')\\nprint(f\\\"Formatted Function: {formatted_func}\\\")  # Formatted Function: <lambda (x)>\\n\\n# Boolean results\\nbool_result = tool.evaluate('(member? 2 (list 1 2 3))')\\nprint(f\\\"Boolean: {bool_result}\\\")  # Boolean: True\\n\\nformatted_bool = tool.evaluate_and_format('(member? 2 (list 1 2 3))')\\nprint(f\\\"Formatted Boolean: {formatted_bool}\\\")  # Formatted Boolean: #t\\n\\ninequality_result = tool.evaluate('(!= 1 2 3)')\\nprint(f\\\"Inequality: {inequality_result}\\\")  # Inequality: True\\n\\ntype_check = tool.evaluate('(number? 42)')\\nprint(f\\\"Type check: {type_check}\\\")  # Type check: True\\n\\nposition_result = tool.evaluate('(position \\\"world\\\" (list \\\"hello\\\" \\\"world\\\"))')\\nprint(f\\\"Position: {position_result}\\\")  # Position: 1\\n\\n# Quote results (both forms produce identical results)\\nquote_result = tool.evaluate('(quote (+ 1 2 3))')\\nprint(f\\\"Quote result: {quote_result}\\\")  # Quote result: ['+', 1, 2, 3]\\n\\nshortcut_result = tool.evaluate(\\\"'(+ 1 2 3)\\\")\\nprint(f\\\"Shortcut result: {shortcut_result}\\\")  # Shortcut result: ['+', 1, 2, 3]\\n\\nformatted_quote = tool.evaluate_and_format('(quote (+ 1 2 3))')\\nprint(f\\\"Formatted quote: {formatted_quote}\\\")  # Formatted quote: (+ 1 2 3)\\n\\nformatted_shortcut = tool.evaluate_and_format(\\\"'(+ 1 2 3)\\\")\\nprint(f\\\"Formatted shortcut: {formatted_shortcut}\\\")  # Formatted shortcut: (+ 1 2 3)\\n\\n# Pattern matching results\\npattern_result = tool.evaluate('(match 42 ((number? n) (* n 2)) (_ \\\"not a number\\\"))')\\nprint(f\\\"Pattern match: {pattern_result}\\\")  # Pattern match: 84\\n\\ncomplex_pattern = tool.evaluate('(match (list 1 2 3) ((a b c) (+ a b c)) (_ \\\"no match\\\"))')\\nprint(f\\\"Complex pattern: {complex_pattern}\\\")  # Complex pattern: 6\\n```\\n\\n### Error Handling Patterns\\n\\n```python\\nfrom aifpl import AIFPL, AIFPLTokenError, AIFPLParseError, AIFPLEvalError\\n\\ntool = AIFPL()\\n\\ntry:\\n    result = tool.evaluate(expression)\\n\\nexcept AIFPLTokenError as e:\\n    print(f\\\"Tokenization error: {e}\\\")\\n\\nexcept AIFPLParseError as e:\\n    print(f\\\"Parsing error: {e}\\\")\\n\\nexcept AIFPLEvalError as e:\\n    print(f\\\"Evaluation error: {e}\\\")\\n\\nexcept AIFPLError as e:\\n    print(f\\\"General AIFPL error: {e}\\\")\\n```\\n\\n### Complex Functional Processing\\n\\n```python\\n# Complex nested operations with functional programming\\nfunctional_expr = '''\\n(let ((data (list 1 2 3 4 5 6 7 8 9 10)))\\n  (let ((process (lambda (nums)\\n                   (let ((evens (filter (lambda (x) (= (% x 2) 0)) nums))\\n                         (squares (map (lambda (x) (* x x)) evens))\\n                         (sum (fold + 0 squares)))\\n                     sum))))\\n    (process data)))\\n'''\\n\\n# Higher-order function composition\\ncomposition_expr = '''\\n(let ((compose (lambda (f g) (lambda (x) (f (g x)))))\\n      (add-one (lambda (x) (+ x 1)))\\n      (double (lambda (x) (* x 2))))\\n  (let ((transform (compose add-one double)))\\n    (map transform (list 1 2 3 4 5))))\\n'''\\n\\n# Recursive data processing with tail optimization\\nrecursive_expr = '''\\n(let ((factorial (lambda (n acc)\\n                   (if (<= n 1)\\n                       acc\\n                       (factorial (- n 1) (* n acc))))))\\n  (factorial 20 1))\\n'''\\n\\n# Quote-based symbolic programming (using shortcuts for cleaner syntax)\\nsymbolic_expr = '''\\n(let ((expressions (list '(+ 1 2)\\n                        '(* 3 4)\\n                        '(- 10 5))))\\n  (let ((operators (map first expressions))\\n        (operands (map rest expressions)))\\n    (list \\\"operators\\\" operators \\\"operands\\\" operands)))\\n'''\\n\\n# Pattern matching for data processing\\npattern_matching_expr = '''\\n(let ((process-items (lambda (items)\\n                       (map (lambda (item)\\n                              (match item\\n                                ((\\\"person\\\" name age) \\n                                 (string-append name \\\" (\\\" (number->string age) \\\")\\\"))\\n                                ((\\\"product\\\" id price)\\n                                 (string-append \\\"Product \\\" (number->string id) \\\": $\\\" (number->string price)))\\n                                (_ \\\"unknown item\\\")))\\n                            items))))\\n  (process-items (list (list \\\"person\\\" \\\"Alice\\\" 30)\\n                      (list \\\"product\\\" 123 29.99)\\n                      (list \\\"invalid\\\" \\\"data\\\"))))\\n'''\\n\\nadvanced_processing = '''\\n(let ((data (list \\\"  hello  \\\" \\\"WORLD\\\" \\\"test\\\" \\\"  EXAMPLE  \\\"))\\n      (clean-normalize (lambda (text)\\n                         (string-downcase (string-trim text)))))\\n  (let ((cleaned (map clean-normalize data))\\n        (filtered (remove \\\"test\\\" cleaned))\\n        (positions (map (lambda (item) \\n                          (position item cleaned)) \\n                       filtered)))\\n    (list \\\"cleaned\\\" cleaned \\\"filtered\\\" filtered \\\"positions\\\" positions)))\\n'''\\n```\\n\",\n  \"error\": null\n}\n```\n`content` is:\n```markdown\n# AIFPL (AI Functional Programming Language)\n\nAIFPL is a mathematical expression language with LISP-like S-expression syntax designed for AI tool integration. It supports mathematical calculations, string manipulation, boolean operations, list processing, conditional evaluation, and functional programming with lambda expressions and higher-order functions.\n\n## Features\n\n- **Pure list representation**: Everything is data - true homoiconicity like traditional Lisp\n- **S-expression syntax**: `(function-or-operator arg1 arg2 ...)`\n- **Quote special form**: `(quote expr)` and shortcut `'expr` for preventing evaluation and creating data literals\n- **Pattern matching**: Comprehensive pattern matching with structural and type-based patterns\n- **Mathematical operations**: Arithmetic, trigonometry, logarithms, bitwise operations\n- **String operations**: Manipulation, searching, conversion with full UTF-8 support\n- **Boolean operations**: Logic operations with strict type checking\n- **List operations**: Construction, manipulation, and conversion with heterogeneous support\n- **Association lists (alists)**: Immutable key-value mappings with O(1) lookup performance\n- **Conditional evaluation**: `if` expressions with lazy evaluation of branches\n- **Lazy evaluation**: `and` and `or` perform lazy evaluation of operands\n- **Lambda expressions**: Anonymous functions with lexical scoping and closures\n- **Local bindings**: `let` expressions for sequential variable binding\n- **Higher-order functions**: `map`, `filter`, `fold`, `range`, and more for functional programming\n- **Tail call optimization**: Automatic optimization for recursive and mutually recursive functions\n- **Type predicates**: Built-in functions to check value types\n- **Number formats**: Integers, floats, complex numbers, hex (0xFF), binary (0b1010), octal (0o755)\n- **String literals**: `\"hello world\"` with escape sequences\n- **Boolean literals**: `#t` (true) and `#f` (false)\n- **Constants**: `pi`, `e`, `j` (imaginary unit), `true`, `false`\n- **Type promotion**: Automatic promotion from int \u2192 float \u2192 complex\n- **Result simplification**: Complex numbers with negligible imaginary parts become real\n- **Comments**: `;` introduces comments\n\n## Usage\n\n### Basic Usage\n\n```python\nfrom aifpl import AIFPL\n\ntool = AIFPL()\nresult = tool.evaluate(\"(+ 1 2 3)\")  # Returns: 6\n```\n\n### With Configuration\n\n```python\ntool = AIFPL(max_depth=200, floating_point_tolerance=1e-12)\nresult = tool.evaluate(\"(sin (* pi 0.5))\")  # Returns: 1\n```\n\n### Formatted Output\n\n```python\n# Get results with LISP-style formatting\nresult_str = tool.evaluate_and_format(\"(list 1 2 3)\")  # Returns: \"(1 2 3)\"\n```\n\n### Error Handling\n\n```python\nfrom aifpl import AIFPL, AIFPLError\n\ntool = AIFPL()\ntry:\n    result = tool.evaluate(\"(+ 1 2\")  # Missing closing paren\nexcept AIFPLError as e:\n    print(f\"AIFPL error: {e}\")\n```\n\n## Supported Operations\n\n### Quote - Data Literals and Code as Data\n\nThe `quote` special form prevents evaluation of expressions, enabling true code-as-data manipulation:\n\n#### Basic Quote Syntax\n```aifpl\n(quote expr)\n'expr          ; Shortcut form (equivalent to (quote expr))\n```\n\n#### Quote Examples - Preventing Evaluation\n```aifpl\n; Without quote - expression gets evaluated\n(+ 1 2 3)                             ; \u2192 6\n\n; With quote - expression returned as data\n(quote (+ 1 2 3))                     ; \u2192 (+ 1 2 3)\n'(+ 1 2 3)                            ; \u2192 (+ 1 2 3) (shortcut form)\n\n; Quote symbols to prevent variable lookup\n(quote x)                             ; \u2192 x (the symbol itself)\n'x                                    ; \u2192 x (shortcut form)\n(quote hello)                         ; \u2192 hello (symbol, not variable lookup)\n'hello                                ; \u2192 hello (shortcut form)\n```\n\n#### Single Quote Shortcut Examples\n```aifpl\n; Basic shortcut usage\n'x                                    ; \u2192 x (same as (quote x))\n'42                                   ; \u2192 42 (same as (quote 42))\n'\"hello\"                              ; \u2192 \"hello\" (same as (quote \"hello\"))\n'#t                                   ; \u2192 #t (same as (quote #t))\n\n; Shortcut with lists\n'(1 2 3)                              ; \u2192 (1 2 3) (same as (quote (1 2 3)))\n'()                                   ; \u2192 () (same as (quote ()))\n\n; Nested shortcut quotes\n''x                                   ; \u2192 (quote x) (same as (quote (quote x)))\n'''x                                  ; \u2192 (quote (quote x)) (triple nested)\n\n; Mixed usage in expressions\n(list 'hello (+ 1 2) 'world)         ; \u2192 (hello 3 world)\n(cons '+ '(1 2 3))                    ; \u2192 (+ 1 2 3)\n```\n\n#### Quote with Lists - Creating Data Structures\n```aifpl\n; Create lists as pure data\n(quote (1 2 3))                       ; \u2192 (1 2 3) (list as data)\n'(1 2 3)                              ; \u2192 (1 2 3) (shortcut form)\n(quote ())                            ; \u2192 () (empty list as data)\n'()                                   ; \u2192 () (shortcut form)\n\n; Create nested data structures\n(quote ((a 1) (b 2) (c 3)))           ; \u2192 ((a 1) (b 2) (c 3))\n'((a 1) (b 2) (c 3))                  ; \u2192 ((a 1) (b 2) (c 3)) (shortcut)\n\n; Mix quoted and unquoted in larger expressions\n(list (quote hello) (+ 1 2) (quote world))  ; \u2192 (hello 3 world)\n(list 'hello (+ 1 2) 'world)         ; \u2192 (hello 3 world) (with shortcuts)\n```\n\n#### Quote with Code Templates\n```aifpl\n; Store code as data for later use\n(let ((template (quote (if CONDITION THEN ELSE))))\n  template)                           ; \u2192 (if CONDITION THEN ELSE)\n(let ((template '(if CONDITION THEN ELSE)))\n  template)                           ; \u2192 (if CONDITION THEN ELSE) (shortcut)\n\n; Create function templates\n(let ((lambda-template (quote (lambda (x) (* x x)))))\n  lambda-template)                    ; \u2192 (lambda (x) (* x x))\n(let ((lambda-template '(lambda (x) (* x x))))\n  lambda-template)                    ; \u2192 (lambda (x) (* x x)) (shortcut)\n\n; Store expressions in lists\n(let ((expressions (list (quote (+ 1 2)) \n                        (quote (* 3 4))\n                        (quote (- 10 5)))))\n  expressions)                        ; \u2192 ((+ 1 2) (* 3 4) (- 10 5))\n(let ((expressions (list '(+ 1 2) \n                        '(* 3 4)\n                        '(- 10 5))))\n  expressions)                        ; \u2192 ((+ 1 2) (* 3 4) (- 10 5)) (shortcuts)\n```\n\n#### Symbolic Programming with Quote\n```aifpl\n; Manipulate code structure\n(let ((expr (quote (+ a b c))))\n  (first expr))                       ; \u2192 + (the operator symbol)\n(let ((expr '(+ a b c)))\n  (first expr))                       ; \u2192 + (shortcut form)\n\n(let ((expr (quote (lambda (x y) (+ x y)))))\n  (let ((params (first (rest expr)))\n        (body (first (rest (rest expr)))))\n    (list \"params\" params \"body\" body)))  ; \u2192 (\"params\" (x y) \"body\" (+ x y))\n(let ((expr '(lambda (x y) (+ x y))))\n  (let ((params (first (rest expr)))\n        (body (first (rest (rest expr)))))\n    (list \"params\" params \"body\" body)))  ; \u2192 (\"params\" (x y) \"body\" (+ x y)) (shortcut)\n\n; Build expressions programmatically\n(let ((op (quote +))\n      (args (quote (1 2 3))))\n  (cons op args))                     ; \u2192 (+ 1 2 3)\n(let ((op '+)\n      (args '(1 2 3)))\n  (cons op args))                     ; \u2192 (+ 1 2 3) (shortcuts)\n```\n\n#### Quote vs. List Constructor\n```aifpl\n; Using list constructor - evaluates arguments\n(list + 1 2 3)                       ; \u2192 (<builtin +> 1 2 3)\n\n; Using quote - no evaluation\n(quote (+ 1 2 3))                     ; \u2192 (+ 1 2 3)\n'(+ 1 2 3)                            ; \u2192 (+ 1 2 3) (shortcut)\n\n; Mixed approach\n(list (quote +) 1 2 3)                ; \u2192 (+ 1 2 3)\n(list '+ 1 2 3)                       ; \u2192 (+ 1 2 3) (shortcut)\n```\n\n#### Data Processing with Quoted Expressions\n```aifpl\n; Process a list of expressions\n(let ((exprs (list (quote (+ 1 2))\n                  (quote (* 3 4))\n                  (quote (/ 8 2)))))\n  (map (lambda (expr) (first expr)) exprs))  ; \u2192 (+ * /)\n(let ((exprs (list '(+ 1 2)\n                  '(* 3 4)\n                  '(/ 8 2))))\n  (map (lambda (expr) (first expr)) exprs))  ; \u2192 (+ * /) (shortcuts)\n\n; Extract operators and operands\n(let ((analyze-expr (lambda (expr)\n                      (if (and (list? expr) (not (null? expr)))\n                          (list \"op\" (first expr) \"args\" (rest expr))\n                          \"not-a-compound-expr\"))))\n  (map analyze-expr (list (quote (+ 1 2))\n                         (quote x)\n                         (quote (* a b c)))))\n; \u2192 ((\"op\" + \"args\" (1 2)) \"not-a-compound-expr\" (\"op\" * \"args\" (a b c)))\n(let ((analyze-expr (lambda (expr)\n                      (if (and (list? expr) (not (null? expr)))\n                          (list \"op\" (first expr) \"args\" (rest expr))\n                          \"not-a-compound-expr\"))))\n  (map analyze-expr (list '(+ 1 2)\n                         'x\n                         '(* a b c))))\n; \u2192 ((\"op\" + \"args\" (1 2)) \"not-a-compound-expr\" (\"op\" * \"args\" (a b c))) (shortcuts)\n```\n\n#### Quote Enables Meta-Programming\n```aifpl\n; Create expressions that create expressions\n(let ((make-adder (lambda (n)\n                    (list (quote lambda) \n                         (quote (x)) \n                         (list (quote +) (quote x) n)))))\n  (make-adder 5))                     ; \u2192 (lambda (x) (+ x 5))\n(let ((make-adder (lambda (n)\n                    (list 'lambda \n                         '(x) \n                         (list '+ 'x n)))))\n  (make-adder 5))                     ; \u2192 (lambda (x) (+ x 5)) (shortcuts)\n\n; Template-based code generation\n(let ((make-predicate (lambda (op value)\n                        (list (quote lambda)\n                             (quote (x))\n                             (list op (quote x) value)))))\n  (list (make-predicate (quote >) 10)\n        (make-predicate (quote =) 0)))  ; \u2192 ((lambda (x) (> x 10)) (lambda (x) (= x 0)))\n(let ((make-predicate (lambda (op value)\n                        (list 'lambda\n                             '(x)\n                             (list op 'x value)))))\n  (list (make-predicate '> 10)\n        (make-predicate '= 0)))       ; \u2192 ((lambda (x) (> x 10)) (lambda (x) (= x 0))) (shortcuts)\n```\n\n#### Homoiconicity in Action\n```aifpl\n; Code and data have the same representation\n(let ((code (quote (+ (* 2 3) 4)))\n      (data (list (quote +) (list (quote *) 2 3) 4)))\n  (= code data))                      ; \u2192 #t (they're identical!)\n(let ((code '(+ (* 2 3) 4))\n      (data (list '+ (list '* 2 3) 4)))\n  (= code data))                      ; \u2192 #t (shortcuts make it cleaner!)\n\n; Manipulate code like any other data\n(let ((expr (quote (+ 1 2 3))))\n  (let ((reversed (reverse expr)))\n    reversed))                        ; \u2192 (3 2 1 +)\n(let ((expr '(+ 1 2 3)))\n  (let ((reversed (reverse expr)))\n    reversed))                        ; \u2192 (3 2 1 +) (shortcut)\n\n; Transform code structures\n(let ((transform-ops (lambda (expr)\n                       (if (list? expr)\n                           (map transform-ops expr)\n                           (if (= expr (quote +))\n                               (quote *)\n                               expr)))))\n  (transform-ops (quote (+ 1 (+ 2 3)))))  ; \u2192 (* 1 (* 2 3))\n(let ((transform-ops (lambda (expr)\n                       (if (list? expr)\n                           (map transform-ops expr)\n                           (if (= expr '+)\n                               '*\n                               expr)))))\n  (transform-ops '(+ 1 (+ 2 3))))     ; \u2192 (* 1 (* 2 3)) (shortcuts)\n```\n\n### Lambda Expressions and Anonymous Functions\n\nLambda expressions create anonymous functions with lexical scoping and closure support:\n\n#### Basic Lambda Syntax\n```aifpl\n(lambda (param1 param2 ...) body)\n```\n\n#### Simple Lambda Examples\n```aifpl\n; Square function\n((lambda (x) (* x x)) 5)                    ; \u2192 25\n\n; Add two numbers\n((lambda (x y) (+ x y)) 3 4)                ; \u2192 7\n\n; String manipulation\n((lambda (s) (string-upcase s)) \"hello\")     ; \u2192 \"HELLO\"\n\n; Conditional logic\n((lambda (x) (if (> x 0) \"positive\" \"non-positive\")) -3)  ; \u2192 \"non-positive\"\n```\n\n#### Lambda Functions as Values\n```aifpl\n; Lambda functions are first-class values\n(let ((square (lambda (x) (* x x))))\n  (square 6))                                ; \u2192 36\n\n; Functions in lists\n(let ((ops (list (lambda (x) (* x 2)) (lambda (x) (+ x 1)))))\n  ((first ops) 5))                          ; \u2192 10\n\n; Higher-order function usage\n(map (lambda (x) (* x x)) (list 1 2 3 4))   ; \u2192 (1 4 9 16)\n```\n\n#### Closures and Lexical Scoping\n```aifpl\n; Closures capture their environment\n(let ((multiplier 10))\n  (let ((times-ten (lambda (x) (* x multiplier))))\n    (times-ten 5)))                         ; \u2192 50\n\n; Nested closures\n(let ((outer-var 100))\n  (let ((make-adder (lambda (n) (lambda (x) (+ x n outer-var)))))\n    (let ((add-five (make-adder 5)))\n      (add-five 3))))                       ; \u2192 108\n\n; Function factories\n(let ((make-multiplier (lambda (factor) (lambda (x) (* x factor)))))\n  (let ((double (make-multiplier 2))\n        (triple (make-multiplier 3)))\n    (list (double 4) (triple 4))))          ; \u2192 (8 12)\n```\n\n#### Recursive Lambda Functions\n```aifpl\n; Factorial with tail recursion (automatically optimized)\n(let ((factorial (lambda (n acc)\n                   (if (<= n 1)\n                       acc\n                       (factorial (- n 1) (* n acc))))))\n  (factorial 5 1))                          ; \u2192 120\n\n; List sum with recursion\n(let ((sum-list (lambda (lst acc)\n                  (if (null? lst)\n                      acc\n                      (sum-list (rest lst) (+ acc (first lst)))))))\n  (sum-list (list 1 2 3 4 5) 0))           ; \u2192 15\n\n; Fibonacci with mutual recursion\n(let ((fib-helper (lambda (n a b)\n                    (if (<= n 0)\n                        a\n                        (fib-helper (- n 1) b (+ a b))))))\n  (let ((fibonacci (lambda (n) (fib-helper n 0 1))))\n    (fibonacci 10)))                        ; \u2192 55\n```\n\n### Local Variable Binding with Let\n\nLet expressions create local variable bindings with sequential evaluation and lexical scoping:\n\n#### Basic Let Syntax\n```aifpl\n(let ((var1 val1) (var2 val2) ...) body)\n```\n\n#### Simple Let Examples\n```aifpl\n; Basic binding\n(let ((x 5)) (+ x 10))                      ; \u2192 15\n\n; Multiple bindings\n(let ((x 3) (y 4)) (+ (* x x) (* y y)))     ; \u2192 25\n\n; String operations\n(let ((name \"Alice\") (age 30))\n  (string-append name \" is \" (number->string age)))  ; \u2192 \"Alice is 30\"\n```\n\n#### Sequential Binding\n```aifpl\n; Later variables can reference earlier ones\n(let ((x 5) (y (* x 2))) (+ x y))           ; \u2192 15\n\n; Building complex expressions\n(let ((base 10)\n      (squared (* base base))\n      (cubed (* squared base)))\n  (list base squared cubed))                ; \u2192 (10 100 1000)\n\n; String processing chain\n(let ((text \"Hello World\")\n      (lower (string-downcase text))\n      (words (string-split lower \" \")))\n  (string-join (reverse words) \"-\"))        ; \u2192 \"world-hello\"\n```\n\n#### Binding Functions\n```aifpl\n; Bind lambda functions to names\n(let ((double (lambda (x) (* x 2)))\n      (triple (lambda (x) (* x 3))))\n  (+ (double 4) (triple 5)))                ; \u2192 23\n\n; Compose functions\n(let ((add-one (lambda (x) (+ x 1)))\n      (square (lambda (x) (* x x)))\n      (compose (lambda (f g) (lambda (x) (f (g x))))))\n  (let ((square-then-add (compose add-one square)))\n    (square-then-add 4)))                   ; \u2192 17\n\n; Recursive function binding\n(let ((countdown (lambda (n)\n                   (if (<= n 0)\n                       (list)\n                       (cons n (countdown (- n 1)))))))\n  (countdown 5))                            ; \u2192 (5 4 3 2 1)\n```\n\n#### Nested Let Expressions\n```aifpl\n; Nested scoping\n(let ((x 10))\n  (let ((x 20) (y x))  ; inner x shadows outer, y gets outer x value\n    (+ x y)))                               ; \u2192 30\n\n; Complex nested computation\n(let ((data (list 1 2 3 4 5)))\n  (let ((squared (map (lambda (x) (* x x)) data))\n        (sum-fn (lambda (lst) (fold + 0 lst))))\n    (let ((total (sum-fn squared))\n          (average (/ total (length squared))))\n      (list \"sum\" total \"average\" average))))  ; \u2192 (\"sum\" 55 \"average\" 11)\n```\n\n### Pattern Matching\n\nPattern matching provides a powerful way to destructure and analyze data based on its shape and content. It offers a concise alternative to nested conditionals and enables elegant functional programming patterns.\n\n#### Basic Pattern Matching Syntax\n```aifpl\n(match expression\n  (pattern1 result1)\n  (pattern2 result2)\n  ...\n  (_ default-result))  ; wildcard pattern (optional)\n```\n\n#### Literal Pattern Matching\n```aifpl\n; Match exact values\n(match 42\n  (42 \"found the answer\")\n  (0 \"zero\")\n  (_ \"something else\"))                     ; \u2192 \"found the answer\"\n\n; String literal matching\n(match \"hello\"\n  (\"world\" \"greeting\")\n  (\"hello\" \"salutation\")\n  (_ \"unknown\"))                            ; \u2192 \"salutation\"\n\n; Boolean literal matching\n(match #t\n  (#t \"true value\")\n  (#f \"false value\"))                       ; \u2192 \"true value\"\n```\n\n#### Variable Pattern Matching\n```aifpl\n; Bind values to variables\n(match 42\n  (x (* x 2)))                              ; \u2192 84 (x is bound to 42)\n\n; Variable patterns always match\n(match \"hello\"\n  (greeting (string-upcase greeting)))      ; \u2192 \"HELLO\"\n\n; Multiple variable patterns (first match wins)\n(match 10\n  (x (+ x 1))\n  (y (* y 2)))                              ; \u2192 11 (first pattern matches)\n```\n\n#### Wildcard Pattern Matching\n```aifpl\n; Wildcard matches anything without binding\n(match 42\n  (_ \"matched something\"))                  ; \u2192 \"matched something\"\n\n; Common use as default case\n(match \"unknown\"\n  (\"hello\" \"greeting\")\n  (\"goodbye\" \"farewell\")\n  (_ \"unrecognized\"))                       ; \u2192 \"unrecognized\"\n\n; Wildcard with computation\n(match (+ 10 20)\n  (_ \"got a result\"))                       ; \u2192 \"got a result\"\n```\n\n#### Type Pattern Matching\n```aifpl\n; Match by type with binding\n(match 42\n  ((number? n) (+ n 10))\n  ((string? s) (string-length s))\n  (_ \"unknown type\"))                       ; \u2192 52\n\n; String type matching\n(match \"hello world\"\n  ((string? text) (string-upcase text))\n  (_ \"not a string\"))                       ; \u2192 \"HELLO WORLD\"\n\n; Boolean type matching\n(match #t\n  ((boolean? flag) (not flag))\n  (_ \"not boolean\"))                        ; \u2192 #f\n\n; List type matching\n(match (list 1 2 3)\n  ((list? items) (length items))\n  (_ \"not a list\"))                         ; \u2192 3\n\n; Function type matching\n(match (lambda (x) (* x 2))\n  ((function? f) \"it's a function\")\n  (_ \"not a function\"))                     ; \u2192 \"it's a function\"\n```\n\n#### List Structure Pattern Matching\n\n**Important:** In AIFPL, the `(head . tail)` pattern always binds `tail` to a list (possibly empty), never to an atom. This differs from Scheme/Lisp.\n\n```aifpl\n; Empty list matching\n(match (list)\n  (() \"empty list\")\n  (_ \"non-empty\"))                          ; \u2192 \"empty list\"\n\n; Fixed-length list matching\n(match (list 1 2 3)\n  ((a b c) (+ a b c))\n  (_ \"wrong length\"))                       ; \u2192 6\n\n; Head-tail decomposition - tail is ALWAYS a list\n(match (list 1 2 3 4)\n  ((head . tail) (list \"head\" head \"tail\" tail))\n  (() \"empty\"))                             ; \u2192 (\"head\" 1 \"tail\" (2 3 4))\n\n; Single element list - tail is empty list\n(match (list 42)\n  ((x . xs) (list x xs)))                   ; \u2192 (42 ())  - xs is (), not an atom\n\n; Two-element list\n(match (list \"hello\" \"world\")\n  ((first second) (string-append first \" \" second))\n  (_ \"not a pair\"))                         ; \u2192 \"hello world\"\n```\n\n**Note:** Unlike Scheme/Lisp where `(cdr '(1 . 2))` returns the atom `2`, AIFPL's `(head . tail)` pattern always binds `tail` to a list. Use fixed-length patterns like `(a b)` when you want direct access to individual elements.\n\n#### Nested Pattern Matching\n```aifpl\n; Nested list patterns\n(match (list (list 1 2) 3)\n  (((a b) c) (+ a b c))\n  (_ \"no match\"))                           ; \u2192 6\n\n; Deep nesting\n(match (list (list (list 1 2) 3) 4)\n  ((((x y) z) w) (+ x y z w))\n  (_ \"no match\"))                           ; \u2192 10\n\n; Mixed literal and variable patterns\n(match (list \"name\" \"Alice\")\n  ((\"name\" value) (string-append \"Hello, \" value))\n  ((\"age\" value) (string-append \"Age: \" (number->string value)))\n  (_ \"unknown field\"))                      ; \u2192 \"Hello, Alice\"\n\n; Nested type patterns\n(match (list (list 1 2 3))\n  (((list? numbers)) (fold + 0 numbers))\n  (_ \"not a list of numbers\"))              ; \u2192 6\n```\n\n#### Pattern Matching with Conditionals\n```aifpl\n; Combine patterns with guards (using nested match)\n(let ((classify-number (lambda (n)\n                         (match n\n                           ((number? x) \n                            (match #t\n                              ((if (> x 0)) \"positive\")\n                              ((if (< x 0)) \"negative\")\n                              (_ \"zero\")))\n                           (_ \"not a number\")))))\n  (list (classify-number 5)\n        (classify-number -3)\n        (classify-number 0)\n        (classify-number \"hello\")))          ; \u2192 (\"positive\" \"negative\" \"zero\" \"not a number\")\n```\n\n#### Complex Data Structure Matching\n```aifpl\n; Process structured data\n(let ((process-person (lambda (person)\n                        (match person\n                          ((\"person\" name age city)\n                           (string-append name \" (\" (number->string age) \") from \" city))\n                          ((\"person\" name age)\n                           (string-append name \" (\" (number->string age) \")\"))\n                          (_ \"invalid person data\")))))\n  (list (process-person (list \"person\" \"Alice\" 30 \"NYC\"))\n        (process-person (list \"person\" \"Bob\" 25))\n        (process-person (list \"invalid\" \"data\"))))\n; \u2192 (\"Alice (30) from NYC\" \"Bob (25)\" \"invalid person data\")\n\n; Tree-like structure processing\n(let ((evaluate-expr (lambda (expr)\n                       (match expr\n                         (((number? n)) n)\n                         ((\"+\" left right) (+ (evaluate-expr left) (evaluate-expr right)))\n                         ((\"*\" left right) (* (evaluate-expr left) (evaluate-expr right)))\n                         (_ \"invalid expression\")))))\n  (evaluate-expr (list \"+\" (list 10) (list \"*\" (list 5) (list 3)))))  ; \u2192 25\n```\n\n#### Pattern Matching vs. Conditional Chains\n```aifpl\n; Traditional nested conditionals\n(let ((process-traditional (lambda (data)\n                             (if (list? data)\n                                 (if (= (length data) 3)\n                                     (if (string? (first data))\n                                         (if (number? (first (rest data)))\n                                             (string-append (first data) \": \" \n                                                          (number->string (first (rest data))))\n                                             \"second not number\")\n                                         \"first not string\")\n                                     \"wrong length\")\n                                 \"not a list\"))))\n  (process-traditional (list \"score\" 95 \"points\")))  ; \u2192 \"score: 95\"\n\n; Equivalent pattern matching (much cleaner)\n(let ((process-pattern (lambda (data)\n                         (match data\n                           (((string? name) (number? value) extra) \n                            (string-append name \": \" (number->string value)))\n                           (_ \"invalid format\")))))\n  (process-pattern (list \"score\" 95 \"points\")))      ; \u2192 \"score: 95\"\n```\n\n#### Advanced Pattern Matching Examples\n```aifpl\n; List processing with patterns\n(let ((process-list (lambda (lst)\n                      (match lst\n                        (() \"empty\")\n                        ((x) (string-append \"single: \" (number->string x)))\n                        ((x y) (string-append \"pair: \" (number->string (+ x y))))\n                        ((head . tail) \n                         (string-append \"list of \" (number->string (+ 1 (length tail))) \" items\"))))))\n  (list (process-list (list))\n        (process-list (list 42))\n        (process-list (list 1 2))\n        (process-list (list 1 2 3 4 5))))\n; \u2192 (\"empty\" \"single: 42\" \"pair: 3\" \"list of 5 items\")\n\n; Configuration processing\n(let ((process-config (lambda (config)\n                        (match config\n                          ((\"database\" \"mysql\" host port)\n                           (string-append \"MySQL at \" host \":\" (number->string port)))\n                          ((\"database\" \"postgres\" host port db)\n                           (string-append \"PostgreSQL \" db \" at \" host \":\" (number->string port)))\n                          ((\"cache\" \"redis\" host)\n                           (string-append \"Redis cache at \" host))\n                          (_ \"unknown configuration\")))))\n  (list (process-config (list \"database\" \"mysql\" \"localhost\" 3306))\n        (process-config (list \"database\" \"postgres\" \"db.example.com\" 5432 \"myapp\"))\n        (process-config (list \"cache\" \"redis\" \"cache.example.com\"))\n        (process-config (list \"unknown\" \"config\"))))\n; \u2192 (\"MySQL at localhost:3306\" \"PostgreSQL myapp at db.example.com:5432\" \"Redis cache at cache.example.com\" \"unknown configuration\")\n\n; Recursive data structure processing\n(let ((json-to-string (lambda (json)\n                        (match json\n                          (((string? s)) (string-append \"\\\"\" s \"\\\"\"))\n                          (((number? n)) (number->string n))\n                          (((boolean? b)) (if b \"true\" \"false\"))\n                          ((\"object\" . pairs)\n                           (let ((pair-strings (map (lambda (pair)\n                                                     (match pair\n                                                       ((key value)\n                                                        (string-append \"\\\"\" key \"\\\": \" \n                                                                     (json-to-string value)))\n                                                       (_ \"invalid pair\")))\n                                                   pairs)))\n                             (string-append \"{\" (string-join pair-strings \", \") \"}\")))\n                          ((\"array\" . items)\n                           (string-append \"[\" \n                                        (string-join (map json-to-string items) \", \") \n                                        \"]\"))\n                          (_ \"invalid JSON\")))))\n  (json-to-string (list \"object\" \n                       (list \"name\" (list \"Alice\"))\n                       (list \"age\" (list 30))\n                       (list \"active\" (list #t)))))\n; \u2192 \"{\\\"name\\\": \\\"Alice\\\", \\\"age\\\": 30, \\\"active\\\": true}\"\n```\n\n#### Pattern Matching Best Practices\n```aifpl\n; Order patterns from specific to general\n(let ((classify (lambda (x)\n                  (match x\n                    (0 \"zero\")              ; Most specific first\n                    (1 \"one\")\n                    ((number? n) \"other number\")  ; More general\n                    (_ \"not a number\")))))          ; Most general last\n  (list (classify 0) (classify 1) (classify 42) (classify \"hello\")))\n; \u2192 (\"zero\" \"one\" \"other number\" \"not a number\")\n\n; Use meaningful variable names in patterns\n(let ((format-person (lambda (data)\n                       (match data\n                         ((name age city) ; Clear variable names\n                          (string-append name \" (\" (number->string age) \") lives in \" city))\n                         (_ \"invalid person\")))))\n  (format-person (list \"Alice\" 30 \"Boston\")))     ; \u2192 \"Alice (30) lives in Boston\"\n\n; Combine pattern matching with higher-order functions\n(let ((process-items (lambda (items)\n                       (map (lambda (item)\n                              (match item\n                                ((\"task\" name priority)\n                                 (string-append name \" [\" priority \"]\"))\n                                ((\"note\" content)\n                                 (string-append \"Note: \" content))\n                                (_ \"unknown item\")))\n                            items))))\n  (process-items (list (list \"task\" \"Buy groceries\" \"high\")\n                      (list \"note\" \"Remember to call mom\")\n                      (list \"invalid\" \"item\"))))\n; \u2192 (\"Buy groceries [high]\" \"Note: Remember to call mom\" \"unknown item\")\n```\n\n### Higher-Order Functions\n\nAIFPL provides powerful higher-order functions for functional programming patterns:\n\n#### Map - Transform Each Element\n```aifpl\n; Basic mapping\n(map (lambda (x) (* x 2)) (list 1 2 3 4))   ; \u2192 (2 4 6 8)\n\n; String transformations\n(map string-upcase (list \"hello\" \"world\"))  ; \u2192 (\"HELLO\" \"WORLD\")\n\n; Complex transformations\n(map (lambda (x) (+ (* x x) 1)) (list 1 2 3))  ; \u2192 (2 5 10)\n\n; Nested list processing\n(map (lambda (pair) (+ (first pair) (first (rest pair))))\n     (list (list 1 2) (list 3 4) (list 5 6)))  ; \u2192 (3 7 11)\n```\n\n#### Filter - Select Elements by Predicate\n```aifpl\n; Basic filtering\n(filter (lambda (x) (> x 0)) (list -1 2 -3 4))  ; \u2192 (2 4)\n\n; String filtering\n(filter (lambda (s) (> (string-length s) 3))\n        (list \"hi\" \"hello\" \"a\" \"world\"))    ; \u2192 (\"hello\" \"world\")\n\n; Complex predicates\n(filter (lambda (x) (= (% x 2) 0)) (range 1 11))  ; \u2192 (2 4 6 8 10)\n\n; Boolean combinations\n(filter (lambda (x) (and (> x 5) (< x 15)))\n        (range 1 20))                       ; \u2192 (6 7 8 9 10 11 12 13 14)\n```\n\n#### Fold - Accumulate Results\n```aifpl\n; Sum all elements\n(fold + 0 (list 1 2 3 4 5))                ; \u2192 15\n\n; Product of elements\n(fold * 1 (list 1 2 3 4))                  ; \u2192 24\n\n; String concatenation\n(fold string-append \"\" (list \"Hello\" \" \" \"World\"))  ; \u2192 \"Hello World\"\n\n; Build reverse list\n(fold (lambda (acc x) (cons x acc)) (list) (list 1 2 3))  ; \u2192 (3 2 1)\n\n; Find maximum\n(fold (lambda (acc x) (if (> x acc) x acc)) 0 (list 3 7 2 9 1))  ; \u2192 9\n\n; Complex accumulation\n(fold (lambda (acc x) (+ acc (* x x))) 0 (list 1 2 3 4))  ; \u2192 30\n```\n\n#### Range - Generate Numeric Sequences\n```aifpl\n; Basic ranges\n(range 1 5)                                 ; \u2192 (1 2 3 4)\n(range 0 10 2)                             ; \u2192 (0 2 4 6 8)\n(range 10 0 -1)                            ; \u2192 (10 9 8 7 6 5 4 3 2 1)\n\n; Use with other functions\n(map (lambda (x) (* x x)) (range 1 6))      ; \u2192 (1 4 9 16 25)\n(filter (lambda (x) (= (% x 3) 0)) (range 1 21))  ; \u2192 (3 6 9 12 15 18)\n\n; Generate data\n(map (lambda (i) (list \"item\" i)) (range 1 4))  ; \u2192 ((\"item\" 1) (\"item\" 2) (\"item\" 3))\n```\n\n#### Find - Locate First Matching Element\n```aifpl\n; Find first positive number\n(find (lambda (x) (> x 0)) (list -1 -2 3 4))  ; \u2192 3\n\n; Find first long string\n(find (lambda (s) (> (string-length s) 4))\n      (list \"hi\" \"hello\" \"a\"))              ; \u2192 \"hello\"\n\n; Returns #f if not found\n(find (lambda (x) (> x 10)) (list 1 2 3))  ; \u2192 #f\n\n; Complex search\n(find (lambda (pair) (= (first pair) \"name\"))\n      (list (list \"age\" 25) (list \"name\" \"John\")))  ; \u2192 (\"name\" \"John\")\n```\n\n#### Any? and All? - Boolean Predicates\n```aifpl\n; Check if any element matches\n(any? (lambda (x) (> x 5)) (list 1 3 7 2))  ; \u2192 #t\n(any? (lambda (x) (< x 0)) (list 1 2 3))   ; \u2192 #f\n\n; Check if all elements match\n(all? (lambda (x) (> x 0)) (list 1 2 3))   ; \u2192 #t\n(all? (lambda (x) (> x 5)) (list 1 3 7))   ; \u2192 #f\n\n; String validation\n(all? (lambda (s) (> (string-length s) 0))\n      (list \"hello\" \"world\" \"test\"))        ; \u2192 #t\n\n(any? (lambda (s) (string-contains? s \"@\"))\n      (list \"user@email.com\" \"plain-text\")) ; \u2192 #t\n```\n\n#### Take and Drop - List Slicing\n```aifpl\n; Take first n elements\n(take 3 (list 1 2 3 4 5))                  ; \u2192 (1 2 3)\n(take 2 (list \"a\" \"b\" \"c\" \"d\"))            ; \u2192 (\"a\" \"b\")\n\n; Drop first n elements\n(drop 2 (list 1 2 3 4 5))                  ; \u2192 (3 4 5)\n(drop 3 (list \"a\" \"b\" \"c\" \"d\"))            ; \u2192 (\"d\")\n\n; Safe operations (don't error on out-of-bounds)\n(take 10 (list 1 2 3))                     ; \u2192 (1 2 3)\n(drop 10 (list 1 2 3))                     ; \u2192 ()\n\n; Combine with other operations\n(take 3 (filter (lambda (x) (> x 0)) (list -1 2 -3 4 5 6)))  ; \u2192 (2 4 5)\n```\n\n### Functional Programming Patterns\n\n#### Data Transformation Pipelines\n```aifpl\n; Process CSV-like data\n(let ((data (list \"john,25\" \"alice,30\" \"bob,22\")))\n  (map (lambda (row)\n         (let ((parts (string-split row \",\")))\n           (list (first parts) (string->number (first (rest parts))))))\n       data))                               ; \u2192 ((\"john\" 25) (\"alice\" 30) (\"bob\" 22))\n\n; Multi-step data processing\n(let ((numbers (range 1 21)))\n  (let ((evens (filter (lambda (x) (= (% x 2) 0)) numbers))\n        (squares (map (lambda (x) (* x x)) evens))\n        (sum (fold + 0 squares)))\n    sum))                                   ; \u2192 1540\n\n; String processing pipeline\n(let ((text \"The Quick Brown Fox\"))\n  (let ((words (string-split (string-downcase text) \" \"))\n        (long-words (filter (lambda (w) (> (string-length w) 3)) words))\n        (capitalized (map string-upcase long-words)))\n    (string-join capitalized \"-\")))         ; \u2192 \"QUICK-BROWN\"\n```\n\n#### Function Composition\n```aifpl\n; Compose two functions\n(let ((compose (lambda (f g) (lambda (x) (f (g x))))))\n  (let ((add-one (lambda (x) (+ x 1)))\n        (double (lambda (x) (* x 2))))\n    (let ((double-then-add (compose add-one double)))\n      (double-then-add 5))))                ; \u2192 11\n\n; Chain multiple transformations\n(let ((pipe (lambda (value . functions)\n              (fold (lambda (acc f) (f acc)) value functions))))\n  (let ((add-ten (lambda (x) (+ x 10)))\n        (multiply-by-three (lambda (x) (* x 3)))\n        (subtract-five (lambda (x) (- x 5))))\n    (pipe 2 add-ten multiply-by-three subtract-five)))  ; \u2192 31\n```\n\n#### Recursive Data Processing\n```aifpl\n; Process nested lists recursively\n(let ((deep-sum (lambda (lst)\n                  (if (null? lst)\n                      0\n                      (let ((head (first lst))\n                            (tail (rest lst)))\n                        (+ (if (list? head)\n                               (deep-sum head)\n                               head)\n                           (deep-sum tail)))))))\n  (deep-sum (list 1 (list 2 3) 4)))        ; \u2192 10\n\n; Tree traversal patterns\n(let ((count-leaves (lambda (tree)\n                      (if (list? tree)\n                          (fold + 0 (map count-leaves tree))\n                          1))))\n  (count-leaves (list 1 (list 2 (list 3 4)) 5)))  ; \u2192 5\n```\n\n#### Validation and Error Handling\n```aifpl\n; Validate all items in a list\n(let ((validate-positive (lambda (nums)\n                          (if (all? (lambda (x) (> x 0)) nums)\n                              nums\n                              \"error: negative numbers found\"))))\n  (list (validate-positive (list 1 2 3))\n        (validate-positive (list 1 -2 3))))  ; \u2192 ((1 2 3) \"error: negative numbers found\")\n\n; Safe operations with defaults\n(let ((safe-divide (lambda (x y)\n                     (if (= y 0)\n                         \"undefined\"\n                         (/ x y)))))\n  (map (lambda (pair) (safe-divide (first pair) (first (rest pair))))\n       (list (list 10 2) (list 15 3) (list 8 0))))  ; \u2192 (5 5 \"undefined\")\n```\n\n### Conditional Operations\n\nAIFPL supports conditional evaluation with lazy evaluation of branches:\n\n```aifpl\n(if condition then-expr else-expr)\n```\n\n#### Basic Examples:\n```aifpl\n(if (> 5 3) \"greater\" \"less\")         ; \u2192 \"greater\"\n(if (= 1 2) (+ 1 1) (* 2 2))          ; \u2192 4\n(if #t \"true branch\" \"false branch\")  ; \u2192 \"true branch\"\n(if #f \"true branch\" \"false branch\")  ; \u2192 \"false branch\"\n```\n\n#### Lazy Evaluation (Key Feature):\n```aifpl\n(if #t 42 (/ 1 0))                    ; \u2192 42 (no division by zero error)\n(if #f (undefined-symbol) \"safe\")     ; \u2192 \"safe\" (no undefined symbol error)\n(if (> x 0) (/ 100 x) \"undefined\")    ; Safe division\n```\n\n#### Practical Examples:\n```aifpl\n; Safe list operations\n(if (null? my-list) \"empty\" (first my-list))\n\n; Data validation\n(if (string-contains? email \"@\") \"valid email\" \"invalid email\")\n\n; Conditional string building\n(if (> count 1)\n    (string-append (number->string count) \" items\")\n    \"1 item\")\n\n; List processing\n(if (member? \"target\" search-list)\n    (string-append \"Found at position \" (number->string (position \"target\" search-list)))\n    \"Not found\")\n```\n\n#### Nested Conditionals:\n```aifpl\n(if (> x 0)\n    (if (> x 10) \"big positive\" \"small positive\")\n    (if (< x -10) \"big negative\" \"small negative or zero\"))\n```\n\n#### Type Requirements:\n- Condition must be a boolean (`#t` or `#f`)\n- Both then-expr and else-expr are required\n- Only the chosen branch is evaluated (lazy evaluation)\n\n### Arithmetic\n- `(+ 1 2 3)` \u2192 `6`\n- `(- 10 3)` \u2192 `7`\n- `(* 2 3 4)` \u2192 `24`\n- `(/ 12 3)` \u2192 `4`\n- `(// 7 3)` \u2192 `2` (floor division)\n- `(% 7 3)` \u2192 `1` (modulo)\n- `(** 2 3)` \u2192 `8` (exponentiation)\n\n### Comparison Operations\n\n#### Equality and Inequality\n```aifpl\n; Equality - all values must be equal\n(= 1 1)                               ; \u2192 #t\n(= 1 2)                               ; \u2192 #f\n(= 1 1 1)                             ; \u2192 #t (all equal)\n(= 1 2 3)                             ; \u2192 #f (not all equal)\n\n; Inequality - any values not equal\n(!= 1 2)                              ; \u2192 #t (any inequality)\n(!= 1 1)                              ; \u2192 #f (all equal)\n(!= 1 2 3)                            ; \u2192 #t (not all equal)\n(!= 1 1 1)                            ; \u2192 #f (all equal)\n```\n\n#### Numeric Comparisons\n```aifpl\n; Comparison chains (all must satisfy the relationship)\n(< 1 2)                               ; \u2192 #t\n(< 1 2 3)                             ; \u2192 #t (1 < 2 < 3)\n(< 1 3 2)                             ; \u2192 #f (3 is not < 2)\n\n(> 3 2)                               ; \u2192 #t\n(> 3 2 1)                             ; \u2192 #t (3 > 2 > 1)\n\n(<= 1 1)                              ; \u2192 #t\n(<= 1 2 2)                            ; \u2192 #t (1 \u2264 2 \u2264 2)\n\n(>= 2 1)                              ; \u2192 #t\n(>= 3 2 2)                            ; \u2192 #t (3 \u2265 2 \u2265 2)\n```\n\n#### Mixed Type Equality\n```aifpl\n; Numeric types can be compared for equality\n(= 1 1.0)                             ; \u2192 #t (int/float equivalence)\n(= 2 (+ 1.0 1.0))                     ; \u2192 #t (numeric equivalence)\n\n; Different non-numeric types are never equal\n(= \"hello\" 5)                         ; \u2192 #f\n(= #t 1)                              ; \u2192 #f\n(= (list 1 2) \"12\")                   ; \u2192 #f\n\n; Lists are compared element by element\n(= (list 1 2) (list 1 2))             ; \u2192 #t\n(= (list 1 2) (list 1 3))             ; \u2192 #f\n```\n\n### Boolean Operations\n- `(and #t #f)` \u2192 `#f`\n- `(and #t #t)` \u2192 `#t`\n- `(or #t #f)` \u2192 `#t`\n- `(or #f #f)` \u2192 `#f`\n- `(not #t)` \u2192 `#f`\n- `(not #f)` \u2192 `#t`\n\n### Type Predicates\n\nAIFPL provides comprehensive type checking functions:\n\n#### Basic Type Predicates\n```aifpl\n; Number type checking (excludes booleans)\n(number? 42)                          ; \u2192 #t\n(number? 3.14)                        ; \u2192 #t\n(number? (+ 1 j))                     ; \u2192 #t (complex)\n(number? #t)                          ; \u2192 #f (booleans are not numbers)\n(number? \"42\")                        ; \u2192 #f\n\n; Specific numeric type checking\n(integer? 42)                         ; \u2192 #t\n(integer? 3.14)                       ; \u2192 #f\n(integer? #t)                         ; \u2192 #f (booleans excluded)\n\n(float? 3.14)                         ; \u2192 #t\n(float? 42)                           ; \u2192 #f\n(float? (/ 1 2))                      ; \u2192 #t (division produces float)\n\n(complex? (+ 1 j))                    ; \u2192 #t\n(complex? 42)                         ; \u2192 #f\n(complex? 3.14)                       ; \u2192 #f\n```\n\n#### Other Type Predicates\n```aifpl\n; String type checking\n(string? \"hello\")                     ; \u2192 #t\n(string? 42)                          ; \u2192 #f\n(string? (number->string 42))         ; \u2192 #t\n\n; Boolean type checking\n(boolean? #t)                         ; \u2192 #t\n(boolean? #f)                         ; \u2192 #t\n(boolean? 1)                          ; \u2192 #f\n(boolean? 0)                          ; \u2192 #f\n\n; Function type checking\n(function? (lambda (x) (* x 2)))      ; \u2192 #t\n(function? +)                         ; \u2192 #t\n(function? \"hello\")                   ; \u2192 #f\n\n; List type checking (already existed)\n(list? (list 1 2 3))                 ; \u2192 #t\n(list? \"hello\")                       ; \u2192 #f\n(list? ())                            ; \u2192 #t (empty list)\n```\n\n#### Type Predicate Usage Patterns\n```aifpl\n; Conditional type handling\n(let ((process-value (lambda (x)\n                       (if (number? x)\n                           (* x 2)\n                           (if (string? x)\n                               (string-upcase x)\n                               \"unknown type\")))))\n  (list (process-value 5)             ; \u2192 10\n        (process-value \"hello\")       ; \u2192 \"HELLO\"\n        (process-value #t)))          ; \u2192 \"unknown type\"\n\n; Type validation\n(let ((validate-numbers (lambda (lst)\n                          (if (all? number? lst)\n                              (fold + 0 lst)\n                              \"error: non-numeric values found\"))))\n  (list (validate-numbers (list 1 2 3))      ; \u2192 6\n        (validate-numbers (list 1 \"x\" 3))))  ; \u2192 \"error: non-numeric values found\"\n\n; Polymorphic operations\n(let ((safe-length (lambda (x)\n                     (if (string? x)\n                         (string-length x)\n                         (if (list? x)\n                             (length x)\n                             \"not a sequence\")))))\n  (list (safe-length \"hello\")         ; \u2192 5\n        (safe-length (list 1 2 3))    ; \u2192 3\n        (safe-length 42)))            ; \u2192 \"not a sequence\"\n```\n\n### Mathematical Functions\n- `(sin (* pi 0.5))` \u2192 `1`\n- `(cos 0)` \u2192 `1`\n- `(log e)` \u2192 `1`\n- `(sqrt 16)` \u2192 `4`\n- `(abs -5)` \u2192 `5`\n\n### Bitwise Operations\n- `(bit-or 5 3)` \u2192 `7`\n- `(bit-and 7 3)` \u2192 `3`\n- `(bit-xor 5 3)` \u2192 `6`\n- `(bit-not 5)` \u2192 `-6`\n\n### Base Conversion\n- `(hex 255)` \u2192 `\"0xff\"`\n- `(bin 10)` \u2192 `\"0b1010\"`\n- `(oct 8)` \u2192 `\"0o10\"`\n\n### Complex Numbers\n- `(complex 3 4)` \u2192 `(3+4j)`\n- `(+ 1 (* 2 j))` \u2192 `(1+2j)`\n- `(real (complex 3 4))` \u2192 `3` (extract real part)\n- `(imag (complex 3 4))` \u2192 `4` (extract imaginary part)\n- `(real 5)` \u2192 `5` (real part of real number)\n- `(imag 5)` \u2192 `0` (imaginary part of real number)\n\n### List Operations\n\n#### List Construction and Manipulation\n\n**Note:** AIFPL uses proper lists only. The `cons` function requires the second argument to be a list.\n\n```aifpl\n(list 1 2 3)                           ; \u2192 (1 2 3)\n(list \"a\" \"b\" \"c\")                     ; \u2192 (\"a\" \"b\" \"c\")\n(list 1 \"hello\" #t)                    ; \u2192 (1 \"hello\" #t) [mixed types]\n(list)                                 ; \u2192 () [empty list]\n(cons 1 (list 2 3))                    ; \u2192 (1 2 3) [prepend to list]\n(cons 1 (list))                        ; \u2192 (1) [prepend to empty list]\n(append (list 1 2) (list 3 4))         ; \u2192 (1 2 3 4) [concatenate]\n(reverse (list 1 2 3))                 ; \u2192 (3 2 1)\n```\n\n**Important:** Unlike Scheme/Lisp, `(cons 1 2)` is invalid in AIFPL. Use `(list 1 2)` to create pairs.\n\n#### List Access and Properties\n\n**Note:** The `rest` function always returns a list, never an atom.\n\n```aifpl\n(first (list 1 2 3))                  ; \u2192 1\n(rest (list 1 2 3))                   ; \u2192 (2 3) [always returns a list]\n(rest (list 1))                       ; \u2192 () [empty list, not an atom]\n(last (list 1 2 3))                   ; \u2192 3\n(list-ref (list \"a\" \"b\" \"c\") 1)       ; \u2192 \"b\" (0-indexed)\n(length (list 1 2 3))                 ; \u2192 3\n(null? (list))                        ; \u2192 #t\n(null? (list 1))                      ; \u2192 #f\n(list? (list 1 2))                    ; \u2192 #t\n(list? \"hello\")                       ; \u2192 #f\n(member? 2 (list 1 2 3))              ; \u2192 #t\n(member? 5 (list 1 2 3))              ; \u2192 #f\n```\n\n#### List Utilities\n```aifpl\n; Remove all occurrences of an element\n(remove 2 (list 1 2 3 2 4))           ; \u2192 (1 3 4)\n(remove \"x\" (list \"a\" \"x\" \"b\" \"x\"))   ; \u2192 (\"a\" \"b\")\n(remove 5 (list 1 2 3))               ; \u2192 (1 2 3) (no change if not found)\n\n; Find index of first occurrence\n(position 2 (list 1 2 3))             ; \u2192 1 (0-based index)\n(position \"b\" (list \"a\" \"b\" \"c\"))     ; \u2192 1\n(position 5 (list 1 2 3))             ; \u2192 #f (not found, consistent with find)\n(position 2 (list 1 2 3 2))           ; \u2192 1 (first occurrence)\n```\n\n#### List Utility Usage Patterns\n```aifpl\n; Clean and process data\n(let ((data (list 1 -2 3 -4 5))\n      (negatives (list -2 -4)))\n  (let ((cleaned (fold (lambda (acc neg) (remove neg acc)) data negatives))\n        (doubled (map (lambda (x) (* x 2)) cleaned)))\n    doubled))                          ; \u2192 (2 6 10)\n\n; Find and replace pattern\n(let ((find-and-process (lambda (item lst)\n                          (let ((pos (position item lst)))\n                            (if pos\n                                (string-append \"Found \" (number->string item) \n                                             \" at position \" (number->string pos))\n                                \"Not found\")))))\n  (list (find-and-process 3 (list 1 2 3 4))    ; \u2192 \"Found 3 at position 2\"\n        (find-and-process 5 (list 1 2 3 4))))  ; \u2192 \"Not found\"\n\n; List difference using remove\n(let ((list-difference (lambda (list1 list2)\n                         (fold remove list1 list2))))\n  (list-difference (list 1 2 3 4 5) (list 2 4)))  ; \u2192 (1 3 5)\n```\n\n#### List Equality\n```aifpl\n(= (list 1 2) (list 1 2))             ; \u2192 #t\n(= (list 1 2) (list 1 3))             ; \u2192 #f\n(= (list 1 2) (list 1 2 3))           ; \u2192 #f\n```\n\n### String Operations\n\n#### String Construction and Conversion\n```aifpl\n(string-append \"hello\" \" \" \"world\")   ; \u2192 \"hello world\"\n(number->string 42)                   ; \u2192 \"42\"\n(number->string 3.14)                 ; \u2192 \"3.14\"\n(string->number \"42\")                 ; \u2192 42\n(string->number \"3.14\")               ; \u2192 3.14\n```\n\n#### String Information and Access\n```aifpl\n(string-length \"hello\")               ; \u2192 5\n(string-ref \"hello\" 1)                ; \u2192 \"e\" (character at index 1)\n(substring \"hello\" 1 4)               ; \u2192 \"ell\" (start=1, end=4 exclusive)\n```\n\n#### String Manipulation\n```aifpl\n(string-upcase \"hello\")               ; \u2192 \"HELLO\"\n(string-downcase \"HELLO\")             ; \u2192 \"hello\"\n(string-trim \"  hello  \")             ; \u2192 \"hello\"\n(string-replace \"hello world\" \"world\" \"AIFPL\")  ; \u2192 \"hello AIFPL\"\n(string-replace \"banana\" \"a\" \"o\")     ; \u2192 \"bonono\" (non-overlapping)\n(string-replace \"test\" \"x\" \"y\")       ; \u2192 \"test\" (no change if not found)\n```\n\n#### String Manipulation Usage Patterns\n```aifpl\n; Clean and normalize text\n(let ((normalize-text (lambda (text)\n                        (let ((trimmed (string-trim text))\n                              (lower (string-downcase trimmed)))\n                          (string-replace lower \" \" \"-\")))))\n  (normalize-text \"  Hello World  \"))  ; \u2192 \"hello-world\"\n\n; Template replacement\n(let ((template \"Hello {name}, you have {count} messages\")\n      (replace-template (lambda (tmpl name count)\n                          (let ((with-name (string-replace tmpl \"{name}\" name)))\n                            (string-replace with-name \"{count}\" (number->string count))))))\n  (replace-template template \"Alice\" 5))  ; \u2192 \"Hello Alice, you have 5 messages\"\n\n; Multiple replacements\n(let ((clean-text (lambda (text)\n                     (let ((step1 (string-replace text \"bad\" \"good\"))\n                           (step2 (string-replace step1 \"ugly\" \"pretty\")))\n                       (string-replace step2 \"wrong\" \"right\")))))\n  (clean-text \"bad ugly wrong text\"))     ; \u2192 \"good pretty right text\"\n```\n\n#### String Predicates\n```aifpl\n(string-contains? \"hello world\" \"world\")  ; \u2192 #t\n(string-prefix? \"hello\" \"he\")             ; \u2192 #t\n(string-suffix? \"hello\" \"lo\")             ; \u2192 #t\n(string=? \"hello\" \"hello\")                ; \u2192 #t\n(string=? \"hello\" \"world\")                ; \u2192 #f\n```\n\n### String-List Integration\n\n#### String-List Conversion\n```aifpl\n(string->list \"hello\")                ; \u2192 (\"h\" \"e\" \"l\" \"l\" \"o\")\n(list->string (list \"h\" \"e\" \"l\" \"l\" \"o\"))  ; \u2192 \"hello\"\n```\n\n#### String Splitting and Joining\n```aifpl\n(string-split \"name,age,city\" \",\")    ; \u2192 (\"name\" \"age\" \"city\")\n(string-split \"hello world\" \" \")      ; \u2192 (\"hello\" \"world\")\n(string-join (list \"hello\" \"world\") \" \")  ; \u2192 \"hello world\"\n(string-join (list \"a\" \"b\" \"c\") \",\") ; \u2192 \"a,b,c\"\n```\n\n### String Literals and Escape Sequences\n\nString literals use double quotes and support escape sequences:\n\n```aifpl\n\"hello world\"                         ; Basic string\n\"She said \\\"Hello!\\\"\"                 ; Escaped quotes\n\"Line 1\\nLine 2\"                      ; Newline\n\"Column 1\\tColumn 2\"                  ; Tab\n\"Path\\\\to\\\\file\"                      ; Backslash\n\"Unicode: \\u03B1\\u03B2\\u03B3\"         ; Greek letters \u03b1\u03b2\u03b3\n```\n\n**Supported escape sequences:**\n- `\\\"` \u2192 literal quote\n- `\\\\` \u2192 literal backslash\n- `\\n` \u2192 newline\n- `\\t` \u2192 tab\n- `\\r` \u2192 carriage return\n- `\\uXXXX` \u2192 Unicode code point (4 hex digits)\n\n### Association Lists (Alists)\n\nAssociation lists (alists) are immutable key-value mappings with O(1) lookup performance. They are first-class data structures optimized for structured data processing.\n\n#### Creating Alists\n\n```aifpl\n; Basic alist creation\n(alist (\"name\" \"Alice\") (\"age\" 30) (\"city\" \"NYC\"))\n; \u2192 (alist (\"name\" \"Alice\") (\"age\" 30) (\"city\" \"NYC\"))\n\n; Empty alist\n(alist)\n; \u2192 (alist)\n\n; Alists with different key types\n(alist (1 \"one\") (2 \"two\") (3 \"three\"))\n(alist (#t \"yes\") (#f \"no\"))\n\n; Nested alists\n(alist \n  (\"user\" (alist (\"name\" \"Bob\") (\"id\" 123)))\n  (\"status\" \"active\"))\n```\n\n**Note**: `alist` is a special form that evaluates the key and value expressions within each pair, but treats the pair structure itself as data.\n\n#### Accessing Alist Values\n\n```aifpl\n; Get value by key\n(let ((person (alist (\"name\" \"Alice\") (\"age\" 30))))\n  (alist-get person \"name\"))\n; \u2192 \"Alice\"\n\n; Get with default value\n(alist-get person \"email\" \"no-email\")\n; \u2192 \"no-email\"\n\n; Missing keys return #f by default\n(alist-get person \"phone\")\n; \u2192 #f\n\n; Nested access\n(let ((data (alist (\"user\" (alist (\"name\" \"Carol\") (\"id\" 456))))))\n  (alist-get (alist-get data \"user\") \"name\"))\n; \u2192 \"Carol\"\n```\n\n#### Modifying Alists (Immutably)\n\nAll alist operations return new alists without modifying the original:\n\n```aifpl\n; Set a key (returns new alist)\n(let ((person (alist (\"name\" \"Alice\") (\"age\" 30))))\n  (alist-set person \"age\" 31))\n; \u2192 (alist (\"name\" \"Alice\") (\"age\" 31))\n\n; Add a new key\n(alist-set person \"email\" \"alice@example.com\")\n; \u2192 (alist (\"name\" \"Alice\") (\"age\" 30) (\"email\" \"alice@example.com\"))\n\n; Original is unchanged\n(let ((original (alist (\"x\" 1)))\n      (modified (alist-set original \"x\" 2)))\n  (list (alist-get original \"x\") (alist-get modified \"x\")))\n; \u2192 (1 2)\n\n; Remove a key\n(alist-remove person \"age\")\n; \u2192 (alist (\"name\" \"Alice\"))\n```\n\n#### Alist Queries\n\n```aifpl\n; Check if key exists\n(alist-has? person \"name\")\n; \u2192 #t\n\n(alist-has? person \"phone\")\n; \u2192 #f\n\n; Get all keys\n(alist-keys (alist (\"a\" 1) (\"b\" 2) (\"c\" 3)))\n; \u2192 (\"a\" \"b\" \"c\")\n\n; Get all values\n(alist-values (alist (\"a\" 1) (\"b\" 2) (\"c\" 3)))\n; \u2192 (1 2 3)\n\n; Type checking\n(alist? (alist (\"x\" 1)))\n; \u2192 #t\n\n(alist? (list 1 2 3))\n; \u2192 #f\n```\n\n#### Merging Alists\n\n```aifpl\n; Merge two alists (second wins on conflicts)\n(let ((defaults (alist (\"port\" 8080) (\"host\" \"localhost\")))\n      (config (alist (\"port\" 3000) (\"debug\" #t))))\n  (alist-merge defaults config))\n; \u2192 (alist (\"port\" 3000) (\"host\" \"localhost\") (\"debug\" #t))\n\n; Merge multiple alists\n(let ((a (alist (\"x\" 1)))\n      (b (alist (\"y\" 2)))\n      (c (alist (\"z\" 3))))\n  (alist-merge (alist-merge a b) c))\n; \u2192 (alist (\"x\" 1) (\"y\" 2) (\"z\" 3))\n```\n\n#### Alists with Functional Operations\n\n```aifpl\n; Map over keys\n(let ((data (alist (\"name\" \"alice\") (\"city\" \"nyc\"))))\n  (map string-upcase (alist-keys data)))\n; \u2192 (\"NAME\" \"CITY\")\n\n; Filter values\n(let ((scores (alist (\"alice\" 85) (\"bob\" 92) (\"carol\" 78))))\n  (filter (lambda (score) (> score 80)) (alist-values scores)))\n; \u2192 (85 92)\n\n; Fold over values\n(let ((prices (alist (\"apple\" 1.5) (\"banana\" 0.8) (\"orange\" 1.2))))\n  (fold + 0 (alist-values prices)))\n; \u2192 3.5\n\n; Process list of alists\n(let ((people (list \n                (alist (\"name\" \"Alice\") (\"age\" 30))\n                (alist (\"name\" \"Bob\") (\"age\" 25))\n                (alist (\"name\" \"Carol\") (\"age\" 35)))))\n  (map (lambda (p) (alist-get p \"name\")) people))\n; \u2192 (\"Alice\" \"Bob\" \"Carol\")\n```\n\n#### Pattern Matching with Alists\n\n```aifpl\n; Match alist type\n(match (alist (\"type\" \"user\") (\"name\" \"Alice\"))\n  ((alist? data) (alist-get data \"name\"))\n  (_ \"not-alist\"))\n; \u2192 \"Alice\"\n\n; Distinguish alist from list\n(let ((process (lambda (data)\n                 (match data\n                   ((alist? a) \"alist\")\n                   ((list? l) \"list\")\n                   (_ \"other\")))))\n  (list (process (alist (\"a\" 1)))\n        (process (list 1 2 3))))\n; \u2192 (\"alist\" \"list\")\n```\n\n#### Alist Performance\n\nAlists in AIFPL use hash-backed storage for O(1) lookup performance:\n\n- `alist-get`: O(1) - constant time lookup\n- `alist-set`: O(n) - creates new alist with updated value\n- `alist-has?`: O(1) - constant time membership test\n- `alist-keys`/`alist-values`: O(n) - iterates all pairs\n- `alist-merge`: O(n+m) - combines two alists\n\nAlists maintain insertion order and are optimized for read-heavy workloads common in data processing.\n\n### Complex Number Operations\nThe `real` and `imag` functions extract components from any numeric value:\n\n**Real Part Extraction:**\n```aifpl\n(real 42)              ; \u2192 42\n(real 3.14)            ; \u2192 3.14\n(real (complex 3 4))   ; \u2192 3\n(real j)               ; \u2192 0\n```\n\n**Imaginary Part Extraction:**\n```aifpl\n(imag 42)              ; \u2192 0\n(imag 3.14)            ; \u2192 0\n(imag (complex 3 4))   ; \u2192 4\n(imag j)               ; \u2192 1\n```\n\n**With Expressions:**\n```aifpl\n(real (+ (complex 1 2) (complex 3 4)))  ; \u2192 4\n(imag (sqrt -1))                        ; \u2192 1\n(real (* j j))                          ; \u2192 -1\n```\n\n## Type System\n\nAIFPL has a strict type system with the following types:\n\n- **Numbers**: `int`, `float`, `complex` (with automatic promotion)\n- **Strings**: UTF-8 strings with no automatic conversion\n- **Booleans**: `#t` and `#f` with no automatic conversion\n- **Lists**: Heterogeneous collections supporting any element type\n- **Functions**: First-class lambda functions with lexical scoping\n\n### Type Promotion Rules\n\n1. **Numeric promotion**: `int \u2192 float \u2192 complex`\n2. **No cross-type operations**: Strings, booleans, and lists don't mix with numbers\n3. **Explicit conversion**: Use conversion functions when needed\n4. **List heterogeneity**: Lists can contain mixed types\n5. **Function values**: Functions are first-class values that can be stored and passed\n\n### Examples of Type Strictness\n\n```aifpl\n; Valid - same types\n(+ 1 2 3)                             ; \u2192 6 (all integers)\n(string-append \"hello\" \" \" \"world\")   ; \u2192 \"hello world\" (all strings)\n(and #t #f #t)                        ; \u2192 #f (all booleans)\n\n; Valid - numeric promotion\n(+ 1 2.5)                             ; \u2192 3.5 (int promoted to float)\n(* 2 (complex 1 1))                   ; \u2192 (2+2j) (promoted to complex)\n\n; Valid - heterogeneous lists\n(list 1 \"hello\" #t)                   ; \u2192 (1 \"hello\" #t)\n(append (list 1 2) (list \"a\" \"b\"))    ; \u2192 (1 2 \"a\" \"b\")\n\n; Valid - list equality\n(= (list 1 2) (list 1 2))             ; \u2192 #t\n\n; Valid - conditionals with boolean conditions\n(if #t \"yes\" \"no\")                    ; \u2192 \"yes\"\n(if (> 5 3) 42 0)                     ; \u2192 42\n\n; Valid - functions as values\n(let ((f (lambda (x) (* x 2)))) (f 5))  ; \u2192 10\n(list (lambda (x) (+ x 1)) (lambda (x) (* x 2)))  ; \u2192 (<lambda (x)> <lambda (x)>)\n\n; Valid - type checking with predicates\n(if (number? x) (* x 2) \"not a number\")\n(filter string? (list 1 \"hello\" #t \"world\"))  ; \u2192 (\"hello\" \"world\")\n\n; Valid - quote for data literals (both forms)\n(quote (+ 1 2 3))                     ; \u2192 (+ 1 2 3) (as data, not evaluation)\n'(+ 1 2 3)                            ; \u2192 (+ 1 2 3) (shortcut form)\n(list (quote hello) (+ 1 2))          ; \u2192 (hello 3) (mixed quoted/unquoted)\n(list 'hello (+ 1 2))                 ; \u2192 (hello 3) (shortcut form)\n\n; Valid - pattern matching\n(match 42\n  ((number? n) (* n 2))\n  (_ \"not a number\"))                 ; \u2192 84\n\n; Invalid - type mismatch\n(+ 1 \"hello\")                         ; Error: cannot add number and string\n(and #t 1)                            ; Error: 'and' requires boolean arguments\n(string-length 42)                    ; Error: string-length requires string\n(+ (list 1 2))                        ; Error: cannot add list\n(< (list 1) (list 2))                 ; Error: cannot compare lists (only = works)\n(if 1 \"yes\" \"no\")                     ; Error: condition must be boolean\n\n; Valid - explicit conversion\n(string-append \"Count: \" (number->string 42))  ; \u2192 \"Count: 42\"\n(+ 5 (string->number \"10\"))                    ; \u2192 15\n(list->string (string->list \"hello\"))          ; \u2192 \"hello\"\n```\n\n### List Type Rules\n\n1. **Mixed types allowed**: `(list 1 \"hi\" #t)` is valid\n2. **No arithmetic operations**: `(+ (list 1 2))` is an error\n3. **Only equality comparison**: `(= (list 1) (list 1))` works, `(< (list 1) (list 2))` doesn't\n4. **Type-specific functions**: List functions require lists, string functions require strings\n5. **Explicit conversion**: Use `string->list`, `list->string` for conversions\n\n### Function Type Rules\n\n1. **First-class values**: Functions can be passed, returned, stored in lists\n2. **Lexical scoping**: Functions access variables from their definition environment\n3. **Closures**: Functions capture their environment when created\n4. **Arity checking**: Function calls must provide exact number of parameters\n5. **Identity equality**: Each lambda creates a unique function object\n\n## Pure List Representation Benefits\n\nThe pure list approach provides several advantages:\n\n1. **True homoiconicity**: Code and data have identical representation\n2. **Simpler architecture**: Only `AIFPLValue` types, no special AST nodes\n3. **Traditional Lisp semantics**: Everything is data, following Lisp philosophy\n4. **Easier to understand**: One consistent representation for all expressions\n5. **Future extensibility**: Natural foundation for features like macros\n6. **Reduced complexity**: Fewer types, simpler parser, more straightforward evaluator\n\n### Internal Representation Examples\n\n```aifpl\n; Lambda expression: (lambda (x) (* x x))\n; Represented as: AIFPLList([AIFPLSymbol(\"lambda\"), AIFPLList([AIFPLSymbol(\"x\")]), AIFPLList([...])])\n\n; Let expression: (let ((x 5)) (+ x 1))\n; Represented as: AIFPLList([AIFPLSymbol(\"let\"), AIFPLList([AIFPLList([...])]), ...])\n\n; Function call: (+ 1 2 3)\n; Represented as: AIFPLList([AIFPLSymbol(\"+\"), AIFPLNumber(1), AIFPLNumber(2), AIFPLNumber(3)])\n\n; Quote expression: (quote (+ 1 2))\n; Represented as: AIFPLList([AIFPLSymbol(\"quote\"), AIFPLList([AIFPLSymbol(\"+\"), AIFPLNumber(1), AIFPLNumber(2)])])\n\n; Single quote shortcut: '(+ 1 2)\n; Represented as: AIFPLList([AIFPLSymbol(\"quote\"), AIFPLList([AIFPLSymbol(\"+\"), AIFPLNumber(1), AIFPLNumber(2)])])\n; (Identical to the full quote form - the shortcut is purely syntactic sugar)\n\n; Match expression: (match x ((number? n) (* n 2)) (_ \"not a number\"))\n; Represented as: AIFPLList([AIFPLSymbol(\"match\"), AIFPLSymbol(\"x\"), AIFPLList([...]), ...])\n```\n\nThe evaluator recognizes special forms by examining the first element of lists, maintaining the traditional Lisp approach where syntax is determined by structure, not by special types.\n\n## Common Usage Patterns\n\n### Pattern Matching for Data Processing\n```aifpl\n; Replace complex nested conditionals with pattern matching\n(let ((process-data (lambda (item)\n                      (match item\n                        ((\"user\" name email) \n                         (string-append \"User: \" name \" (\" email \")\"))\n                        ((\"product\" id price)\n                         (string-append \"Product #\" (number->string id) \": $\" (number->string price)))\n                        ((\"order\" id items total)\n                         (string-append \"Order #\" (number->string id) \" (\" \n                                      (number->string (length items)) \" items): $\" \n                                      (number->string total)))\n                        (_ \"unknown data type\")))))\n  (map process-data (list (list \"user\" \"Alice\" \"alice@example.com\")\n                         (list \"product\" 123 29.99)\n                         (list \"order\" 456 (list \"item1\" \"item2\") 59.98)\n                         (list \"invalid\" \"data\"))))\n; \u2192 (\"User: Alice (alice@example.com)\" \"Product #123: $29.99\" \"Order #456 (2 items): $59.98\" \"unknown data type\")\n\n; Type-based processing with pattern matching\n(let ((safe-operation (lambda (x y)\n                        (match (list x y)\n                          (((number? a) (number? b)) (+ a b))\n                          (((string? a) (string? b)) (string-append a \" \" b))\n                          (((list? a) (list? b)) (append a b))\n                          (_ \"incompatible types\")))))\n  (list (safe-operation 5 10)\n        (safe-operation \"hello\" \"world\")\n        (safe-operation (list 1 2) (list 3 4))\n        (safe-operation 5 \"hello\")))\n; \u2192 (15 \"hello world\" (1 2 3 4) \"incompatible types\")\n\n; Configuration parsing with patterns\n(let ((parse-config (lambda (config-list)\n                      (map (lambda (item)\n                             (match item\n                               ((\"server\" host port)\n                                (list \"server-config\" host port))\n                               ((\"database\" type connection-string)\n                                (list \"db-config\" type connection-string))\n                               ((\"feature\" name enabled)\n                                (list \"feature-toggle\" name enabled))\n                               (_ (list \"unknown-config\" item))))\n                           config-list))))\n  (parse-config (list (list \"server\" \"localhost\" 8080)\n                     (list \"database\" \"postgresql\" \"postgres://localhost/mydb\")\n                     (list \"feature\" \"new-ui\" #t)\n                     (list \"invalid\" \"config\" \"entry\"))))\n; \u2192 ((\"server-config\" \"localhost\" 8080) (\"db-config\" \"postgresql\" \"postgres://localhost/mydb\") (\"feature-toggle\" \"new-ui\" #t) (\"unknown-config\" (\"invalid\" \"config\" \"entry\")))\n```\n\n### Symbolic Programming with Quote\n```aifpl\n; Store and manipulate code as data (using shortcuts for cleaner syntax)\n(let ((expressions (list '(+ 1 2)\n                        '(* 3 4)\n                        '(- 10 5))))\n  (map first expressions))                  ; \u2192 (+ * -) (extract operators)\n\n; Template-based programming (shortcuts make templates more readable)\n(let ((make-comparison (lambda (op value)\n                         (list 'lambda\n                              '(x)\n                              (list op 'x value)))))\n  (list (make-comparison '> 10)\n        (make-comparison '= 0)))            ; \u2192 ((lambda (x) (> x 10)) (lambda (x) (= x 0)))\n\n; Code transformation (shortcuts improve readability)\n(let ((negate-condition (lambda (expr)\n                          (if (and (list? expr) (= (first expr) '>))\n                              (cons '<= (rest expr))\n                              expr))))\n  (negate-condition '(> x 5)))              ; \u2192 (<= x 5)\n```\n\n### Functional Data Processing\n```aifpl\n; Process list of numbers\n(let ((numbers (list 1 2 3 4 5 6 7 8 9 10)))\n  (let ((evens (filter (lambda (x) (= (% x 2) 0)) numbers))\n        (doubled (map (lambda (x) (* x 2)) evens))\n        (sum (fold + 0 doubled)))\n    sum))                                   ; \u2192 60\n\n; Text processing pipeline\n(let ((text \"The quick brown fox jumps\"))\n  (let ((words (string-split text \" \"))\n        (long-words (filter (lambda (w) (> (string-length w) 3)) words))\n        (upper-words (map string-upcase long-words)))\n    (string-join upper-words \"-\")))         ; \u2192 \"QUICK-BROWN-JUMPS\"\n\n; Data validation and transformation\n(let ((validate-and-double (lambda (nums)\n                            (if (all? (lambda (x) (> x 0)) nums)\n                                (map (lambda (x) (* x 2)) nums)\n                                \"error: negative numbers\"))))\n  (list (validate-and-double (list 1 2 3))\n        (validate-and-double (list 1 -2 3))))  ; \u2192 ((2 4 6) \"error: negative numbers\")\n```\n\n### Conditional Processing\n```aifpl\n; Safe division\n(if (= divisor 0) \"undefined\" (/ dividend divisor))\n\n; Safe list access\n(if (null? my-list) \"empty\" (first my-list))\n\n; Data validation\n(if (string-contains? input \"@\")\n    (string-append \"Email: \" input)\n    \"Invalid email format\")\n\n; Conditional list processing\n(if (> (length items) 0)\n    (string-join items \", \")\n    \"No items\")\n\n; Nested conditionals for complex logic\n(if (> temperature 30)\n    \"hot\"\n    (if (> temperature 20) \"warm\" \"cold\"))\n```\n\n### Function Composition and Higher-Order Patterns\n```aifpl\n; Create reusable transformations\n(let ((process-data (lambda (data)\n                      (let ((clean (filter (lambda (x) (> x 0)) data))\n                            (transformed (map (lambda (x) (+ (* x x) 1)) clean))\n                            (limited (take 5 transformed)))\n                        limited))))\n  (process-data (list -1 2 3 -4 5 6 7 8)))  ; \u2192 (5 10 26 37 50)\n\n; Build complex predicates\n(let ((in-range (lambda (min max)\n                  (lambda (x) (and (>= x min) (<= x max)))))\n      (is-even (lambda (x) (= (% x 2) 0))))\n  (let ((even-in-range (lambda (x) (and (is-even x) ((in-range 10 50) x)))))\n    (filter even-in-range (range 1 60))))   ; \u2192 (10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50)\n\n; Recursive data structures\n(let ((tree-sum (lambda (tree)\n                  (if (list? tree)\n                      (fold + 0 (map tree-sum tree))\n                      tree))))\n  (tree-sum (list 1 (list 2 3) (list (list 4 5) 6))))  ; \u2192 21\n```\n\n### Type-Safe Programming Patterns\n```aifpl\n; Polymorphic function with type checking\n(let ((safe-process (lambda (value)\n                      (if (number? value)\n                          (* value value)\n                          (if (string? value)\n                              (string-upcase value)\n                              (if (list? value)\n                                  (length value)\n                                  \"unknown type\"))))))\n  (map safe-process (list 5 \"hello\" (list 1 2 3) #t)))  ; \u2192 (25 \"HELLO\" 3 \"unknown type\")\n\n; Type validation pipeline\n(let ((validate-input (lambda (data)\n                        (if (list? data)\n                            (if (all? number? data)\n                                (fold + 0 data)\n                                \"error: non-numeric data\")\n                            \"error: not a list\"))))\n  (list (validate-input (list 1 2 3))        ; \u2192 6\n        (validate-input (list 1 \"x\" 3))      ; \u2192 \"error: non-numeric data\"\n        (validate-input \"not a list\")))      ; \u2192 \"error: not a list\"\n\n; Mixed type list processing\n(let ((categorize (lambda (items)\n                    (let ((numbers (filter number? items))\n                          (strings (filter string? items))\n                          (booleans (filter boolean? items)))\n                      (list (list \"numbers\" numbers)\n                            (list \"strings\" strings)\n                            (list \"booleans\" booleans))))))\n  (categorize (list 1 \"hello\" #t 3.14 \"world\" #f)))\n; \u2192 ((\"numbers\" (1 3.14)) (\"strings\" (\"hello\" \"world\")) (\"booleans\" (#t #f)))\n```\n\n### String Processing\n```aifpl\n; Split CSV data and process\n(string-split \"name,age,city\" \",\")              ; \u2192 (\"name\" \"age\" \"city\")\n(first (string-split \"John,25,NYC\" \",\"))        ; \u2192 \"John\"\n(length (string-split \"a,b,c,d\" \",\"))           ; \u2192 4\n\n; Build strings from components\n(string-join (list \"hello\" \"world\") \" \")        ; \u2192 \"hello world\"\n(string-join (reverse (string-split \"a-b-c\" \"-\")) \"+\")  ; \u2192 \"c+b+a\"\n\n; Conditional string processing\n(if (> (string-length text) 10)\n    (string-append (substring text 0 10) \"...\")\n    text)\n\n; Advanced text processing\n(let ((clean-and-format (lambda (text)\n                          (let ((trimmed (string-trim text))\n                                (normalized (string-replace trimmed \"  \" \" \")))\n                            (string-upcase normalized)))))\n  (clean-and-format \"  hello    world  \"))      ; \u2192 \"HELLO  WORLD\"\n```\n\n### Character-Level Processing\n```aifpl\n; Convert to characters, process, convert back\n(string->list \"hello\")                          ; \u2192 (\"h\" \"e\" \"l\" \"l\" \"o\")\n(reverse (string->list \"hello\"))                ; \u2192 (\"o\" \"l\" \"l\" \"e\" \"h\")\n(list->string (reverse (string->list \"hello\"))) ; \u2192 \"olleh\"\n```\n\n### Data Structure Manipulation\n```aifpl\n; Build complex data structures\n(list (list \"name\" \"John\") (list \"age\" 25))     ; \u2192 ((\"name\" \"John\") (\"age\" 25))\n(first (list (list 1 2) (list 3 4)))            ; \u2192 (1 2)\n(rest (first (list (list 1 2 3) (list 4 5))))   ; \u2192 (2 3)\n\n; Conditional data processing\n(if (member? \"error\" status-list)\n    (list \"status\" \"error\" \"failed\")\n    (list \"status\" \"ok\" \"success\"))\n\n; Advanced list manipulation \n(let ((data (list 1 2 3 2 4 2 5))\n      (target 2))\n  (let ((cleaned (remove target data))\n        (position-info (position target data)))\n    (list \"original\" data \n          \"cleaned\" cleaned \n          \"first-position\" position-info)))\n; \u2192 (\"original\" (1 2 3 2 4 2 5) \"cleaned\" (1 3 4 5) \"first-position\" 1)\n```\n\n### Quote Shortcut Usage Patterns\n```aifpl\n; Building expressions with mixed quoted and evaluated parts\n(let ((make-setter (lambda (var value)\n                     (list 'let (list (list var value)) var))))\n  (make-setter 'x 42))                      ; \u2192 (let ((x 42)) x)\n\n; Code generation with templates\n(let ((make-validator (lambda (type-pred error-msg)\n                        '(lambda (value)\n                           (if (,type-pred value)\n                               value\n                               ,error-msg)))))\n  ; Note: This is conceptual - actual implementation would need more complex quasiquoting\n  (make-validator 'number? \"not a number\"))\n\n; Data-driven programming\n(let ((operations '((add +) (multiply *) (subtract -))))\n  (map (lambda (op) (first (rest op))) operations))  ; \u2192 (+ * -)\n\n; Pattern matching simulation\n(let ((match-expr (lambda (pattern expr)\n                    (if (= (first pattern) (first expr))\n                        'match\n                        'no-match))))\n  (list (match-expr '(+ ? ?) '(+ 1 2))     ; \u2192 match\n        (match-expr '(+ ? ?) '(* 1 2))))   ; \u2192 no-match\n```\n\n## Advanced Features\n\n### Tail Call Optimization\n\nAIFPL automatically optimizes tail calls to prevent stack overflow in recursive functions:\n\n```aifpl\n; Factorial with tail recursion (automatically optimized)\n(let ((factorial (lambda (n acc)\n                   (if (<= n 1)\n                       acc\n                       (factorial (- n 1) (* n acc))))))\n  (factorial 1000 1))                       ; Works with large numbers\n\n; Mutual recursion is also optimized\n(let ((is-even (lambda (n)\n                 (if (= n 0) #t (is-odd (- n 1)))))\n      (is-odd (lambda (n)\n                (if (= n 0) #f (is-even (- n 1))))))\n  (is-even 10000))                          ; \u2192 #t (no stack overflow)\n```\n\n### Lexical Scoping and Closures\n\nFunctions capture their lexical environment, creating closures:\n\n```aifpl\n; Function factory with captured state\n(let ((make-adder (lambda (increment)\n                    (lambda (x) (+ x increment)))))\n  (let ((add-five (make-adder 5))\n        (add-ten (make-adder 10)))\n    (list (add-five 3) (add-ten 3))))      ; \u2192 (8 13)\n\n; Nested closures capturing multiple levels\n(let ((outer-value 100))\n  (let ((make-calculator (lambda (operation)\n                           (lambda (x y)\n                             (operation (+ x outer-value) y)))))\n    (let ((multiply-with-offset (make-calculator *))\n          (add-with-offset (make-calculator +)))\n      (list (multiply-with-offset 2 3)     ; \u2192 (102 * 3) = 306\n            (add-with-offset 5 10)))))     ; \u2192 (105 + 10) = 115\n```\n\n### Error Handling Patterns\n\n```aifpl\n; Validation chains\n(let ((validate-number (lambda (x)\n                         (if (> x 0) x \"error: not positive\")))\n      (validate-range (lambda (x)\n                        (if (and (>= x 1) (<= x 100)) x \"error: out of range\"))))\n  (let ((process (lambda (x)\n                   (let ((step1 (validate-number x)))\n                     (if (string? step1)\n                         step1\n                         (validate-range step1))))))\n    (list (process 50) (process -5) (process 150))))  ; \u2192 (50 \"error: not positive\" \"error: out of range\")\n\n; Safe operations with defaults\n(let ((safe-head (lambda (lst default)\n                   (if (null? lst) default (first lst))))\n      (safe-tail (lambda (lst default)\n                   (if (null? lst) default (last lst))))\n      (safe-divide (lambda (x y default)\n                     (if (= y 0) default (/ x y)))))\n  (list (safe-head (list) \"empty\")\n        (safe-tail (list 1 2 3) \"empty\")\n        (safe-divide 10 0 \"undefined\")))    ; \u2192 (\"empty\" 3 \"undefined\")\n```\n\n## Differences from Traditional Lisp/Scheme\n\n**AIFPL uses proper lists only, not cons cells.** This is a fundamental difference from traditional Lisp/Scheme that affects list construction and pattern matching.\n\n### Key Differences\n\n#### 1. Cons Requires a List as Second Argument\n\n**Traditional Lisp/Scheme:**\n```scheme\n(cons 1 2)              ; => (1 . 2)  - creates a dotted pair\n(cons 1 (cons 2 3))     ; => (1 2 . 3) - creates an improper list\n```\n\n**AIFPL:**\n```aifpl\n(cons 1 (list 2 3))     ; => (1 2 3)  \u2713 Valid - second arg is a list\n(cons 1 (list 2))       ; => (1 2)    \u2713 Valid\n(cons 1 2)              ; => ERROR    \u2717 Invalid - second arg must be a list!\n```\n\n**Why?** AIFPL lists are backed by Python tuples. All lists are proper lists - there are no dotted pairs or improper lists. This makes the language simpler and more predictable.\n\n**To create pairs:** Use `(list a b)` instead of cons cells.\n\n#### 2. Rest Always Returns a List\n\n**Traditional Lisp/Scheme:**\n```scheme\n(cdr '(1))        ; => ()  - empty list\n(cdr '(1 . 2))    ; => 2   - can return an atom!\n```\n\n**AIFPL:**\n```aifpl\n(rest (list 1))         ; => ()     - always returns a list\n(rest (list 1 2))       ; => (2)    - always returns a list\n; No way to get an atom from rest\n```\n\n**Why?** This guarantees type safety. You always know `rest` returns a list, never an atom.\n\n#### 3. Pattern Matching: Tail is Always a List\n\n**Traditional Lisp/Scheme:**\n```scheme\n(match '(1 . 2) ((h . t) t))    ; => 2   - t binds to atom\n(match '(1 2) ((h . t) t))      ; => (2) - t binds to list\n```\n\n**AIFPL:**\n```aifpl\n(match (list 1 2) ((h . t) t))      ; => (2)  - t is always a list\n(match (list 1) ((h . t) t))        ; => ()   - t is empty list, not atom\n```\n\n**Why?** Consistency. The `(head . tail)` pattern always binds `tail` to a list (possibly empty), never to an atom.\n\n#### 4. No car/cdr - Use first/rest\n\nAIFPL uses more descriptive names:\n- `first` instead of `car`\n- `rest` instead of `cdr`\n- `last` for the last element\n\nThese names are clearer and emphasize that `rest` always returns a list.\n\n### Other Differences from Scheme/Lisp\n\n- **No mutation**: No `set!`, `set-car!`, `set-cdr!` - all data is immutable\n- **No macros**: No `define-syntax` or `defmacro` - all special forms are built-in\n- **No global definitions**: No top-level `define` - use `let` for bindings\n- **Strict type system**: Boolean operations require booleans, no \"truthy\" values\n- **No continuations**: No `call/cc` - simpler execution model\n\n### Migration Guide\n\nIf you're coming from Scheme/Lisp:\n\n**Creating pairs:**\n```aifpl\n; Instead of: (cons 1 2)\n(list 1 2)              ; Two-element list\n```\n\n**Association lists:**\n```aifpl\n; Instead of: '((a . 1) (b . 2))\n(list (list \"a\" 1) (list \"b\" 2))    ; List of two-element lists\n```\n\n**Pattern matching:**\n```aifpl\n; Pattern (h . t) always binds t to a list\n(match (list 1 2 3)\n  ((h . t) (list h t)))             ; => (1 (2 3))  - t is (2 3), not 2 3\n\n; For fixed-length patterns, use explicit elements\n(match (list 1 2)\n  ((a b) (list a b)))               ; => (1 2)  - direct binding\n```\n\n### Why These Differences?\n\n1. **Simplicity**: Proper lists only means fewer edge cases\n2. **Type safety**: `rest` always returns a list - no runtime type checking needed\n3. **Predictability**: Consistent behavior makes code easier to reason about\n4. **AI-friendly**: Fewer special cases for AI models to learn\n\n## Design Principles\n\n1. **Pure List Representation**: Everything is data, following traditional Lisp philosophy\n2. **Functional Programming**: First-class functions, immutable data, no side effects\n3. **Lexical Scoping**: Variables resolved in their definition environment\n4. **Tail Call Optimization**: Automatic optimization for recursive patterns\n5. **Type Safety**: Comprehensive type hints and strict type checking\n6. **Error Handling**: Detailed error messages with position information\n7. **Performance**: Efficient evaluation with automatic optimizations\n8. **LISP Compatibility**: Following traditional LISP semantics where applicable\n9. **Lazy Evaluation**: Conditionals and boolean operators use lazy evaluation\n10. **Independence**: No dependencies on external packages\n11. **Simplicity**: Direct S-expression evaluation without over-engineering\n12. **Homoiconicity**: Code and data use identical representations\n13. **Syntactic Sugar**: Single quote shortcut provides convenient syntax while maintaining pure list representation\n14. **Pattern Matching**: Comprehensive pattern matching for elegant data processing\n15. **Proper Lists Only**: Lists are backed by Python tuples, no cons cells or improper lists for simplicity and type safety\n\n## Architecture\n\nAIFPL uses a **pure list representation** for all code, following traditional Lisp philosophy:\n\n- **Everything is data**: Code and data have identical representation (`AIFPLValue` objects)\n- **No special AST nodes**: Lambda expressions, let expressions, and function calls are all just lists\n- **Homoiconic**: The same data structures represent both code and data\n- **Simple and consistent**: One unified representation for all expressions\n\n### Package Structure\n\n```plaintext\nsrc/aifpl/\n\u251c\u2500\u2500 __init__.py              # Package exports\n\u251c\u2500\u2500 aifpl.py                 # Main AIFPL class (public API)\n\u251c\u2500\u2500 aifpl_error.py           # Exception classes\n\u251c\u2500\u2500 aifpl_token.py           # Token types and definitions\n\u251c\u2500\u2500 aifpl_tokenizer.py       # Tokenizer implementation\n\u251c\u2500\u2500 aifpl_parser.py          # Parser (creates AIFPLValue objects)\n\u251c\u2500\u2500 aifpl_evaluator.py       # Expression evaluator\n\u251c\u2500\u2500 aifpl_environment.py     # Environment and function management\n\u251c\u2500\u2500 aifpl_value.py           # Value hierarchy (AIFPLValue types)\n\u2514\u2500\u2500 aifpl_dependency_analyzer.py  # Let binding dependency analysis\n```\n\n### Core Types\n\n- **AIFPLValue**: Base class for all values (numbers, strings, booleans, symbols, lists, functions)\n\n### Exception Hierarchy\n\n- `AIFPLError` - Base exception\n  - `AIFPLTokenError` - Tokenization errors\n  - `AIFPLParseError` - Parsing errors\n  - `AIFPLEvalError` - Evaluation errors\n\n## Advanced Usage\n\n### Custom Configuration\n\n```python\n# Increase recursion depth for deeply nested expressions\ntool = AIFPL(max_depth=500)\n\n# Adjust tolerance for complex number simplification\ntool = AIFPL(floating_point_tolerance=1e-15)\n```\n\n### Working with Results\n\n```python\n# Raw evaluation returns Python objects\nresult = tool.evaluate('(list 1 2 3)')\nprint(f\"Result: {result}\")  # Result: [1, 2, 3]\nprint(f\"Type: {type(result)}\")  # Type: <class 'list'>\n\n# Formatted evaluation returns LISP-style strings\nformatted = tool.evaluate_and_format('(list 1 2 3)')\nprint(f\"Formatted: {formatted}\")  # Formatted: (1 2 3)\n\n# Function results\nfunc_result = tool.evaluate('(lambda (x) (* x x))')\nprint(f\"Function: {func_result}\")  # Function: <aifpl.aifpl_environment.AIFPLLambdaFunction object>\n\nformatted_func = tool.evaluate_and_format('(lambda (x) (* x x))')\nprint(f\"Formatted Function: {formatted_func}\")  # Formatted Function: <lambda (x)>\n\n# Boolean results\nbool_result = tool.evaluate('(member? 2 (list 1 2 3))')\nprint(f\"Boolean: {bool_result}\")  # Boolean: True\n\nformatted_bool = tool.evaluate_and_format('(member? 2 (list 1 2 3))')\nprint(f\"Formatted Boolean: {formatted_bool}\")  # Formatted Boolean: #t\n\ninequality_result = tool.evaluate('(!= 1 2 3)')\nprint(f\"Inequality: {inequality_result}\")  # Inequality: True\n\ntype_check = tool.evaluate('(number? 42)')\nprint(f\"Type check: {type_check}\")  # Type check: True\n\nposition_result = tool.evaluate('(position \"world\" (list \"hello\" \"world\"))')\nprint(f\"Position: {position_result}\")  # Position: 1\n\n# Quote results (both forms produce identical results)\nquote_result = tool.evaluate('(quote (+ 1 2 3))')\nprint(f\"Quote result: {quote_result}\")  # Quote result: ['+', 1, 2, 3]\n\nshortcut_result = tool.evaluate(\"'(+ 1 2 3)\")\nprint(f\"Shortcut result: {shortcut_result}\")  # Shortcut result: ['+', 1, 2, 3]\n\nformatted_quote = tool.evaluate_and_format('(quote (+ 1 2 3))')\nprint(f\"Formatted quote: {formatted_quote}\")  # Formatted quote: (+ 1 2 3)\n\nformatted_shortcut = tool.evaluate_and_format(\"'(+ 1 2 3)\")\nprint(f\"Formatted shortcut: {formatted_shortcut}\")  # Formatted shortcut: (+ 1 2 3)\n\n# Pattern matching results\npattern_result = tool.evaluate('(match 42 ((number? n) (* n 2)) (_ \"not a number\"))')\nprint(f\"Pattern match: {pattern_result}\")  # Pattern match: 84\n\ncomplex_pattern = tool.evaluate('(match (list 1 2 3) ((a b c) (+ a b c)) (_ \"no match\"))')\nprint(f\"Complex pattern: {complex_pattern}\")  # Complex pattern: 6\n```\n\n### Error Handling Patterns\n\n```python\nfrom aifpl import AIFPL, AIFPLTokenError, AIFPLParseError, AIFPLEvalError\n\ntool = AIFPL()\n\ntry:\n    result = tool.evaluate(expression)\n\nexcept AIFPLTokenError as e:\n    print(f\"Tokenization error: {e}\")\n\nexcept AIFPLParseError as e:\n    print(f\"Parsing error: {e}\")\n\nexcept AIFPLEvalError as e:\n    print(f\"Evaluation error: {e}\")\n\nexcept AIFPLError as e:\n    print(f\"General AIFPL error: {e}\")\n```\n\n### Complex Functional Processing\n\n```python\n# Complex nested operations with functional programming\nfunctional_expr = '''\n(let ((data (list 1 2 3 4 5 6 7 8 9 10)))\n  (let ((process (lambda (nums)\n                   (let ((evens (filter (lambda (x) (= (% x 2) 0)) nums))\n                         (squares (map (lambda (x) (* x x)) evens))\n                         (sum (fold + 0 squares)))\n                     sum))))\n    (process data)))\n'''\n\n# Higher-order function composition\ncomposition_expr = '''\n(let ((compose (lambda (f g) (lambda (x) (f (g x)))))\n      (add-one (lambda (x) (+ x 1)))\n      (double (lambda (x) (* x 2))))\n  (let ((transform (compose add-one double)))\n    (map transform (list 1 2 3 4 5))))\n'''\n\n# Recursive data processing with tail optimization\nrecursive_expr = '''\n(let ((factorial (lambda (n acc)\n                   (if (<= n 1)\n                       acc\n                       (factorial (- n 1) (* n acc))))))\n  (factorial 20 1))\n'''\n\n# Quote-based symbolic programming (using shortcuts for cleaner syntax)\nsymbolic_expr = '''\n(let ((expressions (list '(+ 1 2)\n                        '(* 3 4)\n                        '(- 10 5))))\n  (let ((operators (map first expressions))\n        (operands (map rest expressions)))\n    (list \"operators\" operators \"operands\" operands)))\n'''\n\n# Pattern matching for data processing\npattern_matching_expr = '''\n(let ((process-items (lambda (items)\n                       (map (lambda (item)\n                              (match item\n                                ((\"person\" name age) \n                                 (string-append name \" (\" (number->string age) \")\"))\n                                ((\"product\" id price)\n                                 (string-append \"Product \" (number->string id) \": $\" (number->string price)))\n                                (_ \"unknown item\")))\n                            items))))\n  (process-items (list (list \"person\" \"Alice\" 30)\n                      (list \"product\" 123 29.99)\n                      (list \"invalid\" \"data\"))))\n'''\n\nadvanced_processing = '''\n(let ((data (list \"  hello  \" \"WORLD\" \"test\" \"  EXAMPLE  \"))\n      (clean-normalize (lambda (text)\n                         (string-downcase (string-trim text)))))\n  (let ((cleaned (map clean-normalize data))\n        (filtered (remove \"test\" cleaned))\n        (positions (map (lambda (item) \n                          (position item cleaned)) \n                       filtered)))\n    (list \"cleaned\" cleaned \"filtered\" filtered \"positions\" positions)))\n'''\n```\n\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_016fp7EzhB5aM1ktuReVriDZ",
          "name": "filesystem",
          "content": "# AIFPL (AI Functional Programming Language)\n\nAIFPL is a mathematical expression language with LISP-like S-expression syntax designed for AI tool integration. It supports mathematical calculations, string manipulation, boolean operations, list processing, conditional evaluation, and functional programming with lambda expressions and higher-order functions.\n\n## Features\n\n- **Pure list representation**: Everything is data - true homoiconicity like traditional Lisp\n- **S-expression syntax**: `(function-or-operator arg1 arg2 ...)`\n- **Quote special form**: `(quote expr)` and shortcut `'expr` for preventing evaluation and creating data literals\n- **Pattern matching**: Comprehensive pattern matching with structural and type-based patterns\n- **Mathematical operations**: Arithmetic, trigonometry, logarithms, bitwise operations\n- **String operations**: Manipulation, searching, conversion with full UTF-8 support\n- **Boolean operations**: Logic operations with strict type checking\n- **List operations**: Construction, manipulation, and conversion with heterogeneous support\n- **Association lists (alists)**: Immutable key-value mappings with O(1) lookup performance\n- **Conditional evaluation**: `if` expressions with lazy evaluation of branches\n- **Lazy evaluation**: `and` and `or` perform lazy evaluation of operands\n- **Lambda expressions**: Anonymous functions with lexical scoping and closures\n- **Local bindings**: `let` expressions for sequential variable binding\n- **Higher-order functions**: `map`, `filter`, `fold`, `range`, and more for functional programming\n- **Tail call optimization**: Automatic optimization for recursive and mutually recursive functions\n- **Type predicates**: Built-in functions to check value types\n- **Number formats**: Integers, floats, complex numbers, hex (0xFF), binary (0b1010), octal (0o755)\n- **String literals**: `\"hello world\"` with escape sequences\n- **Boolean literals**: `#t` (true) and `#f` (false)\n- **Constants**: `pi`, `e`, `j` (imaginary unit), `true`, `false`\n- **Type promotion**: Automatic promotion from int \u2192 float \u2192 complex\n- **Result simplification**: Complex numbers with negligible imaginary parts become real\n- **Comments**: `;` introduces comments\n\n## Usage\n\n### Basic Usage\n\n```python\nfrom aifpl import AIFPL\n\ntool = AIFPL()\nresult = tool.evaluate(\"(+ 1 2 3)\")  # Returns: 6\n```\n\n### With Configuration\n\n```python\ntool = AIFPL(max_depth=200, floating_point_tolerance=1e-12)\nresult = tool.evaluate(\"(sin (* pi 0.5))\")  # Returns: 1\n```\n\n### Formatted Output\n\n```python\n# Get results with LISP-style formatting\nresult_str = tool.evaluate_and_format(\"(list 1 2 3)\")  # Returns: \"(1 2 3)\"\n```\n\n### Error Handling\n\n```python\nfrom aifpl import AIFPL, AIFPLError\n\ntool = AIFPL()\ntry:\n    result = tool.evaluate(\"(+ 1 2\")  # Missing closing paren\nexcept AIFPLError as e:\n    print(f\"AIFPL error: {e}\")\n```\n\n## Supported Operations\n\n### Quote - Data Literals and Code as Data\n\nThe `quote` special form prevents evaluation of expressions, enabling true code-as-data manipulation:\n\n#### Basic Quote Syntax\n```aifpl\n(quote expr)\n'expr          ; Shortcut form (equivalent to (quote expr))\n```\n\n#### Quote Examples - Preventing Evaluation\n```aifpl\n; Without quote - expression gets evaluated\n(+ 1 2 3)                             ; \u2192 6\n\n; With quote - expression returned as data\n(quote (+ 1 2 3))                     ; \u2192 (+ 1 2 3)\n'(+ 1 2 3)                            ; \u2192 (+ 1 2 3) (shortcut form)\n\n; Quote symbols to prevent variable lookup\n(quote x)                             ; \u2192 x (the symbol itself)\n'x                                    ; \u2192 x (shortcut form)\n(quote hello)                         ; \u2192 hello (symbol, not variable lookup)\n'hello                                ; \u2192 hello (shortcut form)\n```\n\n#### Single Quote Shortcut Examples\n```aifpl\n; Basic shortcut usage\n'x                                    ; \u2192 x (same as (quote x))\n'42                                   ; \u2192 42 (same as (quote 42))\n'\"hello\"                              ; \u2192 \"hello\" (same as (quote \"hello\"))\n'#t                                   ; \u2192 #t (same as (quote #t))\n\n; Shortcut with lists\n'(1 2 3)                              ; \u2192 (1 2 3) (same as (quote (1 2 3)))\n'()                                   ; \u2192 () (same as (quote ()))\n\n; Nested shortcut quotes\n''x                                   ; \u2192 (quote x) (same as (quote (quote x)))\n'''x                                  ; \u2192 (quote (quote x)) (triple nested)\n\n; Mixed usage in expressions\n(list 'hello (+ 1 2) 'world)         ; \u2192 (hello 3 world)\n(cons '+ '(1 2 3))                    ; \u2192 (+ 1 2 3)\n```\n\n#### Quote with Lists - Creating Data Structures\n```aifpl\n; Create lists as pure data\n(quote (1 2 3))                       ; \u2192 (1 2 3) (list as data)\n'(1 2 3)                              ; \u2192 (1 2 3) (shortcut form)\n(quote ())                            ; \u2192 () (empty list as data)\n'()                                   ; \u2192 () (shortcut form)\n\n; Create nested data structures\n(quote ((a 1) (b 2) (c 3)))           ; \u2192 ((a 1) (b 2) (c 3))\n'((a 1) (b 2) (c 3))                  ; \u2192 ((a 1) (b 2) (c 3)) (shortcut)\n\n; Mix quoted and unquoted in larger expressions\n(list (quote hello) (+ 1 2) (quote world))  ; \u2192 (hello 3 world)\n(list 'hello (+ 1 2) 'world)         ; \u2192 (hello 3 world) (with shortcuts)\n```\n\n#### Quote with Code Templates\n```aifpl\n; Store code as data for later use\n(let ((template (quote (if CONDITION THEN ELSE))))\n  template)                           ; \u2192 (if CONDITION THEN ELSE)\n(let ((template '(if CONDITION THEN ELSE)))\n  template)                           ; \u2192 (if CONDITION THEN ELSE) (shortcut)\n\n; Create function templates\n(let ((lambda-template (quote (lambda (x) (* x x)))))\n  lambda-template)                    ; \u2192 (lambda (x) (* x x))\n(let ((lambda-template '(lambda (x) (* x x))))\n  lambda-template)                    ; \u2192 (lambda (x) (* x x)) (shortcut)\n\n; Store expressions in lists\n(let ((expressions (list (quote (+ 1 2)) \n                        (quote (* 3 4))\n                        (quote (- 10 5)))))\n  expressions)                        ; \u2192 ((+ 1 2) (* 3 4) (- 10 5))\n(let ((expressions (list '(+ 1 2) \n                        '(* 3 4)\n                        '(- 10 5))))\n  expressions)                        ; \u2192 ((+ 1 2) (* 3 4) (- 10 5)) (shortcuts)\n```\n\n#### Symbolic Programming with Quote\n```aifpl\n; Manipulate code structure\n(let ((expr (quote (+ a b c))))\n  (first expr))                       ; \u2192 + (the operator symbol)\n(let ((expr '(+ a b c)))\n  (first expr))                       ; \u2192 + (shortcut form)\n\n(let ((expr (quote (lambda (x y) (+ x y)))))\n  (let ((params (first (rest expr)))\n        (body (first (rest (rest expr)))))\n    (list \"params\" params \"body\" body)))  ; \u2192 (\"params\" (x y) \"body\" (+ x y))\n(let ((expr '(lambda (x y) (+ x y))))\n  (let ((params (first (rest expr)))\n        (body (first (rest (rest expr)))))\n    (list \"params\" params \"body\" body)))  ; \u2192 (\"params\" (x y) \"body\" (+ x y)) (shortcut)\n\n; Build expressions programmatically\n(let ((op (quote +))\n      (args (quote (1 2 3))))\n  (cons op args))                     ; \u2192 (+ 1 2 3)\n(let ((op '+)\n      (args '(1 2 3)))\n  (cons op args))                     ; \u2192 (+ 1 2 3) (shortcuts)\n```\n\n#### Quote vs. List Constructor\n```aifpl\n; Using list constructor - evaluates arguments\n(list + 1 2 3)                       ; \u2192 (<builtin +> 1 2 3)\n\n; Using quote - no evaluation\n(quote (+ 1 2 3))                     ; \u2192 (+ 1 2 3)\n'(+ 1 2 3)                            ; \u2192 (+ 1 2 3) (shortcut)\n\n; Mixed approach\n(list (quote +) 1 2 3)                ; \u2192 (+ 1 2 3)\n(list '+ 1 2 3)                       ; \u2192 (+ 1 2 3) (shortcut)\n```\n\n#### Data Processing with Quoted Expressions\n```aifpl\n; Process a list of expressions\n(let ((exprs (list (quote (+ 1 2))\n                  (quote (* 3 4))\n                  (quote (/ 8 2)))))\n  (map (lambda (expr) (first expr)) exprs))  ; \u2192 (+ * /)\n(let ((exprs (list '(+ 1 2)\n                  '(* 3 4)\n                  '(/ 8 2))))\n  (map (lambda (expr) (first expr)) exprs))  ; \u2192 (+ * /) (shortcuts)\n\n; Extract operators and operands\n(let ((analyze-expr (lambda (expr)\n                      (if (and (list? expr) (not (null? expr)))\n                          (list \"op\" (first expr) \"args\" (rest expr))\n                          \"not-a-compound-expr\"))))\n  (map analyze-expr (list (quote (+ 1 2))\n                         (quote x)\n                         (quote (* a b c)))))\n; \u2192 ((\"op\" + \"args\" (1 2)) \"not-a-compound-expr\" (\"op\" * \"args\" (a b c)))\n(let ((analyze-expr (lambda (expr)\n                      (if (and (list? expr) (not (null? expr)))\n                          (list \"op\" (first expr) \"args\" (rest expr))\n                          \"not-a-compound-expr\"))))\n  (map analyze-expr (list '(+ 1 2)\n                         'x\n                         '(* a b c))))\n; \u2192 ((\"op\" + \"args\" (1 2)) \"not-a-compound-expr\" (\"op\" * \"args\" (a b c))) (shortcuts)\n```\n\n#### Quote Enables Meta-Programming\n```aifpl\n; Create expressions that create expressions\n(let ((make-adder (lambda (n)\n                    (list (quote lambda) \n                         (quote (x)) \n                         (list (quote +) (quote x) n)))))\n  (make-adder 5))                     ; \u2192 (lambda (x) (+ x 5))\n(let ((make-adder (lambda (n)\n                    (list 'lambda \n                         '(x) \n                         (list '+ 'x n)))))\n  (make-adder 5))                     ; \u2192 (lambda (x) (+ x 5)) (shortcuts)\n\n; Template-based code generation\n(let ((make-predicate (lambda (op value)\n                        (list (quote lambda)\n                             (quote (x))\n                             (list op (quote x) value)))))\n  (list (make-predicate (quote >) 10)\n        (make-predicate (quote =) 0)))  ; \u2192 ((lambda (x) (> x 10)) (lambda (x) (= x 0)))\n(let ((make-predicate (lambda (op value)\n                        (list 'lambda\n                             '(x)\n                             (list op 'x value)))))\n  (list (make-predicate '> 10)\n        (make-predicate '= 0)))       ; \u2192 ((lambda (x) (> x 10)) (lambda (x) (= x 0))) (shortcuts)\n```\n\n#### Homoiconicity in Action\n```aifpl\n; Code and data have the same representation\n(let ((code (quote (+ (* 2 3) 4)))\n      (data (list (quote +) (list (quote *) 2 3) 4)))\n  (= code data))                      ; \u2192 #t (they're identical!)\n(let ((code '(+ (* 2 3) 4))\n      (data (list '+ (list '* 2 3) 4)))\n  (= code data))                      ; \u2192 #t (shortcuts make it cleaner!)\n\n; Manipulate code like any other data\n(let ((expr (quote (+ 1 2 3))))\n  (let ((reversed (reverse expr)))\n    reversed))                        ; \u2192 (3 2 1 +)\n(let ((expr '(+ 1 2 3)))\n  (let ((reversed (reverse expr)))\n    reversed))                        ; \u2192 (3 2 1 +) (shortcut)\n\n; Transform code structures\n(let ((transform-ops (lambda (expr)\n                       (if (list? expr)\n                           (map transform-ops expr)\n                           (if (= expr (quote +))\n                               (quote *)\n                               expr)))))\n  (transform-ops (quote (+ 1 (+ 2 3)))))  ; \u2192 (* 1 (* 2 3))\n(let ((transform-ops (lambda (expr)\n                       (if (list? expr)\n                           (map transform-ops expr)\n                           (if (= expr '+)\n                               '*\n                               expr)))))\n  (transform-ops '(+ 1 (+ 2 3))))     ; \u2192 (* 1 (* 2 3)) (shortcuts)\n```\n\n### Lambda Expressions and Anonymous Functions\n\nLambda expressions create anonymous functions with lexical scoping and closure support:\n\n#### Basic Lambda Syntax\n```aifpl\n(lambda (param1 param2 ...) body)\n```\n\n#### Simple Lambda Examples\n```aifpl\n; Square function\n((lambda (x) (* x x)) 5)                    ; \u2192 25\n\n; Add two numbers\n((lambda (x y) (+ x y)) 3 4)                ; \u2192 7\n\n; String manipulation\n((lambda (s) (string-upcase s)) \"hello\")     ; \u2192 \"HELLO\"\n\n; Conditional logic\n((lambda (x) (if (> x 0) \"positive\" \"non-positive\")) -3)  ; \u2192 \"non-positive\"\n```\n\n#### Lambda Functions as Values\n```aifpl\n; Lambda functions are first-class values\n(let ((square (lambda (x) (* x x))))\n  (square 6))                                ; \u2192 36\n\n; Functions in lists\n(let ((ops (list (lambda (x) (* x 2)) (lambda (x) (+ x 1)))))\n  ((first ops) 5))                          ; \u2192 10\n\n; Higher-order function usage\n(map (lambda (x) (* x x)) (list 1 2 3 4))   ; \u2192 (1 4 9 16)\n```\n\n#### Closures and Lexical Scoping\n```aifpl\n; Closures capture their environment\n(let ((multiplier 10))\n  (let ((times-ten (lambda (x) (* x multiplier))))\n    (times-ten 5)))                         ; \u2192 50\n\n; Nested closures\n(let ((outer-var 100))\n  (let ((make-adder (lambda (n) (lambda (x) (+ x n outer-var)))))\n    (let ((add-five (make-adder 5)))\n      (add-five 3))))                       ; \u2192 108\n\n; Function factories\n(let ((make-multiplier (lambda (factor) (lambda (x) (* x factor)))))\n  (let ((double (make-multiplier 2))\n        (triple (make-multiplier 3)))\n    (list (double 4) (triple 4))))          ; \u2192 (8 12)\n```\n\n#### Recursive Lambda Functions\n```aifpl\n; Factorial with tail recursion (automatically optimized)\n(let ((factorial (lambda (n acc)\n                   (if (<= n 1)\n                       acc\n                       (factorial (- n 1) (* n acc))))))\n  (factorial 5 1))                          ; \u2192 120\n\n; List sum with recursion\n(let ((sum-list (lambda (lst acc)\n                  (if (null? lst)\n                      acc\n                      (sum-list (rest lst) (+ acc (first lst)))))))\n  (sum-list (list 1 2 3 4 5) 0))           ; \u2192 15\n\n; Fibonacci with mutual recursion\n(let ((fib-helper (lambda (n a b)\n                    (if (<= n 0)\n                        a\n                        (fib-helper (- n 1) b (+ a b))))))\n  (let ((fibonacci (lambda (n) (fib-helper n 0 1))))\n    (fibonacci 10)))                        ; \u2192 55\n```\n\n### Local Variable Binding with Let\n\nLet expressions create local variable bindings with sequential evaluation and lexical scoping:\n\n#### Basic Let Syntax\n```aifpl\n(let ((var1 val1) (var2 val2) ...) body)\n```\n\n#### Simple Let Examples\n```aifpl\n; Basic binding\n(let ((x 5)) (+ x 10))                      ; \u2192 15\n\n; Multiple bindings\n(let ((x 3) (y 4)) (+ (* x x) (* y y)))     ; \u2192 25\n\n; String operations\n(let ((name \"Alice\") (age 30))\n  (string-append name \" is \" (number->string age)))  ; \u2192 \"Alice is 30\"\n```\n\n#### Sequential Binding\n```aifpl\n; Later variables can reference earlier ones\n(let ((x 5) (y (* x 2))) (+ x y))           ; \u2192 15\n\n; Building complex expressions\n(let ((base 10)\n      (squared (* base base))\n      (cubed (* squared base)))\n  (list base squared cubed))                ; \u2192 (10 100 1000)\n\n; String processing chain\n(let ((text \"Hello World\")\n      (lower (string-downcase text))\n      (words (string-split lower \" \")))\n  (string-join (reverse words) \"-\"))        ; \u2192 \"world-hello\"\n```\n\n#### Binding Functions\n```aifpl\n; Bind lambda functions to names\n(let ((double (lambda (x) (* x 2)))\n      (triple (lambda (x) (* x 3))))\n  (+ (double 4) (triple 5)))                ; \u2192 23\n\n; Compose functions\n(let ((add-one (lambda (x) (+ x 1)))\n      (square (lambda (x) (* x x)))\n      (compose (lambda (f g) (lambda (x) (f (g x))))))\n  (let ((square-then-add (compose add-one square)))\n    (square-then-add 4)))                   ; \u2192 17\n\n; Recursive function binding\n(let ((countdown (lambda (n)\n                   (if (<= n 0)\n                       (list)\n                       (cons n (countdown (- n 1)))))))\n  (countdown 5))                            ; \u2192 (5 4 3 2 1)\n```\n\n#### Nested Let Expressions\n```aifpl\n; Nested scoping\n(let ((x 10))\n  (let ((x 20) (y x))  ; inner x shadows outer, y gets outer x value\n    (+ x y)))                               ; \u2192 30\n\n; Complex nested computation\n(let ((data (list 1 2 3 4 5)))\n  (let ((squared (map (lambda (x) (* x x)) data))\n        (sum-fn (lambda (lst) (fold + 0 lst))))\n    (let ((total (sum-fn squared))\n          (average (/ total (length squared))))\n      (list \"sum\" total \"average\" average))))  ; \u2192 (\"sum\" 55 \"average\" 11)\n```\n\n### Pattern Matching\n\nPattern matching provides a powerful way to destructure and analyze data based on its shape and content. It offers a concise alternative to nested conditionals and enables elegant functional programming patterns.\n\n#### Basic Pattern Matching Syntax\n```aifpl\n(match expression\n  (pattern1 result1)\n  (pattern2 result2)\n  ...\n  (_ default-result))  ; wildcard pattern (optional)\n```\n\n#### Literal Pattern Matching\n```aifpl\n; Match exact values\n(match 42\n  (42 \"found the answer\")\n  (0 \"zero\")\n  (_ \"something else\"))                     ; \u2192 \"found the answer\"\n\n; String literal matching\n(match \"hello\"\n  (\"world\" \"greeting\")\n  (\"hello\" \"salutation\")\n  (_ \"unknown\"))                            ; \u2192 \"salutation\"\n\n; Boolean literal matching\n(match #t\n  (#t \"true value\")\n  (#f \"false value\"))                       ; \u2192 \"true value\"\n```\n\n#### Variable Pattern Matching\n```aifpl\n; Bind values to variables\n(match 42\n  (x (* x 2)))                              ; \u2192 84 (x is bound to 42)\n\n; Variable patterns always match\n(match \"hello\"\n  (greeting (string-upcase greeting)))      ; \u2192 \"HELLO\"\n\n; Multiple variable patterns (first match wins)\n(match 10\n  (x (+ x 1))\n  (y (* y 2)))                              ; \u2192 11 (first pattern matches)\n```\n\n#### Wildcard Pattern Matching\n```aifpl\n; Wildcard matches anything without binding\n(match 42\n  (_ \"matched something\"))                  ; \u2192 \"matched something\"\n\n; Common use as default case\n(match \"unknown\"\n  (\"hello\" \"greeting\")\n  (\"goodbye\" \"farewell\")\n  (_ \"unrecognized\"))                       ; \u2192 \"unrecognized\"\n\n; Wildcard with computation\n(match (+ 10 20)\n  (_ \"got a result\"))                       ; \u2192 \"got a result\"\n```\n\n#### Type Pattern Matching\n```aifpl\n; Match by type with binding\n(match 42\n  ((number? n) (+ n 10))\n  ((string? s) (string-length s))\n  (_ \"unknown type\"))                       ; \u2192 52\n\n; String type matching\n(match \"hello world\"\n  ((string? text) (string-upcase text))\n  (_ \"not a string\"))                       ; \u2192 \"HELLO WORLD\"\n\n; Boolean type matching\n(match #t\n  ((boolean? flag) (not flag))\n  (_ \"not boolean\"))                        ; \u2192 #f\n\n; List type matching\n(match (list 1 2 3)\n  ((list? items) (length items))\n  (_ \"not a list\"))                         ; \u2192 3\n\n; Function type matching\n(match (lambda (x) (* x 2))\n  ((function? f) \"it's a function\")\n  (_ \"not a function\"))                     ; \u2192 \"it's a function\"\n```\n\n#### List Structure Pattern Matching\n\n**Important:** In AIFPL, the `(head . tail)` pattern always binds `tail` to a list (possibly empty), never to an atom. This differs from Scheme/Lisp.\n\n```aifpl\n; Empty list matching\n(match (list)\n  (() \"empty list\")\n  (_ \"non-empty\"))                          ; \u2192 \"empty list\"\n\n; Fixed-length list matching\n(match (list 1 2 3)\n  ((a b c) (+ a b c))\n  (_ \"wrong length\"))                       ; \u2192 6\n\n; Head-tail decomposition - tail is ALWAYS a list\n(match (list 1 2 3 4)\n  ((head . tail) (list \"head\" head \"tail\" tail))\n  (() \"empty\"))                             ; \u2192 (\"head\" 1 \"tail\" (2 3 4))\n\n; Single element list - tail is empty list\n(match (list 42)\n  ((x . xs) (list x xs)))                   ; \u2192 (42 ())  - xs is (), not an atom\n\n; Two-element list\n(match (list \"hello\" \"world\")\n  ((first second) (string-append first \" \" second))\n  (_ \"not a pair\"))                         ; \u2192 \"hello world\"\n```\n\n**Note:** Unlike Scheme/Lisp where `(cdr '(1 . 2))` returns the atom `2`, AIFPL's `(head . tail)` pattern always binds `tail` to a list. Use fixed-length patterns like `(a b)` when you want direct access to individual elements.\n\n#### Nested Pattern Matching\n```aifpl\n; Nested list patterns\n(match (list (list 1 2) 3)\n  (((a b) c) (+ a b c))\n  (_ \"no match\"))                           ; \u2192 6\n\n; Deep nesting\n(match (list (list (list 1 2) 3) 4)\n  ((((x y) z) w) (+ x y z w))\n  (_ \"no match\"))                           ; \u2192 10\n\n; Mixed literal and variable patterns\n(match (list \"name\" \"Alice\")\n  ((\"name\" value) (string-append \"Hello, \" value))\n  ((\"age\" value) (string-append \"Age: \" (number->string value)))\n  (_ \"unknown field\"))                      ; \u2192 \"Hello, Alice\"\n\n; Nested type patterns\n(match (list (list 1 2 3))\n  (((list? numbers)) (fold + 0 numbers))\n  (_ \"not a list of numbers\"))              ; \u2192 6\n```\n\n#### Pattern Matching with Conditionals\n```aifpl\n; Combine patterns with guards (using nested match)\n(let ((classify-number (lambda (n)\n                         (match n\n                           ((number? x) \n                            (match #t\n                              ((if (> x 0)) \"positive\")\n                              ((if (< x 0)) \"negative\")\n                              (_ \"zero\")))\n                           (_ \"not a number\")))))\n  (list (classify-number 5)\n        (classify-number -3)\n        (classify-number 0)\n        (classify-number \"hello\")))          ; \u2192 (\"positive\" \"negative\" \"zero\" \"not a number\")\n```\n\n#### Complex Data Structure Matching\n```aifpl\n; Process structured data\n(let ((process-person (lambda (person)\n                        (match person\n                          ((\"person\" name age city)\n                           (string-append name \" (\" (number->string age) \") from \" city))\n                          ((\"person\" name age)\n                           (string-append name \" (\" (number->string age) \")\"))\n                          (_ \"invalid person data\")))))\n  (list (process-person (list \"person\" \"Alice\" 30 \"NYC\"))\n        (process-person (list \"person\" \"Bob\" 25))\n        (process-person (list \"invalid\" \"data\"))))\n; \u2192 (\"Alice (30) from NYC\" \"Bob (25)\" \"invalid person data\")\n\n; Tree-like structure processing\n(let ((evaluate-expr (lambda (expr)\n                       (match expr\n                         (((number? n)) n)\n                         ((\"+\" left right) (+ (evaluate-expr left) (evaluate-expr right)))\n                         ((\"*\" left right) (* (evaluate-expr left) (evaluate-expr right)))\n                         (_ \"invalid expression\")))))\n  (evaluate-expr (list \"+\" (list 10) (list \"*\" (list 5) (list 3)))))  ; \u2192 25\n```\n\n#### Pattern Matching vs. Conditional Chains\n```aifpl\n; Traditional nested conditionals\n(let ((process-traditional (lambda (data)\n                             (if (list? data)\n                                 (if (= (length data) 3)\n                                     (if (string? (first data))\n                                         (if (number? (first (rest data)))\n                                             (string-append (first data) \": \" \n                                                          (number->string (first (rest data))))\n                                             \"second not number\")\n                                         \"first not string\")\n                                     \"wrong length\")\n                                 \"not a list\"))))\n  (process-traditional (list \"score\" 95 \"points\")))  ; \u2192 \"score: 95\"\n\n; Equivalent pattern matching (much cleaner)\n(let ((process-pattern (lambda (data)\n                         (match data\n                           (((string? name) (number? value) extra) \n                            (string-append name \": \" (number->string value)))\n                           (_ \"invalid format\")))))\n  (process-pattern (list \"score\" 95 \"points\")))      ; \u2192 \"score: 95\"\n```\n\n#### Advanced Pattern Matching Examples\n```aifpl\n; List processing with patterns\n(let ((process-list (lambda (lst)\n                      (match lst\n                        (() \"empty\")\n                        ((x) (string-append \"single: \" (number->string x)))\n                        ((x y) (string-append \"pair: \" (number->string (+ x y))))\n                        ((head . tail) \n                         (string-append \"list of \" (number->string (+ 1 (length tail))) \" items\"))))))\n  (list (process-list (list))\n        (process-list (list 42))\n        (process-list (list 1 2))\n        (process-list (list 1 2 3 4 5))))\n; \u2192 (\"empty\" \"single: 42\" \"pair: 3\" \"list of 5 items\")\n\n; Configuration processing\n(let ((process-config (lambda (config)\n                        (match config\n                          ((\"database\" \"mysql\" host port)\n                           (string-append \"MySQL at \" host \":\" (number->string port)))\n                          ((\"database\" \"postgres\" host port db)\n                           (string-append \"PostgreSQL \" db \" at \" host \":\" (number->string port)))\n                          ((\"cache\" \"redis\" host)\n                           (string-append \"Redis cache at \" host))\n                          (_ \"unknown configuration\")))))\n  (list (process-config (list \"database\" \"mysql\" \"localhost\" 3306))\n        (process-config (list \"database\" \"postgres\" \"db.example.com\" 5432 \"myapp\"))\n        (process-config (list \"cache\" \"redis\" \"cache.example.com\"))\n        (process-config (list \"unknown\" \"config\"))))\n; \u2192 (\"MySQL at localhost:3306\" \"PostgreSQL myapp at db.example.com:5432\" \"Redis cache at cache.example.com\" \"unknown configuration\")\n\n; Recursive data structure processing\n(let ((json-to-string (lambda (json)\n                        (match json\n                          (((string? s)) (string-append \"\\\"\" s \"\\\"\"))\n                          (((number? n)) (number->string n))\n                          (((boolean? b)) (if b \"true\" \"false\"))\n                          ((\"object\" . pairs)\n                           (let ((pair-strings (map (lambda (pair)\n                                                     (match pair\n                                                       ((key value)\n                                                        (string-append \"\\\"\" key \"\\\": \" \n                                                                     (json-to-string value)))\n                                                       (_ \"invalid pair\")))\n                                                   pairs)))\n                             (string-append \"{\" (string-join pair-strings \", \") \"}\")))\n                          ((\"array\" . items)\n                           (string-append \"[\" \n                                        (string-join (map json-to-string items) \", \") \n                                        \"]\"))\n                          (_ \"invalid JSON\")))))\n  (json-to-string (list \"object\" \n                       (list \"name\" (list \"Alice\"))\n                       (list \"age\" (list 30))\n                       (list \"active\" (list #t)))))\n; \u2192 \"{\\\"name\\\": \\\"Alice\\\", \\\"age\\\": 30, \\\"active\\\": true}\"\n```\n\n#### Pattern Matching Best Practices\n```aifpl\n; Order patterns from specific to general\n(let ((classify (lambda (x)\n                  (match x\n                    (0 \"zero\")              ; Most specific first\n                    (1 \"one\")\n                    ((number? n) \"other number\")  ; More general\n                    (_ \"not a number\")))))          ; Most general last\n  (list (classify 0) (classify 1) (classify 42) (classify \"hello\")))\n; \u2192 (\"zero\" \"one\" \"other number\" \"not a number\")\n\n; Use meaningful variable names in patterns\n(let ((format-person (lambda (data)\n                       (match data\n                         ((name age city) ; Clear variable names\n                          (string-append name \" (\" (number->string age) \") lives in \" city))\n                         (_ \"invalid person\")))))\n  (format-person (list \"Alice\" 30 \"Boston\")))     ; \u2192 \"Alice (30) lives in Boston\"\n\n; Combine pattern matching with higher-order functions\n(let ((process-items (lambda (items)\n                       (map (lambda (item)\n                              (match item\n                                ((\"task\" name priority)\n                                 (string-append name \" [\" priority \"]\"))\n                                ((\"note\" content)\n                                 (string-append \"Note: \" content))\n                                (_ \"unknown item\")))\n                            items))))\n  (process-items (list (list \"task\" \"Buy groceries\" \"high\")\n                      (list \"note\" \"Remember to call mom\")\n                      (list \"invalid\" \"item\"))))\n; \u2192 (\"Buy groceries [high]\" \"Note: Remember to call mom\" \"unknown item\")\n```\n\n### Higher-Order Functions\n\nAIFPL provides powerful higher-order functions for functional programming patterns:\n\n#### Map - Transform Each Element\n```aifpl\n; Basic mapping\n(map (lambda (x) (* x 2)) (list 1 2 3 4))   ; \u2192 (2 4 6 8)\n\n; String transformations\n(map string-upcase (list \"hello\" \"world\"))  ; \u2192 (\"HELLO\" \"WORLD\")\n\n; Complex transformations\n(map (lambda (x) (+ (* x x) 1)) (list 1 2 3))  ; \u2192 (2 5 10)\n\n; Nested list processing\n(map (lambda (pair) (+ (first pair) (first (rest pair))))\n     (list (list 1 2) (list 3 4) (list 5 6)))  ; \u2192 (3 7 11)\n```\n\n#### Filter - Select Elements by Predicate\n```aifpl\n; Basic filtering\n(filter (lambda (x) (> x 0)) (list -1 2 -3 4))  ; \u2192 (2 4)\n\n; String filtering\n(filter (lambda (s) (> (string-length s) 3))\n        (list \"hi\" \"hello\" \"a\" \"world\"))    ; \u2192 (\"hello\" \"world\")\n\n; Complex predicates\n(filter (lambda (x) (= (% x 2) 0)) (range 1 11))  ; \u2192 (2 4 6 8 10)\n\n; Boolean combinations\n(filter (lambda (x) (and (> x 5) (< x 15)))\n        (range 1 20))                       ; \u2192 (6 7 8 9 10 11 12 13 14)\n```\n\n#### Fold - Accumulate Results\n```aifpl\n; Sum all elements\n(fold + 0 (list 1 2 3 4 5))                ; \u2192 15\n\n; Product of elements\n(fold * 1 (list 1 2 3 4))                  ; \u2192 24\n\n; String concatenation\n(fold string-append \"\" (list \"Hello\" \" \" \"World\"))  ; \u2192 \"Hello World\"\n\n; Build reverse list\n(fold (lambda (acc x) (cons x acc)) (list) (list 1 2 3))  ; \u2192 (3 2 1)\n\n; Find maximum\n(fold (lambda (acc x) (if (> x acc) x acc)) 0 (list 3 7 2 9 1))  ; \u2192 9\n\n; Complex accumulation\n(fold (lambda (acc x) (+ acc (* x x))) 0 (list 1 2 3 4))  ; \u2192 30\n```\n\n#### Range - Generate Numeric Sequences\n```aifpl\n; Basic ranges\n(range 1 5)                                 ; \u2192 (1 2 3 4)\n(range 0 10 2)                             ; \u2192 (0 2 4 6 8)\n(range 10 0 -1)                            ; \u2192 (10 9 8 7 6 5 4 3 2 1)\n\n; Use with other functions\n(map (lambda (x) (* x x)) (range 1 6))      ; \u2192 (1 4 9 16 25)\n(filter (lambda (x) (= (% x 3) 0)) (range 1 21))  ; \u2192 (3 6 9 12 15 18)\n\n; Generate data\n(map (lambda (i) (list \"item\" i)) (range 1 4))  ; \u2192 ((\"item\" 1) (\"item\" 2) (\"item\" 3))\n```\n\n#### Find - Locate First Matching Element\n```aifpl\n; Find first positive number\n(find (lambda (x) (> x 0)) (list -1 -2 3 4))  ; \u2192 3\n\n; Find first long string\n(find (lambda (s) (> (string-length s) 4))\n      (list \"hi\" \"hello\" \"a\"))              ; \u2192 \"hello\"\n\n; Returns #f if not found\n(find (lambda (x) (> x 10)) (list 1 2 3))  ; \u2192 #f\n\n; Complex search\n(find (lambda (pair) (= (first pair) \"name\"))\n      (list (list \"age\" 25) (list \"name\" \"John\")))  ; \u2192 (\"name\" \"John\")\n```\n\n#### Any? and All? - Boolean Predicates\n```aifpl\n; Check if any element matches\n(any? (lambda (x) (> x 5)) (list 1 3 7 2))  ; \u2192 #t\n(any? (lambda (x) (< x 0)) (list 1 2 3))   ; \u2192 #f\n\n; Check if all elements match\n(all? (lambda (x) (> x 0)) (list 1 2 3))   ; \u2192 #t\n(all? (lambda (x) (> x 5)) (list 1 3 7))   ; \u2192 #f\n\n; String validation\n(all? (lambda (s) (> (string-length s) 0))\n      (list \"hello\" \"world\" \"test\"))        ; \u2192 #t\n\n(any? (lambda (s) (string-contains? s \"@\"))\n      (list \"user@email.com\" \"plain-text\")) ; \u2192 #t\n```\n\n#### Take and Drop - List Slicing\n```aifpl\n; Take first n elements\n(take 3 (list 1 2 3 4 5))                  ; \u2192 (1 2 3)\n(take 2 (list \"a\" \"b\" \"c\" \"d\"))            ; \u2192 (\"a\" \"b\")\n\n; Drop first n elements\n(drop 2 (list 1 2 3 4 5))                  ; \u2192 (3 4 5)\n(drop 3 (list \"a\" \"b\" \"c\" \"d\"))            ; \u2192 (\"d\")\n\n; Safe operations (don't error on out-of-bounds)\n(take 10 (list 1 2 3))                     ; \u2192 (1 2 3)\n(drop 10 (list 1 2 3))                     ; \u2192 ()\n\n; Combine with other operations\n(take 3 (filter (lambda (x) (> x 0)) (list -1 2 -3 4 5 6)))  ; \u2192 (2 4 5)\n```\n\n### Functional Programming Patterns\n\n#### Data Transformation Pipelines\n```aifpl\n; Process CSV-like data\n(let ((data (list \"john,25\" \"alice,30\" \"bob,22\")))\n  (map (lambda (row)\n         (let ((parts (string-split row \",\")))\n           (list (first parts) (string->number (first (rest parts))))))\n       data))                               ; \u2192 ((\"john\" 25) (\"alice\" 30) (\"bob\" 22))\n\n; Multi-step data processing\n(let ((numbers (range 1 21)))\n  (let ((evens (filter (lambda (x) (= (% x 2) 0)) numbers))\n        (squares (map (lambda (x) (* x x)) evens))\n        (sum (fold + 0 squares)))\n    sum))                                   ; \u2192 1540\n\n; String processing pipeline\n(let ((text \"The Quick Brown Fox\"))\n  (let ((words (string-split (string-downcase text) \" \"))\n        (long-words (filter (lambda (w) (> (string-length w) 3)) words))\n        (capitalized (map string-upcase long-words)))\n    (string-join capitalized \"-\")))         ; \u2192 \"QUICK-BROWN\"\n```\n\n#### Function Composition\n```aifpl\n; Compose two functions\n(let ((compose (lambda (f g) (lambda (x) (f (g x))))))\n  (let ((add-one (lambda (x) (+ x 1)))\n        (double (lambda (x) (* x 2))))\n    (let ((double-then-add (compose add-one double)))\n      (double-then-add 5))))                ; \u2192 11\n\n; Chain multiple transformations\n(let ((pipe (lambda (value . functions)\n              (fold (lambda (acc f) (f acc)) value functions))))\n  (let ((add-ten (lambda (x) (+ x 10)))\n        (multiply-by-three (lambda (x) (* x 3)))\n        (subtract-five (lambda (x) (- x 5))))\n    (pipe 2 add-ten multiply-by-three subtract-five)))  ; \u2192 31\n```\n\n#### Recursive Data Processing\n```aifpl\n; Process nested lists recursively\n(let ((deep-sum (lambda (lst)\n                  (if (null? lst)\n                      0\n                      (let ((head (first lst))\n                            (tail (rest lst)))\n                        (+ (if (list? head)\n                               (deep-sum head)\n                               head)\n                           (deep-sum tail)))))))\n  (deep-sum (list 1 (list 2 3) 4)))        ; \u2192 10\n\n; Tree traversal patterns\n(let ((count-leaves (lambda (tree)\n                      (if (list? tree)\n                          (fold + 0 (map count-leaves tree))\n                          1))))\n  (count-leaves (list 1 (list 2 (list 3 4)) 5)))  ; \u2192 5\n```\n\n#### Validation and Error Handling\n```aifpl\n; Validate all items in a list\n(let ((validate-positive (lambda (nums)\n                          (if (all? (lambda (x) (> x 0)) nums)\n                              nums\n                              \"error: negative numbers found\"))))\n  (list (validate-positive (list 1 2 3))\n        (validate-positive (list 1 -2 3))))  ; \u2192 ((1 2 3) \"error: negative numbers found\")\n\n; Safe operations with defaults\n(let ((safe-divide (lambda (x y)\n                     (if (= y 0)\n                         \"undefined\"\n                         (/ x y)))))\n  (map (lambda (pair) (safe-divide (first pair) (first (rest pair))))\n       (list (list 10 2) (list 15 3) (list 8 0))))  ; \u2192 (5 5 \"undefined\")\n```\n\n### Conditional Operations\n\nAIFPL supports conditional evaluation with lazy evaluation of branches:\n\n```aifpl\n(if condition then-expr else-expr)\n```\n\n#### Basic Examples:\n```aifpl\n(if (> 5 3) \"greater\" \"less\")         ; \u2192 \"greater\"\n(if (= 1 2) (+ 1 1) (* 2 2))          ; \u2192 4\n(if #t \"true branch\" \"false branch\")  ; \u2192 \"true branch\"\n(if #f \"true branch\" \"false branch\")  ; \u2192 \"false branch\"\n```\n\n#### Lazy Evaluation (Key Feature):\n```aifpl\n(if #t 42 (/ 1 0))                    ; \u2192 42 (no division by zero error)\n(if #f (undefined-symbol) \"safe\")     ; \u2192 \"safe\" (no undefined symbol error)\n(if (> x 0) (/ 100 x) \"undefined\")    ; Safe division\n```\n\n#### Practical Examples:\n```aifpl\n; Safe list operations\n(if (null? my-list) \"empty\" (first my-list))\n\n; Data validation\n(if (string-contains? email \"@\") \"valid email\" \"invalid email\")\n\n; Conditional string building\n(if (> count 1)\n    (string-append (number->string count) \" items\")\n    \"1 item\")\n\n; List processing\n(if (member? \"target\" search-list)\n    (string-append \"Found at position \" (number->string (position \"target\" search-list)))\n    \"Not found\")\n```\n\n#### Nested Conditionals:\n```aifpl\n(if (> x 0)\n    (if (> x 10) \"big positive\" \"small positive\")\n    (if (< x -10) \"big negative\" \"small negative or zero\"))\n```\n\n#### Type Requirements:\n- Condition must be a boolean (`#t` or `#f`)\n- Both then-expr and else-expr are required\n- Only the chosen branch is evaluated (lazy evaluation)\n\n### Arithmetic\n- `(+ 1 2 3)` \u2192 `6`\n- `(- 10 3)` \u2192 `7`\n- `(* 2 3 4)` \u2192 `24`\n- `(/ 12 3)` \u2192 `4`\n- `(// 7 3)` \u2192 `2` (floor division)\n- `(% 7 3)` \u2192 `1` (modulo)\n- `(** 2 3)` \u2192 `8` (exponentiation)\n\n### Comparison Operations\n\n#### Equality and Inequality\n```aifpl\n; Equality - all values must be equal\n(= 1 1)                               ; \u2192 #t\n(= 1 2)                               ; \u2192 #f\n(= 1 1 1)                             ; \u2192 #t (all equal)\n(= 1 2 3)                             ; \u2192 #f (not all equal)\n\n; Inequality - any values not equal\n(!= 1 2)                              ; \u2192 #t (any inequality)\n(!= 1 1)                              ; \u2192 #f (all equal)\n(!= 1 2 3)                            ; \u2192 #t (not all equal)\n(!= 1 1 1)                            ; \u2192 #f (all equal)\n```\n\n#### Numeric Comparisons\n```aifpl\n; Comparison chains (all must satisfy the relationship)\n(< 1 2)                               ; \u2192 #t\n(< 1 2 3)                             ; \u2192 #t (1 < 2 < 3)\n(< 1 3 2)                             ; \u2192 #f (3 is not < 2)\n\n(> 3 2)                               ; \u2192 #t\n(> 3 2 1)                             ; \u2192 #t (3 > 2 > 1)\n\n(<= 1 1)                              ; \u2192 #t\n(<= 1 2 2)                            ; \u2192 #t (1 \u2264 2 \u2264 2)\n\n(>= 2 1)                              ; \u2192 #t\n(>= 3 2 2)                            ; \u2192 #t (3 \u2265 2 \u2265 2)\n```\n\n#### Mixed Type Equality\n```aifpl\n; Numeric types can be compared for equality\n(= 1 1.0)                             ; \u2192 #t (int/float equivalence)\n(= 2 (+ 1.0 1.0))                     ; \u2192 #t (numeric equivalence)\n\n; Different non-numeric types are never equal\n(= \"hello\" 5)                         ; \u2192 #f\n(= #t 1)                              ; \u2192 #f\n(= (list 1 2) \"12\")                   ; \u2192 #f\n\n; Lists are compared element by element\n(= (list 1 2) (list 1 2))             ; \u2192 #t\n(= (list 1 2) (list 1 3))             ; \u2192 #f\n```\n\n### Boolean Operations\n- `(and #t #f)` \u2192 `#f`\n- `(and #t #t)` \u2192 `#t`\n- `(or #t #f)` \u2192 `#t`\n- `(or #f #f)` \u2192 `#f`\n- `(not #t)` \u2192 `#f`\n- `(not #f)` \u2192 `#t`\n\n### Type Predicates\n\nAIFPL provides comprehensive type checking functions:\n\n#### Basic Type Predicates\n```aifpl\n; Number type checking (excludes booleans)\n(number? 42)                          ; \u2192 #t\n(number? 3.14)                        ; \u2192 #t\n(number? (+ 1 j))                     ; \u2192 #t (complex)\n(number? #t)                          ; \u2192 #f (booleans are not numbers)\n(number? \"42\")                        ; \u2192 #f\n\n; Specific numeric type checking\n(integer? 42)                         ; \u2192 #t\n(integer? 3.14)                       ; \u2192 #f\n(integer? #t)                         ; \u2192 #f (booleans excluded)\n\n(float? 3.14)                         ; \u2192 #t\n(float? 42)                           ; \u2192 #f\n(float? (/ 1 2))                      ; \u2192 #t (division produces float)\n\n(complex? (+ 1 j))                    ; \u2192 #t\n(complex? 42)                         ; \u2192 #f\n(complex? 3.14)                       ; \u2192 #f\n```\n\n#### Other Type Predicates\n```aifpl\n; String type checking\n(string? \"hello\")                     ; \u2192 #t\n(string? 42)                          ; \u2192 #f\n(string? (number->string 42))         ; \u2192 #t\n\n; Boolean type checking\n(boolean? #t)                         ; \u2192 #t\n(boolean? #f)                         ; \u2192 #t\n(boolean? 1)                          ; \u2192 #f\n(boolean? 0)                          ; \u2192 #f\n\n; Function type checking\n(function? (lambda (x) (* x 2)))      ; \u2192 #t\n(function? +)                         ; \u2192 #t\n(function? \"hello\")                   ; \u2192 #f\n\n; List type checking (already existed)\n(list? (list 1 2 3))                 ; \u2192 #t\n(list? \"hello\")                       ; \u2192 #f\n(list? ())                            ; \u2192 #t (empty list)\n```\n\n#### Type Predicate Usage Patterns\n```aifpl\n; Conditional type handling\n(let ((process-value (lambda (x)\n                       (if (number? x)\n                           (* x 2)\n                           (if (string? x)\n                               (string-upcase x)\n                               \"unknown type\")))))\n  (list (process-value 5)             ; \u2192 10\n        (process-value \"hello\")       ; \u2192 \"HELLO\"\n        (process-value #t)))          ; \u2192 \"unknown type\"\n\n; Type validation\n(let ((validate-numbers (lambda (lst)\n                          (if (all? number? lst)\n                              (fold + 0 lst)\n                              \"error: non-numeric values found\"))))\n  (list (validate-numbers (list 1 2 3))      ; \u2192 6\n        (validate-numbers (list 1 \"x\" 3))))  ; \u2192 \"error: non-numeric values found\"\n\n; Polymorphic operations\n(let ((safe-length (lambda (x)\n                     (if (string? x)\n                         (string-length x)\n                         (if (list? x)\n                             (length x)\n                             \"not a sequence\")))))\n  (list (safe-length \"hello\")         ; \u2192 5\n        (safe-length (list 1 2 3))    ; \u2192 3\n        (safe-length 42)))            ; \u2192 \"not a sequence\"\n```\n\n### Mathematical Functions\n- `(sin (* pi 0.5))` \u2192 `1`\n- `(cos 0)` \u2192 `1`\n- `(log e)` \u2192 `1`\n- `(sqrt 16)` \u2192 `4`\n- `(abs -5)` \u2192 `5`\n\n### Bitwise Operations\n- `(bit-or 5 3)` \u2192 `7`\n- `(bit-and 7 3)` \u2192 `3`\n- `(bit-xor 5 3)` \u2192 `6`\n- `(bit-not 5)` \u2192 `-6`\n\n### Base Conversion\n- `(hex 255)` \u2192 `\"0xff\"`\n- `(bin 10)` \u2192 `\"0b1010\"`\n- `(oct 8)` \u2192 `\"0o10\"`\n\n### Complex Numbers\n- `(complex 3 4)` \u2192 `(3+4j)`\n- `(+ 1 (* 2 j))` \u2192 `(1+2j)`\n- `(real (complex 3 4))` \u2192 `3` (extract real part)\n- `(imag (complex 3 4))` \u2192 `4` (extract imaginary part)\n- `(real 5)` \u2192 `5` (real part of real number)\n- `(imag 5)` \u2192 `0` (imaginary part of real number)\n\n### List Operations\n\n#### List Construction and Manipulation\n\n**Note:** AIFPL uses proper lists only. The `cons` function requires the second argument to be a list.\n\n```aifpl\n(list 1 2 3)                           ; \u2192 (1 2 3)\n(list \"a\" \"b\" \"c\")                     ; \u2192 (\"a\" \"b\" \"c\")\n(list 1 \"hello\" #t)                    ; \u2192 (1 \"hello\" #t) [mixed types]\n(list)                                 ; \u2192 () [empty list]\n(cons 1 (list 2 3))                    ; \u2192 (1 2 3) [prepend to list]\n(cons 1 (list))                        ; \u2192 (1) [prepend to empty list]\n(append (list 1 2) (list 3 4))         ; \u2192 (1 2 3 4) [concatenate]\n(reverse (list 1 2 3))                 ; \u2192 (3 2 1)\n```\n\n**Important:** Unlike Scheme/Lisp, `(cons 1 2)` is invalid in AIFPL. Use `(list 1 2)` to create pairs.\n\n#### List Access and Properties\n\n**Note:** The `rest` function always returns a list, never an atom.\n\n```aifpl\n(first (list 1 2 3))                  ; \u2192 1\n(rest (list 1 2 3))                   ; \u2192 (2 3) [always returns a list]\n(rest (list 1))                       ; \u2192 () [empty list, not an atom]\n(last (list 1 2 3))                   ; \u2192 3\n(list-ref (list \"a\" \"b\" \"c\") 1)       ; \u2192 \"b\" (0-indexed)\n(length (list 1 2 3))                 ; \u2192 3\n(null? (list))                        ; \u2192 #t\n(null? (list 1))                      ; \u2192 #f\n(list? (list 1 2))                    ; \u2192 #t\n(list? \"hello\")                       ; \u2192 #f\n(member? 2 (list 1 2 3))              ; \u2192 #t\n(member? 5 (list 1 2 3))              ; \u2192 #f\n```\n\n#### List Utilities\n```aifpl\n; Remove all occurrences of an element\n(remove 2 (list 1 2 3 2 4))           ; \u2192 (1 3 4)\n(remove \"x\" (list \"a\" \"x\" \"b\" \"x\"))   ; \u2192 (\"a\" \"b\")\n(remove 5 (list 1 2 3))               ; \u2192 (1 2 3) (no change if not found)\n\n; Find index of first occurrence\n(position 2 (list 1 2 3))             ; \u2192 1 (0-based index)\n(position \"b\" (list \"a\" \"b\" \"c\"))     ; \u2192 1\n(position 5 (list 1 2 3))             ; \u2192 #f (not found, consistent with find)\n(position 2 (list 1 2 3 2))           ; \u2192 1 (first occurrence)\n```\n\n#### List Utility Usage Patterns\n```aifpl\n; Clean and process data\n(let ((data (list 1 -2 3 -4 5))\n      (negatives (list -2 -4)))\n  (let ((cleaned (fold (lambda (acc neg) (remove neg acc)) data negatives))\n        (doubled (map (lambda (x) (* x 2)) cleaned)))\n    doubled))                          ; \u2192 (2 6 10)\n\n; Find and replace pattern\n(let ((find-and-process (lambda (item lst)\n                          (let ((pos (position item lst)))\n                            (if pos\n                                (string-append \"Found \" (number->string item) \n                                             \" at position \" (number->string pos))\n                                \"Not found\")))))\n  (list (find-and-process 3 (list 1 2 3 4))    ; \u2192 \"Found 3 at position 2\"\n        (find-and-process 5 (list 1 2 3 4))))  ; \u2192 \"Not found\"\n\n; List difference using remove\n(let ((list-difference (lambda (list1 list2)\n                         (fold remove list1 list2))))\n  (list-difference (list 1 2 3 4 5) (list 2 4)))  ; \u2192 (1 3 5)\n```\n\n#### List Equality\n```aifpl\n(= (list 1 2) (list 1 2))             ; \u2192 #t\n(= (list 1 2) (list 1 3))             ; \u2192 #f\n(= (list 1 2) (list 1 2 3))           ; \u2192 #f\n```\n\n### String Operations\n\n#### String Construction and Conversion\n```aifpl\n(string-append \"hello\" \" \" \"world\")   ; \u2192 \"hello world\"\n(number->string 42)                   ; \u2192 \"42\"\n(number->string 3.14)                 ; \u2192 \"3.14\"\n(string->number \"42\")                 ; \u2192 42\n(string->number \"3.14\")               ; \u2192 3.14\n```\n\n#### String Information and Access\n```aifpl\n(string-length \"hello\")               ; \u2192 5\n(string-ref \"hello\" 1)                ; \u2192 \"e\" (character at index 1)\n(substring \"hello\" 1 4)               ; \u2192 \"ell\" (start=1, end=4 exclusive)\n```\n\n#### String Manipulation\n```aifpl\n(string-upcase \"hello\")               ; \u2192 \"HELLO\"\n(string-downcase \"HELLO\")             ; \u2192 \"hello\"\n(string-trim \"  hello  \")             ; \u2192 \"hello\"\n(string-replace \"hello world\" \"world\" \"AIFPL\")  ; \u2192 \"hello AIFPL\"\n(string-replace \"banana\" \"a\" \"o\")     ; \u2192 \"bonono\" (non-overlapping)\n(string-replace \"test\" \"x\" \"y\")       ; \u2192 \"test\" (no change if not found)\n```\n\n#### String Manipulation Usage Patterns\n```aifpl\n; Clean and normalize text\n(let ((normalize-text (lambda (text)\n                        (let ((trimmed (string-trim text))\n                              (lower (string-downcase trimmed)))\n                          (string-replace lower \" \" \"-\")))))\n  (normalize-text \"  Hello World  \"))  ; \u2192 \"hello-world\"\n\n; Template replacement\n(let ((template \"Hello {name}, you have {count} messages\")\n      (replace-template (lambda (tmpl name count)\n                          (let ((with-name (string-replace tmpl \"{name}\" name)))\n                            (string-replace with-name \"{count}\" (number->string count))))))\n  (replace-template template \"Alice\" 5))  ; \u2192 \"Hello Alice, you have 5 messages\"\n\n; Multiple replacements\n(let ((clean-text (lambda (text)\n                     (let ((step1 (string-replace text \"bad\" \"good\"))\n                           (step2 (string-replace step1 \"ugly\" \"pretty\")))\n                       (string-replace step2 \"wrong\" \"right\")))))\n  (clean-text \"bad ugly wrong text\"))     ; \u2192 \"good pretty right text\"\n```\n\n#### String Predicates\n```aifpl\n(string-contains? \"hello world\" \"world\")  ; \u2192 #t\n(string-prefix? \"hello\" \"he\")             ; \u2192 #t\n(string-suffix? \"hello\" \"lo\")             ; \u2192 #t\n(string=? \"hello\" \"hello\")                ; \u2192 #t\n(string=? \"hello\" \"world\")                ; \u2192 #f\n```\n\n### String-List Integration\n\n#### String-List Conversion\n```aifpl\n(string->list \"hello\")                ; \u2192 (\"h\" \"e\" \"l\" \"l\" \"o\")\n(list->string (list \"h\" \"e\" \"l\" \"l\" \"o\"))  ; \u2192 \"hello\"\n```\n\n#### String Splitting and Joining\n```aifpl\n(string-split \"name,age,city\" \",\")    ; \u2192 (\"name\" \"age\" \"city\")\n(string-split \"hello world\" \" \")      ; \u2192 (\"hello\" \"world\")\n(string-join (list \"hello\" \"world\") \" \")  ; \u2192 \"hello world\"\n(string-join (list \"a\" \"b\" \"c\") \",\") ; \u2192 \"a,b,c\"\n```\n\n### String Literals and Escape Sequences\n\nString literals use double quotes and support escape sequences:\n\n```aifpl\n\"hello world\"                         ; Basic string\n\"She said \\\"Hello!\\\"\"                 ; Escaped quotes\n\"Line 1\\nLine 2\"                      ; Newline\n\"Column 1\\tColumn 2\"                  ; Tab\n\"Path\\\\to\\\\file\"                      ; Backslash\n\"Unicode: \\u03B1\\u03B2\\u03B3\"         ; Greek letters \u03b1\u03b2\u03b3\n```\n\n**Supported escape sequences:**\n- `\\\"` \u2192 literal quote\n- `\\\\` \u2192 literal backslash\n- `\\n` \u2192 newline\n- `\\t` \u2192 tab\n- `\\r` \u2192 carriage return\n- `\\uXXXX` \u2192 Unicode code point (4 hex digits)\n\n### Association Lists (Alists)\n\nAssociation lists (alists) are immutable key-value mappings with O(1) lookup performance. They are first-class data structures optimized for structured data processing.\n\n#### Creating Alists\n\n```aifpl\n; Basic alist creation\n(alist (\"name\" \"Alice\") (\"age\" 30) (\"city\" \"NYC\"))\n; \u2192 (alist (\"name\" \"Alice\") (\"age\" 30) (\"city\" \"NYC\"))\n\n; Empty alist\n(alist)\n; \u2192 (alist)\n\n; Alists with different key types\n(alist (1 \"one\") (2 \"two\") (3 \"three\"))\n(alist (#t \"yes\") (#f \"no\"))\n\n; Nested alists\n(alist \n  (\"user\" (alist (\"name\" \"Bob\") (\"id\" 123)))\n  (\"status\" \"active\"))\n```\n\n**Note**: `alist` is a special form that evaluates the key and value expressions within each pair, but treats the pair structure itself as data.\n\n#### Accessing Alist Values\n\n```aifpl\n; Get value by key\n(let ((person (alist (\"name\" \"Alice\") (\"age\" 30))))\n  (alist-get person \"name\"))\n; \u2192 \"Alice\"\n\n; Get with default value\n(alist-get person \"email\" \"no-email\")\n; \u2192 \"no-email\"\n\n; Missing keys return #f by default\n(alist-get person \"phone\")\n; \u2192 #f\n\n; Nested access\n(let ((data (alist (\"user\" (alist (\"name\" \"Carol\") (\"id\" 456))))))\n  (alist-get (alist-get data \"user\") \"name\"))\n; \u2192 \"Carol\"\n```\n\n#### Modifying Alists (Immutably)\n\nAll alist operations return new alists without modifying the original:\n\n```aifpl\n; Set a key (returns new alist)\n(let ((person (alist (\"name\" \"Alice\") (\"age\" 30))))\n  (alist-set person \"age\" 31))\n; \u2192 (alist (\"name\" \"Alice\") (\"age\" 31))\n\n; Add a new key\n(alist-set person \"email\" \"alice@example.com\")\n; \u2192 (alist (\"name\" \"Alice\") (\"age\" 30) (\"email\" \"alice@example.com\"))\n\n; Original is unchanged\n(let ((original (alist (\"x\" 1)))\n      (modified (alist-set original \"x\" 2)))\n  (list (alist-get original \"x\") (alist-get modified \"x\")))\n; \u2192 (1 2)\n\n; Remove a key\n(alist-remove person \"age\")\n; \u2192 (alist (\"name\" \"Alice\"))\n```\n\n#### Alist Queries\n\n```aifpl\n; Check if key exists\n(alist-has? person \"name\")\n; \u2192 #t\n\n(alist-has? person \"phone\")\n; \u2192 #f\n\n; Get all keys\n(alist-keys (alist (\"a\" 1) (\"b\" 2) (\"c\" 3)))\n; \u2192 (\"a\" \"b\" \"c\")\n\n; Get all values\n(alist-values (alist (\"a\" 1) (\"b\" 2) (\"c\" 3)))\n; \u2192 (1 2 3)\n\n; Type checking\n(alist? (alist (\"x\" 1)))\n; \u2192 #t\n\n(alist? (list 1 2 3))\n; \u2192 #f\n```\n\n#### Merging Alists\n\n```aifpl\n; Merge two alists (second wins on conflicts)\n(let ((defaults (alist (\"port\" 8080) (\"host\" \"localhost\")))\n      (config (alist (\"port\" 3000) (\"debug\" #t))))\n  (alist-merge defaults config))\n; \u2192 (alist (\"port\" 3000) (\"host\" \"localhost\") (\"debug\" #t))\n\n; Merge multiple alists\n(let ((a (alist (\"x\" 1)))\n      (b (alist (\"y\" 2)))\n      (c (alist (\"z\" 3))))\n  (alist-merge (alist-merge a b) c))\n; \u2192 (alist (\"x\" 1) (\"y\" 2) (\"z\" 3))\n```\n\n#### Alists with Functional Operations\n\n```aifpl\n; Map over keys\n(let ((data (alist (\"name\" \"alice\") (\"city\" \"nyc\"))))\n  (map string-upcase (alist-keys data)))\n; \u2192 (\"NAME\" \"CITY\")\n\n; Filter values\n(let ((scores (alist (\"alice\" 85) (\"bob\" 92) (\"carol\" 78))))\n  (filter (lambda (score) (> score 80)) (alist-values scores)))\n; \u2192 (85 92)\n\n; Fold over values\n(let ((prices (alist (\"apple\" 1.5) (\"banana\" 0.8) (\"orange\" 1.2))))\n  (fold + 0 (alist-values prices)))\n; \u2192 3.5\n\n; Process list of alists\n(let ((people (list \n                (alist (\"name\" \"Alice\") (\"age\" 30))\n                (alist (\"name\" \"Bob\") (\"age\" 25))\n                (alist (\"name\" \"Carol\") (\"age\" 35)))))\n  (map (lambda (p) (alist-get p \"name\")) people))\n; \u2192 (\"Alice\" \"Bob\" \"Carol\")\n```\n\n#### Pattern Matching with Alists\n\n```aifpl\n; Match alist type\n(match (alist (\"type\" \"user\") (\"name\" \"Alice\"))\n  ((alist? data) (alist-get data \"name\"))\n  (_ \"not-alist\"))\n; \u2192 \"Alice\"\n\n; Distinguish alist from list\n(let ((process (lambda (data)\n                 (match data\n                   ((alist? a) \"alist\")\n                   ((list? l) \"list\")\n                   (_ \"other\")))))\n  (list (process (alist (\"a\" 1)))\n        (process (list 1 2 3))))\n; \u2192 (\"alist\" \"list\")\n```\n\n#### Alist Performance\n\nAlists in AIFPL use hash-backed storage for O(1) lookup performance:\n\n- `alist-get`: O(1) - constant time lookup\n- `alist-set`: O(n) - creates new alist with updated value\n- `alist-has?`: O(1) - constant time membership test\n- `alist-keys`/`alist-values`: O(n) - iterates all pairs\n- `alist-merge`: O(n+m) - combines two alists\n\nAlists maintain insertion order and are optimized for read-heavy workloads common in data processing.\n\n### Complex Number Operations\nThe `real` and `imag` functions extract components from any numeric value:\n\n**Real Part Extraction:**\n```aifpl\n(real 42)              ; \u2192 42\n(real 3.14)            ; \u2192 3.14\n(real (complex 3 4))   ; \u2192 3\n(real j)               ; \u2192 0\n```\n\n**Imaginary Part Extraction:**\n```aifpl\n(imag 42)              ; \u2192 0\n(imag 3.14)            ; \u2192 0\n(imag (complex 3 4))   ; \u2192 4\n(imag j)               ; \u2192 1\n```\n\n**With Expressions:**\n```aifpl\n(real (+ (complex 1 2) (complex 3 4)))  ; \u2192 4\n(imag (sqrt -1))                        ; \u2192 1\n(real (* j j))                          ; \u2192 -1\n```\n\n## Type System\n\nAIFPL has a strict type system with the following types:\n\n- **Numbers**: `int`, `float`, `complex` (with automatic promotion)\n- **Strings**: UTF-8 strings with no automatic conversion\n- **Booleans**: `#t` and `#f` with no automatic conversion\n- **Lists**: Heterogeneous collections supporting any element type\n- **Functions**: First-class lambda functions with lexical scoping\n\n### Type Promotion Rules\n\n1. **Numeric promotion**: `int \u2192 float \u2192 complex`\n2. **No cross-type operations**: Strings, booleans, and lists don't mix with numbers\n3. **Explicit conversion**: Use conversion functions when needed\n4. **List heterogeneity**: Lists can contain mixed types\n5. **Function values**: Functions are first-class values that can be stored and passed\n\n### Examples of Type Strictness\n\n```aifpl\n; Valid - same types\n(+ 1 2 3)                             ; \u2192 6 (all integers)\n(string-append \"hello\" \" \" \"world\")   ; \u2192 \"hello world\" (all strings)\n(and #t #f #t)                        ; \u2192 #f (all booleans)\n\n; Valid - numeric promotion\n(+ 1 2.5)                             ; \u2192 3.5 (int promoted to float)\n(* 2 (complex 1 1))                   ; \u2192 (2+2j) (promoted to complex)\n\n; Valid - heterogeneous lists\n(list 1 \"hello\" #t)                   ; \u2192 (1 \"hello\" #t)\n(append (list 1 2) (list \"a\" \"b\"))    ; \u2192 (1 2 \"a\" \"b\")\n\n; Valid - list equality\n(= (list 1 2) (list 1 2))             ; \u2192 #t\n\n; Valid - conditionals with boolean conditions\n(if #t \"yes\" \"no\")                    ; \u2192 \"yes\"\n(if (> 5 3) 42 0)                     ; \u2192 42\n\n; Valid - functions as values\n(let ((f (lambda (x) (* x 2)))) (f 5))  ; \u2192 10\n(list (lambda (x) (+ x 1)) (lambda (x) (* x 2)))  ; \u2192 (<lambda (x)> <lambda (x)>)\n\n; Valid - type checking with predicates\n(if (number? x) (* x 2) \"not a number\")\n(filter string? (list 1 \"hello\" #t \"world\"))  ; \u2192 (\"hello\" \"world\")\n\n; Valid - quote for data literals (both forms)\n(quote (+ 1 2 3))                     ; \u2192 (+ 1 2 3) (as data, not evaluation)\n'(+ 1 2 3)                            ; \u2192 (+ 1 2 3) (shortcut form)\n(list (quote hello) (+ 1 2))          ; \u2192 (hello 3) (mixed quoted/unquoted)\n(list 'hello (+ 1 2))                 ; \u2192 (hello 3) (shortcut form)\n\n; Valid - pattern matching\n(match 42\n  ((number? n) (* n 2))\n  (_ \"not a number\"))                 ; \u2192 84\n\n; Invalid - type mismatch\n(+ 1 \"hello\")                         ; Error: cannot add number and string\n(and #t 1)                            ; Error: 'and' requires boolean arguments\n(string-length 42)                    ; Error: string-length requires string\n(+ (list 1 2))                        ; Error: cannot add list\n(< (list 1) (list 2))                 ; Error: cannot compare lists (only = works)\n(if 1 \"yes\" \"no\")                     ; Error: condition must be boolean\n\n; Valid - explicit conversion\n(string-append \"Count: \" (number->string 42))  ; \u2192 \"Count: 42\"\n(+ 5 (string->number \"10\"))                    ; \u2192 15\n(list->string (string->list \"hello\"))          ; \u2192 \"hello\"\n```\n\n### List Type Rules\n\n1. **Mixed types allowed**: `(list 1 \"hi\" #t)` is valid\n2. **No arithmetic operations**: `(+ (list 1 2))` is an error\n3. **Only equality comparison**: `(= (list 1) (list 1))` works, `(< (list 1) (list 2))` doesn't\n4. **Type-specific functions**: List functions require lists, string functions require strings\n5. **Explicit conversion**: Use `string->list`, `list->string` for conversions\n\n### Function Type Rules\n\n1. **First-class values**: Functions can be passed, returned, stored in lists\n2. **Lexical scoping**: Functions access variables from their definition environment\n3. **Closures**: Functions capture their environment when created\n4. **Arity checking**: Function calls must provide exact number of parameters\n5. **Identity equality**: Each lambda creates a unique function object\n\n## Pure List Representation Benefits\n\nThe pure list approach provides several advantages:\n\n1. **True homoiconicity**: Code and data have identical representation\n2. **Simpler architecture**: Only `AIFPLValue` types, no special AST nodes\n3. **Traditional Lisp semantics**: Everything is data, following Lisp philosophy\n4. **Easier to understand**: One consistent representation for all expressions\n5. **Future extensibility**: Natural foundation for features like macros\n6. **Reduced complexity**: Fewer types, simpler parser, more straightforward evaluator\n\n### Internal Representation Examples\n\n```aifpl\n; Lambda expression: (lambda (x) (* x x))\n; Represented as: AIFPLList([AIFPLSymbol(\"lambda\"), AIFPLList([AIFPLSymbol(\"x\")]), AIFPLList([...])])\n\n; Let expression: (let ((x 5)) (+ x 1))\n; Represented as: AIFPLList([AIFPLSymbol(\"let\"), AIFPLList([AIFPLList([...])]), ...])\n\n; Function call: (+ 1 2 3)\n; Represented as: AIFPLList([AIFPLSymbol(\"+\"), AIFPLNumber(1), AIFPLNumber(2), AIFPLNumber(3)])\n\n; Quote expression: (quote (+ 1 2))\n; Represented as: AIFPLList([AIFPLSymbol(\"quote\"), AIFPLList([AIFPLSymbol(\"+\"), AIFPLNumber(1), AIFPLNumber(2)])])\n\n; Single quote shortcut: '(+ 1 2)\n; Represented as: AIFPLList([AIFPLSymbol(\"quote\"), AIFPLList([AIFPLSymbol(\"+\"), AIFPLNumber(1), AIFPLNumber(2)])])\n; (Identical to the full quote form - the shortcut is purely syntactic sugar)\n\n; Match expression: (match x ((number? n) (* n 2)) (_ \"not a number\"))\n; Represented as: AIFPLList([AIFPLSymbol(\"match\"), AIFPLSymbol(\"x\"), AIFPLList([...]), ...])\n```\n\nThe evaluator recognizes special forms by examining the first element of lists, maintaining the traditional Lisp approach where syntax is determined by structure, not by special types.\n\n## Common Usage Patterns\n\n### Pattern Matching for Data Processing\n```aifpl\n; Replace complex nested conditionals with pattern matching\n(let ((process-data (lambda (item)\n                      (match item\n                        ((\"user\" name email) \n                         (string-append \"User: \" name \" (\" email \")\"))\n                        ((\"product\" id price)\n                         (string-append \"Product #\" (number->string id) \": $\" (number->string price)))\n                        ((\"order\" id items total)\n                         (string-append \"Order #\" (number->string id) \" (\" \n                                      (number->string (length items)) \" items): $\" \n                                      (number->string total)))\n                        (_ \"unknown data type\")))))\n  (map process-data (list (list \"user\" \"Alice\" \"alice@example.com\")\n                         (list \"product\" 123 29.99)\n                         (list \"order\" 456 (list \"item1\" \"item2\") 59.98)\n                         (list \"invalid\" \"data\"))))\n; \u2192 (\"User: Alice (alice@example.com)\" \"Product #123: $29.99\" \"Order #456 (2 items): $59.98\" \"unknown data type\")\n\n; Type-based processing with pattern matching\n(let ((safe-operation (lambda (x y)\n                        (match (list x y)\n                          (((number? a) (number? b)) (+ a b))\n                          (((string? a) (string? b)) (string-append a \" \" b))\n                          (((list? a) (list? b)) (append a b))\n                          (_ \"incompatible types\")))))\n  (list (safe-operation 5 10)\n        (safe-operation \"hello\" \"world\")\n        (safe-operation (list 1 2) (list 3 4))\n        (safe-operation 5 \"hello\")))\n; \u2192 (15 \"hello world\" (1 2 3 4) \"incompatible types\")\n\n; Configuration parsing with patterns\n(let ((parse-config (lambda (config-list)\n                      (map (lambda (item)\n                             (match item\n                               ((\"server\" host port)\n                                (list \"server-config\" host port))\n                               ((\"database\" type connection-string)\n                                (list \"db-config\" type connection-string))\n                               ((\"feature\" name enabled)\n                                (list \"feature-toggle\" name enabled))\n                               (_ (list \"unknown-config\" item))))\n                           config-list))))\n  (parse-config (list (list \"server\" \"localhost\" 8080)\n                     (list \"database\" \"postgresql\" \"postgres://localhost/mydb\")\n                     (list \"feature\" \"new-ui\" #t)\n                     (list \"invalid\" \"config\" \"entry\"))))\n; \u2192 ((\"server-config\" \"localhost\" 8080) (\"db-config\" \"postgresql\" \"postgres://localhost/mydb\") (\"feature-toggle\" \"new-ui\" #t) (\"unknown-config\" (\"invalid\" \"config\" \"entry\")))\n```\n\n### Symbolic Programming with Quote\n```aifpl\n; Store and manipulate code as data (using shortcuts for cleaner syntax)\n(let ((expressions (list '(+ 1 2)\n                        '(* 3 4)\n                        '(- 10 5))))\n  (map first expressions))                  ; \u2192 (+ * -) (extract operators)\n\n; Template-based programming (shortcuts make templates more readable)\n(let ((make-comparison (lambda (op value)\n                         (list 'lambda\n                              '(x)\n                              (list op 'x value)))))\n  (list (make-comparison '> 10)\n        (make-comparison '= 0)))            ; \u2192 ((lambda (x) (> x 10)) (lambda (x) (= x 0)))\n\n; Code transformation (shortcuts improve readability)\n(let ((negate-condition (lambda (expr)\n                          (if (and (list? expr) (= (first expr) '>))\n                              (cons '<= (rest expr))\n                              expr))))\n  (negate-condition '(> x 5)))              ; \u2192 (<= x 5)\n```\n\n### Functional Data Processing\n```aifpl\n; Process list of numbers\n(let ((numbers (list 1 2 3 4 5 6 7 8 9 10)))\n  (let ((evens (filter (lambda (x) (= (% x 2) 0)) numbers))\n        (doubled (map (lambda (x) (* x 2)) evens))\n        (sum (fold + 0 doubled)))\n    sum))                                   ; \u2192 60\n\n; Text processing pipeline\n(let ((text \"The quick brown fox jumps\"))\n  (let ((words (string-split text \" \"))\n        (long-words (filter (lambda (w) (> (string-length w) 3)) words))\n        (upper-words (map string-upcase long-words)))\n    (string-join upper-words \"-\")))         ; \u2192 \"QUICK-BROWN-JUMPS\"\n\n; Data validation and transformation\n(let ((validate-and-double (lambda (nums)\n                            (if (all? (lambda (x) (> x 0)) nums)\n                                (map (lambda (x) (* x 2)) nums)\n                                \"error: negative numbers\"))))\n  (list (validate-and-double (list 1 2 3))\n        (validate-and-double (list 1 -2 3))))  ; \u2192 ((2 4 6) \"error: negative numbers\")\n```\n\n### Conditional Processing\n```aifpl\n; Safe division\n(if (= divisor 0) \"undefined\" (/ dividend divisor))\n\n; Safe list access\n(if (null? my-list) \"empty\" (first my-list))\n\n; Data validation\n(if (string-contains? input \"@\")\n    (string-append \"Email: \" input)\n    \"Invalid email format\")\n\n; Conditional list processing\n(if (> (length items) 0)\n    (string-join items \", \")\n    \"No items\")\n\n; Nested conditionals for complex logic\n(if (> temperature 30)\n    \"hot\"\n    (if (> temperature 20) \"warm\" \"cold\"))\n```\n\n### Function Composition and Higher-Order Patterns\n```aifpl\n; Create reusable transformations\n(let ((process-data (lambda (data)\n                      (let ((clean (filter (lambda (x) (> x 0)) data))\n                            (transformed (map (lambda (x) (+ (* x x) 1)) clean))\n                            (limited (take 5 transformed)))\n                        limited))))\n  (process-data (list -1 2 3 -4 5 6 7 8)))  ; \u2192 (5 10 26 37 50)\n\n; Build complex predicates\n(let ((in-range (lambda (min max)\n                  (lambda (x) (and (>= x min) (<= x max)))))\n      (is-even (lambda (x) (= (% x 2) 0))))\n  (let ((even-in-range (lambda (x) (and (is-even x) ((in-range 10 50) x)))))\n    (filter even-in-range (range 1 60))))   ; \u2192 (10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50)\n\n; Recursive data structures\n(let ((tree-sum (lambda (tree)\n                  (if (list? tree)\n                      (fold + 0 (map tree-sum tree))\n                      tree))))\n  (tree-sum (list 1 (list 2 3) (list (list 4 5) 6))))  ; \u2192 21\n```\n\n### Type-Safe Programming Patterns\n```aifpl\n; Polymorphic function with type checking\n(let ((safe-process (lambda (value)\n                      (if (number? value)\n                          (* value value)\n                          (if (string? value)\n                              (string-upcase value)\n                              (if (list? value)\n                                  (length value)\n                                  \"unknown type\"))))))\n  (map safe-process (list 5 \"hello\" (list 1 2 3) #t)))  ; \u2192 (25 \"HELLO\" 3 \"unknown type\")\n\n; Type validation pipeline\n(let ((validate-input (lambda (data)\n                        (if (list? data)\n                            (if (all? number? data)\n                                (fold + 0 data)\n                                \"error: non-numeric data\")\n                            \"error: not a list\"))))\n  (list (validate-input (list 1 2 3))        ; \u2192 6\n        (validate-input (list 1 \"x\" 3))      ; \u2192 \"error: non-numeric data\"\n        (validate-input \"not a list\")))      ; \u2192 \"error: not a list\"\n\n; Mixed type list processing\n(let ((categorize (lambda (items)\n                    (let ((numbers (filter number? items))\n                          (strings (filter string? items))\n                          (booleans (filter boolean? items)))\n                      (list (list \"numbers\" numbers)\n                            (list \"strings\" strings)\n                            (list \"booleans\" booleans))))))\n  (categorize (list 1 \"hello\" #t 3.14 \"world\" #f)))\n; \u2192 ((\"numbers\" (1 3.14)) (\"strings\" (\"hello\" \"world\")) (\"booleans\" (#t #f)))\n```\n\n### String Processing\n```aifpl\n; Split CSV data and process\n(string-split \"name,age,city\" \",\")              ; \u2192 (\"name\" \"age\" \"city\")\n(first (string-split \"John,25,NYC\" \",\"))        ; \u2192 \"John\"\n(length (string-split \"a,b,c,d\" \",\"))           ; \u2192 4\n\n; Build strings from components\n(string-join (list \"hello\" \"world\") \" \")        ; \u2192 \"hello world\"\n(string-join (reverse (string-split \"a-b-c\" \"-\")) \"+\")  ; \u2192 \"c+b+a\"\n\n; Conditional string processing\n(if (> (string-length text) 10)\n    (string-append (substring text 0 10) \"...\")\n    text)\n\n; Advanced text processing\n(let ((clean-and-format (lambda (text)\n                          (let ((trimmed (string-trim text))\n                                (normalized (string-replace trimmed \"  \" \" \")))\n                            (string-upcase normalized)))))\n  (clean-and-format \"  hello    world  \"))      ; \u2192 \"HELLO  WORLD\"\n```\n\n### Character-Level Processing\n```aifpl\n; Convert to characters, process, convert back\n(string->list \"hello\")                          ; \u2192 (\"h\" \"e\" \"l\" \"l\" \"o\")\n(reverse (string->list \"hello\"))                ; \u2192 (\"o\" \"l\" \"l\" \"e\" \"h\")\n(list->string (reverse (string->list \"hello\"))) ; \u2192 \"olleh\"\n```\n\n### Data Structure Manipulation\n```aifpl\n; Build complex data structures\n(list (list \"name\" \"John\") (list \"age\" 25))     ; \u2192 ((\"name\" \"John\") (\"age\" 25))\n(first (list (list 1 2) (list 3 4)))            ; \u2192 (1 2)\n(rest (first (list (list 1 2 3) (list 4 5))))   ; \u2192 (2 3)\n\n; Conditional data processing\n(if (member? \"error\" status-list)\n    (list \"status\" \"error\" \"failed\")\n    (list \"status\" \"ok\" \"success\"))\n\n; Advanced list manipulation \n(let ((data (list 1 2 3 2 4 2 5))\n      (target 2))\n  (let ((cleaned (remove target data))\n        (position-info (position target data)))\n    (list \"original\" data \n          \"cleaned\" cleaned \n          \"first-position\" position-info)))\n; \u2192 (\"original\" (1 2 3 2 4 2 5) \"cleaned\" (1 3 4 5) \"first-position\" 1)\n```\n\n### Quote Shortcut Usage Patterns\n```aifpl\n; Building expressions with mixed quoted and evaluated parts\n(let ((make-setter (lambda (var value)\n                     (list 'let (list (list var value)) var))))\n  (make-setter 'x 42))                      ; \u2192 (let ((x 42)) x)\n\n; Code generation with templates\n(let ((make-validator (lambda (type-pred error-msg)\n                        '(lambda (value)\n                           (if (,type-pred value)\n                               value\n                               ,error-msg)))))\n  ; Note: This is conceptual - actual implementation would need more complex quasiquoting\n  (make-validator 'number? \"not a number\"))\n\n; Data-driven programming\n(let ((operations '((add +) (multiply *) (subtract -))))\n  (map (lambda (op) (first (rest op))) operations))  ; \u2192 (+ * -)\n\n; Pattern matching simulation\n(let ((match-expr (lambda (pattern expr)\n                    (if (= (first pattern) (first expr))\n                        'match\n                        'no-match))))\n  (list (match-expr '(+ ? ?) '(+ 1 2))     ; \u2192 match\n        (match-expr '(+ ? ?) '(* 1 2))))   ; \u2192 no-match\n```\n\n## Advanced Features\n\n### Tail Call Optimization\n\nAIFPL automatically optimizes tail calls to prevent stack overflow in recursive functions:\n\n```aifpl\n; Factorial with tail recursion (automatically optimized)\n(let ((factorial (lambda (n acc)\n                   (if (<= n 1)\n                       acc\n                       (factorial (- n 1) (* n acc))))))\n  (factorial 1000 1))                       ; Works with large numbers\n\n; Mutual recursion is also optimized\n(let ((is-even (lambda (n)\n                 (if (= n 0) #t (is-odd (- n 1)))))\n      (is-odd (lambda (n)\n                (if (= n 0) #f (is-even (- n 1))))))\n  (is-even 10000))                          ; \u2192 #t (no stack overflow)\n```\n\n### Lexical Scoping and Closures\n\nFunctions capture their lexical environment, creating closures:\n\n```aifpl\n; Function factory with captured state\n(let ((make-adder (lambda (increment)\n                    (lambda (x) (+ x increment)))))\n  (let ((add-five (make-adder 5))\n        (add-ten (make-adder 10)))\n    (list (add-five 3) (add-ten 3))))      ; \u2192 (8 13)\n\n; Nested closures capturing multiple levels\n(let ((outer-value 100))\n  (let ((make-calculator (lambda (operation)\n                           (lambda (x y)\n                             (operation (+ x outer-value) y)))))\n    (let ((multiply-with-offset (make-calculator *))\n          (add-with-offset (make-calculator +)))\n      (list (multiply-with-offset 2 3)     ; \u2192 (102 * 3) = 306\n            (add-with-offset 5 10)))))     ; \u2192 (105 + 10) = 115\n```\n\n### Error Handling Patterns\n\n```aifpl\n; Validation chains\n(let ((validate-number (lambda (x)\n                         (if (> x 0) x \"error: not positive\")))\n      (validate-range (lambda (x)\n                        (if (and (>= x 1) (<= x 100)) x \"error: out of range\"))))\n  (let ((process (lambda (x)\n                   (let ((step1 (validate-number x)))\n                     (if (string? step1)\n                         step1\n                         (validate-range step1))))))\n    (list (process 50) (process -5) (process 150))))  ; \u2192 (50 \"error: not positive\" \"error: out of range\")\n\n; Safe operations with defaults\n(let ((safe-head (lambda (lst default)\n                   (if (null? lst) default (first lst))))\n      (safe-tail (lambda (lst default)\n                   (if (null? lst) default (last lst))))\n      (safe-divide (lambda (x y default)\n                     (if (= y 0) default (/ x y)))))\n  (list (safe-head (list) \"empty\")\n        (safe-tail (list 1 2 3) \"empty\")\n        (safe-divide 10 0 \"undefined\")))    ; \u2192 (\"empty\" 3 \"undefined\")\n```\n\n## Differences from Traditional Lisp/Scheme\n\n**AIFPL uses proper lists only, not cons cells.** This is a fundamental difference from traditional Lisp/Scheme that affects list construction and pattern matching.\n\n### Key Differences\n\n#### 1. Cons Requires a List as Second Argument\n\n**Traditional Lisp/Scheme:**\n```scheme\n(cons 1 2)              ; => (1 . 2)  - creates a dotted pair\n(cons 1 (cons 2 3))     ; => (1 2 . 3) - creates an improper list\n```\n\n**AIFPL:**\n```aifpl\n(cons 1 (list 2 3))     ; => (1 2 3)  \u2713 Valid - second arg is a list\n(cons 1 (list 2))       ; => (1 2)    \u2713 Valid\n(cons 1 2)              ; => ERROR    \u2717 Invalid - second arg must be a list!\n```\n\n**Why?** AIFPL lists are backed by Python tuples. All lists are proper lists - there are no dotted pairs or improper lists. This makes the language simpler and more predictable.\n\n**To create pairs:** Use `(list a b)` instead of cons cells.\n\n#### 2. Rest Always Returns a List\n\n**Traditional Lisp/Scheme:**\n```scheme\n(cdr '(1))        ; => ()  - empty list\n(cdr '(1 . 2))    ; => 2   - can return an atom!\n```\n\n**AIFPL:**\n```aifpl\n(rest (list 1))         ; => ()     - always returns a list\n(rest (list 1 2))       ; => (2)    - always returns a list\n; No way to get an atom from rest\n```\n\n**Why?** This guarantees type safety. You always know `rest` returns a list, never an atom.\n\n#### 3. Pattern Matching: Tail is Always a List\n\n**Traditional Lisp/Scheme:**\n```scheme\n(match '(1 . 2) ((h . t) t))    ; => 2   - t binds to atom\n(match '(1 2) ((h . t) t))      ; => (2) - t binds to list\n```\n\n**AIFPL:**\n```aifpl\n(match (list 1 2) ((h . t) t))      ; => (2)  - t is always a list\n(match (list 1) ((h . t) t))        ; => ()   - t is empty list, not atom\n```\n\n**Why?** Consistency. The `(head . tail)` pattern always binds `tail` to a list (possibly empty), never to an atom.\n\n#### 4. No car/cdr - Use first/rest\n\nAIFPL uses more descriptive names:\n- `first` instead of `car`\n- `rest` instead of `cdr`\n- `last` for the last element\n\nThese names are clearer and emphasize that `rest` always returns a list.\n\n### Other Differences from Scheme/Lisp\n\n- **No mutation**: No `set!`, `set-car!`, `set-cdr!` - all data is immutable\n- **No macros**: No `define-syntax` or `defmacro` - all special forms are built-in\n- **No global definitions**: No top-level `define` - use `let` for bindings\n- **Strict type system**: Boolean operations require booleans, no \"truthy\" values\n- **No continuations**: No `call/cc` - simpler execution model\n\n### Migration Guide\n\nIf you're coming from Scheme/Lisp:\n\n**Creating pairs:**\n```aifpl\n; Instead of: (cons 1 2)\n(list 1 2)              ; Two-element list\n```\n\n**Association lists:**\n```aifpl\n; Instead of: '((a . 1) (b . 2))\n(list (list \"a\" 1) (list \"b\" 2))    ; List of two-element lists\n```\n\n**Pattern matching:**\n```aifpl\n; Pattern (h . t) always binds t to a list\n(match (list 1 2 3)\n  ((h . t) (list h t)))             ; => (1 (2 3))  - t is (2 3), not 2 3\n\n; For fixed-length patterns, use explicit elements\n(match (list 1 2)\n  ((a b) (list a b)))               ; => (1 2)  - direct binding\n```\n\n### Why These Differences?\n\n1. **Simplicity**: Proper lists only means fewer edge cases\n2. **Type safety**: `rest` always returns a list - no runtime type checking needed\n3. **Predictability**: Consistent behavior makes code easier to reason about\n4. **AI-friendly**: Fewer special cases for AI models to learn\n\n## Design Principles\n\n1. **Pure List Representation**: Everything is data, following traditional Lisp philosophy\n2. **Functional Programming**: First-class functions, immutable data, no side effects\n3. **Lexical Scoping**: Variables resolved in their definition environment\n4. **Tail Call Optimization**: Automatic optimization for recursive patterns\n5. **Type Safety**: Comprehensive type hints and strict type checking\n6. **Error Handling**: Detailed error messages with position information\n7. **Performance**: Efficient evaluation with automatic optimizations\n8. **LISP Compatibility**: Following traditional LISP semantics where applicable\n9. **Lazy Evaluation**: Conditionals and boolean operators use lazy evaluation\n10. **Independence**: No dependencies on external packages\n11. **Simplicity**: Direct S-expression evaluation without over-engineering\n12. **Homoiconicity**: Code and data use identical representations\n13. **Syntactic Sugar**: Single quote shortcut provides convenient syntax while maintaining pure list representation\n14. **Pattern Matching**: Comprehensive pattern matching for elegant data processing\n15. **Proper Lists Only**: Lists are backed by Python tuples, no cons cells or improper lists for simplicity and type safety\n\n## Architecture\n\nAIFPL uses a **pure list representation** for all code, following traditional Lisp philosophy:\n\n- **Everything is data**: Code and data have identical representation (`AIFPLValue` objects)\n- **No special AST nodes**: Lambda expressions, let expressions, and function calls are all just lists\n- **Homoiconic**: The same data structures represent both code and data\n- **Simple and consistent**: One unified representation for all expressions\n\n### Package Structure\n\n```plaintext\nsrc/aifpl/\n\u251c\u2500\u2500 __init__.py              # Package exports\n\u251c\u2500\u2500 aifpl.py                 # Main AIFPL class (public API)\n\u251c\u2500\u2500 aifpl_error.py           # Exception classes\n\u251c\u2500\u2500 aifpl_token.py           # Token types and definitions\n\u251c\u2500\u2500 aifpl_tokenizer.py       # Tokenizer implementation\n\u251c\u2500\u2500 aifpl_parser.py          # Parser (creates AIFPLValue objects)\n\u251c\u2500\u2500 aifpl_evaluator.py       # Expression evaluator\n\u251c\u2500\u2500 aifpl_environment.py     # Environment and function management\n\u251c\u2500\u2500 aifpl_value.py           # Value hierarchy (AIFPLValue types)\n\u2514\u2500\u2500 aifpl_dependency_analyzer.py  # Let binding dependency analysis\n```\n\n### Core Types\n\n- **AIFPLValue**: Base class for all values (numbers, strings, booleans, symbols, lists, functions)\n\n### Exception Hierarchy\n\n- `AIFPLError` - Base exception\n  - `AIFPLTokenError` - Tokenization errors\n  - `AIFPLParseError` - Parsing errors\n  - `AIFPLEvalError` - Evaluation errors\n\n## Advanced Usage\n\n### Custom Configuration\n\n```python\n# Increase recursion depth for deeply nested expressions\ntool = AIFPL(max_depth=500)\n\n# Adjust tolerance for complex number simplification\ntool = AIFPL(floating_point_tolerance=1e-15)\n```\n\n### Working with Results\n\n```python\n# Raw evaluation returns Python objects\nresult = tool.evaluate('(list 1 2 3)')\nprint(f\"Result: {result}\")  # Result: [1, 2, 3]\nprint(f\"Type: {type(result)}\")  # Type: <class 'list'>\n\n# Formatted evaluation returns LISP-style strings\nformatted = tool.evaluate_and_format('(list 1 2 3)')\nprint(f\"Formatted: {formatted}\")  # Formatted: (1 2 3)\n\n# Function results\nfunc_result = tool.evaluate('(lambda (x) (* x x))')\nprint(f\"Function: {func_result}\")  # Function: <aifpl.aifpl_environment.AIFPLLambdaFunction object>\n\nformatted_func = tool.evaluate_and_format('(lambda (x) (* x x))')\nprint(f\"Formatted Function: {formatted_func}\")  # Formatted Function: <lambda (x)>\n\n# Boolean results\nbool_result = tool.evaluate('(member? 2 (list 1 2 3))')\nprint(f\"Boolean: {bool_result}\")  # Boolean: True\n\nformatted_bool = tool.evaluate_and_format('(member? 2 (list 1 2 3))')\nprint(f\"Formatted Boolean: {formatted_bool}\")  # Formatted Boolean: #t\n\ninequality_result = tool.evaluate('(!= 1 2 3)')\nprint(f\"Inequality: {inequality_result}\")  # Inequality: True\n\ntype_check = tool.evaluate('(number? 42)')\nprint(f\"Type check: {type_check}\")  # Type check: True\n\nposition_result = tool.evaluate('(position \"world\" (list \"hello\" \"world\"))')\nprint(f\"Position: {position_result}\")  # Position: 1\n\n# Quote results (both forms produce identical results)\nquote_result = tool.evaluate('(quote (+ 1 2 3))')\nprint(f\"Quote result: {quote_result}\")  # Quote result: ['+', 1, 2, 3]\n\nshortcut_result = tool.evaluate(\"'(+ 1 2 3)\")\nprint(f\"Shortcut result: {shortcut_result}\")  # Shortcut result: ['+', 1, 2, 3]\n\nformatted_quote = tool.evaluate_and_format('(quote (+ 1 2 3))')\nprint(f\"Formatted quote: {formatted_quote}\")  # Formatted quote: (+ 1 2 3)\n\nformatted_shortcut = tool.evaluate_and_format(\"'(+ 1 2 3)\")\nprint(f\"Formatted shortcut: {formatted_shortcut}\")  # Formatted shortcut: (+ 1 2 3)\n\n# Pattern matching results\npattern_result = tool.evaluate('(match 42 ((number? n) (* n 2)) (_ \"not a number\"))')\nprint(f\"Pattern match: {pattern_result}\")  # Pattern match: 84\n\ncomplex_pattern = tool.evaluate('(match (list 1 2 3) ((a b c) (+ a b c)) (_ \"no match\"))')\nprint(f\"Complex pattern: {complex_pattern}\")  # Complex pattern: 6\n```\n\n### Error Handling Patterns\n\n```python\nfrom aifpl import AIFPL, AIFPLTokenError, AIFPLParseError, AIFPLEvalError\n\ntool = AIFPL()\n\ntry:\n    result = tool.evaluate(expression)\n\nexcept AIFPLTokenError as e:\n    print(f\"Tokenization error: {e}\")\n\nexcept AIFPLParseError as e:\n    print(f\"Parsing error: {e}\")\n\nexcept AIFPLEvalError as e:\n    print(f\"Evaluation error: {e}\")\n\nexcept AIFPLError as e:\n    print(f\"General AIFPL error: {e}\")\n```\n\n### Complex Functional Processing\n\n```python\n# Complex nested operations with functional programming\nfunctional_expr = '''\n(let ((data (list 1 2 3 4 5 6 7 8 9 10)))\n  (let ((process (lambda (nums)\n                   (let ((evens (filter (lambda (x) (= (% x 2) 0)) nums))\n                         (squares (map (lambda (x) (* x x)) evens))\n                         (sum (fold + 0 squares)))\n                     sum))))\n    (process data)))\n'''\n\n# Higher-order function composition\ncomposition_expr = '''\n(let ((compose (lambda (f g) (lambda (x) (f (g x)))))\n      (add-one (lambda (x) (+ x 1)))\n      (double (lambda (x) (* x 2))))\n  (let ((transform (compose add-one double)))\n    (map transform (list 1 2 3 4 5))))\n'''\n\n# Recursive data processing with tail optimization\nrecursive_expr = '''\n(let ((factorial (lambda (n acc)\n                   (if (<= n 1)\n                       acc\n                       (factorial (- n 1) (* n acc))))))\n  (factorial 20 1))\n'''\n\n# Quote-based symbolic programming (using shortcuts for cleaner syntax)\nsymbolic_expr = '''\n(let ((expressions (list '(+ 1 2)\n                        '(* 3 4)\n                        '(- 10 5))))\n  (let ((operators (map first expressions))\n        (operands (map rest expressions)))\n    (list \"operators\" operators \"operands\" operands)))\n'''\n\n# Pattern matching for data processing\npattern_matching_expr = '''\n(let ((process-items (lambda (items)\n                       (map (lambda (item)\n                              (match item\n                                ((\"person\" name age) \n                                 (string-append name \" (\" (number->string age) \")\"))\n                                ((\"product\" id price)\n                                 (string-append \"Product \" (number->string id) \": $\" (number->string price)))\n                                (_ \"unknown item\")))\n                            items))))\n  (process-items (list (list \"person\" \"Alice\" 30)\n                      (list \"product\" 123 29.99)\n                      (list \"invalid\" \"data\"))))\n'''\n\nadvanced_processing = '''\n(let ((data (list \"  hello  \" \"WORLD\" \"test\" \"  EXAMPLE  \"))\n      (clean-normalize (lambda (text)\n                         (string-downcase (string-trim text)))))\n  (let ((cleaned (map clean-normalize data))\n        (filtered (remove \"test\" cleaned))\n        (positions (map (lambda (item) \n                          (position item cleaned)) \n                       filtered)))\n    (list \"cleaned\" cleaned \"filtered\" filtered \"positions\" positions)))\n'''\n```\n",
          "error": null
        }
      ]
    },
    {
      "id": "1627a703-bf62-4d1c-9f0b-dd04a7c8c851",
      "timestamp": "2026-01-11T15:17:20.941882+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_016fp7EzhB5aM1ktuReVriDZ",
          "name": "filesystem",
          "content": "# AIFPL (AI Functional Programming Language)\n\nAIFPL is a mathematical expression language with LISP-like S-expression syntax designed for AI tool integration. It supports mathematical calculations, string manipulation, boolean operations, list processing, conditional evaluation, and functional programming with lambda expressions and higher-order functions.\n\n## Features\n\n- **Pure list representation**: Everything is data - true homoiconicity like traditional Lisp\n- **S-expression syntax**: `(function-or-operator arg1 arg2 ...)`\n- **Quote special form**: `(quote expr)` and shortcut `'expr` for preventing evaluation and creating data literals\n- **Pattern matching**: Comprehensive pattern matching with structural and type-based patterns\n- **Mathematical operations**: Arithmetic, trigonometry, logarithms, bitwise operations\n- **String operations**: Manipulation, searching, conversion with full UTF-8 support\n- **Boolean operations**: Logic operations with strict type checking\n- **List operations**: Construction, manipulation, and conversion with heterogeneous support\n- **Association lists (alists)**: Immutable key-value mappings with O(1) lookup performance\n- **Conditional evaluation**: `if` expressions with lazy evaluation of branches\n- **Lazy evaluation**: `and` and `or` perform lazy evaluation of operands\n- **Lambda expressions**: Anonymous functions with lexical scoping and closures\n- **Local bindings**: `let` expressions for sequential variable binding\n- **Higher-order functions**: `map`, `filter`, `fold`, `range`, and more for functional programming\n- **Tail call optimization**: Automatic optimization for recursive and mutually recursive functions\n- **Type predicates**: Built-in functions to check value types\n- **Number formats**: Integers, floats, complex numbers, hex (0xFF), binary (0b1010), octal (0o755)\n- **String literals**: `\"hello world\"` with escape sequences\n- **Boolean literals**: `#t` (true) and `#f` (false)\n- **Constants**: `pi`, `e`, `j` (imaginary unit), `true`, `false`\n- **Type promotion**: Automatic promotion from int \u2192 float \u2192 complex\n- **Result simplification**: Complex numbers with negligible imaginary parts become real\n- **Comments**: `;` introduces comments\n\n## Usage\n\n### Basic Usage\n\n```python\nfrom aifpl import AIFPL\n\ntool = AIFPL()\nresult = tool.evaluate(\"(+ 1 2 3)\")  # Returns: 6\n```\n\n### With Configuration\n\n```python\ntool = AIFPL(max_depth=200, floating_point_tolerance=1e-12)\nresult = tool.evaluate(\"(sin (* pi 0.5))\")  # Returns: 1\n```\n\n### Formatted Output\n\n```python\n# Get results with LISP-style formatting\nresult_str = tool.evaluate_and_format(\"(list 1 2 3)\")  # Returns: \"(1 2 3)\"\n```\n\n### Error Handling\n\n```python\nfrom aifpl import AIFPL, AIFPLError\n\ntool = AIFPL()\ntry:\n    result = tool.evaluate(\"(+ 1 2\")  # Missing closing paren\nexcept AIFPLError as e:\n    print(f\"AIFPL error: {e}\")\n```\n\n## Supported Operations\n\n### Quote - Data Literals and Code as Data\n\nThe `quote` special form prevents evaluation of expressions, enabling true code-as-data manipulation:\n\n#### Basic Quote Syntax\n```aifpl\n(quote expr)\n'expr          ; Shortcut form (equivalent to (quote expr))\n```\n\n#### Quote Examples - Preventing Evaluation\n```aifpl\n; Without quote - expression gets evaluated\n(+ 1 2 3)                             ; \u2192 6\n\n; With quote - expression returned as data\n(quote (+ 1 2 3))                     ; \u2192 (+ 1 2 3)\n'(+ 1 2 3)                            ; \u2192 (+ 1 2 3) (shortcut form)\n\n; Quote symbols to prevent variable lookup\n(quote x)                             ; \u2192 x (the symbol itself)\n'x                                    ; \u2192 x (shortcut form)\n(quote hello)                         ; \u2192 hello (symbol, not variable lookup)\n'hello                                ; \u2192 hello (shortcut form)\n```\n\n#### Single Quote Shortcut Examples\n```aifpl\n; Basic shortcut usage\n'x                                    ; \u2192 x (same as (quote x))\n'42                                   ; \u2192 42 (same as (quote 42))\n'\"hello\"                              ; \u2192 \"hello\" (same as (quote \"hello\"))\n'#t                                   ; \u2192 #t (same as (quote #t))\n\n; Shortcut with lists\n'(1 2 3)                              ; \u2192 (1 2 3) (same as (quote (1 2 3)))\n'()                                   ; \u2192 () (same as (quote ()))\n\n; Nested shortcut quotes\n''x                                   ; \u2192 (quote x) (same as (quote (quote x)))\n'''x                                  ; \u2192 (quote (quote x)) (triple nested)\n\n; Mixed usage in expressions\n(list 'hello (+ 1 2) 'world)         ; \u2192 (hello 3 world)\n(cons '+ '(1 2 3))                    ; \u2192 (+ 1 2 3)\n```\n\n#### Quote with Lists - Creating Data Structures\n```aifpl\n; Create lists as pure data\n(quote (1 2 3))                       ; \u2192 (1 2 3) (list as data)\n'(1 2 3)                              ; \u2192 (1 2 3) (shortcut form)\n(quote ())                            ; \u2192 () (empty list as data)\n'()                                   ; \u2192 () (shortcut form)\n\n; Create nested data structures\n(quote ((a 1) (b 2) (c 3)))           ; \u2192 ((a 1) (b 2) (c 3))\n'((a 1) (b 2) (c 3))                  ; \u2192 ((a 1) (b 2) (c 3)) (shortcut)\n\n; Mix quoted and unquoted in larger expressions\n(list (quote hello) (+ 1 2) (quote world))  ; \u2192 (hello 3 world)\n(list 'hello (+ 1 2) 'world)         ; \u2192 (hello 3 world) (with shortcuts)\n```\n\n#### Quote with Code Templates\n```aifpl\n; Store code as data for later use\n(let ((template (quote (if CONDITION THEN ELSE))))\n  template)                           ; \u2192 (if CONDITION THEN ELSE)\n(let ((template '(if CONDITION THEN ELSE)))\n  template)                           ; \u2192 (if CONDITION THEN ELSE) (shortcut)\n\n; Create function templates\n(let ((lambda-template (quote (lambda (x) (* x x)))))\n  lambda-template)                    ; \u2192 (lambda (x) (* x x))\n(let ((lambda-template '(lambda (x) (* x x))))\n  lambda-template)                    ; \u2192 (lambda (x) (* x x)) (shortcut)\n\n; Store expressions in lists\n(let ((expressions (list (quote (+ 1 2)) \n                        (quote (* 3 4))\n                        (quote (- 10 5)))))\n  expressions)                        ; \u2192 ((+ 1 2) (* 3 4) (- 10 5))\n(let ((expressions (list '(+ 1 2) \n                        '(* 3 4)\n                        '(- 10 5))))\n  expressions)                        ; \u2192 ((+ 1 2) (* 3 4) (- 10 5)) (shortcuts)\n```\n\n#### Symbolic Programming with Quote\n```aifpl\n; Manipulate code structure\n(let ((expr (quote (+ a b c))))\n  (first expr))                       ; \u2192 + (the operator symbol)\n(let ((expr '(+ a b c)))\n  (first expr))                       ; \u2192 + (shortcut form)\n\n(let ((expr (quote (lambda (x y) (+ x y)))))\n  (let ((params (first (rest expr)))\n        (body (first (rest (rest expr)))))\n    (list \"params\" params \"body\" body)))  ; \u2192 (\"params\" (x y) \"body\" (+ x y))\n(let ((expr '(lambda (x y) (+ x y))))\n  (let ((params (first (rest expr)))\n        (body (first (rest (rest expr)))))\n    (list \"params\" params \"body\" body)))  ; \u2192 (\"params\" (x y) \"body\" (+ x y)) (shortcut)\n\n; Build expressions programmatically\n(let ((op (quote +))\n      (args (quote (1 2 3))))\n  (cons op args))                     ; \u2192 (+ 1 2 3)\n(let ((op '+)\n      (args '(1 2 3)))\n  (cons op args))                     ; \u2192 (+ 1 2 3) (shortcuts)\n```\n\n#### Quote vs. List Constructor\n```aifpl\n; Using list constructor - evaluates arguments\n(list + 1 2 3)                       ; \u2192 (<builtin +> 1 2 3)\n\n; Using quote - no evaluation\n(quote (+ 1 2 3))                     ; \u2192 (+ 1 2 3)\n'(+ 1 2 3)                            ; \u2192 (+ 1 2 3) (shortcut)\n\n; Mixed approach\n(list (quote +) 1 2 3)                ; \u2192 (+ 1 2 3)\n(list '+ 1 2 3)                       ; \u2192 (+ 1 2 3) (shortcut)\n```\n\n#### Data Processing with Quoted Expressions\n```aifpl\n; Process a list of expressions\n(let ((exprs (list (quote (+ 1 2))\n                  (quote (* 3 4))\n                  (quote (/ 8 2)))))\n  (map (lambda (expr) (first expr)) exprs))  ; \u2192 (+ * /)\n(let ((exprs (list '(+ 1 2)\n                  '(* 3 4)\n                  '(/ 8 2))))\n  (map (lambda (expr) (first expr)) exprs))  ; \u2192 (+ * /) (shortcuts)\n\n; Extract operators and operands\n(let ((analyze-expr (lambda (expr)\n                      (if (and (list? expr) (not (null? expr)))\n                          (list \"op\" (first expr) \"args\" (rest expr))\n                          \"not-a-compound-expr\"))))\n  (map analyze-expr (list (quote (+ 1 2))\n                         (quote x)\n                         (quote (* a b c)))))\n; \u2192 ((\"op\" + \"args\" (1 2)) \"not-a-compound-expr\" (\"op\" * \"args\" (a b c)))\n(let ((analyze-expr (lambda (expr)\n                      (if (and (list? expr) (not (null? expr)))\n                          (list \"op\" (first expr) \"args\" (rest expr))\n                          \"not-a-compound-expr\"))))\n  (map analyze-expr (list '(+ 1 2)\n                         'x\n                         '(* a b c))))\n; \u2192 ((\"op\" + \"args\" (1 2)) \"not-a-compound-expr\" (\"op\" * \"args\" (a b c))) (shortcuts)\n```\n\n#### Quote Enables Meta-Programming\n```aifpl\n; Create expressions that create expressions\n(let ((make-adder (lambda (n)\n                    (list (quote lambda) \n                         (quote (x)) \n                         (list (quote +) (quote x) n)))))\n  (make-adder 5))                     ; \u2192 (lambda (x) (+ x 5))\n(let ((make-adder (lambda (n)\n                    (list 'lambda \n                         '(x) \n                         (list '+ 'x n)))))\n  (make-adder 5))                     ; \u2192 (lambda (x) (+ x 5)) (shortcuts)\n\n; Template-based code generation\n(let ((make-predicate (lambda (op value)\n                        (list (quote lambda)\n                             (quote (x))\n                             (list op (quote x) value)))))\n  (list (make-predicate (quote >) 10)\n        (make-predicate (quote =) 0)))  ; \u2192 ((lambda (x) (> x 10)) (lambda (x) (= x 0)))\n(let ((make-predicate (lambda (op value)\n                        (list 'lambda\n                             '(x)\n                             (list op 'x value)))))\n  (list (make-predicate '> 10)\n        (make-predicate '= 0)))       ; \u2192 ((lambda (x) (> x 10)) (lambda (x) (= x 0))) (shortcuts)\n```\n\n#### Homoiconicity in Action\n```aifpl\n; Code and data have the same representation\n(let ((code (quote (+ (* 2 3) 4)))\n      (data (list (quote +) (list (quote *) 2 3) 4)))\n  (= code data))                      ; \u2192 #t (they're identical!)\n(let ((code '(+ (* 2 3) 4))\n      (data (list '+ (list '* 2 3) 4)))\n  (= code data))                      ; \u2192 #t (shortcuts make it cleaner!)\n\n; Manipulate code like any other data\n(let ((expr (quote (+ 1 2 3))))\n  (let ((reversed (reverse expr)))\n    reversed))                        ; \u2192 (3 2 1 +)\n(let ((expr '(+ 1 2 3)))\n  (let ((reversed (reverse expr)))\n    reversed))                        ; \u2192 (3 2 1 +) (shortcut)\n\n; Transform code structures\n(let ((transform-ops (lambda (expr)\n                       (if (list? expr)\n                           (map transform-ops expr)\n                           (if (= expr (quote +))\n                               (quote *)\n                               expr)))))\n  (transform-ops (quote (+ 1 (+ 2 3)))))  ; \u2192 (* 1 (* 2 3))\n(let ((transform-ops (lambda (expr)\n                       (if (list? expr)\n                           (map transform-ops expr)\n                           (if (= expr '+)\n                               '*\n                               expr)))))\n  (transform-ops '(+ 1 (+ 2 3))))     ; \u2192 (* 1 (* 2 3)) (shortcuts)\n```\n\n### Lambda Expressions and Anonymous Functions\n\nLambda expressions create anonymous functions with lexical scoping and closure support:\n\n#### Basic Lambda Syntax\n```aifpl\n(lambda (param1 param2 ...) body)\n```\n\n#### Simple Lambda Examples\n```aifpl\n; Square function\n((lambda (x) (* x x)) 5)                    ; \u2192 25\n\n; Add two numbers\n((lambda (x y) (+ x y)) 3 4)                ; \u2192 7\n\n; String manipulation\n((lambda (s) (string-upcase s)) \"hello\")     ; \u2192 \"HELLO\"\n\n; Conditional logic\n((lambda (x) (if (> x 0) \"positive\" \"non-positive\")) -3)  ; \u2192 \"non-positive\"\n```\n\n#### Lambda Functions as Values\n```aifpl\n; Lambda functions are first-class values\n(let ((square (lambda (x) (* x x))))\n  (square 6))                                ; \u2192 36\n\n; Functions in lists\n(let ((ops (list (lambda (x) (* x 2)) (lambda (x) (+ x 1)))))\n  ((first ops) 5))                          ; \u2192 10\n\n; Higher-order function usage\n(map (lambda (x) (* x x)) (list 1 2 3 4))   ; \u2192 (1 4 9 16)\n```\n\n#### Closures and Lexical Scoping\n```aifpl\n; Closures capture their environment\n(let ((multiplier 10))\n  (let ((times-ten (lambda (x) (* x multiplier))))\n    (times-ten 5)))                         ; \u2192 50\n\n; Nested closures\n(let ((outer-var 100))\n  (let ((make-adder (lambda (n) (lambda (x) (+ x n outer-var)))))\n    (let ((add-five (make-adder 5)))\n      (add-five 3))))                       ; \u2192 108\n\n; Function factories\n(let ((make-multiplier (lambda (factor) (lambda (x) (* x factor)))))\n  (let ((double (make-multiplier 2))\n        (triple (make-multiplier 3)))\n    (list (double 4) (triple 4))))          ; \u2192 (8 12)\n```\n\n#### Recursive Lambda Functions\n```aifpl\n; Factorial with tail recursion (automatically optimized)\n(let ((factorial (lambda (n acc)\n                   (if (<= n 1)\n                       acc\n                       (factorial (- n 1) (* n acc))))))\n  (factorial 5 1))                          ; \u2192 120\n\n; List sum with recursion\n(let ((sum-list (lambda (lst acc)\n                  (if (null? lst)\n                      acc\n                      (sum-list (rest lst) (+ acc (first lst)))))))\n  (sum-list (list 1 2 3 4 5) 0))           ; \u2192 15\n\n; Fibonacci with mutual recursion\n(let ((fib-helper (lambda (n a b)\n                    (if (<= n 0)\n                        a\n                        (fib-helper (- n 1) b (+ a b))))))\n  (let ((fibonacci (lambda (n) (fib-helper n 0 1))))\n    (fibonacci 10)))                        ; \u2192 55\n```\n\n### Local Variable Binding with Let\n\nLet expressions create local variable bindings with sequential evaluation and lexical scoping:\n\n#### Basic Let Syntax\n```aifpl\n(let ((var1 val1) (var2 val2) ...) body)\n```\n\n#### Simple Let Examples\n```aifpl\n; Basic binding\n(let ((x 5)) (+ x 10))                      ; \u2192 15\n\n; Multiple bindings\n(let ((x 3) (y 4)) (+ (* x x) (* y y)))     ; \u2192 25\n\n; String operations\n(let ((name \"Alice\") (age 30))\n  (string-append name \" is \" (number->string age)))  ; \u2192 \"Alice is 30\"\n```\n\n#### Sequential Binding\n```aifpl\n; Later variables can reference earlier ones\n(let ((x 5) (y (* x 2))) (+ x y))           ; \u2192 15\n\n; Building complex expressions\n(let ((base 10)\n      (squared (* base base))\n      (cubed (* squared base)))\n  (list base squared cubed))                ; \u2192 (10 100 1000)\n\n; String processing chain\n(let ((text \"Hello World\")\n      (lower (string-downcase text))\n      (words (string-split lower \" \")))\n  (string-join (reverse words) \"-\"))        ; \u2192 \"world-hello\"\n```\n\n#### Binding Functions\n```aifpl\n; Bind lambda functions to names\n(let ((double (lambda (x) (* x 2)))\n      (triple (lambda (x) (* x 3))))\n  (+ (double 4) (triple 5)))                ; \u2192 23\n\n; Compose functions\n(let ((add-one (lambda (x) (+ x 1)))\n      (square (lambda (x) (* x x)))\n      (compose (lambda (f g) (lambda (x) (f (g x))))))\n  (let ((square-then-add (compose add-one square)))\n    (square-then-add 4)))                   ; \u2192 17\n\n; Recursive function binding\n(let ((countdown (lambda (n)\n                   (if (<= n 0)\n                       (list)\n                       (cons n (countdown (- n 1)))))))\n  (countdown 5))                            ; \u2192 (5 4 3 2 1)\n```\n\n#### Nested Let Expressions\n```aifpl\n; Nested scoping\n(let ((x 10))\n  (let ((x 20) (y x))  ; inner x shadows outer, y gets outer x value\n    (+ x y)))                               ; \u2192 30\n\n; Complex nested computation\n(let ((data (list 1 2 3 4 5)))\n  (let ((squared (map (lambda (x) (* x x)) data))\n        (sum-fn (lambda (lst) (fold + 0 lst))))\n    (let ((total (sum-fn squared))\n          (average (/ total (length squared))))\n      (list \"sum\" total \"average\" average))))  ; \u2192 (\"sum\" 55 \"average\" 11)\n```\n\n### Pattern Matching\n\nPattern matching provides a powerful way to destructure and analyze data based on its shape and content. It offers a concise alternative to nested conditionals and enables elegant functional programming patterns.\n\n#### Basic Pattern Matching Syntax\n```aifpl\n(match expression\n  (pattern1 result1)\n  (pattern2 result2)\n  ...\n  (_ default-result))  ; wildcard pattern (optional)\n```\n\n#### Literal Pattern Matching\n```aifpl\n; Match exact values\n(match 42\n  (42 \"found the answer\")\n  (0 \"zero\")\n  (_ \"something else\"))                     ; \u2192 \"found the answer\"\n\n; String literal matching\n(match \"hello\"\n  (\"world\" \"greeting\")\n  (\"hello\" \"salutation\")\n  (_ \"unknown\"))                            ; \u2192 \"salutation\"\n\n; Boolean literal matching\n(match #t\n  (#t \"true value\")\n  (#f \"false value\"))                       ; \u2192 \"true value\"\n```\n\n#### Variable Pattern Matching\n```aifpl\n; Bind values to variables\n(match 42\n  (x (* x 2)))                              ; \u2192 84 (x is bound to 42)\n\n; Variable patterns always match\n(match \"hello\"\n  (greeting (string-upcase greeting)))      ; \u2192 \"HELLO\"\n\n; Multiple variable patterns (first match wins)\n(match 10\n  (x (+ x 1))\n  (y (* y 2)))                              ; \u2192 11 (first pattern matches)\n```\n\n#### Wildcard Pattern Matching\n```aifpl\n; Wildcard matches anything without binding\n(match 42\n  (_ \"matched something\"))                  ; \u2192 \"matched something\"\n\n; Common use as default case\n(match \"unknown\"\n  (\"hello\" \"greeting\")\n  (\"goodbye\" \"farewell\")\n  (_ \"unrecognized\"))                       ; \u2192 \"unrecognized\"\n\n; Wildcard with computation\n(match (+ 10 20)\n  (_ \"got a result\"))                       ; \u2192 \"got a result\"\n```\n\n#### Type Pattern Matching\n```aifpl\n; Match by type with binding\n(match 42\n  ((number? n) (+ n 10))\n  ((string? s) (string-length s))\n  (_ \"unknown type\"))                       ; \u2192 52\n\n; String type matching\n(match \"hello world\"\n  ((string? text) (string-upcase text))\n  (_ \"not a string\"))                       ; \u2192 \"HELLO WORLD\"\n\n; Boolean type matching\n(match #t\n  ((boolean? flag) (not flag))\n  (_ \"not boolean\"))                        ; \u2192 #f\n\n; List type matching\n(match (list 1 2 3)\n  ((list? items) (length items))\n  (_ \"not a list\"))                         ; \u2192 3\n\n; Function type matching\n(match (lambda (x) (* x 2))\n  ((function? f) \"it's a function\")\n  (_ \"not a function\"))                     ; \u2192 \"it's a function\"\n```\n\n#### List Structure Pattern Matching\n\n**Important:** In AIFPL, the `(head . tail)` pattern always binds `tail` to a list (possibly empty), never to an atom. This differs from Scheme/Lisp.\n\n```aifpl\n; Empty list matching\n(match (list)\n  (() \"empty list\")\n  (_ \"non-empty\"))                          ; \u2192 \"empty list\"\n\n; Fixed-length list matching\n(match (list 1 2 3)\n  ((a b c) (+ a b c))\n  (_ \"wrong length\"))                       ; \u2192 6\n\n; Head-tail decomposition - tail is ALWAYS a list\n(match (list 1 2 3 4)\n  ((head . tail) (list \"head\" head \"tail\" tail))\n  (() \"empty\"))                             ; \u2192 (\"head\" 1 \"tail\" (2 3 4))\n\n; Single element list - tail is empty list\n(match (list 42)\n  ((x . xs) (list x xs)))                   ; \u2192 (42 ())  - xs is (), not an atom\n\n; Two-element list\n(match (list \"hello\" \"world\")\n  ((first second) (string-append first \" \" second))\n  (_ \"not a pair\"))                         ; \u2192 \"hello world\"\n```\n\n**Note:** Unlike Scheme/Lisp where `(cdr '(1 . 2))` returns the atom `2`, AIFPL's `(head . tail)` pattern always binds `tail` to a list. Use fixed-length patterns like `(a b)` when you want direct access to individual elements.\n\n#### Nested Pattern Matching\n```aifpl\n; Nested list patterns\n(match (list (list 1 2) 3)\n  (((a b) c) (+ a b c))\n  (_ \"no match\"))                           ; \u2192 6\n\n; Deep nesting\n(match (list (list (list 1 2) 3) 4)\n  ((((x y) z) w) (+ x y z w))\n  (_ \"no match\"))                           ; \u2192 10\n\n; Mixed literal and variable patterns\n(match (list \"name\" \"Alice\")\n  ((\"name\" value) (string-append \"Hello, \" value))\n  ((\"age\" value) (string-append \"Age: \" (number->string value)))\n  (_ \"unknown field\"))                      ; \u2192 \"Hello, Alice\"\n\n; Nested type patterns\n(match (list (list 1 2 3))\n  (((list? numbers)) (fold + 0 numbers))\n  (_ \"not a list of numbers\"))              ; \u2192 6\n```\n\n#### Pattern Matching with Conditionals\n```aifpl\n; Combine patterns with guards (using nested match)\n(let ((classify-number (lambda (n)\n                         (match n\n                           ((number? x) \n                            (match #t\n                              ((if (> x 0)) \"positive\")\n                              ((if (< x 0)) \"negative\")\n                              (_ \"zero\")))\n                           (_ \"not a number\")))))\n  (list (classify-number 5)\n        (classify-number -3)\n        (classify-number 0)\n        (classify-number \"hello\")))          ; \u2192 (\"positive\" \"negative\" \"zero\" \"not a number\")\n```\n\n#### Complex Data Structure Matching\n```aifpl\n; Process structured data\n(let ((process-person (lambda (person)\n                        (match person\n                          ((\"person\" name age city)\n                           (string-append name \" (\" (number->string age) \") from \" city))\n                          ((\"person\" name age)\n                           (string-append name \" (\" (number->string age) \")\"))\n                          (_ \"invalid person data\")))))\n  (list (process-person (list \"person\" \"Alice\" 30 \"NYC\"))\n        (process-person (list \"person\" \"Bob\" 25))\n        (process-person (list \"invalid\" \"data\"))))\n; \u2192 (\"Alice (30) from NYC\" \"Bob (25)\" \"invalid person data\")\n\n; Tree-like structure processing\n(let ((evaluate-expr (lambda (expr)\n                       (match expr\n                         (((number? n)) n)\n                         ((\"+\" left right) (+ (evaluate-expr left) (evaluate-expr right)))\n                         ((\"*\" left right) (* (evaluate-expr left) (evaluate-expr right)))\n                         (_ \"invalid expression\")))))\n  (evaluate-expr (list \"+\" (list 10) (list \"*\" (list 5) (list 3)))))  ; \u2192 25\n```\n\n#### Pattern Matching vs. Conditional Chains\n```aifpl\n; Traditional nested conditionals\n(let ((process-traditional (lambda (data)\n                             (if (list? data)\n                                 (if (= (length data) 3)\n                                     (if (string? (first data))\n                                         (if (number? (first (rest data)))\n                                             (string-append (first data) \": \" \n                                                          (number->string (first (rest data))))\n                                             \"second not number\")\n                                         \"first not string\")\n                                     \"wrong length\")\n                                 \"not a list\"))))\n  (process-traditional (list \"score\" 95 \"points\")))  ; \u2192 \"score: 95\"\n\n; Equivalent pattern matching (much cleaner)\n(let ((process-pattern (lambda (data)\n                         (match data\n                           (((string? name) (number? value) extra) \n                            (string-append name \": \" (number->string value)))\n                           (_ \"invalid format\")))))\n  (process-pattern (list \"score\" 95 \"points\")))      ; \u2192 \"score: 95\"\n```\n\n#### Advanced Pattern Matching Examples\n```aifpl\n; List processing with patterns\n(let ((process-list (lambda (lst)\n                      (match lst\n                        (() \"empty\")\n                        ((x) (string-append \"single: \" (number->string x)))\n                        ((x y) (string-append \"pair: \" (number->string (+ x y))))\n                        ((head . tail) \n                         (string-append \"list of \" (number->string (+ 1 (length tail))) \" items\"))))))\n  (list (process-list (list))\n        (process-list (list 42))\n        (process-list (list 1 2))\n        (process-list (list 1 2 3 4 5))))\n; \u2192 (\"empty\" \"single: 42\" \"pair: 3\" \"list of 5 items\")\n\n; Configuration processing\n(let ((process-config (lambda (config)\n                        (match config\n                          ((\"database\" \"mysql\" host port)\n                           (string-append \"MySQL at \" host \":\" (number->string port)))\n                          ((\"database\" \"postgres\" host port db)\n                           (string-append \"PostgreSQL \" db \" at \" host \":\" (number->string port)))\n                          ((\"cache\" \"redis\" host)\n                           (string-append \"Redis cache at \" host))\n                          (_ \"unknown configuration\")))))\n  (list (process-config (list \"database\" \"mysql\" \"localhost\" 3306))\n        (process-config (list \"database\" \"postgres\" \"db.example.com\" 5432 \"myapp\"))\n        (process-config (list \"cache\" \"redis\" \"cache.example.com\"))\n        (process-config (list \"unknown\" \"config\"))))\n; \u2192 (\"MySQL at localhost:3306\" \"PostgreSQL myapp at db.example.com:5432\" \"Redis cache at cache.example.com\" \"unknown configuration\")\n\n; Recursive data structure processing\n(let ((json-to-string (lambda (json)\n                        (match json\n                          (((string? s)) (string-append \"\\\"\" s \"\\\"\"))\n                          (((number? n)) (number->string n))\n                          (((boolean? b)) (if b \"true\" \"false\"))\n                          ((\"object\" . pairs)\n                           (let ((pair-strings (map (lambda (pair)\n                                                     (match pair\n                                                       ((key value)\n                                                        (string-append \"\\\"\" key \"\\\": \" \n                                                                     (json-to-string value)))\n                                                       (_ \"invalid pair\")))\n                                                   pairs)))\n                             (string-append \"{\" (string-join pair-strings \", \") \"}\")))\n                          ((\"array\" . items)\n                           (string-append \"[\" \n                                        (string-join (map json-to-string items) \", \") \n                                        \"]\"))\n                          (_ \"invalid JSON\")))))\n  (json-to-string (list \"object\" \n                       (list \"name\" (list \"Alice\"))\n                       (list \"age\" (list 30))\n                       (list \"active\" (list #t)))))\n; \u2192 \"{\\\"name\\\": \\\"Alice\\\", \\\"age\\\": 30, \\\"active\\\": true}\"\n```\n\n#### Pattern Matching Best Practices\n```aifpl\n; Order patterns from specific to general\n(let ((classify (lambda (x)\n                  (match x\n                    (0 \"zero\")              ; Most specific first\n                    (1 \"one\")\n                    ((number? n) \"other number\")  ; More general\n                    (_ \"not a number\")))))          ; Most general last\n  (list (classify 0) (classify 1) (classify 42) (classify \"hello\")))\n; \u2192 (\"zero\" \"one\" \"other number\" \"not a number\")\n\n; Use meaningful variable names in patterns\n(let ((format-person (lambda (data)\n                       (match data\n                         ((name age city) ; Clear variable names\n                          (string-append name \" (\" (number->string age) \") lives in \" city))\n                         (_ \"invalid person\")))))\n  (format-person (list \"Alice\" 30 \"Boston\")))     ; \u2192 \"Alice (30) lives in Boston\"\n\n; Combine pattern matching with higher-order functions\n(let ((process-items (lambda (items)\n                       (map (lambda (item)\n                              (match item\n                                ((\"task\" name priority)\n                                 (string-append name \" [\" priority \"]\"))\n                                ((\"note\" content)\n                                 (string-append \"Note: \" content))\n                                (_ \"unknown item\")))\n                            items))))\n  (process-items (list (list \"task\" \"Buy groceries\" \"high\")\n                      (list \"note\" \"Remember to call mom\")\n                      (list \"invalid\" \"item\"))))\n; \u2192 (\"Buy groceries [high]\" \"Note: Remember to call mom\" \"unknown item\")\n```\n\n### Higher-Order Functions\n\nAIFPL provides powerful higher-order functions for functional programming patterns:\n\n#### Map - Transform Each Element\n```aifpl\n; Basic mapping\n(map (lambda (x) (* x 2)) (list 1 2 3 4))   ; \u2192 (2 4 6 8)\n\n; String transformations\n(map string-upcase (list \"hello\" \"world\"))  ; \u2192 (\"HELLO\" \"WORLD\")\n\n; Complex transformations\n(map (lambda (x) (+ (* x x) 1)) (list 1 2 3))  ; \u2192 (2 5 10)\n\n; Nested list processing\n(map (lambda (pair) (+ (first pair) (first (rest pair))))\n     (list (list 1 2) (list 3 4) (list 5 6)))  ; \u2192 (3 7 11)\n```\n\n#### Filter - Select Elements by Predicate\n```aifpl\n; Basic filtering\n(filter (lambda (x) (> x 0)) (list -1 2 -3 4))  ; \u2192 (2 4)\n\n; String filtering\n(filter (lambda (s) (> (string-length s) 3))\n        (list \"hi\" \"hello\" \"a\" \"world\"))    ; \u2192 (\"hello\" \"world\")\n\n; Complex predicates\n(filter (lambda (x) (= (% x 2) 0)) (range 1 11))  ; \u2192 (2 4 6 8 10)\n\n; Boolean combinations\n(filter (lambda (x) (and (> x 5) (< x 15)))\n        (range 1 20))                       ; \u2192 (6 7 8 9 10 11 12 13 14)\n```\n\n#### Fold - Accumulate Results\n```aifpl\n; Sum all elements\n(fold + 0 (list 1 2 3 4 5))                ; \u2192 15\n\n; Product of elements\n(fold * 1 (list 1 2 3 4))                  ; \u2192 24\n\n; String concatenation\n(fold string-append \"\" (list \"Hello\" \" \" \"World\"))  ; \u2192 \"Hello World\"\n\n; Build reverse list\n(fold (lambda (acc x) (cons x acc)) (list) (list 1 2 3))  ; \u2192 (3 2 1)\n\n; Find maximum\n(fold (lambda (acc x) (if (> x acc) x acc)) 0 (list 3 7 2 9 1))  ; \u2192 9\n\n; Complex accumulation\n(fold (lambda (acc x) (+ acc (* x x))) 0 (list 1 2 3 4))  ; \u2192 30\n```\n\n#### Range - Generate Numeric Sequences\n```aifpl\n; Basic ranges\n(range 1 5)                                 ; \u2192 (1 2 3 4)\n(range 0 10 2)                             ; \u2192 (0 2 4 6 8)\n(range 10 0 -1)                            ; \u2192 (10 9 8 7 6 5 4 3 2 1)\n\n; Use with other functions\n(map (lambda (x) (* x x)) (range 1 6))      ; \u2192 (1 4 9 16 25)\n(filter (lambda (x) (= (% x 3) 0)) (range 1 21))  ; \u2192 (3 6 9 12 15 18)\n\n; Generate data\n(map (lambda (i) (list \"item\" i)) (range 1 4))  ; \u2192 ((\"item\" 1) (\"item\" 2) (\"item\" 3))\n```\n\n#### Find - Locate First Matching Element\n```aifpl\n; Find first positive number\n(find (lambda (x) (> x 0)) (list -1 -2 3 4))  ; \u2192 3\n\n; Find first long string\n(find (lambda (s) (> (string-length s) 4))\n      (list \"hi\" \"hello\" \"a\"))              ; \u2192 \"hello\"\n\n; Returns #f if not found\n(find (lambda (x) (> x 10)) (list 1 2 3))  ; \u2192 #f\n\n; Complex search\n(find (lambda (pair) (= (first pair) \"name\"))\n      (list (list \"age\" 25) (list \"name\" \"John\")))  ; \u2192 (\"name\" \"John\")\n```\n\n#### Any? and All? - Boolean Predicates\n```aifpl\n; Check if any element matches\n(any? (lambda (x) (> x 5)) (list 1 3 7 2))  ; \u2192 #t\n(any? (lambda (x) (< x 0)) (list 1 2 3))   ; \u2192 #f\n\n; Check if all elements match\n(all? (lambda (x) (> x 0)) (list 1 2 3))   ; \u2192 #t\n(all? (lambda (x) (> x 5)) (list 1 3 7))   ; \u2192 #f\n\n; String validation\n(all? (lambda (s) (> (string-length s) 0))\n      (list \"hello\" \"world\" \"test\"))        ; \u2192 #t\n\n(any? (lambda (s) (string-contains? s \"@\"))\n      (list \"user@email.com\" \"plain-text\")) ; \u2192 #t\n```\n\n#### Take and Drop - List Slicing\n```aifpl\n; Take first n elements\n(take 3 (list 1 2 3 4 5))                  ; \u2192 (1 2 3)\n(take 2 (list \"a\" \"b\" \"c\" \"d\"))            ; \u2192 (\"a\" \"b\")\n\n; Drop first n elements\n(drop 2 (list 1 2 3 4 5))                  ; \u2192 (3 4 5)\n(drop 3 (list \"a\" \"b\" \"c\" \"d\"))            ; \u2192 (\"d\")\n\n; Safe operations (don't error on out-of-bounds)\n(take 10 (list 1 2 3))                     ; \u2192 (1 2 3)\n(drop 10 (list 1 2 3))                     ; \u2192 ()\n\n; Combine with other operations\n(take 3 (filter (lambda (x) (> x 0)) (list -1 2 -3 4 5 6)))  ; \u2192 (2 4 5)\n```\n\n### Functional Programming Patterns\n\n#### Data Transformation Pipelines\n```aifpl\n; Process CSV-like data\n(let ((data (list \"john,25\" \"alice,30\" \"bob,22\")))\n  (map (lambda (row)\n         (let ((parts (string-split row \",\")))\n           (list (first parts) (string->number (first (rest parts))))))\n       data))                               ; \u2192 ((\"john\" 25) (\"alice\" 30) (\"bob\" 22))\n\n; Multi-step data processing\n(let ((numbers (range 1 21)))\n  (let ((evens (filter (lambda (x) (= (% x 2) 0)) numbers))\n        (squares (map (lambda (x) (* x x)) evens))\n        (sum (fold + 0 squares)))\n    sum))                                   ; \u2192 1540\n\n; String processing pipeline\n(let ((text \"The Quick Brown Fox\"))\n  (let ((words (string-split (string-downcase text) \" \"))\n        (long-words (filter (lambda (w) (> (string-length w) 3)) words))\n        (capitalized (map string-upcase long-words)))\n    (string-join capitalized \"-\")))         ; \u2192 \"QUICK-BROWN\"\n```\n\n#### Function Composition\n```aifpl\n; Compose two functions\n(let ((compose (lambda (f g) (lambda (x) (f (g x))))))\n  (let ((add-one (lambda (x) (+ x 1)))\n        (double (lambda (x) (* x 2))))\n    (let ((double-then-add (compose add-one double)))\n      (double-then-add 5))))                ; \u2192 11\n\n; Chain multiple transformations\n(let ((pipe (lambda (value . functions)\n              (fold (lambda (acc f) (f acc)) value functions))))\n  (let ((add-ten (lambda (x) (+ x 10)))\n        (multiply-by-three (lambda (x) (* x 3)))\n        (subtract-five (lambda (x) (- x 5))))\n    (pipe 2 add-ten multiply-by-three subtract-five)))  ; \u2192 31\n```\n\n#### Recursive Data Processing\n```aifpl\n; Process nested lists recursively\n(let ((deep-sum (lambda (lst)\n                  (if (null? lst)\n                      0\n                      (let ((head (first lst))\n                            (tail (rest lst)))\n                        (+ (if (list? head)\n                               (deep-sum head)\n                               head)\n                           (deep-sum tail)))))))\n  (deep-sum (list 1 (list 2 3) 4)))        ; \u2192 10\n\n; Tree traversal patterns\n(let ((count-leaves (lambda (tree)\n                      (if (list? tree)\n                          (fold + 0 (map count-leaves tree))\n                          1))))\n  (count-leaves (list 1 (list 2 (list 3 4)) 5)))  ; \u2192 5\n```\n\n#### Validation and Error Handling\n```aifpl\n; Validate all items in a list\n(let ((validate-positive (lambda (nums)\n                          (if (all? (lambda (x) (> x 0)) nums)\n                              nums\n                              \"error: negative numbers found\"))))\n  (list (validate-positive (list 1 2 3))\n        (validate-positive (list 1 -2 3))))  ; \u2192 ((1 2 3) \"error: negative numbers found\")\n\n; Safe operations with defaults\n(let ((safe-divide (lambda (x y)\n                     (if (= y 0)\n                         \"undefined\"\n                         (/ x y)))))\n  (map (lambda (pair) (safe-divide (first pair) (first (rest pair))))\n       (list (list 10 2) (list 15 3) (list 8 0))))  ; \u2192 (5 5 \"undefined\")\n```\n\n### Conditional Operations\n\nAIFPL supports conditional evaluation with lazy evaluation of branches:\n\n```aifpl\n(if condition then-expr else-expr)\n```\n\n#### Basic Examples:\n```aifpl\n(if (> 5 3) \"greater\" \"less\")         ; \u2192 \"greater\"\n(if (= 1 2) (+ 1 1) (* 2 2))          ; \u2192 4\n(if #t \"true branch\" \"false branch\")  ; \u2192 \"true branch\"\n(if #f \"true branch\" \"false branch\")  ; \u2192 \"false branch\"\n```\n\n#### Lazy Evaluation (Key Feature):\n```aifpl\n(if #t 42 (/ 1 0))                    ; \u2192 42 (no division by zero error)\n(if #f (undefined-symbol) \"safe\")     ; \u2192 \"safe\" (no undefined symbol error)\n(if (> x 0) (/ 100 x) \"undefined\")    ; Safe division\n```\n\n#### Practical Examples:\n```aifpl\n; Safe list operations\n(if (null? my-list) \"empty\" (first my-list))\n\n; Data validation\n(if (string-contains? email \"@\") \"valid email\" \"invalid email\")\n\n; Conditional string building\n(if (> count 1)\n    (string-append (number->string count) \" items\")\n    \"1 item\")\n\n; List processing\n(if (member? \"target\" search-list)\n    (string-append \"Found at position \" (number->string (position \"target\" search-list)))\n    \"Not found\")\n```\n\n#### Nested Conditionals:\n```aifpl\n(if (> x 0)\n    (if (> x 10) \"big positive\" \"small positive\")\n    (if (< x -10) \"big negative\" \"small negative or zero\"))\n```\n\n#### Type Requirements:\n- Condition must be a boolean (`#t` or `#f`)\n- Both then-expr and else-expr are required\n- Only the chosen branch is evaluated (lazy evaluation)\n\n### Arithmetic\n- `(+ 1 2 3)` \u2192 `6`\n- `(- 10 3)` \u2192 `7`\n- `(* 2 3 4)` \u2192 `24`\n- `(/ 12 3)` \u2192 `4`\n- `(// 7 3)` \u2192 `2` (floor division)\n- `(% 7 3)` \u2192 `1` (modulo)\n- `(** 2 3)` \u2192 `8` (exponentiation)\n\n### Comparison Operations\n\n#### Equality and Inequality\n```aifpl\n; Equality - all values must be equal\n(= 1 1)                               ; \u2192 #t\n(= 1 2)                               ; \u2192 #f\n(= 1 1 1)                             ; \u2192 #t (all equal)\n(= 1 2 3)                             ; \u2192 #f (not all equal)\n\n; Inequality - any values not equal\n(!= 1 2)                              ; \u2192 #t (any inequality)\n(!= 1 1)                              ; \u2192 #f (all equal)\n(!= 1 2 3)                            ; \u2192 #t (not all equal)\n(!= 1 1 1)                            ; \u2192 #f (all equal)\n```\n\n#### Numeric Comparisons\n```aifpl\n; Comparison chains (all must satisfy the relationship)\n(< 1 2)                               ; \u2192 #t\n(< 1 2 3)                             ; \u2192 #t (1 < 2 < 3)\n(< 1 3 2)                             ; \u2192 #f (3 is not < 2)\n\n(> 3 2)                               ; \u2192 #t\n(> 3 2 1)                             ; \u2192 #t (3 > 2 > 1)\n\n(<= 1 1)                              ; \u2192 #t\n(<= 1 2 2)                            ; \u2192 #t (1 \u2264 2 \u2264 2)\n\n(>= 2 1)                              ; \u2192 #t\n(>= 3 2 2)                            ; \u2192 #t (3 \u2265 2 \u2265 2)\n```\n\n#### Mixed Type Equality\n```aifpl\n; Numeric types can be compared for equality\n(= 1 1.0)                             ; \u2192 #t (int/float equivalence)\n(= 2 (+ 1.0 1.0))                     ; \u2192 #t (numeric equivalence)\n\n; Different non-numeric types are never equal\n(= \"hello\" 5)                         ; \u2192 #f\n(= #t 1)                              ; \u2192 #f\n(= (list 1 2) \"12\")                   ; \u2192 #f\n\n; Lists are compared element by element\n(= (list 1 2) (list 1 2))             ; \u2192 #t\n(= (list 1 2) (list 1 3))             ; \u2192 #f\n```\n\n### Boolean Operations\n- `(and #t #f)` \u2192 `#f`\n- `(and #t #t)` \u2192 `#t`\n- `(or #t #f)` \u2192 `#t`\n- `(or #f #f)` \u2192 `#f`\n- `(not #t)` \u2192 `#f`\n- `(not #f)` \u2192 `#t`\n\n### Type Predicates\n\nAIFPL provides comprehensive type checking functions:\n\n#### Basic Type Predicates\n```aifpl\n; Number type checking (excludes booleans)\n(number? 42)                          ; \u2192 #t\n(number? 3.14)                        ; \u2192 #t\n(number? (+ 1 j))                     ; \u2192 #t (complex)\n(number? #t)                          ; \u2192 #f (booleans are not numbers)\n(number? \"42\")                        ; \u2192 #f\n\n; Specific numeric type checking\n(integer? 42)                         ; \u2192 #t\n(integer? 3.14)                       ; \u2192 #f\n(integer? #t)                         ; \u2192 #f (booleans excluded)\n\n(float? 3.14)                         ; \u2192 #t\n(float? 42)                           ; \u2192 #f\n(float? (/ 1 2))                      ; \u2192 #t (division produces float)\n\n(complex? (+ 1 j))                    ; \u2192 #t\n(complex? 42)                         ; \u2192 #f\n(complex? 3.14)                       ; \u2192 #f\n```\n\n#### Other Type Predicates\n```aifpl\n; String type checking\n(string? \"hello\")                     ; \u2192 #t\n(string? 42)                          ; \u2192 #f\n(string? (number->string 42))         ; \u2192 #t\n\n; Boolean type checking\n(boolean? #t)                         ; \u2192 #t\n(boolean? #f)                         ; \u2192 #t\n(boolean? 1)                          ; \u2192 #f\n(boolean? 0)                          ; \u2192 #f\n\n; Function type checking\n(function? (lambda (x) (* x 2)))      ; \u2192 #t\n(function? +)                         ; \u2192 #t\n(function? \"hello\")                   ; \u2192 #f\n\n; List type checking (already existed)\n(list? (list 1 2 3))                 ; \u2192 #t\n(list? \"hello\")                       ; \u2192 #f\n(list? ())                            ; \u2192 #t (empty list)\n```\n\n#### Type Predicate Usage Patterns\n```aifpl\n; Conditional type handling\n(let ((process-value (lambda (x)\n                       (if (number? x)\n                           (* x 2)\n                           (if (string? x)\n                               (string-upcase x)\n                               \"unknown type\")))))\n  (list (process-value 5)             ; \u2192 10\n        (process-value \"hello\")       ; \u2192 \"HELLO\"\n        (process-value #t)))          ; \u2192 \"unknown type\"\n\n; Type validation\n(let ((validate-numbers (lambda (lst)\n                          (if (all? number? lst)\n                              (fold + 0 lst)\n                              \"error: non-numeric values found\"))))\n  (list (validate-numbers (list 1 2 3))      ; \u2192 6\n        (validate-numbers (list 1 \"x\" 3))))  ; \u2192 \"error: non-numeric values found\"\n\n; Polymorphic operations\n(let ((safe-length (lambda (x)\n                     (if (string? x)\n                         (string-length x)\n                         (if (list? x)\n                             (length x)\n                             \"not a sequence\")))))\n  (list (safe-length \"hello\")         ; \u2192 5\n        (safe-length (list 1 2 3))    ; \u2192 3\n        (safe-length 42)))            ; \u2192 \"not a sequence\"\n```\n\n### Mathematical Functions\n- `(sin (* pi 0.5))` \u2192 `1`\n- `(cos 0)` \u2192 `1`\n- `(log e)` \u2192 `1`\n- `(sqrt 16)` \u2192 `4`\n- `(abs -5)` \u2192 `5`\n\n### Bitwise Operations\n- `(bit-or 5 3)` \u2192 `7`\n- `(bit-and 7 3)` \u2192 `3`\n- `(bit-xor 5 3)` \u2192 `6`\n- `(bit-not 5)` \u2192 `-6`\n\n### Base Conversion\n- `(hex 255)` \u2192 `\"0xff\"`\n- `(bin 10)` \u2192 `\"0b1010\"`\n- `(oct 8)` \u2192 `\"0o10\"`\n\n### Complex Numbers\n- `(complex 3 4)` \u2192 `(3+4j)`\n- `(+ 1 (* 2 j))` \u2192 `(1+2j)`\n- `(real (complex 3 4))` \u2192 `3` (extract real part)\n- `(imag (complex 3 4))` \u2192 `4` (extract imaginary part)\n- `(real 5)` \u2192 `5` (real part of real number)\n- `(imag 5)` \u2192 `0` (imaginary part of real number)\n\n### List Operations\n\n#### List Construction and Manipulation\n\n**Note:** AIFPL uses proper lists only. The `cons` function requires the second argument to be a list.\n\n```aifpl\n(list 1 2 3)                           ; \u2192 (1 2 3)\n(list \"a\" \"b\" \"c\")                     ; \u2192 (\"a\" \"b\" \"c\")\n(list 1 \"hello\" #t)                    ; \u2192 (1 \"hello\" #t) [mixed types]\n(list)                                 ; \u2192 () [empty list]\n(cons 1 (list 2 3))                    ; \u2192 (1 2 3) [prepend to list]\n(cons 1 (list))                        ; \u2192 (1) [prepend to empty list]\n(append (list 1 2) (list 3 4))         ; \u2192 (1 2 3 4) [concatenate]\n(reverse (list 1 2 3))                 ; \u2192 (3 2 1)\n```\n\n**Important:** Unlike Scheme/Lisp, `(cons 1 2)` is invalid in AIFPL. Use `(list 1 2)` to create pairs.\n\n#### List Access and Properties\n\n**Note:** The `rest` function always returns a list, never an atom.\n\n```aifpl\n(first (list 1 2 3))                  ; \u2192 1\n(rest (list 1 2 3))                   ; \u2192 (2 3) [always returns a list]\n(rest (list 1))                       ; \u2192 () [empty list, not an atom]\n(last (list 1 2 3))                   ; \u2192 3\n(list-ref (list \"a\" \"b\" \"c\") 1)       ; \u2192 \"b\" (0-indexed)\n(length (list 1 2 3))                 ; \u2192 3\n(null? (list))                        ; \u2192 #t\n(null? (list 1))                      ; \u2192 #f\n(list? (list 1 2))                    ; \u2192 #t\n(list? \"hello\")                       ; \u2192 #f\n(member? 2 (list 1 2 3))              ; \u2192 #t\n(member? 5 (list 1 2 3))              ; \u2192 #f\n```\n\n#### List Utilities\n```aifpl\n; Remove all occurrences of an element\n(remove 2 (list 1 2 3 2 4))           ; \u2192 (1 3 4)\n(remove \"x\" (list \"a\" \"x\" \"b\" \"x\"))   ; \u2192 (\"a\" \"b\")\n(remove 5 (list 1 2 3))               ; \u2192 (1 2 3) (no change if not found)\n\n; Find index of first occurrence\n(position 2 (list 1 2 3))             ; \u2192 1 (0-based index)\n(position \"b\" (list \"a\" \"b\" \"c\"))     ; \u2192 1\n(position 5 (list 1 2 3))             ; \u2192 #f (not found, consistent with find)\n(position 2 (list 1 2 3 2))           ; \u2192 1 (first occurrence)\n```\n\n#### List Utility Usage Patterns\n```aifpl\n; Clean and process data\n(let ((data (list 1 -2 3 -4 5))\n      (negatives (list -2 -4)))\n  (let ((cleaned (fold (lambda (acc neg) (remove neg acc)) data negatives))\n        (doubled (map (lambda (x) (* x 2)) cleaned)))\n    doubled))                          ; \u2192 (2 6 10)\n\n; Find and replace pattern\n(let ((find-and-process (lambda (item lst)\n                          (let ((pos (position item lst)))\n                            (if pos\n                                (string-append \"Found \" (number->string item) \n                                             \" at position \" (number->string pos))\n                                \"Not found\")))))\n  (list (find-and-process 3 (list 1 2 3 4))    ; \u2192 \"Found 3 at position 2\"\n        (find-and-process 5 (list 1 2 3 4))))  ; \u2192 \"Not found\"\n\n; List difference using remove\n(let ((list-difference (lambda (list1 list2)\n                         (fold remove list1 list2))))\n  (list-difference (list 1 2 3 4 5) (list 2 4)))  ; \u2192 (1 3 5)\n```\n\n#### List Equality\n```aifpl\n(= (list 1 2) (list 1 2))             ; \u2192 #t\n(= (list 1 2) (list 1 3))             ; \u2192 #f\n(= (list 1 2) (list 1 2 3))           ; \u2192 #f\n```\n\n### String Operations\n\n#### String Construction and Conversion\n```aifpl\n(string-append \"hello\" \" \" \"world\")   ; \u2192 \"hello world\"\n(number->string 42)                   ; \u2192 \"42\"\n(number->string 3.14)                 ; \u2192 \"3.14\"\n(string->number \"42\")                 ; \u2192 42\n(string->number \"3.14\")               ; \u2192 3.14\n```\n\n#### String Information and Access\n```aifpl\n(string-length \"hello\")               ; \u2192 5\n(string-ref \"hello\" 1)                ; \u2192 \"e\" (character at index 1)\n(substring \"hello\" 1 4)               ; \u2192 \"ell\" (start=1, end=4 exclusive)\n```\n\n#### String Manipulation\n```aifpl\n(string-upcase \"hello\")               ; \u2192 \"HELLO\"\n(string-downcase \"HELLO\")             ; \u2192 \"hello\"\n(string-trim \"  hello  \")             ; \u2192 \"hello\"\n(string-replace \"hello world\" \"world\" \"AIFPL\")  ; \u2192 \"hello AIFPL\"\n(string-replace \"banana\" \"a\" \"o\")     ; \u2192 \"bonono\" (non-overlapping)\n(string-replace \"test\" \"x\" \"y\")       ; \u2192 \"test\" (no change if not found)\n```\n\n#### String Manipulation Usage Patterns\n```aifpl\n; Clean and normalize text\n(let ((normalize-text (lambda (text)\n                        (let ((trimmed (string-trim text))\n                              (lower (string-downcase trimmed)))\n                          (string-replace lower \" \" \"-\")))))\n  (normalize-text \"  Hello World  \"))  ; \u2192 \"hello-world\"\n\n; Template replacement\n(let ((template \"Hello {name}, you have {count} messages\")\n      (replace-template (lambda (tmpl name count)\n                          (let ((with-name (string-replace tmpl \"{name}\" name)))\n                            (string-replace with-name \"{count}\" (number->string count))))))\n  (replace-template template \"Alice\" 5))  ; \u2192 \"Hello Alice, you have 5 messages\"\n\n; Multiple replacements\n(let ((clean-text (lambda (text)\n                     (let ((step1 (string-replace text \"bad\" \"good\"))\n                           (step2 (string-replace step1 \"ugly\" \"pretty\")))\n                       (string-replace step2 \"wrong\" \"right\")))))\n  (clean-text \"bad ugly wrong text\"))     ; \u2192 \"good pretty right text\"\n```\n\n#### String Predicates\n```aifpl\n(string-contains? \"hello world\" \"world\")  ; \u2192 #t\n(string-prefix? \"hello\" \"he\")             ; \u2192 #t\n(string-suffix? \"hello\" \"lo\")             ; \u2192 #t\n(string=? \"hello\" \"hello\")                ; \u2192 #t\n(string=? \"hello\" \"world\")                ; \u2192 #f\n```\n\n### String-List Integration\n\n#### String-List Conversion\n```aifpl\n(string->list \"hello\")                ; \u2192 (\"h\" \"e\" \"l\" \"l\" \"o\")\n(list->string (list \"h\" \"e\" \"l\" \"l\" \"o\"))  ; \u2192 \"hello\"\n```\n\n#### String Splitting and Joining\n```aifpl\n(string-split \"name,age,city\" \",\")    ; \u2192 (\"name\" \"age\" \"city\")\n(string-split \"hello world\" \" \")      ; \u2192 (\"hello\" \"world\")\n(string-join (list \"hello\" \"world\") \" \")  ; \u2192 \"hello world\"\n(string-join (list \"a\" \"b\" \"c\") \",\") ; \u2192 \"a,b,c\"\n```\n\n### String Literals and Escape Sequences\n\nString literals use double quotes and support escape sequences:\n\n```aifpl\n\"hello world\"                         ; Basic string\n\"She said \\\"Hello!\\\"\"                 ; Escaped quotes\n\"Line 1\\nLine 2\"                      ; Newline\n\"Column 1\\tColumn 2\"                  ; Tab\n\"Path\\\\to\\\\file\"                      ; Backslash\n\"Unicode: \\u03B1\\u03B2\\u03B3\"         ; Greek letters \u03b1\u03b2\u03b3\n```\n\n**Supported escape sequences:**\n- `\\\"` \u2192 literal quote\n- `\\\\` \u2192 literal backslash\n- `\\n` \u2192 newline\n- `\\t` \u2192 tab\n- `\\r` \u2192 carriage return\n- `\\uXXXX` \u2192 Unicode code point (4 hex digits)\n\n### Association Lists (Alists)\n\nAssociation lists (alists) are immutable key-value mappings with O(1) lookup performance. They are first-class data structures optimized for structured data processing.\n\n#### Creating Alists\n\n```aifpl\n; Basic alist creation\n(alist (\"name\" \"Alice\") (\"age\" 30) (\"city\" \"NYC\"))\n; \u2192 (alist (\"name\" \"Alice\") (\"age\" 30) (\"city\" \"NYC\"))\n\n; Empty alist\n(alist)\n; \u2192 (alist)\n\n; Alists with different key types\n(alist (1 \"one\") (2 \"two\") (3 \"three\"))\n(alist (#t \"yes\") (#f \"no\"))\n\n; Nested alists\n(alist \n  (\"user\" (alist (\"name\" \"Bob\") (\"id\" 123)))\n  (\"status\" \"active\"))\n```\n\n**Note**: `alist` is a special form that evaluates the key and value expressions within each pair, but treats the pair structure itself as data.\n\n#### Accessing Alist Values\n\n```aifpl\n; Get value by key\n(let ((person (alist (\"name\" \"Alice\") (\"age\" 30))))\n  (alist-get person \"name\"))\n; \u2192 \"Alice\"\n\n; Get with default value\n(alist-get person \"email\" \"no-email\")\n; \u2192 \"no-email\"\n\n; Missing keys return #f by default\n(alist-get person \"phone\")\n; \u2192 #f\n\n; Nested access\n(let ((data (alist (\"user\" (alist (\"name\" \"Carol\") (\"id\" 456))))))\n  (alist-get (alist-get data \"user\") \"name\"))\n; \u2192 \"Carol\"\n```\n\n#### Modifying Alists (Immutably)\n\nAll alist operations return new alists without modifying the original:\n\n```aifpl\n; Set a key (returns new alist)\n(let ((person (alist (\"name\" \"Alice\") (\"age\" 30))))\n  (alist-set person \"age\" 31))\n; \u2192 (alist (\"name\" \"Alice\") (\"age\" 31))\n\n; Add a new key\n(alist-set person \"email\" \"alice@example.com\")\n; \u2192 (alist (\"name\" \"Alice\") (\"age\" 30) (\"email\" \"alice@example.com\"))\n\n; Original is unchanged\n(let ((original (alist (\"x\" 1)))\n      (modified (alist-set original \"x\" 2)))\n  (list (alist-get original \"x\") (alist-get modified \"x\")))\n; \u2192 (1 2)\n\n; Remove a key\n(alist-remove person \"age\")\n; \u2192 (alist (\"name\" \"Alice\"))\n```\n\n#### Alist Queries\n\n```aifpl\n; Check if key exists\n(alist-has? person \"name\")\n; \u2192 #t\n\n(alist-has? person \"phone\")\n; \u2192 #f\n\n; Get all keys\n(alist-keys (alist (\"a\" 1) (\"b\" 2) (\"c\" 3)))\n; \u2192 (\"a\" \"b\" \"c\")\n\n; Get all values\n(alist-values (alist (\"a\" 1) (\"b\" 2) (\"c\" 3)))\n; \u2192 (1 2 3)\n\n; Type checking\n(alist? (alist (\"x\" 1)))\n; \u2192 #t\n\n(alist? (list 1 2 3))\n; \u2192 #f\n```\n\n#### Merging Alists\n\n```aifpl\n; Merge two alists (second wins on conflicts)\n(let ((defaults (alist (\"port\" 8080) (\"host\" \"localhost\")))\n      (config (alist (\"port\" 3000) (\"debug\" #t))))\n  (alist-merge defaults config))\n; \u2192 (alist (\"port\" 3000) (\"host\" \"localhost\") (\"debug\" #t))\n\n; Merge multiple alists\n(let ((a (alist (\"x\" 1)))\n      (b (alist (\"y\" 2)))\n      (c (alist (\"z\" 3))))\n  (alist-merge (alist-merge a b) c))\n; \u2192 (alist (\"x\" 1) (\"y\" 2) (\"z\" 3))\n```\n\n#### Alists with Functional Operations\n\n```aifpl\n; Map over keys\n(let ((data (alist (\"name\" \"alice\") (\"city\" \"nyc\"))))\n  (map string-upcase (alist-keys data)))\n; \u2192 (\"NAME\" \"CITY\")\n\n; Filter values\n(let ((scores (alist (\"alice\" 85) (\"bob\" 92) (\"carol\" 78))))\n  (filter (lambda (score) (> score 80)) (alist-values scores)))\n; \u2192 (85 92)\n\n; Fold over values\n(let ((prices (alist (\"apple\" 1.5) (\"banana\" 0.8) (\"orange\" 1.2))))\n  (fold + 0 (alist-values prices)))\n; \u2192 3.5\n\n; Process list of alists\n(let ((people (list \n                (alist (\"name\" \"Alice\") (\"age\" 30))\n                (alist (\"name\" \"Bob\") (\"age\" 25))\n                (alist (\"name\" \"Carol\") (\"age\" 35)))))\n  (map (lambda (p) (alist-get p \"name\")) people))\n; \u2192 (\"Alice\" \"Bob\" \"Carol\")\n```\n\n#### Pattern Matching with Alists\n\n```aifpl\n; Match alist type\n(match (alist (\"type\" \"user\") (\"name\" \"Alice\"))\n  ((alist? data) (alist-get data \"name\"))\n  (_ \"not-alist\"))\n; \u2192 \"Alice\"\n\n; Distinguish alist from list\n(let ((process (lambda (data)\n                 (match data\n                   ((alist? a) \"alist\")\n                   ((list? l) \"list\")\n                   (_ \"other\")))))\n  (list (process (alist (\"a\" 1)))\n        (process (list 1 2 3))))\n; \u2192 (\"alist\" \"list\")\n```\n\n#### Alist Performance\n\nAlists in AIFPL use hash-backed storage for O(1) lookup performance:\n\n- `alist-get`: O(1) - constant time lookup\n- `alist-set`: O(n) - creates new alist with updated value\n- `alist-has?`: O(1) - constant time membership test\n- `alist-keys`/`alist-values`: O(n) - iterates all pairs\n- `alist-merge`: O(n+m) - combines two alists\n\nAlists maintain insertion order and are optimized for read-heavy workloads common in data processing.\n\n### Complex Number Operations\nThe `real` and `imag` functions extract components from any numeric value:\n\n**Real Part Extraction:**\n```aifpl\n(real 42)              ; \u2192 42\n(real 3.14)            ; \u2192 3.14\n(real (complex 3 4))   ; \u2192 3\n(real j)               ; \u2192 0\n```\n\n**Imaginary Part Extraction:**\n```aifpl\n(imag 42)              ; \u2192 0\n(imag 3.14)            ; \u2192 0\n(imag (complex 3 4))   ; \u2192 4\n(imag j)               ; \u2192 1\n```\n\n**With Expressions:**\n```aifpl\n(real (+ (complex 1 2) (complex 3 4)))  ; \u2192 4\n(imag (sqrt -1))                        ; \u2192 1\n(real (* j j))                          ; \u2192 -1\n```\n\n## Type System\n\nAIFPL has a strict type system with the following types:\n\n- **Numbers**: `int`, `float`, `complex` (with automatic promotion)\n- **Strings**: UTF-8 strings with no automatic conversion\n- **Booleans**: `#t` and `#f` with no automatic conversion\n- **Lists**: Heterogeneous collections supporting any element type\n- **Functions**: First-class lambda functions with lexical scoping\n\n### Type Promotion Rules\n\n1. **Numeric promotion**: `int \u2192 float \u2192 complex`\n2. **No cross-type operations**: Strings, booleans, and lists don't mix with numbers\n3. **Explicit conversion**: Use conversion functions when needed\n4. **List heterogeneity**: Lists can contain mixed types\n5. **Function values**: Functions are first-class values that can be stored and passed\n\n### Examples of Type Strictness\n\n```aifpl\n; Valid - same types\n(+ 1 2 3)                             ; \u2192 6 (all integers)\n(string-append \"hello\" \" \" \"world\")   ; \u2192 \"hello world\" (all strings)\n(and #t #f #t)                        ; \u2192 #f (all booleans)\n\n; Valid - numeric promotion\n(+ 1 2.5)                             ; \u2192 3.5 (int promoted to float)\n(* 2 (complex 1 1))                   ; \u2192 (2+2j) (promoted to complex)\n\n; Valid - heterogeneous lists\n(list 1 \"hello\" #t)                   ; \u2192 (1 \"hello\" #t)\n(append (list 1 2) (list \"a\" \"b\"))    ; \u2192 (1 2 \"a\" \"b\")\n\n; Valid - list equality\n(= (list 1 2) (list 1 2))             ; \u2192 #t\n\n; Valid - conditionals with boolean conditions\n(if #t \"yes\" \"no\")                    ; \u2192 \"yes\"\n(if (> 5 3) 42 0)                     ; \u2192 42\n\n; Valid - functions as values\n(let ((f (lambda (x) (* x 2)))) (f 5))  ; \u2192 10\n(list (lambda (x) (+ x 1)) (lambda (x) (* x 2)))  ; \u2192 (<lambda (x)> <lambda (x)>)\n\n; Valid - type checking with predicates\n(if (number? x) (* x 2) \"not a number\")\n(filter string? (list 1 \"hello\" #t \"world\"))  ; \u2192 (\"hello\" \"world\")\n\n; Valid - quote for data literals (both forms)\n(quote (+ 1 2 3))                     ; \u2192 (+ 1 2 3) (as data, not evaluation)\n'(+ 1 2 3)                            ; \u2192 (+ 1 2 3) (shortcut form)\n(list (quote hello) (+ 1 2))          ; \u2192 (hello 3) (mixed quoted/unquoted)\n(list 'hello (+ 1 2))                 ; \u2192 (hello 3) (shortcut form)\n\n; Valid - pattern matching\n(match 42\n  ((number? n) (* n 2))\n  (_ \"not a number\"))                 ; \u2192 84\n\n; Invalid - type mismatch\n(+ 1 \"hello\")                         ; Error: cannot add number and string\n(and #t 1)                            ; Error: 'and' requires boolean arguments\n(string-length 42)                    ; Error: string-length requires string\n(+ (list 1 2))                        ; Error: cannot add list\n(< (list 1) (list 2))                 ; Error: cannot compare lists (only = works)\n(if 1 \"yes\" \"no\")                     ; Error: condition must be boolean\n\n; Valid - explicit conversion\n(string-append \"Count: \" (number->string 42))  ; \u2192 \"Count: 42\"\n(+ 5 (string->number \"10\"))                    ; \u2192 15\n(list->string (string->list \"hello\"))          ; \u2192 \"hello\"\n```\n\n### List Type Rules\n\n1. **Mixed types allowed**: `(list 1 \"hi\" #t)` is valid\n2. **No arithmetic operations**: `(+ (list 1 2))` is an error\n3. **Only equality comparison**: `(= (list 1) (list 1))` works, `(< (list 1) (list 2))` doesn't\n4. **Type-specific functions**: List functions require lists, string functions require strings\n5. **Explicit conversion**: Use `string->list`, `list->string` for conversions\n\n### Function Type Rules\n\n1. **First-class values**: Functions can be passed, returned, stored in lists\n2. **Lexical scoping**: Functions access variables from their definition environment\n3. **Closures**: Functions capture their environment when created\n4. **Arity checking**: Function calls must provide exact number of parameters\n5. **Identity equality**: Each lambda creates a unique function object\n\n## Pure List Representation Benefits\n\nThe pure list approach provides several advantages:\n\n1. **True homoiconicity**: Code and data have identical representation\n2. **Simpler architecture**: Only `AIFPLValue` types, no special AST nodes\n3. **Traditional Lisp semantics**: Everything is data, following Lisp philosophy\n4. **Easier to understand**: One consistent representation for all expressions\n5. **Future extensibility**: Natural foundation for features like macros\n6. **Reduced complexity**: Fewer types, simpler parser, more straightforward evaluator\n\n### Internal Representation Examples\n\n```aifpl\n; Lambda expression: (lambda (x) (* x x))\n; Represented as: AIFPLList([AIFPLSymbol(\"lambda\"), AIFPLList([AIFPLSymbol(\"x\")]), AIFPLList([...])])\n\n; Let expression: (let ((x 5)) (+ x 1))\n; Represented as: AIFPLList([AIFPLSymbol(\"let\"), AIFPLList([AIFPLList([...])]), ...])\n\n; Function call: (+ 1 2 3)\n; Represented as: AIFPLList([AIFPLSymbol(\"+\"), AIFPLNumber(1), AIFPLNumber(2), AIFPLNumber(3)])\n\n; Quote expression: (quote (+ 1 2))\n; Represented as: AIFPLList([AIFPLSymbol(\"quote\"), AIFPLList([AIFPLSymbol(\"+\"), AIFPLNumber(1), AIFPLNumber(2)])])\n\n; Single quote shortcut: '(+ 1 2)\n; Represented as: AIFPLList([AIFPLSymbol(\"quote\"), AIFPLList([AIFPLSymbol(\"+\"), AIFPLNumber(1), AIFPLNumber(2)])])\n; (Identical to the full quote form - the shortcut is purely syntactic sugar)\n\n; Match expression: (match x ((number? n) (* n 2)) (_ \"not a number\"))\n; Represented as: AIFPLList([AIFPLSymbol(\"match\"), AIFPLSymbol(\"x\"), AIFPLList([...]), ...])\n```\n\nThe evaluator recognizes special forms by examining the first element of lists, maintaining the traditional Lisp approach where syntax is determined by structure, not by special types.\n\n## Common Usage Patterns\n\n### Pattern Matching for Data Processing\n```aifpl\n; Replace complex nested conditionals with pattern matching\n(let ((process-data (lambda (item)\n                      (match item\n                        ((\"user\" name email) \n                         (string-append \"User: \" name \" (\" email \")\"))\n                        ((\"product\" id price)\n                         (string-append \"Product #\" (number->string id) \": $\" (number->string price)))\n                        ((\"order\" id items total)\n                         (string-append \"Order #\" (number->string id) \" (\" \n                                      (number->string (length items)) \" items): $\" \n                                      (number->string total)))\n                        (_ \"unknown data type\")))))\n  (map process-data (list (list \"user\" \"Alice\" \"alice@example.com\")\n                         (list \"product\" 123 29.99)\n                         (list \"order\" 456 (list \"item1\" \"item2\") 59.98)\n                         (list \"invalid\" \"data\"))))\n; \u2192 (\"User: Alice (alice@example.com)\" \"Product #123: $29.99\" \"Order #456 (2 items): $59.98\" \"unknown data type\")\n\n; Type-based processing with pattern matching\n(let ((safe-operation (lambda (x y)\n                        (match (list x y)\n                          (((number? a) (number? b)) (+ a b))\n                          (((string? a) (string? b)) (string-append a \" \" b))\n                          (((list? a) (list? b)) (append a b))\n                          (_ \"incompatible types\")))))\n  (list (safe-operation 5 10)\n        (safe-operation \"hello\" \"world\")\n        (safe-operation (list 1 2) (list 3 4))\n        (safe-operation 5 \"hello\")))\n; \u2192 (15 \"hello world\" (1 2 3 4) \"incompatible types\")\n\n; Configuration parsing with patterns\n(let ((parse-config (lambda (config-list)\n                      (map (lambda (item)\n                             (match item\n                               ((\"server\" host port)\n                                (list \"server-config\" host port))\n                               ((\"database\" type connection-string)\n                                (list \"db-config\" type connection-string))\n                               ((\"feature\" name enabled)\n                                (list \"feature-toggle\" name enabled))\n                               (_ (list \"unknown-config\" item))))\n                           config-list))))\n  (parse-config (list (list \"server\" \"localhost\" 8080)\n                     (list \"database\" \"postgresql\" \"postgres://localhost/mydb\")\n                     (list \"feature\" \"new-ui\" #t)\n                     (list \"invalid\" \"config\" \"entry\"))))\n; \u2192 ((\"server-config\" \"localhost\" 8080) (\"db-config\" \"postgresql\" \"postgres://localhost/mydb\") (\"feature-toggle\" \"new-ui\" #t) (\"unknown-config\" (\"invalid\" \"config\" \"entry\")))\n```\n\n### Symbolic Programming with Quote\n```aifpl\n; Store and manipulate code as data (using shortcuts for cleaner syntax)\n(let ((expressions (list '(+ 1 2)\n                        '(* 3 4)\n                        '(- 10 5))))\n  (map first expressions))                  ; \u2192 (+ * -) (extract operators)\n\n; Template-based programming (shortcuts make templates more readable)\n(let ((make-comparison (lambda (op value)\n                         (list 'lambda\n                              '(x)\n                              (list op 'x value)))))\n  (list (make-comparison '> 10)\n        (make-comparison '= 0)))            ; \u2192 ((lambda (x) (> x 10)) (lambda (x) (= x 0)))\n\n; Code transformation (shortcuts improve readability)\n(let ((negate-condition (lambda (expr)\n                          (if (and (list? expr) (= (first expr) '>))\n                              (cons '<= (rest expr))\n                              expr))))\n  (negate-condition '(> x 5)))              ; \u2192 (<= x 5)\n```\n\n### Functional Data Processing\n```aifpl\n; Process list of numbers\n(let ((numbers (list 1 2 3 4 5 6 7 8 9 10)))\n  (let ((evens (filter (lambda (x) (= (% x 2) 0)) numbers))\n        (doubled (map (lambda (x) (* x 2)) evens))\n        (sum (fold + 0 doubled)))\n    sum))                                   ; \u2192 60\n\n; Text processing pipeline\n(let ((text \"The quick brown fox jumps\"))\n  (let ((words (string-split text \" \"))\n        (long-words (filter (lambda (w) (> (string-length w) 3)) words))\n        (upper-words (map string-upcase long-words)))\n    (string-join upper-words \"-\")))         ; \u2192 \"QUICK-BROWN-JUMPS\"\n\n; Data validation and transformation\n(let ((validate-and-double (lambda (nums)\n                            (if (all? (lambda (x) (> x 0)) nums)\n                                (map (lambda (x) (* x 2)) nums)\n                                \"error: negative numbers\"))))\n  (list (validate-and-double (list 1 2 3))\n        (validate-and-double (list 1 -2 3))))  ; \u2192 ((2 4 6) \"error: negative numbers\")\n```\n\n### Conditional Processing\n```aifpl\n; Safe division\n(if (= divisor 0) \"undefined\" (/ dividend divisor))\n\n; Safe list access\n(if (null? my-list) \"empty\" (first my-list))\n\n; Data validation\n(if (string-contains? input \"@\")\n    (string-append \"Email: \" input)\n    \"Invalid email format\")\n\n; Conditional list processing\n(if (> (length items) 0)\n    (string-join items \", \")\n    \"No items\")\n\n; Nested conditionals for complex logic\n(if (> temperature 30)\n    \"hot\"\n    (if (> temperature 20) \"warm\" \"cold\"))\n```\n\n### Function Composition and Higher-Order Patterns\n```aifpl\n; Create reusable transformations\n(let ((process-data (lambda (data)\n                      (let ((clean (filter (lambda (x) (> x 0)) data))\n                            (transformed (map (lambda (x) (+ (* x x) 1)) clean))\n                            (limited (take 5 transformed)))\n                        limited))))\n  (process-data (list -1 2 3 -4 5 6 7 8)))  ; \u2192 (5 10 26 37 50)\n\n; Build complex predicates\n(let ((in-range (lambda (min max)\n                  (lambda (x) (and (>= x min) (<= x max)))))\n      (is-even (lambda (x) (= (% x 2) 0))))\n  (let ((even-in-range (lambda (x) (and (is-even x) ((in-range 10 50) x)))))\n    (filter even-in-range (range 1 60))))   ; \u2192 (10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50)\n\n; Recursive data structures\n(let ((tree-sum (lambda (tree)\n                  (if (list? tree)\n                      (fold + 0 (map tree-sum tree))\n                      tree))))\n  (tree-sum (list 1 (list 2 3) (list (list 4 5) 6))))  ; \u2192 21\n```\n\n### Type-Safe Programming Patterns\n```aifpl\n; Polymorphic function with type checking\n(let ((safe-process (lambda (value)\n                      (if (number? value)\n                          (* value value)\n                          (if (string? value)\n                              (string-upcase value)\n                              (if (list? value)\n                                  (length value)\n                                  \"unknown type\"))))))\n  (map safe-process (list 5 \"hello\" (list 1 2 3) #t)))  ; \u2192 (25 \"HELLO\" 3 \"unknown type\")\n\n; Type validation pipeline\n(let ((validate-input (lambda (data)\n                        (if (list? data)\n                            (if (all? number? data)\n                                (fold + 0 data)\n                                \"error: non-numeric data\")\n                            \"error: not a list\"))))\n  (list (validate-input (list 1 2 3))        ; \u2192 6\n        (validate-input (list 1 \"x\" 3))      ; \u2192 \"error: non-numeric data\"\n        (validate-input \"not a list\")))      ; \u2192 \"error: not a list\"\n\n; Mixed type list processing\n(let ((categorize (lambda (items)\n                    (let ((numbers (filter number? items))\n                          (strings (filter string? items))\n                          (booleans (filter boolean? items)))\n                      (list (list \"numbers\" numbers)\n                            (list \"strings\" strings)\n                            (list \"booleans\" booleans))))))\n  (categorize (list 1 \"hello\" #t 3.14 \"world\" #f)))\n; \u2192 ((\"numbers\" (1 3.14)) (\"strings\" (\"hello\" \"world\")) (\"booleans\" (#t #f)))\n```\n\n### String Processing\n```aifpl\n; Split CSV data and process\n(string-split \"name,age,city\" \",\")              ; \u2192 (\"name\" \"age\" \"city\")\n(first (string-split \"John,25,NYC\" \",\"))        ; \u2192 \"John\"\n(length (string-split \"a,b,c,d\" \",\"))           ; \u2192 4\n\n; Build strings from components\n(string-join (list \"hello\" \"world\") \" \")        ; \u2192 \"hello world\"\n(string-join (reverse (string-split \"a-b-c\" \"-\")) \"+\")  ; \u2192 \"c+b+a\"\n\n; Conditional string processing\n(if (> (string-length text) 10)\n    (string-append (substring text 0 10) \"...\")\n    text)\n\n; Advanced text processing\n(let ((clean-and-format (lambda (text)\n                          (let ((trimmed (string-trim text))\n                                (normalized (string-replace trimmed \"  \" \" \")))\n                            (string-upcase normalized)))))\n  (clean-and-format \"  hello    world  \"))      ; \u2192 \"HELLO  WORLD\"\n```\n\n### Character-Level Processing\n```aifpl\n; Convert to characters, process, convert back\n(string->list \"hello\")                          ; \u2192 (\"h\" \"e\" \"l\" \"l\" \"o\")\n(reverse (string->list \"hello\"))                ; \u2192 (\"o\" \"l\" \"l\" \"e\" \"h\")\n(list->string (reverse (string->list \"hello\"))) ; \u2192 \"olleh\"\n```\n\n### Data Structure Manipulation\n```aifpl\n; Build complex data structures\n(list (list \"name\" \"John\") (list \"age\" 25))     ; \u2192 ((\"name\" \"John\") (\"age\" 25))\n(first (list (list 1 2) (list 3 4)))            ; \u2192 (1 2)\n(rest (first (list (list 1 2 3) (list 4 5))))   ; \u2192 (2 3)\n\n; Conditional data processing\n(if (member? \"error\" status-list)\n    (list \"status\" \"error\" \"failed\")\n    (list \"status\" \"ok\" \"success\"))\n\n; Advanced list manipulation \n(let ((data (list 1 2 3 2 4 2 5))\n      (target 2))\n  (let ((cleaned (remove target data))\n        (position-info (position target data)))\n    (list \"original\" data \n          \"cleaned\" cleaned \n          \"first-position\" position-info)))\n; \u2192 (\"original\" (1 2 3 2 4 2 5) \"cleaned\" (1 3 4 5) \"first-position\" 1)\n```\n\n### Quote Shortcut Usage Patterns\n```aifpl\n; Building expressions with mixed quoted and evaluated parts\n(let ((make-setter (lambda (var value)\n                     (list 'let (list (list var value)) var))))\n  (make-setter 'x 42))                      ; \u2192 (let ((x 42)) x)\n\n; Code generation with templates\n(let ((make-validator (lambda (type-pred error-msg)\n                        '(lambda (value)\n                           (if (,type-pred value)\n                               value\n                               ,error-msg)))))\n  ; Note: This is conceptual - actual implementation would need more complex quasiquoting\n  (make-validator 'number? \"not a number\"))\n\n; Data-driven programming\n(let ((operations '((add +) (multiply *) (subtract -))))\n  (map (lambda (op) (first (rest op))) operations))  ; \u2192 (+ * -)\n\n; Pattern matching simulation\n(let ((match-expr (lambda (pattern expr)\n                    (if (= (first pattern) (first expr))\n                        'match\n                        'no-match))))\n  (list (match-expr '(+ ? ?) '(+ 1 2))     ; \u2192 match\n        (match-expr '(+ ? ?) '(* 1 2))))   ; \u2192 no-match\n```\n\n## Advanced Features\n\n### Tail Call Optimization\n\nAIFPL automatically optimizes tail calls to prevent stack overflow in recursive functions:\n\n```aifpl\n; Factorial with tail recursion (automatically optimized)\n(let ((factorial (lambda (n acc)\n                   (if (<= n 1)\n                       acc\n                       (factorial (- n 1) (* n acc))))))\n  (factorial 1000 1))                       ; Works with large numbers\n\n; Mutual recursion is also optimized\n(let ((is-even (lambda (n)\n                 (if (= n 0) #t (is-odd (- n 1)))))\n      (is-odd (lambda (n)\n                (if (= n 0) #f (is-even (- n 1))))))\n  (is-even 10000))                          ; \u2192 #t (no stack overflow)\n```\n\n### Lexical Scoping and Closures\n\nFunctions capture their lexical environment, creating closures:\n\n```aifpl\n; Function factory with captured state\n(let ((make-adder (lambda (increment)\n                    (lambda (x) (+ x increment)))))\n  (let ((add-five (make-adder 5))\n        (add-ten (make-adder 10)))\n    (list (add-five 3) (add-ten 3))))      ; \u2192 (8 13)\n\n; Nested closures capturing multiple levels\n(let ((outer-value 100))\n  (let ((make-calculator (lambda (operation)\n                           (lambda (x y)\n                             (operation (+ x outer-value) y)))))\n    (let ((multiply-with-offset (make-calculator *))\n          (add-with-offset (make-calculator +)))\n      (list (multiply-with-offset 2 3)     ; \u2192 (102 * 3) = 306\n            (add-with-offset 5 10)))))     ; \u2192 (105 + 10) = 115\n```\n\n### Error Handling Patterns\n\n```aifpl\n; Validation chains\n(let ((validate-number (lambda (x)\n                         (if (> x 0) x \"error: not positive\")))\n      (validate-range (lambda (x)\n                        (if (and (>= x 1) (<= x 100)) x \"error: out of range\"))))\n  (let ((process (lambda (x)\n                   (let ((step1 (validate-number x)))\n                     (if (string? step1)\n                         step1\n                         (validate-range step1))))))\n    (list (process 50) (process -5) (process 150))))  ; \u2192 (50 \"error: not positive\" \"error: out of range\")\n\n; Safe operations with defaults\n(let ((safe-head (lambda (lst default)\n                   (if (null? lst) default (first lst))))\n      (safe-tail (lambda (lst default)\n                   (if (null? lst) default (last lst))))\n      (safe-divide (lambda (x y default)\n                     (if (= y 0) default (/ x y)))))\n  (list (safe-head (list) \"empty\")\n        (safe-tail (list 1 2 3) \"empty\")\n        (safe-divide 10 0 \"undefined\")))    ; \u2192 (\"empty\" 3 \"undefined\")\n```\n\n## Differences from Traditional Lisp/Scheme\n\n**AIFPL uses proper lists only, not cons cells.** This is a fundamental difference from traditional Lisp/Scheme that affects list construction and pattern matching.\n\n### Key Differences\n\n#### 1. Cons Requires a List as Second Argument\n\n**Traditional Lisp/Scheme:**\n```scheme\n(cons 1 2)              ; => (1 . 2)  - creates a dotted pair\n(cons 1 (cons 2 3))     ; => (1 2 . 3) - creates an improper list\n```\n\n**AIFPL:**\n```aifpl\n(cons 1 (list 2 3))     ; => (1 2 3)  \u2713 Valid - second arg is a list\n(cons 1 (list 2))       ; => (1 2)    \u2713 Valid\n(cons 1 2)              ; => ERROR    \u2717 Invalid - second arg must be a list!\n```\n\n**Why?** AIFPL lists are backed by Python tuples. All lists are proper lists - there are no dotted pairs or improper lists. This makes the language simpler and more predictable.\n\n**To create pairs:** Use `(list a b)` instead of cons cells.\n\n#### 2. Rest Always Returns a List\n\n**Traditional Lisp/Scheme:**\n```scheme\n(cdr '(1))        ; => ()  - empty list\n(cdr '(1 . 2))    ; => 2   - can return an atom!\n```\n\n**AIFPL:**\n```aifpl\n(rest (list 1))         ; => ()     - always returns a list\n(rest (list 1 2))       ; => (2)    - always returns a list\n; No way to get an atom from rest\n```\n\n**Why?** This guarantees type safety. You always know `rest` returns a list, never an atom.\n\n#### 3. Pattern Matching: Tail is Always a List\n\n**Traditional Lisp/Scheme:**\n```scheme\n(match '(1 . 2) ((h . t) t))    ; => 2   - t binds to atom\n(match '(1 2) ((h . t) t))      ; => (2) - t binds to list\n```\n\n**AIFPL:**\n```aifpl\n(match (list 1 2) ((h . t) t))      ; => (2)  - t is always a list\n(match (list 1) ((h . t) t))        ; => ()   - t is empty list, not atom\n```\n\n**Why?** Consistency. The `(head . tail)` pattern always binds `tail` to a list (possibly empty), never to an atom.\n\n#### 4. No car/cdr - Use first/rest\n\nAIFPL uses more descriptive names:\n- `first` instead of `car`\n- `rest` instead of `cdr`\n- `last` for the last element\n\nThese names are clearer and emphasize that `rest` always returns a list.\n\n### Other Differences from Scheme/Lisp\n\n- **No mutation**: No `set!`, `set-car!`, `set-cdr!` - all data is immutable\n- **No macros**: No `define-syntax` or `defmacro` - all special forms are built-in\n- **No global definitions**: No top-level `define` - use `let` for bindings\n- **Strict type system**: Boolean operations require booleans, no \"truthy\" values\n- **No continuations**: No `call/cc` - simpler execution model\n\n### Migration Guide\n\nIf you're coming from Scheme/Lisp:\n\n**Creating pairs:**\n```aifpl\n; Instead of: (cons 1 2)\n(list 1 2)              ; Two-element list\n```\n\n**Association lists:**\n```aifpl\n; Instead of: '((a . 1) (b . 2))\n(list (list \"a\" 1) (list \"b\" 2))    ; List of two-element lists\n```\n\n**Pattern matching:**\n```aifpl\n; Pattern (h . t) always binds t to a list\n(match (list 1 2 3)\n  ((h . t) (list h t)))             ; => (1 (2 3))  - t is (2 3), not 2 3\n\n; For fixed-length patterns, use explicit elements\n(match (list 1 2)\n  ((a b) (list a b)))               ; => (1 2)  - direct binding\n```\n\n### Why These Differences?\n\n1. **Simplicity**: Proper lists only means fewer edge cases\n2. **Type safety**: `rest` always returns a list - no runtime type checking needed\n3. **Predictability**: Consistent behavior makes code easier to reason about\n4. **AI-friendly**: Fewer special cases for AI models to learn\n\n## Design Principles\n\n1. **Pure List Representation**: Everything is data, following traditional Lisp philosophy\n2. **Functional Programming**: First-class functions, immutable data, no side effects\n3. **Lexical Scoping**: Variables resolved in their definition environment\n4. **Tail Call Optimization**: Automatic optimization for recursive patterns\n5. **Type Safety**: Comprehensive type hints and strict type checking\n6. **Error Handling**: Detailed error messages with position information\n7. **Performance**: Efficient evaluation with automatic optimizations\n8. **LISP Compatibility**: Following traditional LISP semantics where applicable\n9. **Lazy Evaluation**: Conditionals and boolean operators use lazy evaluation\n10. **Independence**: No dependencies on external packages\n11. **Simplicity**: Direct S-expression evaluation without over-engineering\n12. **Homoiconicity**: Code and data use identical representations\n13. **Syntactic Sugar**: Single quote shortcut provides convenient syntax while maintaining pure list representation\n14. **Pattern Matching**: Comprehensive pattern matching for elegant data processing\n15. **Proper Lists Only**: Lists are backed by Python tuples, no cons cells or improper lists for simplicity and type safety\n\n## Architecture\n\nAIFPL uses a **pure list representation** for all code, following traditional Lisp philosophy:\n\n- **Everything is data**: Code and data have identical representation (`AIFPLValue` objects)\n- **No special AST nodes**: Lambda expressions, let expressions, and function calls are all just lists\n- **Homoiconic**: The same data structures represent both code and data\n- **Simple and consistent**: One unified representation for all expressions\n\n### Package Structure\n\n```plaintext\nsrc/aifpl/\n\u251c\u2500\u2500 __init__.py              # Package exports\n\u251c\u2500\u2500 aifpl.py                 # Main AIFPL class (public API)\n\u251c\u2500\u2500 aifpl_error.py           # Exception classes\n\u251c\u2500\u2500 aifpl_token.py           # Token types and definitions\n\u251c\u2500\u2500 aifpl_tokenizer.py       # Tokenizer implementation\n\u251c\u2500\u2500 aifpl_parser.py          # Parser (creates AIFPLValue objects)\n\u251c\u2500\u2500 aifpl_evaluator.py       # Expression evaluator\n\u251c\u2500\u2500 aifpl_environment.py     # Environment and function management\n\u251c\u2500\u2500 aifpl_value.py           # Value hierarchy (AIFPLValue types)\n\u2514\u2500\u2500 aifpl_dependency_analyzer.py  # Let binding dependency analysis\n```\n\n### Core Types\n\n- **AIFPLValue**: Base class for all values (numbers, strings, booleans, symbols, lists, functions)\n\n### Exception Hierarchy\n\n- `AIFPLError` - Base exception\n  - `AIFPLTokenError` - Tokenization errors\n  - `AIFPLParseError` - Parsing errors\n  - `AIFPLEvalError` - Evaluation errors\n\n## Advanced Usage\n\n### Custom Configuration\n\n```python\n# Increase recursion depth for deeply nested expressions\ntool = AIFPL(max_depth=500)\n\n# Adjust tolerance for complex number simplification\ntool = AIFPL(floating_point_tolerance=1e-15)\n```\n\n### Working with Results\n\n```python\n# Raw evaluation returns Python objects\nresult = tool.evaluate('(list 1 2 3)')\nprint(f\"Result: {result}\")  # Result: [1, 2, 3]\nprint(f\"Type: {type(result)}\")  # Type: <class 'list'>\n\n# Formatted evaluation returns LISP-style strings\nformatted = tool.evaluate_and_format('(list 1 2 3)')\nprint(f\"Formatted: {formatted}\")  # Formatted: (1 2 3)\n\n# Function results\nfunc_result = tool.evaluate('(lambda (x) (* x x))')\nprint(f\"Function: {func_result}\")  # Function: <aifpl.aifpl_environment.AIFPLLambdaFunction object>\n\nformatted_func = tool.evaluate_and_format('(lambda (x) (* x x))')\nprint(f\"Formatted Function: {formatted_func}\")  # Formatted Function: <lambda (x)>\n\n# Boolean results\nbool_result = tool.evaluate('(member? 2 (list 1 2 3))')\nprint(f\"Boolean: {bool_result}\")  # Boolean: True\n\nformatted_bool = tool.evaluate_and_format('(member? 2 (list 1 2 3))')\nprint(f\"Formatted Boolean: {formatted_bool}\")  # Formatted Boolean: #t\n\ninequality_result = tool.evaluate('(!= 1 2 3)')\nprint(f\"Inequality: {inequality_result}\")  # Inequality: True\n\ntype_check = tool.evaluate('(number? 42)')\nprint(f\"Type check: {type_check}\")  # Type check: True\n\nposition_result = tool.evaluate('(position \"world\" (list \"hello\" \"world\"))')\nprint(f\"Position: {position_result}\")  # Position: 1\n\n# Quote results (both forms produce identical results)\nquote_result = tool.evaluate('(quote (+ 1 2 3))')\nprint(f\"Quote result: {quote_result}\")  # Quote result: ['+', 1, 2, 3]\n\nshortcut_result = tool.evaluate(\"'(+ 1 2 3)\")\nprint(f\"Shortcut result: {shortcut_result}\")  # Shortcut result: ['+', 1, 2, 3]\n\nformatted_quote = tool.evaluate_and_format('(quote (+ 1 2 3))')\nprint(f\"Formatted quote: {formatted_quote}\")  # Formatted quote: (+ 1 2 3)\n\nformatted_shortcut = tool.evaluate_and_format(\"'(+ 1 2 3)\")\nprint(f\"Formatted shortcut: {formatted_shortcut}\")  # Formatted shortcut: (+ 1 2 3)\n\n# Pattern matching results\npattern_result = tool.evaluate('(match 42 ((number? n) (* n 2)) (_ \"not a number\"))')\nprint(f\"Pattern match: {pattern_result}\")  # Pattern match: 84\n\ncomplex_pattern = tool.evaluate('(match (list 1 2 3) ((a b c) (+ a b c)) (_ \"no match\"))')\nprint(f\"Complex pattern: {complex_pattern}\")  # Complex pattern: 6\n```\n\n### Error Handling Patterns\n\n```python\nfrom aifpl import AIFPL, AIFPLTokenError, AIFPLParseError, AIFPLEvalError\n\ntool = AIFPL()\n\ntry:\n    result = tool.evaluate(expression)\n\nexcept AIFPLTokenError as e:\n    print(f\"Tokenization error: {e}\")\n\nexcept AIFPLParseError as e:\n    print(f\"Parsing error: {e}\")\n\nexcept AIFPLEvalError as e:\n    print(f\"Evaluation error: {e}\")\n\nexcept AIFPLError as e:\n    print(f\"General AIFPL error: {e}\")\n```\n\n### Complex Functional Processing\n\n```python\n# Complex nested operations with functional programming\nfunctional_expr = '''\n(let ((data (list 1 2 3 4 5 6 7 8 9 10)))\n  (let ((process (lambda (nums)\n                   (let ((evens (filter (lambda (x) (= (% x 2) 0)) nums))\n                         (squares (map (lambda (x) (* x x)) evens))\n                         (sum (fold + 0 squares)))\n                     sum))))\n    (process data)))\n'''\n\n# Higher-order function composition\ncomposition_expr = '''\n(let ((compose (lambda (f g) (lambda (x) (f (g x)))))\n      (add-one (lambda (x) (+ x 1)))\n      (double (lambda (x) (* x 2))))\n  (let ((transform (compose add-one double)))\n    (map transform (list 1 2 3 4 5))))\n'''\n\n# Recursive data processing with tail optimization\nrecursive_expr = '''\n(let ((factorial (lambda (n acc)\n                   (if (<= n 1)\n                       acc\n                       (factorial (- n 1) (* n acc))))))\n  (factorial 20 1))\n'''\n\n# Quote-based symbolic programming (using shortcuts for cleaner syntax)\nsymbolic_expr = '''\n(let ((expressions (list '(+ 1 2)\n                        '(* 3 4)\n                        '(- 10 5))))\n  (let ((operators (map first expressions))\n        (operands (map rest expressions)))\n    (list \"operators\" operators \"operands\" operands)))\n'''\n\n# Pattern matching for data processing\npattern_matching_expr = '''\n(let ((process-items (lambda (items)\n                       (map (lambda (item)\n                              (match item\n                                ((\"person\" name age) \n                                 (string-append name \" (\" (number->string age) \")\"))\n                                ((\"product\" id price)\n                                 (string-append \"Product \" (number->string id) \": $\" (number->string price)))\n                                (_ \"unknown item\")))\n                            items))))\n  (process-items (list (list \"person\" \"Alice\" 30)\n                      (list \"product\" 123 29.99)\n                      (list \"invalid\" \"data\"))))\n'''\n\nadvanced_processing = '''\n(let ((data (list \"  hello  \" \"WORLD\" \"test\" \"  EXAMPLE  \"))\n      (clean-normalize (lambda (text)\n                         (string-downcase (string-trim text)))))\n  (let ((cleaned (map clean-normalize data))\n        (filtered (remove \"test\" cleaned))\n        (positions (map (lambda (item) \n                          (position item cleaned)) \n                       filtered)))\n    (list \"cleaned\" cleaned \"filtered\" filtered \"positions\" positions)))\n'''\n```\n",
          "error": null
        }
      ]
    },
    {
      "id": "8e94ecd9-a2e6-469d-a2cc-a67f4577d4fa",
      "timestamp": "2026-01-11T15:17:23.071933+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "423d141f-5cd5-4b4b-877a-9cc79d07fc38",
      "timestamp": "2026-01-11T15:17:23.082089+00:00",
      "type": "ai_response",
      "content": "Now let me compare this README with my tool description to identify what needs to be updated. Let me analyze the differences:",
      "completed": true,
      "usage": {
        "prompt_tokens": 36473,
        "completion_tokens": 260,
        "total_tokens": 36733
      },
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_01KDp1kDpBSX4rTBomVWdEch",
          "name": "AIFPL",
          "arguments": {
            "operation": "evaluate",
            "expression": "(let ((readme-features (list \"quote\" \"lambda\" \"let\" \"pattern-matching\" \"alists\" \"type-predicates\" \"higher-order\" \"string-ops\" \"list-ops\" \"complex-numbers\" \"real-imag-functions\"))\n      (tool-features (list \"quote\" \"lambda\" \"let\" \"pattern-matching\" \"alists\" \"type-predicates\" \"higher-order\" \"string-ops\" \"list-ops\" \"complex-numbers\" \"real-imag-functions\" \"comments\"))\n      (missing-in-readme (filter (lambda (f) (not (member? f readme-features))) tool-features)))\n  (list \"missing\" missing-in-readme))"
          }
        }
      ]
    },
    {
      "id": "a7ea11c1-c496-4575-9f07-c8aa825e070a",
      "timestamp": "2026-01-11T15:17:27.321768+00:00",
      "type": "tool_call",
      "content": "```json\n{\n  \"id\": \"toolu_01KDp1kDpBSX4rTBomVWdEch\",\n  \"name\": \"AIFPL\",\n  \"arguments\": {\n    \"operation\": \"evaluate\",\n    \"expression\": \"(let ((readme-features (list \\\"quote\\\" \\\"lambda\\\" \\\"let\\\" \\\"pattern-matching\\\" \\\"alists\\\" \\\"type-predicates\\\" \\\"higher-order\\\" \\\"string-ops\\\" \\\"list-ops\\\" \\\"complex-numbers\\\" \\\"real-imag-functions\\\"))\\n      (tool-features (list \\\"quote\\\" \\\"lambda\\\" \\\"let\\\" \\\"pattern-matching\\\" \\\"alists\\\" \\\"type-predicates\\\" \\\"higher-order\\\" \\\"string-ops\\\" \\\"list-ops\\\" \\\"complex-numbers\\\" \\\"real-imag-functions\\\" \\\"comments\\\"))\\n      (missing-in-readme (filter (lambda (f) (not (member? f readme-features))) tool-features)))\\n  (list \\\"missing\\\" missing-in-readme))\"\n  }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_01KDp1kDpBSX4rTBomVWdEch",
          "name": "AIFPL",
          "arguments": {
            "operation": "evaluate",
            "expression": "(let ((readme-features (list \"quote\" \"lambda\" \"let\" \"pattern-matching\" \"alists\" \"type-predicates\" \"higher-order\" \"string-ops\" \"list-ops\" \"complex-numbers\" \"real-imag-functions\"))\n      (tool-features (list \"quote\" \"lambda\" \"let\" \"pattern-matching\" \"alists\" \"type-predicates\" \"higher-order\" \"string-ops\" \"list-ops\" \"complex-numbers\" \"real-imag-functions\" \"comments\"))\n      (missing-in-readme (filter (lambda (f) (not (member? f readme-features))) tool-features)))\n  (list \"missing\" missing-in-readme))"
          }
        }
      ],
      "tool_call_context": "`expression` is:\n```aifpl\n(let ((readme-features (list \"quote\" \"lambda\" \"let\" \"pattern-matching\" \"alists\" \"type-predicates\" \"higher-order\" \"string-ops\" \"list-ops\" \"complex-numbers\" \"real-imag-functions\"))\n      (tool-features (list \"quote\" \"lambda\" \"let\" \"pattern-matching\" \"alists\" \"type-predicates\" \"higher-order\" \"string-ops\" \"list-ops\" \"complex-numbers\" \"real-imag-functions\" \"comments\"))\n      (missing-in-readme (filter (lambda (f) (not (member? f readme-features))) tool-features)))\n  (list \"missing\" missing-in-readme))\n```"
    },
    {
      "id": "e54dd88e-dd35-40b3-8e4c-eb06ed1c9c97",
      "timestamp": "2026-01-11T15:17:27.335940+00:00",
      "type": "tool_result",
      "content": "```json\n{\n  \"id\": \"toolu_01KDp1kDpBSX4rTBomVWdEch\",\n  \"name\": \"AIFPL\",\n  \"content\": \"(\\\"missing\\\" (\\\"comments\\\"))\",\n  \"error\": null\n}\n```\n`content` is:\n```aifpl\n(\"missing\" (\"comments\"))\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01KDp1kDpBSX4rTBomVWdEch",
          "name": "AIFPL",
          "content": "(\"missing\" (\"comments\"))",
          "error": null
        }
      ]
    },
    {
      "id": "f2845bc7-dadf-4d22-a735-ebe10810174a",
      "timestamp": "2026-01-11T15:17:27.339087+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01KDp1kDpBSX4rTBomVWdEch",
          "name": "AIFPL",
          "content": "(\"missing\" (\"comments\"))",
          "error": null
        }
      ]
    },
    {
      "id": "738708db-df0c-4926-8ed5-be65d6bc53d3",
      "timestamp": "2026-01-11T15:17:29.400793+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "2d4a19d2-8a97-4a63-aaab-e8f642d56aca",
      "timestamp": "2026-01-11T15:17:29.419780+00:00",
      "type": "ai_response",
      "content": "Based on my comparison of the README with my tool description, here are the suggested changes to update the README:\n\n## Suggested Changes to README.md\n\n### 1. **Add Comments Section** (MISSING)\nThe tool description mentions that comments use semicolon (`;`) for single-line comments, but the README only briefly mentions it in the features list. Add a dedicated section:\n\n```markdown\n### Comments\n\nAIFPL supports single-line comments using the semicolon (`;`) character:\n\n```aifpl\n; This is a comment\n(+ 1 2)  ; Calculate sum\n\n; Comments can appear anywhere\n(let ((x 5))  ; Bind x to 5\n  (* x 2))    ; Double it\n```\n\nComments extend to the end of the line and are ignored during evaluation.\n```\n\n### 2. **Clarify `real` and `imag` Work on All Numbers**\nThe README shows this in the \"Complex Number Operations\" section, but it could be more prominent. The current section is good, but consider adding emphasis:\n\n```markdown\n### Complex Number Operations\nThe `real` and `imag` functions extract components from **any numeric value** (not just complex numbers):\n```\n\n### 3. **Update Features List**\nThe features list at the top mentions comments but doesn't have a dedicated section. Add:\n- **Comments**: Single-line comments with `;` character\n\n### 4. **Minor Clarifications**\n\n**In the Type Predicates section**, ensure it's clear that `number?` excludes booleans:\n```markdown\n#### Basic Type Predicates\n```aifpl\n; Number type checking (excludes booleans - important!)\n(number? 42)                          ; \u2192 #t\n(number? #t)                          ; \u2192 #f (booleans are NOT numbers in AIFPL)\n```\n\n### 5. **Add Note About Alist Special Form Evaluation**\nIn the Alists section, clarify that `alist` evaluates pair elements:\n\n```markdown\n**Note**: `alist` is a special form that evaluates the key and value expressions within each pair, but treats the pair structure itself as data. This means `(alist (\"name\" (string-append \"Al\" \"ice\")))` will evaluate the `string-append` to produce `(alist (\"name\" \"Alice\"))`.\n```\n\n### 6. **Emphasize No Side Effects**\nAdd to the \"Key Features\" section:\n```markdown\n- **No side effects**: Pure functional language - no mutation, no I/O, safe for AI tool integration\n```\n\n### 7. **Add Escape Sequences Reference**\nThe README mentions escape sequences but could have a quick reference table:\n\n```markdown\n### String Literals and Escape Sequences\n\nString literals use double quotes and support escape sequences:\n\n```aifpl\n\"hello world\"                         ; Basic string\n\"She said \\\"Hello!\\\"\"                 ; Escaped quotes\n\"Line 1\\nLine 2\"                      ; Newline\n\"Column 1\\tColumn 2\"                  ; Tab\n\"Path\\\\to\\\\file\"                      ; Backslash\n\"Unicode: \\u03B1\\u03B2\\u03B3\"         ; Greek letters \u03b1\u03b2\u03b3\n```\n\n**Supported escape sequences:**\n- `\\\"` \u2192 literal quote\n- `\\\\` \u2192 literal backslash\n- `\\n` \u2192 newline (LF)\n- `\\t` \u2192 horizontal tab\n- `\\r` \u2192 carriage return (CR)\n- `\\uXXXX` \u2192 Unicode code point (4 hex digits)\n```\n\n### Summary of Changes Needed:\n\n1. \u2705 **Add dedicated Comments section** - Currently only mentioned in passing\n2. \u2705 **Emphasize `real`/`imag` work on all numbers** - Already shown but could be clearer\n3. \u2705 **Add \"no side effects\" to key features** - Important for AI tool context\n4. \u2705 **Clarify alist special form evaluation** - Already mentioned but could be more explicit\n5. \u2705 **Add escape sequences reference table** - Currently shown in examples but no quick reference\n\nThe README is quite comprehensive overall! The main gap is the lack of a dedicated comments section, and some minor clarifications would help. The structure and content are excellent - it's very thorough and well-organized.",
      "completed": true,
      "usage": {
        "prompt_tokens": 36750,
        "completion_tokens": 1008,
        "total_tokens": 37758
      },
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "9bb3212a-f7db-4743-a26c-bf5a55cf33e9",
      "timestamp": "2026-01-11T15:18:01.889073+00:00",
      "type": "user_message",
      "content": "preview the current version for me",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "b62030cb-0442-4c47-8387-7b0b5b206a61",
      "timestamp": "2026-01-11T15:18:03.924558+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "5f28068d-6a74-4dd9-8834-32d4e06490c5",
      "timestamp": "2026-01-11T15:18:04.901310+00:00",
      "type": "ai_response",
      "content": "",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_01QNBLCknun1u5yVuVBC2nZd",
          "name": "system",
          "arguments": {
            "operation": "open_preview_tab",
            "file_path": "src/aifpl/README.md"
          }
        }
      ]
    },
    {
      "id": "9716ef62-4483-45c6-9dc6-dbfc5a373fc1",
      "timestamp": "2026-01-11T15:18:04.908659+00:00",
      "type": "tool_call",
      "content": "```json\n{\n  \"id\": \"toolu_01QNBLCknun1u5yVuVBC2nZd\",\n  \"name\": \"system\",\n  \"arguments\": {\n    \"operation\": \"open_preview_tab\",\n    \"file_path\": \"src/aifpl/README.md\"\n  }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_01QNBLCknun1u5yVuVBC2nZd",
          "name": "system",
          "arguments": {
            "operation": "open_preview_tab",
            "file_path": "src/aifpl/README.md"
          }
        }
      ]
    },
    {
      "id": "b8647d1d-5882-492f-aeaf-8df0001a611f",
      "timestamp": "2026-01-11T15:18:05.271737+00:00",
      "type": "tool_result",
      "content": "```json\n{\n  \"id\": \"toolu_01QNBLCknun1u5yVuVBC2nZd\",\n  \"name\": \"system\",\n  \"content\": \"Opened preview tab for: 'src/aifpl/README.md', tab ID: 838c3f02-a97a-4f87-906d-80919040eb09\",\n  \"error\": null\n}\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01QNBLCknun1u5yVuVBC2nZd",
          "name": "system",
          "content": "Opened preview tab for: 'src/aifpl/README.md', tab ID: 838c3f02-a97a-4f87-906d-80919040eb09",
          "error": null
        }
      ]
    },
    {
      "id": "9209c6cd-f52f-4d08-82f7-fce6e7cb23ce",
      "timestamp": "2026-01-11T15:18:05.273976+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01QNBLCknun1u5yVuVBC2nZd",
          "name": "system",
          "content": "Opened preview tab for: 'src/aifpl/README.md', tab ID: 838c3f02-a97a-4f87-906d-80919040eb09",
          "error": null
        }
      ]
    },
    {
      "id": "905448e1-d5ca-4514-a58a-9db95757f54d",
      "timestamp": "2026-01-11T15:18:07.608451+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "a675e59f-b298-4040-abb5-94f3975f4845",
      "timestamp": "2026-01-11T15:18:07.621406+00:00",
      "type": "ai_response",
      "content": "I've opened a preview of the current README.md file for you. You can now see the formatted version of the document. \n\nAs I mentioned in my analysis, the README is quite comprehensive and well-structured. The main additions needed based on the tool description are:\n\n1. A dedicated **Comments** section (currently only briefly mentioned)\n2. Some minor clarifications about type behavior\n3. Emphasis on \"no side effects\" for AI tool context\n\nWould you like me to create an updated version of the README with these additions?",
      "completed": true,
      "usage": {
        "prompt_tokens": 37907,
        "completion_tokens": 116,
        "total_tokens": 38023
      },
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "59ced832-069b-4d52-9d97-369f2332fd29",
      "timestamp": "2026-01-11T15:18:21.642991+00:00",
      "type": "user_message",
      "content": "and open in an editor",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "04864ae4-e3a5-4b7c-a674-cbfad9fcaebd",
      "timestamp": "2026-01-11T15:18:23.787327+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "0f764a78-7b87-425a-8dac-0bd37b54d98b",
      "timestamp": "2026-01-11T15:18:24.471763+00:00",
      "type": "ai_response",
      "content": "",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_01ETAY86eSg3TPd7ML5irzN7",
          "name": "system",
          "arguments": {
            "operation": "open_editor_tab",
            "file_path": "src/aifpl/README.md"
          }
        }
      ]
    },
    {
      "id": "cd2fdb70-2d27-4fe2-b9c7-beb170907fdd",
      "timestamp": "2026-01-11T15:18:24.477487+00:00",
      "type": "tool_call",
      "content": "```json\n{\n  \"id\": \"toolu_01ETAY86eSg3TPd7ML5irzN7\",\n  \"name\": \"system\",\n  \"arguments\": {\n    \"operation\": \"open_editor_tab\",\n    \"file_path\": \"src/aifpl/README.md\"\n  }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_01ETAY86eSg3TPd7ML5irzN7",
          "name": "system",
          "arguments": {
            "operation": "open_editor_tab",
            "file_path": "src/aifpl/README.md"
          }
        }
      ]
    },
    {
      "id": "bdbc0d48-a38a-48bc-8737-617d3876a63b",
      "timestamp": "2026-01-11T15:18:24.602082+00:00",
      "type": "tool_result",
      "content": "```json\n{\n  \"id\": \"toolu_01ETAY86eSg3TPd7ML5irzN7\",\n  \"name\": \"system\",\n  \"content\": \"Opened editor tab for file: 'src/aifpl/README.md', tab ID: 6f13fcb4-562f-4ae1-822a-ba51a8376abe\",\n  \"error\": null\n}\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01ETAY86eSg3TPd7ML5irzN7",
          "name": "system",
          "content": "Opened editor tab for file: 'src/aifpl/README.md', tab ID: 6f13fcb4-562f-4ae1-822a-ba51a8376abe",
          "error": null
        }
      ]
    },
    {
      "id": "cb3a0b60-ad82-4082-8f19-da22129268f7",
      "timestamp": "2026-01-11T15:18:24.603917+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01ETAY86eSg3TPd7ML5irzN7",
          "name": "system",
          "content": "Opened editor tab for file: 'src/aifpl/README.md', tab ID: 6f13fcb4-562f-4ae1-822a-ba51a8376abe",
          "error": null
        }
      ]
    },
    {
      "id": "55ecbd49-6905-4dd6-9143-af47840de52e",
      "timestamp": "2026-01-11T15:18:27.371967+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "adc9fa3f-5033-43fe-932c-6889480240f0",
      "timestamp": "2026-01-11T15:18:27.382948+00:00",
      "type": "ai_response",
      "content": "I've opened the README.md file in an editor tab for you. Now you can see both the preview and the editor side by side.\n\nWould you like me to prepare the specific changes as a diff that you can apply to update the README with the missing features from the tool description?",
      "completed": true,
      "usage": {
        "prompt_tokens": 38174,
        "completion_tokens": 62,
        "total_tokens": 38236
      },
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "523f1760-5e46-4cd1-ba7a-0a97b68ea6a0",
      "timestamp": "2026-01-11T15:19:54.276555+00:00",
      "type": "user_message",
      "content": "does the type predicate section cover alists?",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "59c77b83-87d2-4751-ae6b-bae430b14806",
      "timestamp": "2026-01-11T15:19:56.358051+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "471458b0-d916-4b07-be78-e9c19f836e54",
      "timestamp": "2026-01-11T15:19:57.613761+00:00",
      "type": "ai_response",
      "content": "",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_01GZ6SLGC8StJFWTJN7QKSix",
          "name": "editor",
          "arguments": {
            "operation": "search",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "search_text": "alist?"
          }
        }
      ]
    },
    {
      "id": "2de7505e-f67b-4aa8-b2dc-da070ee5b12a",
      "timestamp": "2026-01-11T15:19:57.622950+00:00",
      "type": "tool_call",
      "content": "```json\n{\n  \"id\": \"toolu_01GZ6SLGC8StJFWTJN7QKSix\",\n  \"name\": \"editor\",\n  \"arguments\": {\n    \"operation\": \"search\",\n    \"tab_id\": \"6f13fcb4-562f-4ae1-822a-ba51a8376abe\",\n    \"search_text\": \"alist?\"\n  }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_01GZ6SLGC8StJFWTJN7QKSix",
          "name": "editor",
          "arguments": {
            "operation": "search",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "search_text": "alist?"
          }
        }
      ]
    },
    {
      "id": "969757dd-d65e-4cc6-98c4-6906a9753679",
      "timestamp": "2026-01-11T15:19:57.633291+00:00",
      "type": "tool_result",
      "content": "```json\n{\n  \"id\": \"toolu_01GZ6SLGC8StJFWTJN7QKSix\",\n  \"name\": \"editor\",\n  \"content\": \"{\\n  \\\"search_text\\\": \\\"alist?\\\",\\n  \\\"case_sensitive\\\": false,\\n  \\\"match_count\\\": 4,\\n  \\\"matches\\\": [\\n    {\\n      \\\"line\\\": 1485,\\n      \\\"column\\\": 8,\\n      \\\"match_text\\\": \\\"alist?\\\",\\n      \\\"context\\\": \\\"(alist? (alist (\\\\\\\"x\\\\\\\" 1)))\\\"\\n    },\\n    {\\n      \\\"line\\\": 1488,\\n      \\\"column\\\": 8,\\n      \\\"match_text\\\": \\\"alist?\\\",\\n      \\\"context\\\": \\\"(alist? (list 1 2 3))\\\"\\n    },\\n    {\\n      \\\"line\\\": 1541,\\n      \\\"column\\\": 11,\\n      \\\"match_text\\\": \\\"alist?\\\",\\n      \\\"context\\\": \\\"  ((alist? data) (alist-get data \\\\\\\"name\\\\\\\"))\\\"\\n    },\\n    {\\n      \\\"line\\\": 1548,\\n      \\\"column\\\": 28,\\n      \\\"match_text\\\": \\\"alist?\\\",\\n      \\\"context\\\": \\\"                   ((alist? a) \\\\\\\"alist\\\\\\\")\\\"\\n    }\\n  ]\\n}\",\n  \"error\": null\n}\n```\n`content` is:\n```json\n{\n  \"search_text\": \"alist?\",\n  \"case_sensitive\": false,\n  \"match_count\": 4,\n  \"matches\": [\n    {\n      \"line\": 1485,\n      \"column\": 8,\n      \"match_text\": \"alist?\",\n      \"context\": \"(alist? (alist (\\\"x\\\" 1)))\"\n    },\n    {\n      \"line\": 1488,\n      \"column\": 8,\n      \"match_text\": \"alist?\",\n      \"context\": \"(alist? (list 1 2 3))\"\n    },\n    {\n      \"line\": 1541,\n      \"column\": 11,\n      \"match_text\": \"alist?\",\n      \"context\": \"  ((alist? data) (alist-get data \\\"name\\\"))\"\n    },\n    {\n      \"line\": 1548,\n      \"column\": 28,\n      \"match_text\": \"alist?\",\n      \"context\": \"                   ((alist? a) \\\"alist\\\")\"\n    }\n  ]\n}\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01GZ6SLGC8StJFWTJN7QKSix",
          "name": "editor",
          "content": "{\n  \"search_text\": \"alist?\",\n  \"case_sensitive\": false,\n  \"match_count\": 4,\n  \"matches\": [\n    {\n      \"line\": 1485,\n      \"column\": 8,\n      \"match_text\": \"alist?\",\n      \"context\": \"(alist? (alist (\\\"x\\\" 1)))\"\n    },\n    {\n      \"line\": 1488,\n      \"column\": 8,\n      \"match_text\": \"alist?\",\n      \"context\": \"(alist? (list 1 2 3))\"\n    },\n    {\n      \"line\": 1541,\n      \"column\": 11,\n      \"match_text\": \"alist?\",\n      \"context\": \"  ((alist? data) (alist-get data \\\"name\\\"))\"\n    },\n    {\n      \"line\": 1548,\n      \"column\": 28,\n      \"match_text\": \"alist?\",\n      \"context\": \"                   ((alist? a) \\\"alist\\\")\"\n    }\n  ]\n}",
          "error": null
        }
      ]
    },
    {
      "id": "467d02e8-2658-4145-ad83-88dec0ff348d",
      "timestamp": "2026-01-11T15:19:57.637679+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01GZ6SLGC8StJFWTJN7QKSix",
          "name": "editor",
          "content": "{\n  \"search_text\": \"alist?\",\n  \"case_sensitive\": false,\n  \"match_count\": 4,\n  \"matches\": [\n    {\n      \"line\": 1485,\n      \"column\": 8,\n      \"match_text\": \"alist?\",\n      \"context\": \"(alist? (alist (\\\"x\\\" 1)))\"\n    },\n    {\n      \"line\": 1488,\n      \"column\": 8,\n      \"match_text\": \"alist?\",\n      \"context\": \"(alist? (list 1 2 3))\"\n    },\n    {\n      \"line\": 1541,\n      \"column\": 11,\n      \"match_text\": \"alist?\",\n      \"context\": \"  ((alist? data) (alist-get data \\\"name\\\"))\"\n    },\n    {\n      \"line\": 1548,\n      \"column\": 28,\n      \"match_text\": \"alist?\",\n      \"context\": \"                   ((alist? a) \\\"alist\\\")\"\n    }\n  ]\n}",
          "error": null
        }
      ]
    },
    {
      "id": "0c9102da-c5fd-44c6-a00d-cc8786210453",
      "timestamp": "2026-01-11T15:20:00.044585+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "8cb23061-37c7-496f-83f9-2af372ccf442",
      "timestamp": "2026-01-11T15:20:01.125944+00:00",
      "type": "ai_response",
      "content": "",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_013JX7soxYYHUUgd1jHxKWzo",
          "name": "editor",
          "arguments": {
            "operation": "read_lines",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "start_line": 850,
            "end_line": 920
          }
        }
      ]
    },
    {
      "id": "9dbb6576-2670-4f58-aff6-a1b8e49cb90b",
      "timestamp": "2026-01-11T15:20:01.133776+00:00",
      "type": "tool_call",
      "content": "```json\n{\n  \"id\": \"toolu_013JX7soxYYHUUgd1jHxKWzo\",\n  \"name\": \"editor\",\n  \"arguments\": {\n    \"operation\": \"read_lines\",\n    \"tab_id\": \"6f13fcb4-562f-4ae1-822a-ba51a8376abe\",\n    \"start_line\": 850,\n    \"end_line\": 920\n  }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_013JX7soxYYHUUgd1jHxKWzo",
          "name": "editor",
          "arguments": {
            "operation": "read_lines",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "start_line": 850,
            "end_line": 920
          }
        }
      ]
    },
    {
      "id": "71c1e126-c27e-4fce-a95e-de4dfea0e253",
      "timestamp": "2026-01-11T15:20:01.140052+00:00",
      "type": "tool_result",
      "content": "```json\n{\n  \"id\": \"toolu_013JX7soxYYHUUgd1jHxKWzo\",\n  \"name\": \"editor\",\n  \"content\": \"{\\n  \\\"range\\\": \\\"850-920\\\",\\n  \\\"lines\\\": {\\n    \\\"850\\\": \\\"; Returns #f if not found\\\",\\n    \\\"851\\\": \\\"(find (lambda (x) (> x 10)) (list 1 2 3))  ; \\\\u2192 #f\\\",\\n    \\\"852\\\": \\\"\\\",\\n    \\\"853\\\": \\\"; Complex search\\\",\\n    \\\"854\\\": \\\"(find (lambda (pair) (= (first pair) \\\\\\\"name\\\\\\\"))\\\",\\n    \\\"855\\\": \\\"      (list (list \\\\\\\"age\\\\\\\" 25) (list \\\\\\\"name\\\\\\\" \\\\\\\"John\\\\\\\")))  ; \\\\u2192 (\\\\\\\"name\\\\\\\" \\\\\\\"John\\\\\\\")\\\",\\n    \\\"856\\\": \\\"```\\\",\\n    \\\"857\\\": \\\"\\\",\\n    \\\"858\\\": \\\"#### Any? and All? - Boolean Predicates\\\",\\n    \\\"859\\\": \\\"```aifpl\\\",\\n    \\\"860\\\": \\\"; Check if any element matches\\\",\\n    \\\"861\\\": \\\"(any? (lambda (x) (> x 5)) (list 1 3 7 2))  ; \\\\u2192 #t\\\",\\n    \\\"862\\\": \\\"(any? (lambda (x) (< x 0)) (list 1 2 3))   ; \\\\u2192 #f\\\",\\n    \\\"863\\\": \\\"\\\",\\n    \\\"864\\\": \\\"; Check if all elements match\\\",\\n    \\\"865\\\": \\\"(all? (lambda (x) (> x 0)) (list 1 2 3))   ; \\\\u2192 #t\\\",\\n    \\\"866\\\": \\\"(all? (lambda (x) (> x 5)) (list 1 3 7))   ; \\\\u2192 #f\\\",\\n    \\\"867\\\": \\\"\\\",\\n    \\\"868\\\": \\\"; String validation\\\",\\n    \\\"869\\\": \\\"(all? (lambda (s) (> (string-length s) 0))\\\",\\n    \\\"870\\\": \\\"      (list \\\\\\\"hello\\\\\\\" \\\\\\\"world\\\\\\\" \\\\\\\"test\\\\\\\"))        ; \\\\u2192 #t\\\",\\n    \\\"871\\\": \\\"\\\",\\n    \\\"872\\\": \\\"(any? (lambda (s) (string-contains? s \\\\\\\"@\\\\\\\"))\\\",\\n    \\\"873\\\": \\\"      (list \\\\\\\"user@email.com\\\\\\\" \\\\\\\"plain-text\\\\\\\")) ; \\\\u2192 #t\\\",\\n    \\\"874\\\": \\\"```\\\",\\n    \\\"875\\\": \\\"\\\",\\n    \\\"876\\\": \\\"#### Take and Drop - List Slicing\\\",\\n    \\\"877\\\": \\\"```aifpl\\\",\\n    \\\"878\\\": \\\"; Take first n elements\\\",\\n    \\\"879\\\": \\\"(take 3 (list 1 2 3 4 5))                  ; \\\\u2192 (1 2 3)\\\",\\n    \\\"880\\\": \\\"(take 2 (list \\\\\\\"a\\\\\\\" \\\\\\\"b\\\\\\\" \\\\\\\"c\\\\\\\" \\\\\\\"d\\\\\\\"))            ; \\\\u2192 (\\\\\\\"a\\\\\\\" \\\\\\\"b\\\\\\\")\\\",\\n    \\\"881\\\": \\\"\\\",\\n    \\\"882\\\": \\\"; Drop first n elements\\\",\\n    \\\"883\\\": \\\"(drop 2 (list 1 2 3 4 5))                  ; \\\\u2192 (3 4 5)\\\",\\n    \\\"884\\\": \\\"(drop 3 (list \\\\\\\"a\\\\\\\" \\\\\\\"b\\\\\\\" \\\\\\\"c\\\\\\\" \\\\\\\"d\\\\\\\"))            ; \\\\u2192 (\\\\\\\"d\\\\\\\")\\\",\\n    \\\"885\\\": \\\"\\\",\\n    \\\"886\\\": \\\"; Safe operations (don't error on out-of-bounds)\\\",\\n    \\\"887\\\": \\\"(take 10 (list 1 2 3))                     ; \\\\u2192 (1 2 3)\\\",\\n    \\\"888\\\": \\\"(drop 10 (list 1 2 3))                     ; \\\\u2192 ()\\\",\\n    \\\"889\\\": \\\"\\\",\\n    \\\"890\\\": \\\"; Combine with other operations\\\",\\n    \\\"891\\\": \\\"(take 3 (filter (lambda (x) (> x 0)) (list -1 2 -3 4 5 6)))  ; \\\\u2192 (2 4 5)\\\",\\n    \\\"892\\\": \\\"```\\\",\\n    \\\"893\\\": \\\"\\\",\\n    \\\"894\\\": \\\"### Functional Programming Patterns\\\",\\n    \\\"895\\\": \\\"\\\",\\n    \\\"896\\\": \\\"#### Data Transformation Pipelines\\\",\\n    \\\"897\\\": \\\"```aifpl\\\",\\n    \\\"898\\\": \\\"; Process CSV-like data\\\",\\n    \\\"899\\\": \\\"(let ((data (list \\\\\\\"john,25\\\\\\\" \\\\\\\"alice,30\\\\\\\" \\\\\\\"bob,22\\\\\\\")))\\\",\\n    \\\"900\\\": \\\"  (map (lambda (row)\\\",\\n    \\\"901\\\": \\\"         (let ((parts (string-split row \\\\\\\",\\\\\\\")))\\\",\\n    \\\"902\\\": \\\"           (list (first parts) (string->number (first (rest parts))))))\\\",\\n    \\\"903\\\": \\\"       data))                               ; \\\\u2192 ((\\\\\\\"john\\\\\\\" 25) (\\\\\\\"alice\\\\\\\" 30) (\\\\\\\"bob\\\\\\\" 22))\\\",\\n    \\\"904\\\": \\\"\\\",\\n    \\\"905\\\": \\\"; Multi-step data processing\\\",\\n    \\\"906\\\": \\\"(let ((numbers (range 1 21)))\\\",\\n    \\\"907\\\": \\\"  (let ((evens (filter (lambda (x) (= (% x 2) 0)) numbers))\\\",\\n    \\\"908\\\": \\\"        (squares (map (lambda (x) (* x x)) evens))\\\",\\n    \\\"909\\\": \\\"        (sum (fold + 0 squares)))\\\",\\n    \\\"910\\\": \\\"    sum))                                   ; \\\\u2192 1540\\\",\\n    \\\"911\\\": \\\"\\\",\\n    \\\"912\\\": \\\"; String processing pipeline\\\",\\n    \\\"913\\\": \\\"(let ((text \\\\\\\"The Quick Brown Fox\\\\\\\"))\\\",\\n    \\\"914\\\": \\\"  (let ((words (string-split (string-downcase text) \\\\\\\" \\\\\\\"))\\\",\\n    \\\"915\\\": \\\"        (long-words (filter (lambda (w) (> (string-length w) 3)) words))\\\",\\n    \\\"916\\\": \\\"        (capitalized (map string-upcase long-words)))\\\",\\n    \\\"917\\\": \\\"    (string-join capitalized \\\\\\\"-\\\\\\\")))         ; \\\\u2192 \\\\\\\"QUICK-BROWN\\\\\\\"\\\",\\n    \\\"918\\\": \\\"```\\\",\\n    \\\"919\\\": \\\"\\\",\\n    \\\"920\\\": \\\"#### Function Composition\\\"\\n  }\\n}\",\n  \"error\": null\n}\n```\n`content` is:\n```json\n{\n  \"range\": \"850-920\",\n  \"lines\": {\n    \"850\": \"; Returns #f if not found\",\n    \"851\": \"(find (lambda (x) (> x 10)) (list 1 2 3))  ; \\u2192 #f\",\n    \"852\": \"\",\n    \"853\": \"; Complex search\",\n    \"854\": \"(find (lambda (pair) (= (first pair) \\\"name\\\"))\",\n    \"855\": \"      (list (list \\\"age\\\" 25) (list \\\"name\\\" \\\"John\\\")))  ; \\u2192 (\\\"name\\\" \\\"John\\\")\",\n    \"856\": \"```\",\n    \"857\": \"\",\n    \"858\": \"#### Any? and All? - Boolean Predicates\",\n    \"859\": \"```aifpl\",\n    \"860\": \"; Check if any element matches\",\n    \"861\": \"(any? (lambda (x) (> x 5)) (list 1 3 7 2))  ; \\u2192 #t\",\n    \"862\": \"(any? (lambda (x) (< x 0)) (list 1 2 3))   ; \\u2192 #f\",\n    \"863\": \"\",\n    \"864\": \"; Check if all elements match\",\n    \"865\": \"(all? (lambda (x) (> x 0)) (list 1 2 3))   ; \\u2192 #t\",\n    \"866\": \"(all? (lambda (x) (> x 5)) (list 1 3 7))   ; \\u2192 #f\",\n    \"867\": \"\",\n    \"868\": \"; String validation\",\n    \"869\": \"(all? (lambda (s) (> (string-length s) 0))\",\n    \"870\": \"      (list \\\"hello\\\" \\\"world\\\" \\\"test\\\"))        ; \\u2192 #t\",\n    \"871\": \"\",\n    \"872\": \"(any? (lambda (s) (string-contains? s \\\"@\\\"))\",\n    \"873\": \"      (list \\\"user@email.com\\\" \\\"plain-text\\\")) ; \\u2192 #t\",\n    \"874\": \"```\",\n    \"875\": \"\",\n    \"876\": \"#### Take and Drop - List Slicing\",\n    \"877\": \"```aifpl\",\n    \"878\": \"; Take first n elements\",\n    \"879\": \"(take 3 (list 1 2 3 4 5))                  ; \\u2192 (1 2 3)\",\n    \"880\": \"(take 2 (list \\\"a\\\" \\\"b\\\" \\\"c\\\" \\\"d\\\"))            ; \\u2192 (\\\"a\\\" \\\"b\\\")\",\n    \"881\": \"\",\n    \"882\": \"; Drop first n elements\",\n    \"883\": \"(drop 2 (list 1 2 3 4 5))                  ; \\u2192 (3 4 5)\",\n    \"884\": \"(drop 3 (list \\\"a\\\" \\\"b\\\" \\\"c\\\" \\\"d\\\"))            ; \\u2192 (\\\"d\\\")\",\n    \"885\": \"\",\n    \"886\": \"; Safe operations (don't error on out-of-bounds)\",\n    \"887\": \"(take 10 (list 1 2 3))                     ; \\u2192 (1 2 3)\",\n    \"888\": \"(drop 10 (list 1 2 3))                     ; \\u2192 ()\",\n    \"889\": \"\",\n    \"890\": \"; Combine with other operations\",\n    \"891\": \"(take 3 (filter (lambda (x) (> x 0)) (list -1 2 -3 4 5 6)))  ; \\u2192 (2 4 5)\",\n    \"892\": \"```\",\n    \"893\": \"\",\n    \"894\": \"### Functional Programming Patterns\",\n    \"895\": \"\",\n    \"896\": \"#### Data Transformation Pipelines\",\n    \"897\": \"```aifpl\",\n    \"898\": \"; Process CSV-like data\",\n    \"899\": \"(let ((data (list \\\"john,25\\\" \\\"alice,30\\\" \\\"bob,22\\\")))\",\n    \"900\": \"  (map (lambda (row)\",\n    \"901\": \"         (let ((parts (string-split row \\\",\\\")))\",\n    \"902\": \"           (list (first parts) (string->number (first (rest parts))))))\",\n    \"903\": \"       data))                               ; \\u2192 ((\\\"john\\\" 25) (\\\"alice\\\" 30) (\\\"bob\\\" 22))\",\n    \"904\": \"\",\n    \"905\": \"; Multi-step data processing\",\n    \"906\": \"(let ((numbers (range 1 21)))\",\n    \"907\": \"  (let ((evens (filter (lambda (x) (= (% x 2) 0)) numbers))\",\n    \"908\": \"        (squares (map (lambda (x) (* x x)) evens))\",\n    \"909\": \"        (sum (fold + 0 squares)))\",\n    \"910\": \"    sum))                                   ; \\u2192 1540\",\n    \"911\": \"\",\n    \"912\": \"; String processing pipeline\",\n    \"913\": \"(let ((text \\\"The Quick Brown Fox\\\"))\",\n    \"914\": \"  (let ((words (string-split (string-downcase text) \\\" \\\"))\",\n    \"915\": \"        (long-words (filter (lambda (w) (> (string-length w) 3)) words))\",\n    \"916\": \"        (capitalized (map string-upcase long-words)))\",\n    \"917\": \"    (string-join capitalized \\\"-\\\")))         ; \\u2192 \\\"QUICK-BROWN\\\"\",\n    \"918\": \"```\",\n    \"919\": \"\",\n    \"920\": \"#### Function Composition\"\n  }\n}\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_013JX7soxYYHUUgd1jHxKWzo",
          "name": "editor",
          "content": "{\n  \"range\": \"850-920\",\n  \"lines\": {\n    \"850\": \"; Returns #f if not found\",\n    \"851\": \"(find (lambda (x) (> x 10)) (list 1 2 3))  ; \\u2192 #f\",\n    \"852\": \"\",\n    \"853\": \"; Complex search\",\n    \"854\": \"(find (lambda (pair) (= (first pair) \\\"name\\\"))\",\n    \"855\": \"      (list (list \\\"age\\\" 25) (list \\\"name\\\" \\\"John\\\")))  ; \\u2192 (\\\"name\\\" \\\"John\\\")\",\n    \"856\": \"```\",\n    \"857\": \"\",\n    \"858\": \"#### Any? and All? - Boolean Predicates\",\n    \"859\": \"```aifpl\",\n    \"860\": \"; Check if any element matches\",\n    \"861\": \"(any? (lambda (x) (> x 5)) (list 1 3 7 2))  ; \\u2192 #t\",\n    \"862\": \"(any? (lambda (x) (< x 0)) (list 1 2 3))   ; \\u2192 #f\",\n    \"863\": \"\",\n    \"864\": \"; Check if all elements match\",\n    \"865\": \"(all? (lambda (x) (> x 0)) (list 1 2 3))   ; \\u2192 #t\",\n    \"866\": \"(all? (lambda (x) (> x 5)) (list 1 3 7))   ; \\u2192 #f\",\n    \"867\": \"\",\n    \"868\": \"; String validation\",\n    \"869\": \"(all? (lambda (s) (> (string-length s) 0))\",\n    \"870\": \"      (list \\\"hello\\\" \\\"world\\\" \\\"test\\\"))        ; \\u2192 #t\",\n    \"871\": \"\",\n    \"872\": \"(any? (lambda (s) (string-contains? s \\\"@\\\"))\",\n    \"873\": \"      (list \\\"user@email.com\\\" \\\"plain-text\\\")) ; \\u2192 #t\",\n    \"874\": \"```\",\n    \"875\": \"\",\n    \"876\": \"#### Take and Drop - List Slicing\",\n    \"877\": \"```aifpl\",\n    \"878\": \"; Take first n elements\",\n    \"879\": \"(take 3 (list 1 2 3 4 5))                  ; \\u2192 (1 2 3)\",\n    \"880\": \"(take 2 (list \\\"a\\\" \\\"b\\\" \\\"c\\\" \\\"d\\\"))            ; \\u2192 (\\\"a\\\" \\\"b\\\")\",\n    \"881\": \"\",\n    \"882\": \"; Drop first n elements\",\n    \"883\": \"(drop 2 (list 1 2 3 4 5))                  ; \\u2192 (3 4 5)\",\n    \"884\": \"(drop 3 (list \\\"a\\\" \\\"b\\\" \\\"c\\\" \\\"d\\\"))            ; \\u2192 (\\\"d\\\")\",\n    \"885\": \"\",\n    \"886\": \"; Safe operations (don't error on out-of-bounds)\",\n    \"887\": \"(take 10 (list 1 2 3))                     ; \\u2192 (1 2 3)\",\n    \"888\": \"(drop 10 (list 1 2 3))                     ; \\u2192 ()\",\n    \"889\": \"\",\n    \"890\": \"; Combine with other operations\",\n    \"891\": \"(take 3 (filter (lambda (x) (> x 0)) (list -1 2 -3 4 5 6)))  ; \\u2192 (2 4 5)\",\n    \"892\": \"```\",\n    \"893\": \"\",\n    \"894\": \"### Functional Programming Patterns\",\n    \"895\": \"\",\n    \"896\": \"#### Data Transformation Pipelines\",\n    \"897\": \"```aifpl\",\n    \"898\": \"; Process CSV-like data\",\n    \"899\": \"(let ((data (list \\\"john,25\\\" \\\"alice,30\\\" \\\"bob,22\\\")))\",\n    \"900\": \"  (map (lambda (row)\",\n    \"901\": \"         (let ((parts (string-split row \\\",\\\")))\",\n    \"902\": \"           (list (first parts) (string->number (first (rest parts))))))\",\n    \"903\": \"       data))                               ; \\u2192 ((\\\"john\\\" 25) (\\\"alice\\\" 30) (\\\"bob\\\" 22))\",\n    \"904\": \"\",\n    \"905\": \"; Multi-step data processing\",\n    \"906\": \"(let ((numbers (range 1 21)))\",\n    \"907\": \"  (let ((evens (filter (lambda (x) (= (% x 2) 0)) numbers))\",\n    \"908\": \"        (squares (map (lambda (x) (* x x)) evens))\",\n    \"909\": \"        (sum (fold + 0 squares)))\",\n    \"910\": \"    sum))                                   ; \\u2192 1540\",\n    \"911\": \"\",\n    \"912\": \"; String processing pipeline\",\n    \"913\": \"(let ((text \\\"The Quick Brown Fox\\\"))\",\n    \"914\": \"  (let ((words (string-split (string-downcase text) \\\" \\\"))\",\n    \"915\": \"        (long-words (filter (lambda (w) (> (string-length w) 3)) words))\",\n    \"916\": \"        (capitalized (map string-upcase long-words)))\",\n    \"917\": \"    (string-join capitalized \\\"-\\\")))         ; \\u2192 \\\"QUICK-BROWN\\\"\",\n    \"918\": \"```\",\n    \"919\": \"\",\n    \"920\": \"#### Function Composition\"\n  }\n}",
          "error": null
        }
      ]
    },
    {
      "id": "1a277e25-87ca-4e48-a2bb-bfc294101e89",
      "timestamp": "2026-01-11T15:20:01.144210+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_013JX7soxYYHUUgd1jHxKWzo",
          "name": "editor",
          "content": "{\n  \"range\": \"850-920\",\n  \"lines\": {\n    \"850\": \"; Returns #f if not found\",\n    \"851\": \"(find (lambda (x) (> x 10)) (list 1 2 3))  ; \\u2192 #f\",\n    \"852\": \"\",\n    \"853\": \"; Complex search\",\n    \"854\": \"(find (lambda (pair) (= (first pair) \\\"name\\\"))\",\n    \"855\": \"      (list (list \\\"age\\\" 25) (list \\\"name\\\" \\\"John\\\")))  ; \\u2192 (\\\"name\\\" \\\"John\\\")\",\n    \"856\": \"```\",\n    \"857\": \"\",\n    \"858\": \"#### Any? and All? - Boolean Predicates\",\n    \"859\": \"```aifpl\",\n    \"860\": \"; Check if any element matches\",\n    \"861\": \"(any? (lambda (x) (> x 5)) (list 1 3 7 2))  ; \\u2192 #t\",\n    \"862\": \"(any? (lambda (x) (< x 0)) (list 1 2 3))   ; \\u2192 #f\",\n    \"863\": \"\",\n    \"864\": \"; Check if all elements match\",\n    \"865\": \"(all? (lambda (x) (> x 0)) (list 1 2 3))   ; \\u2192 #t\",\n    \"866\": \"(all? (lambda (x) (> x 5)) (list 1 3 7))   ; \\u2192 #f\",\n    \"867\": \"\",\n    \"868\": \"; String validation\",\n    \"869\": \"(all? (lambda (s) (> (string-length s) 0))\",\n    \"870\": \"      (list \\\"hello\\\" \\\"world\\\" \\\"test\\\"))        ; \\u2192 #t\",\n    \"871\": \"\",\n    \"872\": \"(any? (lambda (s) (string-contains? s \\\"@\\\"))\",\n    \"873\": \"      (list \\\"user@email.com\\\" \\\"plain-text\\\")) ; \\u2192 #t\",\n    \"874\": \"```\",\n    \"875\": \"\",\n    \"876\": \"#### Take and Drop - List Slicing\",\n    \"877\": \"```aifpl\",\n    \"878\": \"; Take first n elements\",\n    \"879\": \"(take 3 (list 1 2 3 4 5))                  ; \\u2192 (1 2 3)\",\n    \"880\": \"(take 2 (list \\\"a\\\" \\\"b\\\" \\\"c\\\" \\\"d\\\"))            ; \\u2192 (\\\"a\\\" \\\"b\\\")\",\n    \"881\": \"\",\n    \"882\": \"; Drop first n elements\",\n    \"883\": \"(drop 2 (list 1 2 3 4 5))                  ; \\u2192 (3 4 5)\",\n    \"884\": \"(drop 3 (list \\\"a\\\" \\\"b\\\" \\\"c\\\" \\\"d\\\"))            ; \\u2192 (\\\"d\\\")\",\n    \"885\": \"\",\n    \"886\": \"; Safe operations (don't error on out-of-bounds)\",\n    \"887\": \"(take 10 (list 1 2 3))                     ; \\u2192 (1 2 3)\",\n    \"888\": \"(drop 10 (list 1 2 3))                     ; \\u2192 ()\",\n    \"889\": \"\",\n    \"890\": \"; Combine with other operations\",\n    \"891\": \"(take 3 (filter (lambda (x) (> x 0)) (list -1 2 -3 4 5 6)))  ; \\u2192 (2 4 5)\",\n    \"892\": \"```\",\n    \"893\": \"\",\n    \"894\": \"### Functional Programming Patterns\",\n    \"895\": \"\",\n    \"896\": \"#### Data Transformation Pipelines\",\n    \"897\": \"```aifpl\",\n    \"898\": \"; Process CSV-like data\",\n    \"899\": \"(let ((data (list \\\"john,25\\\" \\\"alice,30\\\" \\\"bob,22\\\")))\",\n    \"900\": \"  (map (lambda (row)\",\n    \"901\": \"         (let ((parts (string-split row \\\",\\\")))\",\n    \"902\": \"           (list (first parts) (string->number (first (rest parts))))))\",\n    \"903\": \"       data))                               ; \\u2192 ((\\\"john\\\" 25) (\\\"alice\\\" 30) (\\\"bob\\\" 22))\",\n    \"904\": \"\",\n    \"905\": \"; Multi-step data processing\",\n    \"906\": \"(let ((numbers (range 1 21)))\",\n    \"907\": \"  (let ((evens (filter (lambda (x) (= (% x 2) 0)) numbers))\",\n    \"908\": \"        (squares (map (lambda (x) (* x x)) evens))\",\n    \"909\": \"        (sum (fold + 0 squares)))\",\n    \"910\": \"    sum))                                   ; \\u2192 1540\",\n    \"911\": \"\",\n    \"912\": \"; String processing pipeline\",\n    \"913\": \"(let ((text \\\"The Quick Brown Fox\\\"))\",\n    \"914\": \"  (let ((words (string-split (string-downcase text) \\\" \\\"))\",\n    \"915\": \"        (long-words (filter (lambda (w) (> (string-length w) 3)) words))\",\n    \"916\": \"        (capitalized (map string-upcase long-words)))\",\n    \"917\": \"    (string-join capitalized \\\"-\\\")))         ; \\u2192 \\\"QUICK-BROWN\\\"\",\n    \"918\": \"```\",\n    \"919\": \"\",\n    \"920\": \"#### Function Composition\"\n  }\n}",
          "error": null
        }
      ]
    },
    {
      "id": "7929a5b0-3729-4e50-b70e-7cb9a2145493",
      "timestamp": "2026-01-11T15:20:03.065481+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "31dd3683-82ad-4900-8a75-3be07d35626c",
      "timestamp": "2026-01-11T15:20:03.078517+00:00",
      "type": "ai_response",
      "content": "Let me search for the Type Predicates section:",
      "completed": true,
      "usage": {
        "prompt_tokens": 40184,
        "completion_tokens": 128,
        "total_tokens": 40312
      },
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_012xKb9fZ1yRNs6nsFsTkhdK",
          "name": "editor",
          "arguments": {
            "operation": "search",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "search_text": "### Type Predicates"
          }
        }
      ]
    },
    {
      "id": "c1107053-73ed-48b6-b1fa-c3f3ba3d2183",
      "timestamp": "2026-01-11T15:20:04.303406+00:00",
      "type": "tool_call",
      "content": "```json\n{\n  \"id\": \"toolu_012xKb9fZ1yRNs6nsFsTkhdK\",\n  \"name\": \"editor\",\n  \"arguments\": {\n    \"operation\": \"search\",\n    \"tab_id\": \"6f13fcb4-562f-4ae1-822a-ba51a8376abe\",\n    \"search_text\": \"### Type Predicates\"\n  }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_012xKb9fZ1yRNs6nsFsTkhdK",
          "name": "editor",
          "arguments": {
            "operation": "search",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "search_text": "### Type Predicates"
          }
        }
      ]
    },
    {
      "id": "832687c0-ef4c-454f-868f-4250c830b0a1",
      "timestamp": "2026-01-11T15:20:04.311112+00:00",
      "type": "tool_result",
      "content": "```json\n{\n  \"id\": \"toolu_012xKb9fZ1yRNs6nsFsTkhdK\",\n  \"name\": \"editor\",\n  \"content\": \"{\\n  \\\"search_text\\\": \\\"### Type Predicates\\\",\\n  \\\"case_sensitive\\\": false,\\n  \\\"match_count\\\": 1,\\n  \\\"matches\\\": [\\n    {\\n      \\\"line\\\": 1100,\\n      \\\"column\\\": 20,\\n      \\\"match_text\\\": \\\"### Type Predicates\\\",\\n      \\\"context\\\": \\\"### Type Predicates\\\"\\n    }\\n  ]\\n}\",\n  \"error\": null\n}\n```\n`content` is:\n```json\n{\n  \"search_text\": \"### Type Predicates\",\n  \"case_sensitive\": false,\n  \"match_count\": 1,\n  \"matches\": [\n    {\n      \"line\": 1100,\n      \"column\": 20,\n      \"match_text\": \"### Type Predicates\",\n      \"context\": \"### Type Predicates\"\n    }\n  ]\n}\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_012xKb9fZ1yRNs6nsFsTkhdK",
          "name": "editor",
          "content": "{\n  \"search_text\": \"### Type Predicates\",\n  \"case_sensitive\": false,\n  \"match_count\": 1,\n  \"matches\": [\n    {\n      \"line\": 1100,\n      \"column\": 20,\n      \"match_text\": \"### Type Predicates\",\n      \"context\": \"### Type Predicates\"\n    }\n  ]\n}",
          "error": null
        }
      ]
    },
    {
      "id": "a29889fb-5acf-48b1-b69d-2bf6fcf12c37",
      "timestamp": "2026-01-11T15:20:04.315079+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_012xKb9fZ1yRNs6nsFsTkhdK",
          "name": "editor",
          "content": "{\n  \"search_text\": \"### Type Predicates\",\n  \"case_sensitive\": false,\n  \"match_count\": 1,\n  \"matches\": [\n    {\n      \"line\": 1100,\n      \"column\": 20,\n      \"match_text\": \"### Type Predicates\",\n      \"context\": \"### Type Predicates\"\n    }\n  ]\n}",
          "error": null
        }
      ]
    },
    {
      "id": "74dffb74-58f2-4ae0-bbed-da2e0a771df5",
      "timestamp": "2026-01-11T15:20:06.393935+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "43862082-3caa-497c-b735-53a2e310b98f",
      "timestamp": "2026-01-11T15:20:07.134339+00:00",
      "type": "ai_response",
      "content": "",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_01KDVb4jjvvXQexYSWwHbrAk",
          "name": "editor",
          "arguments": {
            "operation": "read_lines",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "start_line": 1100,
            "end_line": 1180
          }
        }
      ]
    },
    {
      "id": "0bf09c15-a156-458b-8e88-ea34bfbce76d",
      "timestamp": "2026-01-11T15:20:07.142327+00:00",
      "type": "tool_call",
      "content": "```json\n{\n  \"id\": \"toolu_01KDVb4jjvvXQexYSWwHbrAk\",\n  \"name\": \"editor\",\n  \"arguments\": {\n    \"operation\": \"read_lines\",\n    \"tab_id\": \"6f13fcb4-562f-4ae1-822a-ba51a8376abe\",\n    \"start_line\": 1100,\n    \"end_line\": 1180\n  }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_01KDVb4jjvvXQexYSWwHbrAk",
          "name": "editor",
          "arguments": {
            "operation": "read_lines",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "start_line": 1100,
            "end_line": 1180
          }
        }
      ]
    },
    {
      "id": "fbc501f5-759b-47b3-be40-ebb1ebe27ac3",
      "timestamp": "2026-01-11T15:20:07.148388+00:00",
      "type": "tool_result",
      "content": "```json\n{\n  \"id\": \"toolu_01KDVb4jjvvXQexYSWwHbrAk\",\n  \"name\": \"editor\",\n  \"content\": \"{\\n  \\\"range\\\": \\\"1100-1180\\\",\\n  \\\"lines\\\": {\\n    \\\"1100\\\": \\\"### Type Predicates\\\",\\n    \\\"1101\\\": \\\"\\\",\\n    \\\"1102\\\": \\\"AIFPL provides comprehensive type checking functions:\\\",\\n    \\\"1103\\\": \\\"\\\",\\n    \\\"1104\\\": \\\"#### Basic Type Predicates\\\",\\n    \\\"1105\\\": \\\"```aifpl\\\",\\n    \\\"1106\\\": \\\"; Number type checking (excludes booleans)\\\",\\n    \\\"1107\\\": \\\"(number? 42)                          ; \\\\u2192 #t\\\",\\n    \\\"1108\\\": \\\"(number? 3.14)                        ; \\\\u2192 #t\\\",\\n    \\\"1109\\\": \\\"(number? (+ 1 j))                     ; \\\\u2192 #t (complex)\\\",\\n    \\\"1110\\\": \\\"(number? #t)                          ; \\\\u2192 #f (booleans are not numbers)\\\",\\n    \\\"1111\\\": \\\"(number? \\\\\\\"42\\\\\\\")                        ; \\\\u2192 #f\\\",\\n    \\\"1112\\\": \\\"\\\",\\n    \\\"1113\\\": \\\"; Specific numeric type checking\\\",\\n    \\\"1114\\\": \\\"(integer? 42)                         ; \\\\u2192 #t\\\",\\n    \\\"1115\\\": \\\"(integer? 3.14)                       ; \\\\u2192 #f\\\",\\n    \\\"1116\\\": \\\"(integer? #t)                         ; \\\\u2192 #f (booleans excluded)\\\",\\n    \\\"1117\\\": \\\"\\\",\\n    \\\"1118\\\": \\\"(float? 3.14)                         ; \\\\u2192 #t\\\",\\n    \\\"1119\\\": \\\"(float? 42)                           ; \\\\u2192 #f\\\",\\n    \\\"1120\\\": \\\"(float? (/ 1 2))                      ; \\\\u2192 #t (division produces float)\\\",\\n    \\\"1121\\\": \\\"\\\",\\n    \\\"1122\\\": \\\"(complex? (+ 1 j))                    ; \\\\u2192 #t\\\",\\n    \\\"1123\\\": \\\"(complex? 42)                         ; \\\\u2192 #f\\\",\\n    \\\"1124\\\": \\\"(complex? 3.14)                       ; \\\\u2192 #f\\\",\\n    \\\"1125\\\": \\\"```\\\",\\n    \\\"1126\\\": \\\"\\\",\\n    \\\"1127\\\": \\\"#### Other Type Predicates\\\",\\n    \\\"1128\\\": \\\"```aifpl\\\",\\n    \\\"1129\\\": \\\"; String type checking\\\",\\n    \\\"1130\\\": \\\"(string? \\\\\\\"hello\\\\\\\")                     ; \\\\u2192 #t\\\",\\n    \\\"1131\\\": \\\"(string? 42)                          ; \\\\u2192 #f\\\",\\n    \\\"1132\\\": \\\"(string? (number->string 42))         ; \\\\u2192 #t\\\",\\n    \\\"1133\\\": \\\"\\\",\\n    \\\"1134\\\": \\\"; Boolean type checking\\\",\\n    \\\"1135\\\": \\\"(boolean? #t)                         ; \\\\u2192 #t\\\",\\n    \\\"1136\\\": \\\"(boolean? #f)                         ; \\\\u2192 #t\\\",\\n    \\\"1137\\\": \\\"(boolean? 1)                          ; \\\\u2192 #f\\\",\\n    \\\"1138\\\": \\\"(boolean? 0)                          ; \\\\u2192 #f\\\",\\n    \\\"1139\\\": \\\"\\\",\\n    \\\"1140\\\": \\\"; Function type checking\\\",\\n    \\\"1141\\\": \\\"(function? (lambda (x) (* x 2)))      ; \\\\u2192 #t\\\",\\n    \\\"1142\\\": \\\"(function? +)                         ; \\\\u2192 #t\\\",\\n    \\\"1143\\\": \\\"(function? \\\\\\\"hello\\\\\\\")                   ; \\\\u2192 #f\\\",\\n    \\\"1144\\\": \\\"\\\",\\n    \\\"1145\\\": \\\"; List type checking (already existed)\\\",\\n    \\\"1146\\\": \\\"(list? (list 1 2 3))                 ; \\\\u2192 #t\\\",\\n    \\\"1147\\\": \\\"(list? \\\\\\\"hello\\\\\\\")                       ; \\\\u2192 #f\\\",\\n    \\\"1148\\\": \\\"(list? ())                            ; \\\\u2192 #t (empty list)\\\",\\n    \\\"1149\\\": \\\"```\\\",\\n    \\\"1150\\\": \\\"\\\",\\n    \\\"1151\\\": \\\"#### Type Predicate Usage Patterns\\\",\\n    \\\"1152\\\": \\\"```aifpl\\\",\\n    \\\"1153\\\": \\\"; Conditional type handling\\\",\\n    \\\"1154\\\": \\\"(let ((process-value (lambda (x)\\\",\\n    \\\"1155\\\": \\\"                       (if (number? x)\\\",\\n    \\\"1156\\\": \\\"                           (* x 2)\\\",\\n    \\\"1157\\\": \\\"                           (if (string? x)\\\",\\n    \\\"1158\\\": \\\"                               (string-upcase x)\\\",\\n    \\\"1159\\\": \\\"                               \\\\\\\"unknown type\\\\\\\")))))\\\",\\n    \\\"1160\\\": \\\"  (list (process-value 5)             ; \\\\u2192 10\\\",\\n    \\\"1161\\\": \\\"        (process-value \\\\\\\"hello\\\\\\\")       ; \\\\u2192 \\\\\\\"HELLO\\\\\\\"\\\",\\n    \\\"1162\\\": \\\"        (process-value #t)))          ; \\\\u2192 \\\\\\\"unknown type\\\\\\\"\\\",\\n    \\\"1163\\\": \\\"\\\",\\n    \\\"1164\\\": \\\"; Type validation\\\",\\n    \\\"1165\\\": \\\"(let ((validate-numbers (lambda (lst)\\\",\\n    \\\"1166\\\": \\\"                          (if (all? number? lst)\\\",\\n    \\\"1167\\\": \\\"                              (fold + 0 lst)\\\",\\n    \\\"1168\\\": \\\"                              \\\\\\\"error: non-numeric values found\\\\\\\"))))\\\",\\n    \\\"1169\\\": \\\"  (list (validate-numbers (list 1 2 3))      ; \\\\u2192 6\\\",\\n    \\\"1170\\\": \\\"        (validate-numbers (list 1 \\\\\\\"x\\\\\\\" 3))))  ; \\\\u2192 \\\\\\\"error: non-numeric values found\\\\\\\"\\\",\\n    \\\"1171\\\": \\\"\\\",\\n    \\\"1172\\\": \\\"; Polymorphic operations\\\",\\n    \\\"1173\\\": \\\"(let ((safe-length (lambda (x)\\\",\\n    \\\"1174\\\": \\\"                     (if (string? x)\\\",\\n    \\\"1175\\\": \\\"                         (string-length x)\\\",\\n    \\\"1176\\\": \\\"                         (if (list? x)\\\",\\n    \\\"1177\\\": \\\"                             (length x)\\\",\\n    \\\"1178\\\": \\\"                             \\\\\\\"not a sequence\\\\\\\")))))\\\",\\n    \\\"1179\\\": \\\"  (list (safe-length \\\\\\\"hello\\\\\\\")         ; \\\\u2192 5\\\",\\n    \\\"1180\\\": \\\"        (safe-length (list 1 2 3))    ; \\\\u2192 3\\\"\\n  }\\n}\",\n  \"error\": null\n}\n```\n`content` is:\n```json\n{\n  \"range\": \"1100-1180\",\n  \"lines\": {\n    \"1100\": \"### Type Predicates\",\n    \"1101\": \"\",\n    \"1102\": \"AIFPL provides comprehensive type checking functions:\",\n    \"1103\": \"\",\n    \"1104\": \"#### Basic Type Predicates\",\n    \"1105\": \"```aifpl\",\n    \"1106\": \"; Number type checking (excludes booleans)\",\n    \"1107\": \"(number? 42)                          ; \\u2192 #t\",\n    \"1108\": \"(number? 3.14)                        ; \\u2192 #t\",\n    \"1109\": \"(number? (+ 1 j))                     ; \\u2192 #t (complex)\",\n    \"1110\": \"(number? #t)                          ; \\u2192 #f (booleans are not numbers)\",\n    \"1111\": \"(number? \\\"42\\\")                        ; \\u2192 #f\",\n    \"1112\": \"\",\n    \"1113\": \"; Specific numeric type checking\",\n    \"1114\": \"(integer? 42)                         ; \\u2192 #t\",\n    \"1115\": \"(integer? 3.14)                       ; \\u2192 #f\",\n    \"1116\": \"(integer? #t)                         ; \\u2192 #f (booleans excluded)\",\n    \"1117\": \"\",\n    \"1118\": \"(float? 3.14)                         ; \\u2192 #t\",\n    \"1119\": \"(float? 42)                           ; \\u2192 #f\",\n    \"1120\": \"(float? (/ 1 2))                      ; \\u2192 #t (division produces float)\",\n    \"1121\": \"\",\n    \"1122\": \"(complex? (+ 1 j))                    ; \\u2192 #t\",\n    \"1123\": \"(complex? 42)                         ; \\u2192 #f\",\n    \"1124\": \"(complex? 3.14)                       ; \\u2192 #f\",\n    \"1125\": \"```\",\n    \"1126\": \"\",\n    \"1127\": \"#### Other Type Predicates\",\n    \"1128\": \"```aifpl\",\n    \"1129\": \"; String type checking\",\n    \"1130\": \"(string? \\\"hello\\\")                     ; \\u2192 #t\",\n    \"1131\": \"(string? 42)                          ; \\u2192 #f\",\n    \"1132\": \"(string? (number->string 42))         ; \\u2192 #t\",\n    \"1133\": \"\",\n    \"1134\": \"; Boolean type checking\",\n    \"1135\": \"(boolean? #t)                         ; \\u2192 #t\",\n    \"1136\": \"(boolean? #f)                         ; \\u2192 #t\",\n    \"1137\": \"(boolean? 1)                          ; \\u2192 #f\",\n    \"1138\": \"(boolean? 0)                          ; \\u2192 #f\",\n    \"1139\": \"\",\n    \"1140\": \"; Function type checking\",\n    \"1141\": \"(function? (lambda (x) (* x 2)))      ; \\u2192 #t\",\n    \"1142\": \"(function? +)                         ; \\u2192 #t\",\n    \"1143\": \"(function? \\\"hello\\\")                   ; \\u2192 #f\",\n    \"1144\": \"\",\n    \"1145\": \"; List type checking (already existed)\",\n    \"1146\": \"(list? (list 1 2 3))                 ; \\u2192 #t\",\n    \"1147\": \"(list? \\\"hello\\\")                       ; \\u2192 #f\",\n    \"1148\": \"(list? ())                            ; \\u2192 #t (empty list)\",\n    \"1149\": \"```\",\n    \"1150\": \"\",\n    \"1151\": \"#### Type Predicate Usage Patterns\",\n    \"1152\": \"```aifpl\",\n    \"1153\": \"; Conditional type handling\",\n    \"1154\": \"(let ((process-value (lambda (x)\",\n    \"1155\": \"                       (if (number? x)\",\n    \"1156\": \"                           (* x 2)\",\n    \"1157\": \"                           (if (string? x)\",\n    \"1158\": \"                               (string-upcase x)\",\n    \"1159\": \"                               \\\"unknown type\\\")))))\",\n    \"1160\": \"  (list (process-value 5)             ; \\u2192 10\",\n    \"1161\": \"        (process-value \\\"hello\\\")       ; \\u2192 \\\"HELLO\\\"\",\n    \"1162\": \"        (process-value #t)))          ; \\u2192 \\\"unknown type\\\"\",\n    \"1163\": \"\",\n    \"1164\": \"; Type validation\",\n    \"1165\": \"(let ((validate-numbers (lambda (lst)\",\n    \"1166\": \"                          (if (all? number? lst)\",\n    \"1167\": \"                              (fold + 0 lst)\",\n    \"1168\": \"                              \\\"error: non-numeric values found\\\"))))\",\n    \"1169\": \"  (list (validate-numbers (list 1 2 3))      ; \\u2192 6\",\n    \"1170\": \"        (validate-numbers (list 1 \\\"x\\\" 3))))  ; \\u2192 \\\"error: non-numeric values found\\\"\",\n    \"1171\": \"\",\n    \"1172\": \"; Polymorphic operations\",\n    \"1173\": \"(let ((safe-length (lambda (x)\",\n    \"1174\": \"                     (if (string? x)\",\n    \"1175\": \"                         (string-length x)\",\n    \"1176\": \"                         (if (list? x)\",\n    \"1177\": \"                             (length x)\",\n    \"1178\": \"                             \\\"not a sequence\\\")))))\",\n    \"1179\": \"  (list (safe-length \\\"hello\\\")         ; \\u2192 5\",\n    \"1180\": \"        (safe-length (list 1 2 3))    ; \\u2192 3\"\n  }\n}\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01KDVb4jjvvXQexYSWwHbrAk",
          "name": "editor",
          "content": "{\n  \"range\": \"1100-1180\",\n  \"lines\": {\n    \"1100\": \"### Type Predicates\",\n    \"1101\": \"\",\n    \"1102\": \"AIFPL provides comprehensive type checking functions:\",\n    \"1103\": \"\",\n    \"1104\": \"#### Basic Type Predicates\",\n    \"1105\": \"```aifpl\",\n    \"1106\": \"; Number type checking (excludes booleans)\",\n    \"1107\": \"(number? 42)                          ; \\u2192 #t\",\n    \"1108\": \"(number? 3.14)                        ; \\u2192 #t\",\n    \"1109\": \"(number? (+ 1 j))                     ; \\u2192 #t (complex)\",\n    \"1110\": \"(number? #t)                          ; \\u2192 #f (booleans are not numbers)\",\n    \"1111\": \"(number? \\\"42\\\")                        ; \\u2192 #f\",\n    \"1112\": \"\",\n    \"1113\": \"; Specific numeric type checking\",\n    \"1114\": \"(integer? 42)                         ; \\u2192 #t\",\n    \"1115\": \"(integer? 3.14)                       ; \\u2192 #f\",\n    \"1116\": \"(integer? #t)                         ; \\u2192 #f (booleans excluded)\",\n    \"1117\": \"\",\n    \"1118\": \"(float? 3.14)                         ; \\u2192 #t\",\n    \"1119\": \"(float? 42)                           ; \\u2192 #f\",\n    \"1120\": \"(float? (/ 1 2))                      ; \\u2192 #t (division produces float)\",\n    \"1121\": \"\",\n    \"1122\": \"(complex? (+ 1 j))                    ; \\u2192 #t\",\n    \"1123\": \"(complex? 42)                         ; \\u2192 #f\",\n    \"1124\": \"(complex? 3.14)                       ; \\u2192 #f\",\n    \"1125\": \"```\",\n    \"1126\": \"\",\n    \"1127\": \"#### Other Type Predicates\",\n    \"1128\": \"```aifpl\",\n    \"1129\": \"; String type checking\",\n    \"1130\": \"(string? \\\"hello\\\")                     ; \\u2192 #t\",\n    \"1131\": \"(string? 42)                          ; \\u2192 #f\",\n    \"1132\": \"(string? (number->string 42))         ; \\u2192 #t\",\n    \"1133\": \"\",\n    \"1134\": \"; Boolean type checking\",\n    \"1135\": \"(boolean? #t)                         ; \\u2192 #t\",\n    \"1136\": \"(boolean? #f)                         ; \\u2192 #t\",\n    \"1137\": \"(boolean? 1)                          ; \\u2192 #f\",\n    \"1138\": \"(boolean? 0)                          ; \\u2192 #f\",\n    \"1139\": \"\",\n    \"1140\": \"; Function type checking\",\n    \"1141\": \"(function? (lambda (x) (* x 2)))      ; \\u2192 #t\",\n    \"1142\": \"(function? +)                         ; \\u2192 #t\",\n    \"1143\": \"(function? \\\"hello\\\")                   ; \\u2192 #f\",\n    \"1144\": \"\",\n    \"1145\": \"; List type checking (already existed)\",\n    \"1146\": \"(list? (list 1 2 3))                 ; \\u2192 #t\",\n    \"1147\": \"(list? \\\"hello\\\")                       ; \\u2192 #f\",\n    \"1148\": \"(list? ())                            ; \\u2192 #t (empty list)\",\n    \"1149\": \"```\",\n    \"1150\": \"\",\n    \"1151\": \"#### Type Predicate Usage Patterns\",\n    \"1152\": \"```aifpl\",\n    \"1153\": \"; Conditional type handling\",\n    \"1154\": \"(let ((process-value (lambda (x)\",\n    \"1155\": \"                       (if (number? x)\",\n    \"1156\": \"                           (* x 2)\",\n    \"1157\": \"                           (if (string? x)\",\n    \"1158\": \"                               (string-upcase x)\",\n    \"1159\": \"                               \\\"unknown type\\\")))))\",\n    \"1160\": \"  (list (process-value 5)             ; \\u2192 10\",\n    \"1161\": \"        (process-value \\\"hello\\\")       ; \\u2192 \\\"HELLO\\\"\",\n    \"1162\": \"        (process-value #t)))          ; \\u2192 \\\"unknown type\\\"\",\n    \"1163\": \"\",\n    \"1164\": \"; Type validation\",\n    \"1165\": \"(let ((validate-numbers (lambda (lst)\",\n    \"1166\": \"                          (if (all? number? lst)\",\n    \"1167\": \"                              (fold + 0 lst)\",\n    \"1168\": \"                              \\\"error: non-numeric values found\\\"))))\",\n    \"1169\": \"  (list (validate-numbers (list 1 2 3))      ; \\u2192 6\",\n    \"1170\": \"        (validate-numbers (list 1 \\\"x\\\" 3))))  ; \\u2192 \\\"error: non-numeric values found\\\"\",\n    \"1171\": \"\",\n    \"1172\": \"; Polymorphic operations\",\n    \"1173\": \"(let ((safe-length (lambda (x)\",\n    \"1174\": \"                     (if (string? x)\",\n    \"1175\": \"                         (string-length x)\",\n    \"1176\": \"                         (if (list? x)\",\n    \"1177\": \"                             (length x)\",\n    \"1178\": \"                             \\\"not a sequence\\\")))))\",\n    \"1179\": \"  (list (safe-length \\\"hello\\\")         ; \\u2192 5\",\n    \"1180\": \"        (safe-length (list 1 2 3))    ; \\u2192 3\"\n  }\n}",
          "error": null
        }
      ]
    },
    {
      "id": "909211e2-a2f7-4264-9806-207b1c48fa51",
      "timestamp": "2026-01-11T15:20:07.152766+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01KDVb4jjvvXQexYSWwHbrAk",
          "name": "editor",
          "content": "{\n  \"range\": \"1100-1180\",\n  \"lines\": {\n    \"1100\": \"### Type Predicates\",\n    \"1101\": \"\",\n    \"1102\": \"AIFPL provides comprehensive type checking functions:\",\n    \"1103\": \"\",\n    \"1104\": \"#### Basic Type Predicates\",\n    \"1105\": \"```aifpl\",\n    \"1106\": \"; Number type checking (excludes booleans)\",\n    \"1107\": \"(number? 42)                          ; \\u2192 #t\",\n    \"1108\": \"(number? 3.14)                        ; \\u2192 #t\",\n    \"1109\": \"(number? (+ 1 j))                     ; \\u2192 #t (complex)\",\n    \"1110\": \"(number? #t)                          ; \\u2192 #f (booleans are not numbers)\",\n    \"1111\": \"(number? \\\"42\\\")                        ; \\u2192 #f\",\n    \"1112\": \"\",\n    \"1113\": \"; Specific numeric type checking\",\n    \"1114\": \"(integer? 42)                         ; \\u2192 #t\",\n    \"1115\": \"(integer? 3.14)                       ; \\u2192 #f\",\n    \"1116\": \"(integer? #t)                         ; \\u2192 #f (booleans excluded)\",\n    \"1117\": \"\",\n    \"1118\": \"(float? 3.14)                         ; \\u2192 #t\",\n    \"1119\": \"(float? 42)                           ; \\u2192 #f\",\n    \"1120\": \"(float? (/ 1 2))                      ; \\u2192 #t (division produces float)\",\n    \"1121\": \"\",\n    \"1122\": \"(complex? (+ 1 j))                    ; \\u2192 #t\",\n    \"1123\": \"(complex? 42)                         ; \\u2192 #f\",\n    \"1124\": \"(complex? 3.14)                       ; \\u2192 #f\",\n    \"1125\": \"```\",\n    \"1126\": \"\",\n    \"1127\": \"#### Other Type Predicates\",\n    \"1128\": \"```aifpl\",\n    \"1129\": \"; String type checking\",\n    \"1130\": \"(string? \\\"hello\\\")                     ; \\u2192 #t\",\n    \"1131\": \"(string? 42)                          ; \\u2192 #f\",\n    \"1132\": \"(string? (number->string 42))         ; \\u2192 #t\",\n    \"1133\": \"\",\n    \"1134\": \"; Boolean type checking\",\n    \"1135\": \"(boolean? #t)                         ; \\u2192 #t\",\n    \"1136\": \"(boolean? #f)                         ; \\u2192 #t\",\n    \"1137\": \"(boolean? 1)                          ; \\u2192 #f\",\n    \"1138\": \"(boolean? 0)                          ; \\u2192 #f\",\n    \"1139\": \"\",\n    \"1140\": \"; Function type checking\",\n    \"1141\": \"(function? (lambda (x) (* x 2)))      ; \\u2192 #t\",\n    \"1142\": \"(function? +)                         ; \\u2192 #t\",\n    \"1143\": \"(function? \\\"hello\\\")                   ; \\u2192 #f\",\n    \"1144\": \"\",\n    \"1145\": \"; List type checking (already existed)\",\n    \"1146\": \"(list? (list 1 2 3))                 ; \\u2192 #t\",\n    \"1147\": \"(list? \\\"hello\\\")                       ; \\u2192 #f\",\n    \"1148\": \"(list? ())                            ; \\u2192 #t (empty list)\",\n    \"1149\": \"```\",\n    \"1150\": \"\",\n    \"1151\": \"#### Type Predicate Usage Patterns\",\n    \"1152\": \"```aifpl\",\n    \"1153\": \"; Conditional type handling\",\n    \"1154\": \"(let ((process-value (lambda (x)\",\n    \"1155\": \"                       (if (number? x)\",\n    \"1156\": \"                           (* x 2)\",\n    \"1157\": \"                           (if (string? x)\",\n    \"1158\": \"                               (string-upcase x)\",\n    \"1159\": \"                               \\\"unknown type\\\")))))\",\n    \"1160\": \"  (list (process-value 5)             ; \\u2192 10\",\n    \"1161\": \"        (process-value \\\"hello\\\")       ; \\u2192 \\\"HELLO\\\"\",\n    \"1162\": \"        (process-value #t)))          ; \\u2192 \\\"unknown type\\\"\",\n    \"1163\": \"\",\n    \"1164\": \"; Type validation\",\n    \"1165\": \"(let ((validate-numbers (lambda (lst)\",\n    \"1166\": \"                          (if (all? number? lst)\",\n    \"1167\": \"                              (fold + 0 lst)\",\n    \"1168\": \"                              \\\"error: non-numeric values found\\\"))))\",\n    \"1169\": \"  (list (validate-numbers (list 1 2 3))      ; \\u2192 6\",\n    \"1170\": \"        (validate-numbers (list 1 \\\"x\\\" 3))))  ; \\u2192 \\\"error: non-numeric values found\\\"\",\n    \"1171\": \"\",\n    \"1172\": \"; Polymorphic operations\",\n    \"1173\": \"(let ((safe-length (lambda (x)\",\n    \"1174\": \"                     (if (string? x)\",\n    \"1175\": \"                         (string-length x)\",\n    \"1176\": \"                         (if (list? x)\",\n    \"1177\": \"                             (length x)\",\n    \"1178\": \"                             \\\"not a sequence\\\")))))\",\n    \"1179\": \"  (list (safe-length \\\"hello\\\")         ; \\u2192 5\",\n    \"1180\": \"        (safe-length (list 1 2 3))    ; \\u2192 3\"\n  }\n}",
          "error": null
        }
      ]
    },
    {
      "id": "758b8c2a-faf6-4448-9dd7-1924f0bda146",
      "timestamp": "2026-01-11T15:20:09.771913+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "358f178b-d500-494d-b2e0-b373713dd5b6",
      "timestamp": "2026-01-11T15:20:09.780738+00:00",
      "type": "ai_response",
      "content": "No, the Type Predicates section does **NOT** cover `alist?`. It covers:\n- `number?`, `integer?`, `float?`, `complex?`\n- `string?`\n- `boolean?`\n- `function?`\n- `list?`\n\nBut it's missing `alist?`. \n\nHowever, looking at the Alists section (around line 1485), `alist?` is mentioned there. Let me check what the tool description says:\n\nAccording to my tool description, `alist?` should be included in the type predicates. So we need to add `alist?` to the \"Other Type Predicates\" section.\n\nHere's what needs to be added:\n\n```markdown\n; Alist type checking\n(alist? (alist (\"x\" 1)))              ; \u2192 #t\n(alist? (list 1 2 3))                 ; \u2192 #f\n(alist? ())                           ; \u2192 #f\n```\n\nThis should be added in the \"Other Type Predicates\" section, right after the list type checking examples.",
      "completed": true,
      "usage": {
        "prompt_tokens": 42068,
        "completion_tokens": 251,
        "total_tokens": 42319
      },
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "15db0180-e072-4378-afd5-42525c09cc46",
      "timestamp": "2026-01-11T15:20:48.404266+00:00",
      "type": "user_message",
      "content": "why do we have basic an other type predicates anyway? They're all first class",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "d6b9cf7b-65bf-45c2-aaf2-5c0ffa39c535",
      "timestamp": "2026-01-11T15:20:50.427636+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "771c15ec-64c6-41f9-a0d4-d87917c07bd6",
      "timestamp": "2026-01-11T15:20:50.438646+00:00",
      "type": "ai_response",
      "content": "You're absolutely right! That's an arbitrary distinction that doesn't make sense. They're all first-class type predicates with the same level of importance. \n\nThe current structure with \"Basic Type Predicates\" (numeric types) and \"Other Type Predicates\" (everything else) creates an unnecessary hierarchy. \n\nA better organization would be to just have **one section** listing all the type predicates, perhaps grouped logically but without implying some are more \"basic\" than others:\n\n```markdown\n### Type Predicates\n\nAIFPL provides comprehensive type checking functions:\n\n```aifpl\n; Numeric type checking\n(number? 42)                          ; \u2192 #t (any numeric type)\n(number? #t)                          ; \u2192 #f (booleans are not numbers)\n(integer? 42)                         ; \u2192 #t\n(float? 3.14)                         ; \u2192 #t\n(complex? (+ 1 j))                    ; \u2192 #t\n\n; String type checking\n(string? \"hello\")                     ; \u2192 #t\n\n; Boolean type checking\n(boolean? #t)                         ; \u2192 #t\n(boolean? 1)                          ; \u2192 #f\n\n; Collection type checking\n(list? (list 1 2 3))                  ; \u2192 #t\n(alist? (alist (\"x\" 1)))              ; \u2192 #t\n\n; Function type checking\n(function? (lambda (x) (* x 2)))      ; \u2192 #t\n(function? +)                         ; \u2192 #t\n```\n```\n\nThis treats them all equally and groups them by the type they check for, which is much more logical. Should I prepare a diff to flatten this structure?",
      "completed": true,
      "usage": {
        "prompt_tokens": 42339,
        "completion_tokens": 386,
        "total_tokens": 42725
      },
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "a952ad75-e00a-4557-8556-a60d24846af2",
      "timestamp": "2026-01-11T15:21:06.008226+00:00",
      "type": "user_message",
      "content": "great - update the doc to reflect this discussion",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "0be851d4-47f1-42a6-9b27-251f5f040d62",
      "timestamp": "2026-01-11T15:21:08.242024+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "9931705f-5e94-4430-b9c6-a7e99a1fad5d",
      "timestamp": "2026-01-11T15:21:09.398127+00:00",
      "type": "ai_response",
      "content": "",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_01XCZEikpwRVwo2JMobq62Gk",
          "name": "editor",
          "arguments": {
            "operation": "read_lines",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "start_line": 1100,
            "end_line": 1185
          }
        }
      ]
    },
    {
      "id": "b76d1d4f-d0d8-436d-b307-0945b8ab34b6",
      "timestamp": "2026-01-11T15:21:09.407078+00:00",
      "type": "tool_call",
      "content": "```json\n{\n  \"id\": \"toolu_01XCZEikpwRVwo2JMobq62Gk\",\n  \"name\": \"editor\",\n  \"arguments\": {\n    \"operation\": \"read_lines\",\n    \"tab_id\": \"6f13fcb4-562f-4ae1-822a-ba51a8376abe\",\n    \"start_line\": 1100,\n    \"end_line\": 1185\n  }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_01XCZEikpwRVwo2JMobq62Gk",
          "name": "editor",
          "arguments": {
            "operation": "read_lines",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "start_line": 1100,
            "end_line": 1185
          }
        }
      ]
    },
    {
      "id": "2bb9435e-1345-4b03-aecb-e0e141b5627d",
      "timestamp": "2026-01-11T15:21:09.414000+00:00",
      "type": "tool_result",
      "content": "```json\n{\n  \"id\": \"toolu_01XCZEikpwRVwo2JMobq62Gk\",\n  \"name\": \"editor\",\n  \"content\": \"{\\n  \\\"range\\\": \\\"1100-1185\\\",\\n  \\\"lines\\\": {\\n    \\\"1100\\\": \\\"### Type Predicates\\\",\\n    \\\"1101\\\": \\\"\\\",\\n    \\\"1102\\\": \\\"AIFPL provides comprehensive type checking functions:\\\",\\n    \\\"1103\\\": \\\"\\\",\\n    \\\"1104\\\": \\\"#### Basic Type Predicates\\\",\\n    \\\"1105\\\": \\\"```aifpl\\\",\\n    \\\"1106\\\": \\\"; Number type checking (excludes booleans)\\\",\\n    \\\"1107\\\": \\\"(number? 42)                          ; \\\\u2192 #t\\\",\\n    \\\"1108\\\": \\\"(number? 3.14)                        ; \\\\u2192 #t\\\",\\n    \\\"1109\\\": \\\"(number? (+ 1 j))                     ; \\\\u2192 #t (complex)\\\",\\n    \\\"1110\\\": \\\"(number? #t)                          ; \\\\u2192 #f (booleans are not numbers)\\\",\\n    \\\"1111\\\": \\\"(number? \\\\\\\"42\\\\\\\")                        ; \\\\u2192 #f\\\",\\n    \\\"1112\\\": \\\"\\\",\\n    \\\"1113\\\": \\\"; Specific numeric type checking\\\",\\n    \\\"1114\\\": \\\"(integer? 42)                         ; \\\\u2192 #t\\\",\\n    \\\"1115\\\": \\\"(integer? 3.14)                       ; \\\\u2192 #f\\\",\\n    \\\"1116\\\": \\\"(integer? #t)                         ; \\\\u2192 #f (booleans excluded)\\\",\\n    \\\"1117\\\": \\\"\\\",\\n    \\\"1118\\\": \\\"(float? 3.14)                         ; \\\\u2192 #t\\\",\\n    \\\"1119\\\": \\\"(float? 42)                           ; \\\\u2192 #f\\\",\\n    \\\"1120\\\": \\\"(float? (/ 1 2))                      ; \\\\u2192 #t (division produces float)\\\",\\n    \\\"1121\\\": \\\"\\\",\\n    \\\"1122\\\": \\\"(complex? (+ 1 j))                    ; \\\\u2192 #t\\\",\\n    \\\"1123\\\": \\\"(complex? 42)                         ; \\\\u2192 #f\\\",\\n    \\\"1124\\\": \\\"(complex? 3.14)                       ; \\\\u2192 #f\\\",\\n    \\\"1125\\\": \\\"```\\\",\\n    \\\"1126\\\": \\\"\\\",\\n    \\\"1127\\\": \\\"#### Other Type Predicates\\\",\\n    \\\"1128\\\": \\\"```aifpl\\\",\\n    \\\"1129\\\": \\\"; String type checking\\\",\\n    \\\"1130\\\": \\\"(string? \\\\\\\"hello\\\\\\\")                     ; \\\\u2192 #t\\\",\\n    \\\"1131\\\": \\\"(string? 42)                          ; \\\\u2192 #f\\\",\\n    \\\"1132\\\": \\\"(string? (number->string 42))         ; \\\\u2192 #t\\\",\\n    \\\"1133\\\": \\\"\\\",\\n    \\\"1134\\\": \\\"; Boolean type checking\\\",\\n    \\\"1135\\\": \\\"(boolean? #t)                         ; \\\\u2192 #t\\\",\\n    \\\"1136\\\": \\\"(boolean? #f)                         ; \\\\u2192 #t\\\",\\n    \\\"1137\\\": \\\"(boolean? 1)                          ; \\\\u2192 #f\\\",\\n    \\\"1138\\\": \\\"(boolean? 0)                          ; \\\\u2192 #f\\\",\\n    \\\"1139\\\": \\\"\\\",\\n    \\\"1140\\\": \\\"; Function type checking\\\",\\n    \\\"1141\\\": \\\"(function? (lambda (x) (* x 2)))      ; \\\\u2192 #t\\\",\\n    \\\"1142\\\": \\\"(function? +)                         ; \\\\u2192 #t\\\",\\n    \\\"1143\\\": \\\"(function? \\\\\\\"hello\\\\\\\")                   ; \\\\u2192 #f\\\",\\n    \\\"1144\\\": \\\"\\\",\\n    \\\"1145\\\": \\\"; List type checking (already existed)\\\",\\n    \\\"1146\\\": \\\"(list? (list 1 2 3))                 ; \\\\u2192 #t\\\",\\n    \\\"1147\\\": \\\"(list? \\\\\\\"hello\\\\\\\")                       ; \\\\u2192 #f\\\",\\n    \\\"1148\\\": \\\"(list? ())                            ; \\\\u2192 #t (empty list)\\\",\\n    \\\"1149\\\": \\\"```\\\",\\n    \\\"1150\\\": \\\"\\\",\\n    \\\"1151\\\": \\\"#### Type Predicate Usage Patterns\\\",\\n    \\\"1152\\\": \\\"```aifpl\\\",\\n    \\\"1153\\\": \\\"; Conditional type handling\\\",\\n    \\\"1154\\\": \\\"(let ((process-value (lambda (x)\\\",\\n    \\\"1155\\\": \\\"                       (if (number? x)\\\",\\n    \\\"1156\\\": \\\"                           (* x 2)\\\",\\n    \\\"1157\\\": \\\"                           (if (string? x)\\\",\\n    \\\"1158\\\": \\\"                               (string-upcase x)\\\",\\n    \\\"1159\\\": \\\"                               \\\\\\\"unknown type\\\\\\\")))))\\\",\\n    \\\"1160\\\": \\\"  (list (process-value 5)             ; \\\\u2192 10\\\",\\n    \\\"1161\\\": \\\"        (process-value \\\\\\\"hello\\\\\\\")       ; \\\\u2192 \\\\\\\"HELLO\\\\\\\"\\\",\\n    \\\"1162\\\": \\\"        (process-value #t)))          ; \\\\u2192 \\\\\\\"unknown type\\\\\\\"\\\",\\n    \\\"1163\\\": \\\"\\\",\\n    \\\"1164\\\": \\\"; Type validation\\\",\\n    \\\"1165\\\": \\\"(let ((validate-numbers (lambda (lst)\\\",\\n    \\\"1166\\\": \\\"                          (if (all? number? lst)\\\",\\n    \\\"1167\\\": \\\"                              (fold + 0 lst)\\\",\\n    \\\"1168\\\": \\\"                              \\\\\\\"error: non-numeric values found\\\\\\\"))))\\\",\\n    \\\"1169\\\": \\\"  (list (validate-numbers (list 1 2 3))      ; \\\\u2192 6\\\",\\n    \\\"1170\\\": \\\"        (validate-numbers (list 1 \\\\\\\"x\\\\\\\" 3))))  ; \\\\u2192 \\\\\\\"error: non-numeric values found\\\\\\\"\\\",\\n    \\\"1171\\\": \\\"\\\",\\n    \\\"1172\\\": \\\"; Polymorphic operations\\\",\\n    \\\"1173\\\": \\\"(let ((safe-length (lambda (x)\\\",\\n    \\\"1174\\\": \\\"                     (if (string? x)\\\",\\n    \\\"1175\\\": \\\"                         (string-length x)\\\",\\n    \\\"1176\\\": \\\"                         (if (list? x)\\\",\\n    \\\"1177\\\": \\\"                             (length x)\\\",\\n    \\\"1178\\\": \\\"                             \\\\\\\"not a sequence\\\\\\\")))))\\\",\\n    \\\"1179\\\": \\\"  (list (safe-length \\\\\\\"hello\\\\\\\")         ; \\\\u2192 5\\\",\\n    \\\"1180\\\": \\\"        (safe-length (list 1 2 3))    ; \\\\u2192 3\\\",\\n    \\\"1181\\\": \\\"        (safe-length 42)))            ; \\\\u2192 \\\\\\\"not a sequence\\\\\\\"\\\",\\n    \\\"1182\\\": \\\"```\\\",\\n    \\\"1183\\\": \\\"\\\",\\n    \\\"1184\\\": \\\"### Mathematical Functions\\\",\\n    \\\"1185\\\": \\\"- `(sin (* pi 0.5))` \\\\u2192 `1`\\\"\\n  }\\n}\",\n  \"error\": null\n}\n```\n`content` is:\n```json\n{\n  \"range\": \"1100-1185\",\n  \"lines\": {\n    \"1100\": \"### Type Predicates\",\n    \"1101\": \"\",\n    \"1102\": \"AIFPL provides comprehensive type checking functions:\",\n    \"1103\": \"\",\n    \"1104\": \"#### Basic Type Predicates\",\n    \"1105\": \"```aifpl\",\n    \"1106\": \"; Number type checking (excludes booleans)\",\n    \"1107\": \"(number? 42)                          ; \\u2192 #t\",\n    \"1108\": \"(number? 3.14)                        ; \\u2192 #t\",\n    \"1109\": \"(number? (+ 1 j))                     ; \\u2192 #t (complex)\",\n    \"1110\": \"(number? #t)                          ; \\u2192 #f (booleans are not numbers)\",\n    \"1111\": \"(number? \\\"42\\\")                        ; \\u2192 #f\",\n    \"1112\": \"\",\n    \"1113\": \"; Specific numeric type checking\",\n    \"1114\": \"(integer? 42)                         ; \\u2192 #t\",\n    \"1115\": \"(integer? 3.14)                       ; \\u2192 #f\",\n    \"1116\": \"(integer? #t)                         ; \\u2192 #f (booleans excluded)\",\n    \"1117\": \"\",\n    \"1118\": \"(float? 3.14)                         ; \\u2192 #t\",\n    \"1119\": \"(float? 42)                           ; \\u2192 #f\",\n    \"1120\": \"(float? (/ 1 2))                      ; \\u2192 #t (division produces float)\",\n    \"1121\": \"\",\n    \"1122\": \"(complex? (+ 1 j))                    ; \\u2192 #t\",\n    \"1123\": \"(complex? 42)                         ; \\u2192 #f\",\n    \"1124\": \"(complex? 3.14)                       ; \\u2192 #f\",\n    \"1125\": \"```\",\n    \"1126\": \"\",\n    \"1127\": \"#### Other Type Predicates\",\n    \"1128\": \"```aifpl\",\n    \"1129\": \"; String type checking\",\n    \"1130\": \"(string? \\\"hello\\\")                     ; \\u2192 #t\",\n    \"1131\": \"(string? 42)                          ; \\u2192 #f\",\n    \"1132\": \"(string? (number->string 42))         ; \\u2192 #t\",\n    \"1133\": \"\",\n    \"1134\": \"; Boolean type checking\",\n    \"1135\": \"(boolean? #t)                         ; \\u2192 #t\",\n    \"1136\": \"(boolean? #f)                         ; \\u2192 #t\",\n    \"1137\": \"(boolean? 1)                          ; \\u2192 #f\",\n    \"1138\": \"(boolean? 0)                          ; \\u2192 #f\",\n    \"1139\": \"\",\n    \"1140\": \"; Function type checking\",\n    \"1141\": \"(function? (lambda (x) (* x 2)))      ; \\u2192 #t\",\n    \"1142\": \"(function? +)                         ; \\u2192 #t\",\n    \"1143\": \"(function? \\\"hello\\\")                   ; \\u2192 #f\",\n    \"1144\": \"\",\n    \"1145\": \"; List type checking (already existed)\",\n    \"1146\": \"(list? (list 1 2 3))                 ; \\u2192 #t\",\n    \"1147\": \"(list? \\\"hello\\\")                       ; \\u2192 #f\",\n    \"1148\": \"(list? ())                            ; \\u2192 #t (empty list)\",\n    \"1149\": \"```\",\n    \"1150\": \"\",\n    \"1151\": \"#### Type Predicate Usage Patterns\",\n    \"1152\": \"```aifpl\",\n    \"1153\": \"; Conditional type handling\",\n    \"1154\": \"(let ((process-value (lambda (x)\",\n    \"1155\": \"                       (if (number? x)\",\n    \"1156\": \"                           (* x 2)\",\n    \"1157\": \"                           (if (string? x)\",\n    \"1158\": \"                               (string-upcase x)\",\n    \"1159\": \"                               \\\"unknown type\\\")))))\",\n    \"1160\": \"  (list (process-value 5)             ; \\u2192 10\",\n    \"1161\": \"        (process-value \\\"hello\\\")       ; \\u2192 \\\"HELLO\\\"\",\n    \"1162\": \"        (process-value #t)))          ; \\u2192 \\\"unknown type\\\"\",\n    \"1163\": \"\",\n    \"1164\": \"; Type validation\",\n    \"1165\": \"(let ((validate-numbers (lambda (lst)\",\n    \"1166\": \"                          (if (all? number? lst)\",\n    \"1167\": \"                              (fold + 0 lst)\",\n    \"1168\": \"                              \\\"error: non-numeric values found\\\"))))\",\n    \"1169\": \"  (list (validate-numbers (list 1 2 3))      ; \\u2192 6\",\n    \"1170\": \"        (validate-numbers (list 1 \\\"x\\\" 3))))  ; \\u2192 \\\"error: non-numeric values found\\\"\",\n    \"1171\": \"\",\n    \"1172\": \"; Polymorphic operations\",\n    \"1173\": \"(let ((safe-length (lambda (x)\",\n    \"1174\": \"                     (if (string? x)\",\n    \"1175\": \"                         (string-length x)\",\n    \"1176\": \"                         (if (list? x)\",\n    \"1177\": \"                             (length x)\",\n    \"1178\": \"                             \\\"not a sequence\\\")))))\",\n    \"1179\": \"  (list (safe-length \\\"hello\\\")         ; \\u2192 5\",\n    \"1180\": \"        (safe-length (list 1 2 3))    ; \\u2192 3\",\n    \"1181\": \"        (safe-length 42)))            ; \\u2192 \\\"not a sequence\\\"\",\n    \"1182\": \"```\",\n    \"1183\": \"\",\n    \"1184\": \"### Mathematical Functions\",\n    \"1185\": \"- `(sin (* pi 0.5))` \\u2192 `1`\"\n  }\n}\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01XCZEikpwRVwo2JMobq62Gk",
          "name": "editor",
          "content": "{\n  \"range\": \"1100-1185\",\n  \"lines\": {\n    \"1100\": \"### Type Predicates\",\n    \"1101\": \"\",\n    \"1102\": \"AIFPL provides comprehensive type checking functions:\",\n    \"1103\": \"\",\n    \"1104\": \"#### Basic Type Predicates\",\n    \"1105\": \"```aifpl\",\n    \"1106\": \"; Number type checking (excludes booleans)\",\n    \"1107\": \"(number? 42)                          ; \\u2192 #t\",\n    \"1108\": \"(number? 3.14)                        ; \\u2192 #t\",\n    \"1109\": \"(number? (+ 1 j))                     ; \\u2192 #t (complex)\",\n    \"1110\": \"(number? #t)                          ; \\u2192 #f (booleans are not numbers)\",\n    \"1111\": \"(number? \\\"42\\\")                        ; \\u2192 #f\",\n    \"1112\": \"\",\n    \"1113\": \"; Specific numeric type checking\",\n    \"1114\": \"(integer? 42)                         ; \\u2192 #t\",\n    \"1115\": \"(integer? 3.14)                       ; \\u2192 #f\",\n    \"1116\": \"(integer? #t)                         ; \\u2192 #f (booleans excluded)\",\n    \"1117\": \"\",\n    \"1118\": \"(float? 3.14)                         ; \\u2192 #t\",\n    \"1119\": \"(float? 42)                           ; \\u2192 #f\",\n    \"1120\": \"(float? (/ 1 2))                      ; \\u2192 #t (division produces float)\",\n    \"1121\": \"\",\n    \"1122\": \"(complex? (+ 1 j))                    ; \\u2192 #t\",\n    \"1123\": \"(complex? 42)                         ; \\u2192 #f\",\n    \"1124\": \"(complex? 3.14)                       ; \\u2192 #f\",\n    \"1125\": \"```\",\n    \"1126\": \"\",\n    \"1127\": \"#### Other Type Predicates\",\n    \"1128\": \"```aifpl\",\n    \"1129\": \"; String type checking\",\n    \"1130\": \"(string? \\\"hello\\\")                     ; \\u2192 #t\",\n    \"1131\": \"(string? 42)                          ; \\u2192 #f\",\n    \"1132\": \"(string? (number->string 42))         ; \\u2192 #t\",\n    \"1133\": \"\",\n    \"1134\": \"; Boolean type checking\",\n    \"1135\": \"(boolean? #t)                         ; \\u2192 #t\",\n    \"1136\": \"(boolean? #f)                         ; \\u2192 #t\",\n    \"1137\": \"(boolean? 1)                          ; \\u2192 #f\",\n    \"1138\": \"(boolean? 0)                          ; \\u2192 #f\",\n    \"1139\": \"\",\n    \"1140\": \"; Function type checking\",\n    \"1141\": \"(function? (lambda (x) (* x 2)))      ; \\u2192 #t\",\n    \"1142\": \"(function? +)                         ; \\u2192 #t\",\n    \"1143\": \"(function? \\\"hello\\\")                   ; \\u2192 #f\",\n    \"1144\": \"\",\n    \"1145\": \"; List type checking (already existed)\",\n    \"1146\": \"(list? (list 1 2 3))                 ; \\u2192 #t\",\n    \"1147\": \"(list? \\\"hello\\\")                       ; \\u2192 #f\",\n    \"1148\": \"(list? ())                            ; \\u2192 #t (empty list)\",\n    \"1149\": \"```\",\n    \"1150\": \"\",\n    \"1151\": \"#### Type Predicate Usage Patterns\",\n    \"1152\": \"```aifpl\",\n    \"1153\": \"; Conditional type handling\",\n    \"1154\": \"(let ((process-value (lambda (x)\",\n    \"1155\": \"                       (if (number? x)\",\n    \"1156\": \"                           (* x 2)\",\n    \"1157\": \"                           (if (string? x)\",\n    \"1158\": \"                               (string-upcase x)\",\n    \"1159\": \"                               \\\"unknown type\\\")))))\",\n    \"1160\": \"  (list (process-value 5)             ; \\u2192 10\",\n    \"1161\": \"        (process-value \\\"hello\\\")       ; \\u2192 \\\"HELLO\\\"\",\n    \"1162\": \"        (process-value #t)))          ; \\u2192 \\\"unknown type\\\"\",\n    \"1163\": \"\",\n    \"1164\": \"; Type validation\",\n    \"1165\": \"(let ((validate-numbers (lambda (lst)\",\n    \"1166\": \"                          (if (all? number? lst)\",\n    \"1167\": \"                              (fold + 0 lst)\",\n    \"1168\": \"                              \\\"error: non-numeric values found\\\"))))\",\n    \"1169\": \"  (list (validate-numbers (list 1 2 3))      ; \\u2192 6\",\n    \"1170\": \"        (validate-numbers (list 1 \\\"x\\\" 3))))  ; \\u2192 \\\"error: non-numeric values found\\\"\",\n    \"1171\": \"\",\n    \"1172\": \"; Polymorphic operations\",\n    \"1173\": \"(let ((safe-length (lambda (x)\",\n    \"1174\": \"                     (if (string? x)\",\n    \"1175\": \"                         (string-length x)\",\n    \"1176\": \"                         (if (list? x)\",\n    \"1177\": \"                             (length x)\",\n    \"1178\": \"                             \\\"not a sequence\\\")))))\",\n    \"1179\": \"  (list (safe-length \\\"hello\\\")         ; \\u2192 5\",\n    \"1180\": \"        (safe-length (list 1 2 3))    ; \\u2192 3\",\n    \"1181\": \"        (safe-length 42)))            ; \\u2192 \\\"not a sequence\\\"\",\n    \"1182\": \"```\",\n    \"1183\": \"\",\n    \"1184\": \"### Mathematical Functions\",\n    \"1185\": \"- `(sin (* pi 0.5))` \\u2192 `1`\"\n  }\n}",
          "error": null
        }
      ]
    },
    {
      "id": "f331b604-1749-4f15-a4cf-e7c4eea7ca61",
      "timestamp": "2026-01-11T15:21:09.418485+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01XCZEikpwRVwo2JMobq62Gk",
          "name": "editor",
          "content": "{\n  \"range\": \"1100-1185\",\n  \"lines\": {\n    \"1100\": \"### Type Predicates\",\n    \"1101\": \"\",\n    \"1102\": \"AIFPL provides comprehensive type checking functions:\",\n    \"1103\": \"\",\n    \"1104\": \"#### Basic Type Predicates\",\n    \"1105\": \"```aifpl\",\n    \"1106\": \"; Number type checking (excludes booleans)\",\n    \"1107\": \"(number? 42)                          ; \\u2192 #t\",\n    \"1108\": \"(number? 3.14)                        ; \\u2192 #t\",\n    \"1109\": \"(number? (+ 1 j))                     ; \\u2192 #t (complex)\",\n    \"1110\": \"(number? #t)                          ; \\u2192 #f (booleans are not numbers)\",\n    \"1111\": \"(number? \\\"42\\\")                        ; \\u2192 #f\",\n    \"1112\": \"\",\n    \"1113\": \"; Specific numeric type checking\",\n    \"1114\": \"(integer? 42)                         ; \\u2192 #t\",\n    \"1115\": \"(integer? 3.14)                       ; \\u2192 #f\",\n    \"1116\": \"(integer? #t)                         ; \\u2192 #f (booleans excluded)\",\n    \"1117\": \"\",\n    \"1118\": \"(float? 3.14)                         ; \\u2192 #t\",\n    \"1119\": \"(float? 42)                           ; \\u2192 #f\",\n    \"1120\": \"(float? (/ 1 2))                      ; \\u2192 #t (division produces float)\",\n    \"1121\": \"\",\n    \"1122\": \"(complex? (+ 1 j))                    ; \\u2192 #t\",\n    \"1123\": \"(complex? 42)                         ; \\u2192 #f\",\n    \"1124\": \"(complex? 3.14)                       ; \\u2192 #f\",\n    \"1125\": \"```\",\n    \"1126\": \"\",\n    \"1127\": \"#### Other Type Predicates\",\n    \"1128\": \"```aifpl\",\n    \"1129\": \"; String type checking\",\n    \"1130\": \"(string? \\\"hello\\\")                     ; \\u2192 #t\",\n    \"1131\": \"(string? 42)                          ; \\u2192 #f\",\n    \"1132\": \"(string? (number->string 42))         ; \\u2192 #t\",\n    \"1133\": \"\",\n    \"1134\": \"; Boolean type checking\",\n    \"1135\": \"(boolean? #t)                         ; \\u2192 #t\",\n    \"1136\": \"(boolean? #f)                         ; \\u2192 #t\",\n    \"1137\": \"(boolean? 1)                          ; \\u2192 #f\",\n    \"1138\": \"(boolean? 0)                          ; \\u2192 #f\",\n    \"1139\": \"\",\n    \"1140\": \"; Function type checking\",\n    \"1141\": \"(function? (lambda (x) (* x 2)))      ; \\u2192 #t\",\n    \"1142\": \"(function? +)                         ; \\u2192 #t\",\n    \"1143\": \"(function? \\\"hello\\\")                   ; \\u2192 #f\",\n    \"1144\": \"\",\n    \"1145\": \"; List type checking (already existed)\",\n    \"1146\": \"(list? (list 1 2 3))                 ; \\u2192 #t\",\n    \"1147\": \"(list? \\\"hello\\\")                       ; \\u2192 #f\",\n    \"1148\": \"(list? ())                            ; \\u2192 #t (empty list)\",\n    \"1149\": \"```\",\n    \"1150\": \"\",\n    \"1151\": \"#### Type Predicate Usage Patterns\",\n    \"1152\": \"```aifpl\",\n    \"1153\": \"; Conditional type handling\",\n    \"1154\": \"(let ((process-value (lambda (x)\",\n    \"1155\": \"                       (if (number? x)\",\n    \"1156\": \"                           (* x 2)\",\n    \"1157\": \"                           (if (string? x)\",\n    \"1158\": \"                               (string-upcase x)\",\n    \"1159\": \"                               \\\"unknown type\\\")))))\",\n    \"1160\": \"  (list (process-value 5)             ; \\u2192 10\",\n    \"1161\": \"        (process-value \\\"hello\\\")       ; \\u2192 \\\"HELLO\\\"\",\n    \"1162\": \"        (process-value #t)))          ; \\u2192 \\\"unknown type\\\"\",\n    \"1163\": \"\",\n    \"1164\": \"; Type validation\",\n    \"1165\": \"(let ((validate-numbers (lambda (lst)\",\n    \"1166\": \"                          (if (all? number? lst)\",\n    \"1167\": \"                              (fold + 0 lst)\",\n    \"1168\": \"                              \\\"error: non-numeric values found\\\"))))\",\n    \"1169\": \"  (list (validate-numbers (list 1 2 3))      ; \\u2192 6\",\n    \"1170\": \"        (validate-numbers (list 1 \\\"x\\\" 3))))  ; \\u2192 \\\"error: non-numeric values found\\\"\",\n    \"1171\": \"\",\n    \"1172\": \"; Polymorphic operations\",\n    \"1173\": \"(let ((safe-length (lambda (x)\",\n    \"1174\": \"                     (if (string? x)\",\n    \"1175\": \"                         (string-length x)\",\n    \"1176\": \"                         (if (list? x)\",\n    \"1177\": \"                             (length x)\",\n    \"1178\": \"                             \\\"not a sequence\\\")))))\",\n    \"1179\": \"  (list (safe-length \\\"hello\\\")         ; \\u2192 5\",\n    \"1180\": \"        (safe-length (list 1 2 3))    ; \\u2192 3\",\n    \"1181\": \"        (safe-length 42)))            ; \\u2192 \\\"not a sequence\\\"\",\n    \"1182\": \"```\",\n    \"1183\": \"\",\n    \"1184\": \"### Mathematical Functions\",\n    \"1185\": \"- `(sin (* pi 0.5))` \\u2192 `1`\"\n  }\n}",
          "error": null
        }
      ]
    },
    {
      "id": "e414ca8b-8123-4f73-bc65-d03aa59837e3",
      "timestamp": "2026-01-11T15:21:11.422780+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "01836429-8203-4291-9101-af3cce591712",
      "timestamp": "2026-01-11T15:21:11.434504+00:00",
      "type": "ai_response",
      "content": "Now I'll create a diff to update the Type Predicates section to remove the artificial \"Basic\" vs \"Other\" distinction, add `alist?`, and add a Comments section:",
      "completed": true,
      "usage": {
        "prompt_tokens": 44472,
        "completion_tokens": 1013,
        "total_tokens": 45485
      },
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_01QmwyhaKFM4j66JD3nGyGJe",
          "name": "editor",
          "arguments": {
            "operation": "apply_diff",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "diff_content": "--- a/src/aifpl/README.md\n+++ b/src/aifpl/README.md\n@@ -1102,48 +1102,47 @@ AIFPL automatically optimizes tail calls to prevent stack overflow in recursive\n AIFPL provides comprehensive type checking functions:\n \n-#### Basic Type Predicates\n ```aifpl\n-; Number type checking (excludes booleans)\n-(number? 42)                          ; \u2192 #t\n-(number? 3.14)                        ; \u2192 #t\n-(number? (+ 1 j))                     ; \u2192 #t (complex)\n+; Numeric type checking\n+(number? 42)                          ; \u2192 #t (any numeric type)\n (number? #t)                          ; \u2192 #f (booleans are not numbers)\n-(number? \"42\")                        ; \u2192 #f\n-\n-; Specific numeric type checking\n (integer? 42)                         ; \u2192 #t\n (integer? 3.14)                       ; \u2192 #f\n-(integer? #t)                         ; \u2192 #f (booleans excluded)\n-\n (float? 3.14)                         ; \u2192 #t\n (float? 42)                           ; \u2192 #f\n (float? (/ 1 2))                      ; \u2192 #t (division produces float)\n-\n (complex? (+ 1 j))                    ; \u2192 #t\n (complex? 42)                         ; \u2192 #f\n-(complex? 3.14)                       ; \u2192 #f\n-```\n \n-#### Other Type Predicates\n-```aifpl\n ; String type checking\n (string? \"hello\")                     ; \u2192 #t\n (string? 42)                          ; \u2192 #f\n-(string? (number->string 42))         ; \u2192 #t\n \n ; Boolean type checking\n (boolean? #t)                         ; \u2192 #t\n-(boolean? #f)                         ; \u2192 #t\n (boolean? 1)                          ; \u2192 #f\n-(boolean? 0)                          ; \u2192 #f\n+\n+; Collection type checking\n+(list? (list 1 2 3))                  ; \u2192 #t\n+(list? \"hello\")                       ; \u2192 #f\n+(list? ())                            ; \u2192 #t (empty list)\n+(alist? (alist (\"x\" 1)))              ; \u2192 #t\n+(alist? (list 1 2 3))                 ; \u2192 #f\n \n ; Function type checking\n (function? (lambda (x) (* x 2)))      ; \u2192 #t\n (function? +)                         ; \u2192 #t\n-(function? \"hello\")                   ; \u2192 #f\n+```\n \n-; List type checking (already existed)\n-(list? (list 1 2 3))                 ; \u2192 #t\n-(list? \"hello\")                       ; \u2192 #f\n-(list? ())                            ; \u2192 #t (empty list)\n+### Comments\n+\n+AIFPL supports single-line comments using the semicolon (`;`) character:\n+\n+```aifpl\n+; This is a comment\n+(+ 1 2)  ; Calculate sum\n+\n+; Comments can appear anywhere\n+(let ((x 5))  ; Bind x to 5\n+  (* x 2))    ; Double it\n ```\n \n-#### Type Predicate Usage Patterns\n+Comments extend to the end of the line and are ignored during evaluation.\n+\n+### Type Predicate Usage Patterns\n ```aifpl\n ; Conditional type handling"
          }
        }
      ]
    },
    {
      "id": "d7a3ddf0-78d2-45af-a55a-dd05d68a387f",
      "timestamp": "2026-01-11T15:21:23.286822+00:00",
      "type": "tool_call",
      "content": "```json\n{\n  \"id\": \"toolu_01QmwyhaKFM4j66JD3nGyGJe\",\n  \"name\": \"editor\",\n  \"arguments\": {\n    \"operation\": \"apply_diff\",\n    \"tab_id\": \"6f13fcb4-562f-4ae1-822a-ba51a8376abe\",\n    \"diff_content\": \"--- a/src/aifpl/README.md\\n+++ b/src/aifpl/README.md\\n@@ -1102,48 +1102,47 @@ AIFPL automatically optimizes tail calls to prevent stack overflow in recursive\\n AIFPL provides comprehensive type checking functions:\\n \\n-#### Basic Type Predicates\\n ```aifpl\\n-; Number type checking (excludes booleans)\\n-(number? 42)                          ; \\u2192 #t\\n-(number? 3.14)                        ; \\u2192 #t\\n-(number? (+ 1 j))                     ; \\u2192 #t (complex)\\n+; Numeric type checking\\n+(number? 42)                          ; \\u2192 #t (any numeric type)\\n (number? #t)                          ; \\u2192 #f (booleans are not numbers)\\n-(number? \\\"42\\\")                        ; \\u2192 #f\\n-\\n-; Specific numeric type checking\\n (integer? 42)                         ; \\u2192 #t\\n (integer? 3.14)                       ; \\u2192 #f\\n-(integer? #t)                         ; \\u2192 #f (booleans excluded)\\n-\\n (float? 3.14)                         ; \\u2192 #t\\n (float? 42)                           ; \\u2192 #f\\n (float? (/ 1 2))                      ; \\u2192 #t (division produces float)\\n-\\n (complex? (+ 1 j))                    ; \\u2192 #t\\n (complex? 42)                         ; \\u2192 #f\\n-(complex? 3.14)                       ; \\u2192 #f\\n-```\\n \\n-#### Other Type Predicates\\n-```aifpl\\n ; String type checking\\n (string? \\\"hello\\\")                     ; \\u2192 #t\\n (string? 42)                          ; \\u2192 #f\\n-(string? (number->string 42))         ; \\u2192 #t\\n \\n ; Boolean type checking\\n (boolean? #t)                         ; \\u2192 #t\\n-(boolean? #f)                         ; \\u2192 #t\\n (boolean? 1)                          ; \\u2192 #f\\n-(boolean? 0)                          ; \\u2192 #f\\n+\\n+; Collection type checking\\n+(list? (list 1 2 3))                  ; \\u2192 #t\\n+(list? \\\"hello\\\")                       ; \\u2192 #f\\n+(list? ())                            ; \\u2192 #t (empty list)\\n+(alist? (alist (\\\"x\\\" 1)))              ; \\u2192 #t\\n+(alist? (list 1 2 3))                 ; \\u2192 #f\\n \\n ; Function type checking\\n (function? (lambda (x) (* x 2)))      ; \\u2192 #t\\n (function? +)                         ; \\u2192 #t\\n-(function? \\\"hello\\\")                   ; \\u2192 #f\\n+```\\n \\n-; List type checking (already existed)\\n-(list? (list 1 2 3))                 ; \\u2192 #t\\n-(list? \\\"hello\\\")                       ; \\u2192 #f\\n-(list? ())                            ; \\u2192 #t (empty list)\\n+### Comments\\n+\\n+AIFPL supports single-line comments using the semicolon (`;`) character:\\n+\\n+```aifpl\\n+; This is a comment\\n+(+ 1 2)  ; Calculate sum\\n+\\n+; Comments can appear anywhere\\n+(let ((x 5))  ; Bind x to 5\\n+  (* x 2))    ; Double it\\n ```\\n \\n-#### Type Predicate Usage Patterns\\n+Comments extend to the end of the line and are ignored during evaluation.\\n+\\n+### Type Predicate Usage Patterns\\n ```aifpl\\n ; Conditional type handling\"\n  }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_01QmwyhaKFM4j66JD3nGyGJe",
          "name": "editor",
          "arguments": {
            "operation": "apply_diff",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "diff_content": "--- a/src/aifpl/README.md\n+++ b/src/aifpl/README.md\n@@ -1102,48 +1102,47 @@ AIFPL automatically optimizes tail calls to prevent stack overflow in recursive\n AIFPL provides comprehensive type checking functions:\n \n-#### Basic Type Predicates\n ```aifpl\n-; Number type checking (excludes booleans)\n-(number? 42)                          ; \u2192 #t\n-(number? 3.14)                        ; \u2192 #t\n-(number? (+ 1 j))                     ; \u2192 #t (complex)\n+; Numeric type checking\n+(number? 42)                          ; \u2192 #t (any numeric type)\n (number? #t)                          ; \u2192 #f (booleans are not numbers)\n-(number? \"42\")                        ; \u2192 #f\n-\n-; Specific numeric type checking\n (integer? 42)                         ; \u2192 #t\n (integer? 3.14)                       ; \u2192 #f\n-(integer? #t)                         ; \u2192 #f (booleans excluded)\n-\n (float? 3.14)                         ; \u2192 #t\n (float? 42)                           ; \u2192 #f\n (float? (/ 1 2))                      ; \u2192 #t (division produces float)\n-\n (complex? (+ 1 j))                    ; \u2192 #t\n (complex? 42)                         ; \u2192 #f\n-(complex? 3.14)                       ; \u2192 #f\n-```\n \n-#### Other Type Predicates\n-```aifpl\n ; String type checking\n (string? \"hello\")                     ; \u2192 #t\n (string? 42)                          ; \u2192 #f\n-(string? (number->string 42))         ; \u2192 #t\n \n ; Boolean type checking\n (boolean? #t)                         ; \u2192 #t\n-(boolean? #f)                         ; \u2192 #t\n (boolean? 1)                          ; \u2192 #f\n-(boolean? 0)                          ; \u2192 #f\n+\n+; Collection type checking\n+(list? (list 1 2 3))                  ; \u2192 #t\n+(list? \"hello\")                       ; \u2192 #f\n+(list? ())                            ; \u2192 #t (empty list)\n+(alist? (alist (\"x\" 1)))              ; \u2192 #t\n+(alist? (list 1 2 3))                 ; \u2192 #f\n \n ; Function type checking\n (function? (lambda (x) (* x 2)))      ; \u2192 #t\n (function? +)                         ; \u2192 #t\n-(function? \"hello\")                   ; \u2192 #f\n+```\n \n-; List type checking (already existed)\n-(list? (list 1 2 3))                 ; \u2192 #t\n-(list? \"hello\")                       ; \u2192 #f\n-(list? ())                            ; \u2192 #t (empty list)\n+### Comments\n+\n+AIFPL supports single-line comments using the semicolon (`;`) character:\n+\n+```aifpl\n+; This is a comment\n+(+ 1 2)  ; Calculate sum\n+\n+; Comments can appear anywhere\n+(let ((x 5))  ; Bind x to 5\n+  (* x 2))    ; Double it\n ```\n \n-#### Type Predicate Usage Patterns\n+Comments extend to the end of the line and are ignored during evaluation.\n+\n+### Type Predicate Usage Patterns\n ```aifpl\n ; Conditional type handling"
          }
        }
      ],
      "tool_call_context": "Diff content:\n```diff\n--- a/src/aifpl/README.md\n+++ b/src/aifpl/README.md\n@@ -1102,48 +1102,47 @@ AIFPL automatically optimizes tail calls to prevent stack overflow in recursive\n AIFPL provides comprehensive type checking functions:\n \n-#### Basic Type Predicates\n ```aifpl\n-; Number type checking (excludes booleans)\n-(number? 42)                          ; \u2192 #t\n-(number? 3.14)                        ; \u2192 #t\n-(number? (+ 1 j))                     ; \u2192 #t (complex)\n+; Numeric type checking\n+(number? 42)                          ; \u2192 #t (any numeric type)\n (number? #t)                          ; \u2192 #f (booleans are not numbers)\n-(number? \"42\")                        ; \u2192 #f\n-\n-; Specific numeric type checking\n (integer? 42)                         ; \u2192 #t\n (integer? 3.14)                       ; \u2192 #f\n-(integer? #t)                         ; \u2192 #f (booleans excluded)\n-\n (float? 3.14)                         ; \u2192 #t\n (float? 42)                           ; \u2192 #f\n (float? (/ 1 2))                      ; \u2192 #t (division produces float)\n-\n (complex? (+ 1 j))                    ; \u2192 #t\n (complex? 42)                         ; \u2192 #f\n-(complex? 3.14)                       ; \u2192 #f\n-```\n \n-#### Other Type Predicates\n-```aifpl\n ; String type checking\n (string? \"hello\")                     ; \u2192 #t\n (string? 42)                          ; \u2192 #f\n-(string? (number->string 42))         ; \u2192 #t\n \n ; Boolean type checking\n (boolean? #t)                         ; \u2192 #t\n-(boolean? #f)                         ; \u2192 #t\n (boolean? 1)                          ; \u2192 #f\n-(boolean? 0)                          ; \u2192 #f\n+\n+; Collection type checking\n+(list? (list 1 2 3))                  ; \u2192 #t\n+(list? \"hello\")                       ; \u2192 #f\n+(list? ())                            ; \u2192 #t (empty list)\n+(alist? (alist (\"x\" 1)))              ; \u2192 #t\n+(alist? (list 1 2 3))                 ; \u2192 #f\n \n ; Function type checking\n (function? (lambda (x) (* x 2)))      ; \u2192 #t\n (function? +)                         ; \u2192 #t\n-(function? \"hello\")                   ; \u2192 #f\n+```\n \n-; List type checking (already existed)\n-(list? (list 1 2 3))                 ; \u2192 #t\n-(list? \"hello\")                       ; \u2192 #f\n-(list? ())                            ; \u2192 #t (empty list)\n+### Comments\n+\n+AIFPL supports single-line comments using the semicolon (`;`) character:\n+\n+```aifpl\n+; This is a comment\n+(+ 1 2)  ; Calculate sum\n+\n+; Comments can appear anywhere\n+(let ((x 5))  ; Bind x to 5\n+  (* x 2))    ; Double it\n ```\n \n-#### Type Predicate Usage Patterns\n+Comments extend to the end of the line and are ignored during evaluation.\n+\n+### Type Predicate Usage Patterns\n ```aifpl\n ; Conditional type handling\n```"
    },
    {
      "id": "ca78ed90-34aa-4f99-b6dc-c4d36618254f",
      "timestamp": "2026-01-11T15:21:23.299721+00:00",
      "type": "tool_result",
      "content": "```json\n{\n  \"id\": \"toolu_01QmwyhaKFM4j66JD3nGyGJe\",\n  \"name\": \"editor\",\n  \"content\": \"Successfully applied 1 hunk(s)\",\n  \"error\": null\n}\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01QmwyhaKFM4j66JD3nGyGJe",
          "name": "editor",
          "content": "Successfully applied 1 hunk(s)",
          "error": null
        }
      ]
    },
    {
      "id": "9f2c7cd1-3c95-42b3-a40f-5e13f4e6e6eb",
      "timestamp": "2026-01-11T15:21:23.302684+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01QmwyhaKFM4j66JD3nGyGJe",
          "name": "editor",
          "content": "Successfully applied 1 hunk(s)",
          "error": null
        }
      ]
    },
    {
      "id": "6157ad88-1460-4127-9eb5-a6ccddaf4ff9",
      "timestamp": "2026-01-11T15:21:25.284300+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "95637886-651e-4151-bffb-f47156a34611",
      "timestamp": "2026-01-11T15:21:25.321358+00:00",
      "type": "ai_response",
      "content": "Great! Now let me also add a note about \"no side effects\" to the key features section. Let me find it first:",
      "completed": true,
      "usage": {
        "prompt_tokens": 45506,
        "completion_tokens": 141,
        "total_tokens": 45647
      },
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_01Ty87zUxQpvu25tCi5EjF2v",
          "name": "editor",
          "arguments": {
            "operation": "search",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "search_text": "## Features"
          }
        }
      ]
    },
    {
      "id": "82944d95-2bdd-4648-bc9b-a98e133ac018",
      "timestamp": "2026-01-11T15:21:27.295050+00:00",
      "type": "tool_call",
      "content": "```json\n{\n  \"id\": \"toolu_01Ty87zUxQpvu25tCi5EjF2v\",\n  \"name\": \"editor\",\n  \"arguments\": {\n    \"operation\": \"search\",\n    \"tab_id\": \"6f13fcb4-562f-4ae1-822a-ba51a8376abe\",\n    \"search_text\": \"## Features\"\n  }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_01Ty87zUxQpvu25tCi5EjF2v",
          "name": "editor",
          "arguments": {
            "operation": "search",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "search_text": "## Features"
          }
        }
      ]
    },
    {
      "id": "9ecda9d8-f88c-4ac9-b250-b6d01ea612e9",
      "timestamp": "2026-01-11T15:21:27.302920+00:00",
      "type": "tool_result",
      "content": "```json\n{\n  \"id\": \"toolu_01Ty87zUxQpvu25tCi5EjF2v\",\n  \"name\": \"editor\",\n  \"content\": \"{\\n  \\\"search_text\\\": \\\"## Features\\\",\\n  \\\"case_sensitive\\\": false,\\n  \\\"match_count\\\": 1,\\n  \\\"matches\\\": [\\n    {\\n      \\\"line\\\": 5,\\n      \\\"column\\\": 12,\\n      \\\"match_text\\\": \\\"## Features\\\",\\n      \\\"context\\\": \\\"## Features\\\"\\n    }\\n  ]\\n}\",\n  \"error\": null\n}\n```\n`content` is:\n```json\n{\n  \"search_text\": \"## Features\",\n  \"case_sensitive\": false,\n  \"match_count\": 1,\n  \"matches\": [\n    {\n      \"line\": 5,\n      \"column\": 12,\n      \"match_text\": \"## Features\",\n      \"context\": \"## Features\"\n    }\n  ]\n}\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01Ty87zUxQpvu25tCi5EjF2v",
          "name": "editor",
          "content": "{\n  \"search_text\": \"## Features\",\n  \"case_sensitive\": false,\n  \"match_count\": 1,\n  \"matches\": [\n    {\n      \"line\": 5,\n      \"column\": 12,\n      \"match_text\": \"## Features\",\n      \"context\": \"## Features\"\n    }\n  ]\n}",
          "error": null
        }
      ]
    },
    {
      "id": "78656651-4520-44fa-b0bb-70e182c60ce8",
      "timestamp": "2026-01-11T15:21:27.307573+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01Ty87zUxQpvu25tCi5EjF2v",
          "name": "editor",
          "content": "{\n  \"search_text\": \"## Features\",\n  \"case_sensitive\": false,\n  \"match_count\": 1,\n  \"matches\": [\n    {\n      \"line\": 5,\n      \"column\": 12,\n      \"match_text\": \"## Features\",\n      \"context\": \"## Features\"\n    }\n  ]\n}",
          "error": null
        }
      ]
    },
    {
      "id": "dc91df1e-19df-4507-925c-6e6087c6d7de",
      "timestamp": "2026-01-11T15:21:29.747667+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "1acb3c5f-7504-4608-a5df-7f9ebbe90ddd",
      "timestamp": "2026-01-11T15:21:30.721907+00:00",
      "type": "ai_response",
      "content": "",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_013s6aNWZYfm5sXFhZUCQxB3",
          "name": "editor",
          "arguments": {
            "operation": "read_lines",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "start_line": 5,
            "end_line": 40
          }
        }
      ]
    },
    {
      "id": "d1442468-60e5-4f23-8f51-06264c9ece5d",
      "timestamp": "2026-01-11T15:21:30.727886+00:00",
      "type": "tool_call",
      "content": "```json\n{\n  \"id\": \"toolu_013s6aNWZYfm5sXFhZUCQxB3\",\n  \"name\": \"editor\",\n  \"arguments\": {\n    \"operation\": \"read_lines\",\n    \"tab_id\": \"6f13fcb4-562f-4ae1-822a-ba51a8376abe\",\n    \"start_line\": 5,\n    \"end_line\": 40\n  }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_013s6aNWZYfm5sXFhZUCQxB3",
          "name": "editor",
          "arguments": {
            "operation": "read_lines",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "start_line": 5,
            "end_line": 40
          }
        }
      ]
    },
    {
      "id": "fea77bb1-03f9-4ebe-aa8a-9e88b720169e",
      "timestamp": "2026-01-11T15:21:30.732628+00:00",
      "type": "tool_result",
      "content": "```json\n{\n  \"id\": \"toolu_013s6aNWZYfm5sXFhZUCQxB3\",\n  \"name\": \"editor\",\n  \"content\": \"{\\n  \\\"range\\\": \\\"5-40\\\",\\n  \\\"lines\\\": {\\n    \\\"5\\\": \\\"## Features\\\",\\n    \\\"6\\\": \\\"\\\",\\n    \\\"7\\\": \\\"- **Pure list representation**: Everything is data - true homoiconicity like traditional Lisp\\\",\\n    \\\"8\\\": \\\"- **S-expression syntax**: `(function-or-operator arg1 arg2 ...)`\\\",\\n    \\\"9\\\": \\\"- **Quote special form**: `(quote expr)` and shortcut `'expr` for preventing evaluation and creating data literals\\\",\\n    \\\"10\\\": \\\"- **Pattern matching**: Comprehensive pattern matching with structural and type-based patterns\\\",\\n    \\\"11\\\": \\\"- **Mathematical operations**: Arithmetic, trigonometry, logarithms, bitwise operations\\\",\\n    \\\"12\\\": \\\"- **String operations**: Manipulation, searching, conversion with full UTF-8 support\\\",\\n    \\\"13\\\": \\\"- **Boolean operations**: Logic operations with strict type checking\\\",\\n    \\\"14\\\": \\\"- **List operations**: Construction, manipulation, and conversion with heterogeneous support\\\",\\n    \\\"15\\\": \\\"- **Association lists (alists)**: Immutable key-value mappings with O(1) lookup performance\\\",\\n    \\\"16\\\": \\\"- **Conditional evaluation**: `if` expressions with lazy evaluation of branches\\\",\\n    \\\"17\\\": \\\"- **Lazy evaluation**: `and` and `or` perform lazy evaluation of operands\\\",\\n    \\\"18\\\": \\\"- **Lambda expressions**: Anonymous functions with lexical scoping and closures\\\",\\n    \\\"19\\\": \\\"- **Local bindings**: `let` expressions for sequential variable binding\\\",\\n    \\\"20\\\": \\\"- **Higher-order functions**: `map`, `filter`, `fold`, `range`, and more for functional programming\\\",\\n    \\\"21\\\": \\\"- **Tail call optimization**: Automatic optimization for recursive and mutually recursive functions\\\",\\n    \\\"22\\\": \\\"- **Type predicates**: Built-in functions to check value types\\\",\\n    \\\"23\\\": \\\"- **Number formats**: Integers, floats, complex numbers, hex (0xFF), binary (0b1010), octal (0o755)\\\",\\n    \\\"24\\\": \\\"- **String literals**: `\\\\\\\"hello world\\\\\\\"` with escape sequences\\\",\\n    \\\"25\\\": \\\"- **Boolean literals**: `#t` (true) and `#f` (false)\\\",\\n    \\\"26\\\": \\\"- **Constants**: `pi`, `e`, `j` (imaginary unit), `true`, `false`\\\",\\n    \\\"27\\\": \\\"- **Type promotion**: Automatic promotion from int \\\\u2192 float \\\\u2192 complex\\\",\\n    \\\"28\\\": \\\"- **Result simplification**: Complex numbers with negligible imaginary parts become real\\\",\\n    \\\"29\\\": \\\"- **Comments**: `;` introduces comments\\\",\\n    \\\"30\\\": \\\"\\\",\\n    \\\"31\\\": \\\"## Usage\\\",\\n    \\\"32\\\": \\\"\\\",\\n    \\\"33\\\": \\\"### Basic Usage\\\",\\n    \\\"34\\\": \\\"\\\",\\n    \\\"35\\\": \\\"```python\\\",\\n    \\\"36\\\": \\\"from aifpl import AIFPL\\\",\\n    \\\"37\\\": \\\"\\\",\\n    \\\"38\\\": \\\"tool = AIFPL()\\\",\\n    \\\"39\\\": \\\"result = tool.evaluate(\\\\\\\"(+ 1 2 3)\\\\\\\")  # Returns: 6\\\",\\n    \\\"40\\\": \\\"```\\\"\\n  }\\n}\",\n  \"error\": null\n}\n```\n`content` is:\n```json\n{\n  \"range\": \"5-40\",\n  \"lines\": {\n    \"5\": \"## Features\",\n    \"6\": \"\",\n    \"7\": \"- **Pure list representation**: Everything is data - true homoiconicity like traditional Lisp\",\n    \"8\": \"- **S-expression syntax**: `(function-or-operator arg1 arg2 ...)`\",\n    \"9\": \"- **Quote special form**: `(quote expr)` and shortcut `'expr` for preventing evaluation and creating data literals\",\n    \"10\": \"- **Pattern matching**: Comprehensive pattern matching with structural and type-based patterns\",\n    \"11\": \"- **Mathematical operations**: Arithmetic, trigonometry, logarithms, bitwise operations\",\n    \"12\": \"- **String operations**: Manipulation, searching, conversion with full UTF-8 support\",\n    \"13\": \"- **Boolean operations**: Logic operations with strict type checking\",\n    \"14\": \"- **List operations**: Construction, manipulation, and conversion with heterogeneous support\",\n    \"15\": \"- **Association lists (alists)**: Immutable key-value mappings with O(1) lookup performance\",\n    \"16\": \"- **Conditional evaluation**: `if` expressions with lazy evaluation of branches\",\n    \"17\": \"- **Lazy evaluation**: `and` and `or` perform lazy evaluation of operands\",\n    \"18\": \"- **Lambda expressions**: Anonymous functions with lexical scoping and closures\",\n    \"19\": \"- **Local bindings**: `let` expressions for sequential variable binding\",\n    \"20\": \"- **Higher-order functions**: `map`, `filter`, `fold`, `range`, and more for functional programming\",\n    \"21\": \"- **Tail call optimization**: Automatic optimization for recursive and mutually recursive functions\",\n    \"22\": \"- **Type predicates**: Built-in functions to check value types\",\n    \"23\": \"- **Number formats**: Integers, floats, complex numbers, hex (0xFF), binary (0b1010), octal (0o755)\",\n    \"24\": \"- **String literals**: `\\\"hello world\\\"` with escape sequences\",\n    \"25\": \"- **Boolean literals**: `#t` (true) and `#f` (false)\",\n    \"26\": \"- **Constants**: `pi`, `e`, `j` (imaginary unit), `true`, `false`\",\n    \"27\": \"- **Type promotion**: Automatic promotion from int \\u2192 float \\u2192 complex\",\n    \"28\": \"- **Result simplification**: Complex numbers with negligible imaginary parts become real\",\n    \"29\": \"- **Comments**: `;` introduces comments\",\n    \"30\": \"\",\n    \"31\": \"## Usage\",\n    \"32\": \"\",\n    \"33\": \"### Basic Usage\",\n    \"34\": \"\",\n    \"35\": \"```python\",\n    \"36\": \"from aifpl import AIFPL\",\n    \"37\": \"\",\n    \"38\": \"tool = AIFPL()\",\n    \"39\": \"result = tool.evaluate(\\\"(+ 1 2 3)\\\")  # Returns: 6\",\n    \"40\": \"```\"\n  }\n}\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_013s6aNWZYfm5sXFhZUCQxB3",
          "name": "editor",
          "content": "{\n  \"range\": \"5-40\",\n  \"lines\": {\n    \"5\": \"## Features\",\n    \"6\": \"\",\n    \"7\": \"- **Pure list representation**: Everything is data - true homoiconicity like traditional Lisp\",\n    \"8\": \"- **S-expression syntax**: `(function-or-operator arg1 arg2 ...)`\",\n    \"9\": \"- **Quote special form**: `(quote expr)` and shortcut `'expr` for preventing evaluation and creating data literals\",\n    \"10\": \"- **Pattern matching**: Comprehensive pattern matching with structural and type-based patterns\",\n    \"11\": \"- **Mathematical operations**: Arithmetic, trigonometry, logarithms, bitwise operations\",\n    \"12\": \"- **String operations**: Manipulation, searching, conversion with full UTF-8 support\",\n    \"13\": \"- **Boolean operations**: Logic operations with strict type checking\",\n    \"14\": \"- **List operations**: Construction, manipulation, and conversion with heterogeneous support\",\n    \"15\": \"- **Association lists (alists)**: Immutable key-value mappings with O(1) lookup performance\",\n    \"16\": \"- **Conditional evaluation**: `if` expressions with lazy evaluation of branches\",\n    \"17\": \"- **Lazy evaluation**: `and` and `or` perform lazy evaluation of operands\",\n    \"18\": \"- **Lambda expressions**: Anonymous functions with lexical scoping and closures\",\n    \"19\": \"- **Local bindings**: `let` expressions for sequential variable binding\",\n    \"20\": \"- **Higher-order functions**: `map`, `filter`, `fold`, `range`, and more for functional programming\",\n    \"21\": \"- **Tail call optimization**: Automatic optimization for recursive and mutually recursive functions\",\n    \"22\": \"- **Type predicates**: Built-in functions to check value types\",\n    \"23\": \"- **Number formats**: Integers, floats, complex numbers, hex (0xFF), binary (0b1010), octal (0o755)\",\n    \"24\": \"- **String literals**: `\\\"hello world\\\"` with escape sequences\",\n    \"25\": \"- **Boolean literals**: `#t` (true) and `#f` (false)\",\n    \"26\": \"- **Constants**: `pi`, `e`, `j` (imaginary unit), `true`, `false`\",\n    \"27\": \"- **Type promotion**: Automatic promotion from int \\u2192 float \\u2192 complex\",\n    \"28\": \"- **Result simplification**: Complex numbers with negligible imaginary parts become real\",\n    \"29\": \"- **Comments**: `;` introduces comments\",\n    \"30\": \"\",\n    \"31\": \"## Usage\",\n    \"32\": \"\",\n    \"33\": \"### Basic Usage\",\n    \"34\": \"\",\n    \"35\": \"```python\",\n    \"36\": \"from aifpl import AIFPL\",\n    \"37\": \"\",\n    \"38\": \"tool = AIFPL()\",\n    \"39\": \"result = tool.evaluate(\\\"(+ 1 2 3)\\\")  # Returns: 6\",\n    \"40\": \"```\"\n  }\n}",
          "error": null
        }
      ]
    },
    {
      "id": "bdf8e459-7d8a-4784-b885-5e7fa06e6c1a",
      "timestamp": "2026-01-11T15:21:30.736008+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_013s6aNWZYfm5sXFhZUCQxB3",
          "name": "editor",
          "content": "{\n  \"range\": \"5-40\",\n  \"lines\": {\n    \"5\": \"## Features\",\n    \"6\": \"\",\n    \"7\": \"- **Pure list representation**: Everything is data - true homoiconicity like traditional Lisp\",\n    \"8\": \"- **S-expression syntax**: `(function-or-operator arg1 arg2 ...)`\",\n    \"9\": \"- **Quote special form**: `(quote expr)` and shortcut `'expr` for preventing evaluation and creating data literals\",\n    \"10\": \"- **Pattern matching**: Comprehensive pattern matching with structural and type-based patterns\",\n    \"11\": \"- **Mathematical operations**: Arithmetic, trigonometry, logarithms, bitwise operations\",\n    \"12\": \"- **String operations**: Manipulation, searching, conversion with full UTF-8 support\",\n    \"13\": \"- **Boolean operations**: Logic operations with strict type checking\",\n    \"14\": \"- **List operations**: Construction, manipulation, and conversion with heterogeneous support\",\n    \"15\": \"- **Association lists (alists)**: Immutable key-value mappings with O(1) lookup performance\",\n    \"16\": \"- **Conditional evaluation**: `if` expressions with lazy evaluation of branches\",\n    \"17\": \"- **Lazy evaluation**: `and` and `or` perform lazy evaluation of operands\",\n    \"18\": \"- **Lambda expressions**: Anonymous functions with lexical scoping and closures\",\n    \"19\": \"- **Local bindings**: `let` expressions for sequential variable binding\",\n    \"20\": \"- **Higher-order functions**: `map`, `filter`, `fold`, `range`, and more for functional programming\",\n    \"21\": \"- **Tail call optimization**: Automatic optimization for recursive and mutually recursive functions\",\n    \"22\": \"- **Type predicates**: Built-in functions to check value types\",\n    \"23\": \"- **Number formats**: Integers, floats, complex numbers, hex (0xFF), binary (0b1010), octal (0o755)\",\n    \"24\": \"- **String literals**: `\\\"hello world\\\"` with escape sequences\",\n    \"25\": \"- **Boolean literals**: `#t` (true) and `#f` (false)\",\n    \"26\": \"- **Constants**: `pi`, `e`, `j` (imaginary unit), `true`, `false`\",\n    \"27\": \"- **Type promotion**: Automatic promotion from int \\u2192 float \\u2192 complex\",\n    \"28\": \"- **Result simplification**: Complex numbers with negligible imaginary parts become real\",\n    \"29\": \"- **Comments**: `;` introduces comments\",\n    \"30\": \"\",\n    \"31\": \"## Usage\",\n    \"32\": \"\",\n    \"33\": \"### Basic Usage\",\n    \"34\": \"\",\n    \"35\": \"```python\",\n    \"36\": \"from aifpl import AIFPL\",\n    \"37\": \"\",\n    \"38\": \"tool = AIFPL()\",\n    \"39\": \"result = tool.evaluate(\\\"(+ 1 2 3)\\\")  # Returns: 6\",\n    \"40\": \"```\"\n  }\n}",
          "error": null
        }
      ]
    },
    {
      "id": "3d12ffbc-0d96-4b3e-8177-4e7892ffdabb",
      "timestamp": "2026-01-11T15:21:33.126969+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "5eb842a2-a330-4a3d-98b7-614bf5ca747d",
      "timestamp": "2026-01-11T15:21:33.140264+00:00",
      "type": "ai_response",
      "content": "Now let me add the \"no side effects\" feature to the list:",
      "completed": true,
      "usage": {
        "prompt_tokens": 46631,
        "completion_tokens": 289,
        "total_tokens": 46920
      },
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_01HyvJQUzLCE6NAjDvACHJji",
          "name": "editor",
          "arguments": {
            "operation": "apply_diff",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "diff_content": "--- a/src/aifpl/README.md\n+++ b/src/aifpl/README.md\n@@ -5,6 +5,7 @@\n ## Features\n \n - **Pure list representation**: Everything is data - true homoiconicity like traditional Lisp\n+- **Pure functional**: No side effects, immutable data, safe for AI tool integration\n - **S-expression syntax**: `(function-or-operator arg1 arg2 ...)`\n - **Quote special form**: `(quote expr)` and shortcut `'expr` for preventing evaluation and creating data literals\n - **Pattern matching**: Comprehensive pattern matching with structural and type-based patterns"
          }
        }
      ]
    },
    {
      "id": "0cf53a29-90fe-4817-9c9c-5b7374ed4d7e",
      "timestamp": "2026-01-11T15:21:35.980314+00:00",
      "type": "tool_call",
      "content": "```json\n{\n  \"id\": \"toolu_01HyvJQUzLCE6NAjDvACHJji\",\n  \"name\": \"editor\",\n  \"arguments\": {\n    \"operation\": \"apply_diff\",\n    \"tab_id\": \"6f13fcb4-562f-4ae1-822a-ba51a8376abe\",\n    \"diff_content\": \"--- a/src/aifpl/README.md\\n+++ b/src/aifpl/README.md\\n@@ -5,6 +5,7 @@\\n ## Features\\n \\n - **Pure list representation**: Everything is data - true homoiconicity like traditional Lisp\\n+- **Pure functional**: No side effects, immutable data, safe for AI tool integration\\n - **S-expression syntax**: `(function-or-operator arg1 arg2 ...)`\\n - **Quote special form**: `(quote expr)` and shortcut `'expr` for preventing evaluation and creating data literals\\n - **Pattern matching**: Comprehensive pattern matching with structural and type-based patterns\"\n  }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_01HyvJQUzLCE6NAjDvACHJji",
          "name": "editor",
          "arguments": {
            "operation": "apply_diff",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "diff_content": "--- a/src/aifpl/README.md\n+++ b/src/aifpl/README.md\n@@ -5,6 +5,7 @@\n ## Features\n \n - **Pure list representation**: Everything is data - true homoiconicity like traditional Lisp\n+- **Pure functional**: No side effects, immutable data, safe for AI tool integration\n - **S-expression syntax**: `(function-or-operator arg1 arg2 ...)`\n - **Quote special form**: `(quote expr)` and shortcut `'expr` for preventing evaluation and creating data literals\n - **Pattern matching**: Comprehensive pattern matching with structural and type-based patterns"
          }
        }
      ],
      "tool_call_context": "Diff content:\n```diff\n--- a/src/aifpl/README.md\n+++ b/src/aifpl/README.md\n@@ -5,6 +5,7 @@\n ## Features\n \n - **Pure list representation**: Everything is data - true homoiconicity like traditional Lisp\n+- **Pure functional**: No side effects, immutable data, safe for AI tool integration\n - **S-expression syntax**: `(function-or-operator arg1 arg2 ...)`\n - **Quote special form**: `(quote expr)` and shortcut `'expr` for preventing evaluation and creating data literals\n - **Pattern matching**: Comprehensive pattern matching with structural and type-based patterns\n```"
    },
    {
      "id": "e17466c4-891b-4bc2-b759-1cb74790ac3e",
      "timestamp": "2026-01-11T15:21:35.990005+00:00",
      "type": "tool_result",
      "content": "```json\n{\n  \"id\": \"toolu_01HyvJQUzLCE6NAjDvACHJji\",\n  \"name\": \"editor\",\n  \"content\": \"Successfully applied 1 hunk(s)\",\n  \"error\": null\n}\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01HyvJQUzLCE6NAjDvACHJji",
          "name": "editor",
          "content": "Successfully applied 1 hunk(s)",
          "error": null
        }
      ]
    },
    {
      "id": "dcb6e705-c6ec-47d2-9b14-fc06948b48f6",
      "timestamp": "2026-01-11T15:21:35.995415+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01HyvJQUzLCE6NAjDvACHJji",
          "name": "editor",
          "content": "Successfully applied 1 hunk(s)",
          "error": null
        }
      ]
    },
    {
      "id": "7e2f35fd-0bf7-4a6c-aa68-f62e529ab06e",
      "timestamp": "2026-01-11T15:21:38.132676+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "4a9faa59-b578-47fb-82a4-550c5689c40b",
      "timestamp": "2026-01-11T15:21:38.174059+00:00",
      "type": "ai_response",
      "content": "Now let me also check the Design Principles section to see if we need to update it:",
      "completed": true,
      "usage": {
        "prompt_tokens": 46941,
        "completion_tokens": 135,
        "total_tokens": 47076
      },
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_01YbvsMYpPgRwLM7Pe7SqtGU",
          "name": "editor",
          "arguments": {
            "operation": "search",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "search_text": "## Design Principles"
          }
        }
      ]
    },
    {
      "id": "8695dedd-cef8-47e3-b1d6-a2b702fd8ad6",
      "timestamp": "2026-01-11T15:21:39.394593+00:00",
      "type": "tool_call",
      "content": "```json\n{\n  \"id\": \"toolu_01YbvsMYpPgRwLM7Pe7SqtGU\",\n  \"name\": \"editor\",\n  \"arguments\": {\n    \"operation\": \"search\",\n    \"tab_id\": \"6f13fcb4-562f-4ae1-822a-ba51a8376abe\",\n    \"search_text\": \"## Design Principles\"\n  }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_01YbvsMYpPgRwLM7Pe7SqtGU",
          "name": "editor",
          "arguments": {
            "operation": "search",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "search_text": "## Design Principles"
          }
        }
      ]
    },
    {
      "id": "3327dfa8-938b-453e-92dd-e40c8dd8d4e4",
      "timestamp": "2026-01-11T15:21:39.403108+00:00",
      "type": "tool_result",
      "content": "```json\n{\n  \"id\": \"toolu_01YbvsMYpPgRwLM7Pe7SqtGU\",\n  \"name\": \"editor\",\n  \"content\": \"{\\n  \\\"search_text\\\": \\\"## Design Principles\\\",\\n  \\\"case_sensitive\\\": false,\\n  \\\"match_count\\\": 1,\\n  \\\"matches\\\": [\\n    {\\n      \\\"line\\\": 2174,\\n      \\\"column\\\": 21,\\n      \\\"match_text\\\": \\\"## Design Principles\\\",\\n      \\\"context\\\": \\\"## Design Principles\\\"\\n    }\\n  ]\\n}\",\n  \"error\": null\n}\n```\n`content` is:\n```json\n{\n  \"search_text\": \"## Design Principles\",\n  \"case_sensitive\": false,\n  \"match_count\": 1,\n  \"matches\": [\n    {\n      \"line\": 2174,\n      \"column\": 21,\n      \"match_text\": \"## Design Principles\",\n      \"context\": \"## Design Principles\"\n    }\n  ]\n}\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01YbvsMYpPgRwLM7Pe7SqtGU",
          "name": "editor",
          "content": "{\n  \"search_text\": \"## Design Principles\",\n  \"case_sensitive\": false,\n  \"match_count\": 1,\n  \"matches\": [\n    {\n      \"line\": 2174,\n      \"column\": 21,\n      \"match_text\": \"## Design Principles\",\n      \"context\": \"## Design Principles\"\n    }\n  ]\n}",
          "error": null
        }
      ]
    },
    {
      "id": "09991978-4f82-4c43-a27b-0e2cafc5f8dc",
      "timestamp": "2026-01-11T15:21:39.407629+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01YbvsMYpPgRwLM7Pe7SqtGU",
          "name": "editor",
          "content": "{\n  \"search_text\": \"## Design Principles\",\n  \"case_sensitive\": false,\n  \"match_count\": 1,\n  \"matches\": [\n    {\n      \"line\": 2174,\n      \"column\": 21,\n      \"match_text\": \"## Design Principles\",\n      \"context\": \"## Design Principles\"\n    }\n  ]\n}",
          "error": null
        }
      ]
    },
    {
      "id": "7025e6ba-5837-469d-af1b-011730cf0d59",
      "timestamp": "2026-01-11T15:21:41.831504+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "87b67a64-9b32-4aa0-be6a-1c07eb32743b",
      "timestamp": "2026-01-11T15:21:42.711547+00:00",
      "type": "ai_response",
      "content": "",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_0179PF5NjDoskmeY3Go6Ju8K",
          "name": "editor",
          "arguments": {
            "operation": "read_lines",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "start_line": 2174,
            "end_line": 2195
          }
        }
      ]
    },
    {
      "id": "31d78e27-61d1-4216-aa74-36a7d211e181",
      "timestamp": "2026-01-11T15:21:42.716761+00:00",
      "type": "tool_call",
      "content": "```json\n{\n  \"id\": \"toolu_0179PF5NjDoskmeY3Go6Ju8K\",\n  \"name\": \"editor\",\n  \"arguments\": {\n    \"operation\": \"read_lines\",\n    \"tab_id\": \"6f13fcb4-562f-4ae1-822a-ba51a8376abe\",\n    \"start_line\": 2174,\n    \"end_line\": 2195\n  }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_0179PF5NjDoskmeY3Go6Ju8K",
          "name": "editor",
          "arguments": {
            "operation": "read_lines",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "start_line": 2174,
            "end_line": 2195
          }
        }
      ]
    },
    {
      "id": "bc41428c-e3c4-4ebf-a9e9-4e6fe775356b",
      "timestamp": "2026-01-11T15:21:42.721265+00:00",
      "type": "tool_result",
      "content": "```json\n{\n  \"id\": \"toolu_0179PF5NjDoskmeY3Go6Ju8K\",\n  \"name\": \"editor\",\n  \"content\": \"{\\n  \\\"range\\\": \\\"2174-2195\\\",\\n  \\\"lines\\\": {\\n    \\\"2174\\\": \\\"## Design Principles\\\",\\n    \\\"2175\\\": \\\"\\\",\\n    \\\"2176\\\": \\\"1. **Pure List Representation**: Everything is data, following traditional Lisp philosophy\\\",\\n    \\\"2177\\\": \\\"2. **Functional Programming**: First-class functions, immutable data, no side effects\\\",\\n    \\\"2178\\\": \\\"3. **Lexical Scoping**: Variables resolved in their definition environment\\\",\\n    \\\"2179\\\": \\\"4. **Tail Call Optimization**: Automatic optimization for recursive patterns\\\",\\n    \\\"2180\\\": \\\"5. **Type Safety**: Comprehensive type hints and strict type checking\\\",\\n    \\\"2181\\\": \\\"6. **Error Handling**: Detailed error messages with position information\\\",\\n    \\\"2182\\\": \\\"7. **Performance**: Efficient evaluation with automatic optimizations\\\",\\n    \\\"2183\\\": \\\"8. **LISP Compatibility**: Following traditional LISP semantics where applicable\\\",\\n    \\\"2184\\\": \\\"9. **Lazy Evaluation**: Conditionals and boolean operators use lazy evaluation\\\",\\n    \\\"2185\\\": \\\"10. **Independence**: No dependencies on external packages\\\",\\n    \\\"2186\\\": \\\"11. **Simplicity**: Direct S-expression evaluation without over-engineering\\\",\\n    \\\"2187\\\": \\\"12. **Homoiconicity**: Code and data use identical representations\\\",\\n    \\\"2188\\\": \\\"13. **Syntactic Sugar**: Single quote shortcut provides convenient syntax while maintaining pure list representation\\\",\\n    \\\"2189\\\": \\\"14. **Pattern Matching**: Comprehensive pattern matching for elegant data processing\\\",\\n    \\\"2190\\\": \\\"15. **Proper Lists Only**: Lists are backed by Python tuples, no cons cells or improper lists for simplicity and type safety\\\",\\n    \\\"2191\\\": \\\"\\\",\\n    \\\"2192\\\": \\\"## Architecture\\\",\\n    \\\"2193\\\": \\\"\\\",\\n    \\\"2194\\\": \\\"AIFPL uses a **pure list representation** for all code, following traditional Lisp philosophy:\\\"\\n  }\\n}\",\n  \"error\": null\n}\n```\n`content` is:\n```json\n{\n  \"range\": \"2174-2195\",\n  \"lines\": {\n    \"2174\": \"## Design Principles\",\n    \"2175\": \"\",\n    \"2176\": \"1. **Pure List Representation**: Everything is data, following traditional Lisp philosophy\",\n    \"2177\": \"2. **Functional Programming**: First-class functions, immutable data, no side effects\",\n    \"2178\": \"3. **Lexical Scoping**: Variables resolved in their definition environment\",\n    \"2179\": \"4. **Tail Call Optimization**: Automatic optimization for recursive patterns\",\n    \"2180\": \"5. **Type Safety**: Comprehensive type hints and strict type checking\",\n    \"2181\": \"6. **Error Handling**: Detailed error messages with position information\",\n    \"2182\": \"7. **Performance**: Efficient evaluation with automatic optimizations\",\n    \"2183\": \"8. **LISP Compatibility**: Following traditional LISP semantics where applicable\",\n    \"2184\": \"9. **Lazy Evaluation**: Conditionals and boolean operators use lazy evaluation\",\n    \"2185\": \"10. **Independence**: No dependencies on external packages\",\n    \"2186\": \"11. **Simplicity**: Direct S-expression evaluation without over-engineering\",\n    \"2187\": \"12. **Homoiconicity**: Code and data use identical representations\",\n    \"2188\": \"13. **Syntactic Sugar**: Single quote shortcut provides convenient syntax while maintaining pure list representation\",\n    \"2189\": \"14. **Pattern Matching**: Comprehensive pattern matching for elegant data processing\",\n    \"2190\": \"15. **Proper Lists Only**: Lists are backed by Python tuples, no cons cells or improper lists for simplicity and type safety\",\n    \"2191\": \"\",\n    \"2192\": \"## Architecture\",\n    \"2193\": \"\",\n    \"2194\": \"AIFPL uses a **pure list representation** for all code, following traditional Lisp philosophy:\"\n  }\n}\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_0179PF5NjDoskmeY3Go6Ju8K",
          "name": "editor",
          "content": "{\n  \"range\": \"2174-2195\",\n  \"lines\": {\n    \"2174\": \"## Design Principles\",\n    \"2175\": \"\",\n    \"2176\": \"1. **Pure List Representation**: Everything is data, following traditional Lisp philosophy\",\n    \"2177\": \"2. **Functional Programming**: First-class functions, immutable data, no side effects\",\n    \"2178\": \"3. **Lexical Scoping**: Variables resolved in their definition environment\",\n    \"2179\": \"4. **Tail Call Optimization**: Automatic optimization for recursive patterns\",\n    \"2180\": \"5. **Type Safety**: Comprehensive type hints and strict type checking\",\n    \"2181\": \"6. **Error Handling**: Detailed error messages with position information\",\n    \"2182\": \"7. **Performance**: Efficient evaluation with automatic optimizations\",\n    \"2183\": \"8. **LISP Compatibility**: Following traditional LISP semantics where applicable\",\n    \"2184\": \"9. **Lazy Evaluation**: Conditionals and boolean operators use lazy evaluation\",\n    \"2185\": \"10. **Independence**: No dependencies on external packages\",\n    \"2186\": \"11. **Simplicity**: Direct S-expression evaluation without over-engineering\",\n    \"2187\": \"12. **Homoiconicity**: Code and data use identical representations\",\n    \"2188\": \"13. **Syntactic Sugar**: Single quote shortcut provides convenient syntax while maintaining pure list representation\",\n    \"2189\": \"14. **Pattern Matching**: Comprehensive pattern matching for elegant data processing\",\n    \"2190\": \"15. **Proper Lists Only**: Lists are backed by Python tuples, no cons cells or improper lists for simplicity and type safety\",\n    \"2191\": \"\",\n    \"2192\": \"## Architecture\",\n    \"2193\": \"\",\n    \"2194\": \"AIFPL uses a **pure list representation** for all code, following traditional Lisp philosophy:\"\n  }\n}",
          "error": null
        }
      ]
    },
    {
      "id": "f6561b80-8597-4c8b-92b9-e7871fa860e5",
      "timestamp": "2026-01-11T15:21:42.725007+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_0179PF5NjDoskmeY3Go6Ju8K",
          "name": "editor",
          "content": "{\n  \"range\": \"2174-2195\",\n  \"lines\": {\n    \"2174\": \"## Design Principles\",\n    \"2175\": \"\",\n    \"2176\": \"1. **Pure List Representation**: Everything is data, following traditional Lisp philosophy\",\n    \"2177\": \"2. **Functional Programming**: First-class functions, immutable data, no side effects\",\n    \"2178\": \"3. **Lexical Scoping**: Variables resolved in their definition environment\",\n    \"2179\": \"4. **Tail Call Optimization**: Automatic optimization for recursive patterns\",\n    \"2180\": \"5. **Type Safety**: Comprehensive type hints and strict type checking\",\n    \"2181\": \"6. **Error Handling**: Detailed error messages with position information\",\n    \"2182\": \"7. **Performance**: Efficient evaluation with automatic optimizations\",\n    \"2183\": \"8. **LISP Compatibility**: Following traditional LISP semantics where applicable\",\n    \"2184\": \"9. **Lazy Evaluation**: Conditionals and boolean operators use lazy evaluation\",\n    \"2185\": \"10. **Independence**: No dependencies on external packages\",\n    \"2186\": \"11. **Simplicity**: Direct S-expression evaluation without over-engineering\",\n    \"2187\": \"12. **Homoiconicity**: Code and data use identical representations\",\n    \"2188\": \"13. **Syntactic Sugar**: Single quote shortcut provides convenient syntax while maintaining pure list representation\",\n    \"2189\": \"14. **Pattern Matching**: Comprehensive pattern matching for elegant data processing\",\n    \"2190\": \"15. **Proper Lists Only**: Lists are backed by Python tuples, no cons cells or improper lists for simplicity and type safety\",\n    \"2191\": \"\",\n    \"2192\": \"## Architecture\",\n    \"2193\": \"\",\n    \"2194\": \"AIFPL uses a **pure list representation** for all code, following traditional Lisp philosophy:\"\n  }\n}",
          "error": null
        }
      ]
    },
    {
      "id": "c705dc0f-ab04-4eef-9d14-d56b701beaa6",
      "timestamp": "2026-01-11T15:21:45.105994+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "29438207-7106-4c8e-8ce1-5adde0882ccb",
      "timestamp": "2026-01-11T15:21:45.121720+00:00",
      "type": "ai_response",
      "content": "Good, the Design Principles section already mentions \"no side effects\" in point #2. Now let me check if there's an escape sequences reference table or if we need to add one:",
      "completed": true,
      "usage": {
        "prompt_tokens": 47789,
        "completion_tokens": 160,
        "total_tokens": 47949
      },
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_014Jz8MhrAAKGALWjUUUqnjL",
          "name": "editor",
          "arguments": {
            "operation": "search",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "search_text": "### String Literals and Escape Sequences"
          }
        }
      ]
    },
    {
      "id": "ea8390cb-a2d6-41bc-85cf-ba76becaa1ef",
      "timestamp": "2026-01-11T15:21:47.153777+00:00",
      "type": "tool_call",
      "content": "```json\n{\n  \"id\": \"toolu_014Jz8MhrAAKGALWjUUUqnjL\",\n  \"name\": \"editor\",\n  \"arguments\": {\n    \"operation\": \"search\",\n    \"tab_id\": \"6f13fcb4-562f-4ae1-822a-ba51a8376abe\",\n    \"search_text\": \"### String Literals and Escape Sequences\"\n  }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_014Jz8MhrAAKGALWjUUUqnjL",
          "name": "editor",
          "arguments": {
            "operation": "search",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "search_text": "### String Literals and Escape Sequences"
          }
        }
      ]
    },
    {
      "id": "2a3dc327-0530-4e45-b82a-f3c9ec10822e",
      "timestamp": "2026-01-11T15:21:47.163998+00:00",
      "type": "tool_result",
      "content": "```json\n{\n  \"id\": \"toolu_014Jz8MhrAAKGALWjUUUqnjL\",\n  \"name\": \"editor\",\n  \"content\": \"{\\n  \\\"search_text\\\": \\\"### String Literals and Escape Sequences\\\",\\n  \\\"case_sensitive\\\": false,\\n  \\\"match_count\\\": 1,\\n  \\\"matches\\\": [\\n    {\\n      \\\"line\\\": 1372,\\n      \\\"column\\\": 41,\\n      \\\"match_text\\\": \\\"### String Literals and Escape Sequences\\\",\\n      \\\"context\\\": \\\"### String Literals and Escape Sequences\\\"\\n    }\\n  ]\\n}\",\n  \"error\": null\n}\n```\n`content` is:\n```json\n{\n  \"search_text\": \"### String Literals and Escape Sequences\",\n  \"case_sensitive\": false,\n  \"match_count\": 1,\n  \"matches\": [\n    {\n      \"line\": 1372,\n      \"column\": 41,\n      \"match_text\": \"### String Literals and Escape Sequences\",\n      \"context\": \"### String Literals and Escape Sequences\"\n    }\n  ]\n}\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_014Jz8MhrAAKGALWjUUUqnjL",
          "name": "editor",
          "content": "{\n  \"search_text\": \"### String Literals and Escape Sequences\",\n  \"case_sensitive\": false,\n  \"match_count\": 1,\n  \"matches\": [\n    {\n      \"line\": 1372,\n      \"column\": 41,\n      \"match_text\": \"### String Literals and Escape Sequences\",\n      \"context\": \"### String Literals and Escape Sequences\"\n    }\n  ]\n}",
          "error": null
        }
      ]
    },
    {
      "id": "0dcf8050-734c-4b22-8a11-0c4291d2dda0",
      "timestamp": "2026-01-11T15:21:47.169645+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_014Jz8MhrAAKGALWjUUUqnjL",
          "name": "editor",
          "content": "{\n  \"search_text\": \"### String Literals and Escape Sequences\",\n  \"case_sensitive\": false,\n  \"match_count\": 1,\n  \"matches\": [\n    {\n      \"line\": 1372,\n      \"column\": 41,\n      \"match_text\": \"### String Literals and Escape Sequences\",\n      \"context\": \"### String Literals and Escape Sequences\"\n    }\n  ]\n}",
          "error": null
        }
      ]
    },
    {
      "id": "bbfd2a88-0d35-4849-934e-a0e3bcba7400",
      "timestamp": "2026-01-11T15:21:49.510317+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "75a674e2-b931-4442-affe-1212f6262410",
      "timestamp": "2026-01-11T15:21:50.211122+00:00",
      "type": "ai_response",
      "content": "",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_01WvQP367L4XNXYSx9eSLWjc",
          "name": "editor",
          "arguments": {
            "operation": "read_lines",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "start_line": 1372,
            "end_line": 1395
          }
        }
      ]
    },
    {
      "id": "b92844f2-5ec4-454d-baa7-c2ad4dbcaa9e",
      "timestamp": "2026-01-11T15:21:50.215643+00:00",
      "type": "tool_call",
      "content": "```json\n{\n  \"id\": \"toolu_01WvQP367L4XNXYSx9eSLWjc\",\n  \"name\": \"editor\",\n  \"arguments\": {\n    \"operation\": \"read_lines\",\n    \"tab_id\": \"6f13fcb4-562f-4ae1-822a-ba51a8376abe\",\n    \"start_line\": 1372,\n    \"end_line\": 1395\n  }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_01WvQP367L4XNXYSx9eSLWjc",
          "name": "editor",
          "arguments": {
            "operation": "read_lines",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe",
            "start_line": 1372,
            "end_line": 1395
          }
        }
      ]
    },
    {
      "id": "4e3dae4a-8ff9-4c87-94cf-b410220eaeec",
      "timestamp": "2026-01-11T15:21:50.220111+00:00",
      "type": "tool_result",
      "content": "```json\n{\n  \"id\": \"toolu_01WvQP367L4XNXYSx9eSLWjc\",\n  \"name\": \"editor\",\n  \"content\": \"{\\n  \\\"range\\\": \\\"1372-1395\\\",\\n  \\\"lines\\\": {\\n    \\\"1372\\\": \\\"### String Literals and Escape Sequences\\\",\\n    \\\"1373\\\": \\\"\\\",\\n    \\\"1374\\\": \\\"String literals use double quotes and support escape sequences:\\\",\\n    \\\"1375\\\": \\\"\\\",\\n    \\\"1376\\\": \\\"```aifpl\\\",\\n    \\\"1377\\\": \\\"\\\\\\\"hello world\\\\\\\"                         ; Basic string\\\",\\n    \\\"1378\\\": \\\"\\\\\\\"She said \\\\\\\\\\\\\\\"Hello!\\\\\\\\\\\\\\\"\\\\\\\"                 ; Escaped quotes\\\",\\n    \\\"1379\\\": \\\"\\\\\\\"Line 1\\\\\\\\nLine 2\\\\\\\"                      ; Newline\\\",\\n    \\\"1380\\\": \\\"\\\\\\\"Column 1\\\\\\\\tColumn 2\\\\\\\"                  ; Tab\\\",\\n    \\\"1381\\\": \\\"\\\\\\\"Path\\\\\\\\\\\\\\\\to\\\\\\\\\\\\\\\\file\\\\\\\"                      ; Backslash\\\",\\n    \\\"1382\\\": \\\"\\\\\\\"Unicode: \\\\\\\\u03B1\\\\\\\\u03B2\\\\\\\\u03B3\\\\\\\"         ; Greek letters \\\\u03b1\\\\u03b2\\\\u03b3\\\",\\n    \\\"1383\\\": \\\"```\\\",\\n    \\\"1384\\\": \\\"\\\",\\n    \\\"1385\\\": \\\"**Supported escape sequences:**\\\",\\n    \\\"1386\\\": \\\"- `\\\\\\\\\\\\\\\"` \\\\u2192 literal quote\\\",\\n    \\\"1387\\\": \\\"- `\\\\\\\\\\\\\\\\` \\\\u2192 literal backslash\\\",\\n    \\\"1388\\\": \\\"- `\\\\\\\\n` \\\\u2192 newline\\\",\\n    \\\"1389\\\": \\\"- `\\\\\\\\t` \\\\u2192 tab\\\",\\n    \\\"1390\\\": \\\"- `\\\\\\\\r` \\\\u2192 carriage return\\\",\\n    \\\"1391\\\": \\\"- `\\\\\\\\uXXXX` \\\\u2192 Unicode code point (4 hex digits)\\\",\\n    \\\"1392\\\": \\\"\\\",\\n    \\\"1393\\\": \\\"### Association Lists (Alists)\\\",\\n    \\\"1394\\\": \\\"\\\",\\n    \\\"1395\\\": \\\"Association lists (alists) are immutable key-value mappings with O(1) lookup performance. They are first-class data structures optimized for structured data processing.\\\"\\n  }\\n}\",\n  \"error\": null\n}\n```\n`content` is:\n```json\n{\n  \"range\": \"1372-1395\",\n  \"lines\": {\n    \"1372\": \"### String Literals and Escape Sequences\",\n    \"1373\": \"\",\n    \"1374\": \"String literals use double quotes and support escape sequences:\",\n    \"1375\": \"\",\n    \"1376\": \"```aifpl\",\n    \"1377\": \"\\\"hello world\\\"                         ; Basic string\",\n    \"1378\": \"\\\"She said \\\\\\\"Hello!\\\\\\\"\\\"                 ; Escaped quotes\",\n    \"1379\": \"\\\"Line 1\\\\nLine 2\\\"                      ; Newline\",\n    \"1380\": \"\\\"Column 1\\\\tColumn 2\\\"                  ; Tab\",\n    \"1381\": \"\\\"Path\\\\\\\\to\\\\\\\\file\\\"                      ; Backslash\",\n    \"1382\": \"\\\"Unicode: \\\\u03B1\\\\u03B2\\\\u03B3\\\"         ; Greek letters \\u03b1\\u03b2\\u03b3\",\n    \"1383\": \"```\",\n    \"1384\": \"\",\n    \"1385\": \"**Supported escape sequences:**\",\n    \"1386\": \"- `\\\\\\\"` \\u2192 literal quote\",\n    \"1387\": \"- `\\\\\\\\` \\u2192 literal backslash\",\n    \"1388\": \"- `\\\\n` \\u2192 newline\",\n    \"1389\": \"- `\\\\t` \\u2192 tab\",\n    \"1390\": \"- `\\\\r` \\u2192 carriage return\",\n    \"1391\": \"- `\\\\uXXXX` \\u2192 Unicode code point (4 hex digits)\",\n    \"1392\": \"\",\n    \"1393\": \"### Association Lists (Alists)\",\n    \"1394\": \"\",\n    \"1395\": \"Association lists (alists) are immutable key-value mappings with O(1) lookup performance. They are first-class data structures optimized for structured data processing.\"\n  }\n}\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01WvQP367L4XNXYSx9eSLWjc",
          "name": "editor",
          "content": "{\n  \"range\": \"1372-1395\",\n  \"lines\": {\n    \"1372\": \"### String Literals and Escape Sequences\",\n    \"1373\": \"\",\n    \"1374\": \"String literals use double quotes and support escape sequences:\",\n    \"1375\": \"\",\n    \"1376\": \"```aifpl\",\n    \"1377\": \"\\\"hello world\\\"                         ; Basic string\",\n    \"1378\": \"\\\"She said \\\\\\\"Hello!\\\\\\\"\\\"                 ; Escaped quotes\",\n    \"1379\": \"\\\"Line 1\\\\nLine 2\\\"                      ; Newline\",\n    \"1380\": \"\\\"Column 1\\\\tColumn 2\\\"                  ; Tab\",\n    \"1381\": \"\\\"Path\\\\\\\\to\\\\\\\\file\\\"                      ; Backslash\",\n    \"1382\": \"\\\"Unicode: \\\\u03B1\\\\u03B2\\\\u03B3\\\"         ; Greek letters \\u03b1\\u03b2\\u03b3\",\n    \"1383\": \"```\",\n    \"1384\": \"\",\n    \"1385\": \"**Supported escape sequences:**\",\n    \"1386\": \"- `\\\\\\\"` \\u2192 literal quote\",\n    \"1387\": \"- `\\\\\\\\` \\u2192 literal backslash\",\n    \"1388\": \"- `\\\\n` \\u2192 newline\",\n    \"1389\": \"- `\\\\t` \\u2192 tab\",\n    \"1390\": \"- `\\\\r` \\u2192 carriage return\",\n    \"1391\": \"- `\\\\uXXXX` \\u2192 Unicode code point (4 hex digits)\",\n    \"1392\": \"\",\n    \"1393\": \"### Association Lists (Alists)\",\n    \"1394\": \"\",\n    \"1395\": \"Association lists (alists) are immutable key-value mappings with O(1) lookup performance. They are first-class data structures optimized for structured data processing.\"\n  }\n}",
          "error": null
        }
      ]
    },
    {
      "id": "79347e97-2be4-421f-b465-e9c6360c0b84",
      "timestamp": "2026-01-11T15:21:50.223522+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01WvQP367L4XNXYSx9eSLWjc",
          "name": "editor",
          "content": "{\n  \"range\": \"1372-1395\",\n  \"lines\": {\n    \"1372\": \"### String Literals and Escape Sequences\",\n    \"1373\": \"\",\n    \"1374\": \"String literals use double quotes and support escape sequences:\",\n    \"1375\": \"\",\n    \"1376\": \"```aifpl\",\n    \"1377\": \"\\\"hello world\\\"                         ; Basic string\",\n    \"1378\": \"\\\"She said \\\\\\\"Hello!\\\\\\\"\\\"                 ; Escaped quotes\",\n    \"1379\": \"\\\"Line 1\\\\nLine 2\\\"                      ; Newline\",\n    \"1380\": \"\\\"Column 1\\\\tColumn 2\\\"                  ; Tab\",\n    \"1381\": \"\\\"Path\\\\\\\\to\\\\\\\\file\\\"                      ; Backslash\",\n    \"1382\": \"\\\"Unicode: \\\\u03B1\\\\u03B2\\\\u03B3\\\"         ; Greek letters \\u03b1\\u03b2\\u03b3\",\n    \"1383\": \"```\",\n    \"1384\": \"\",\n    \"1385\": \"**Supported escape sequences:**\",\n    \"1386\": \"- `\\\\\\\"` \\u2192 literal quote\",\n    \"1387\": \"- `\\\\\\\\` \\u2192 literal backslash\",\n    \"1388\": \"- `\\\\n` \\u2192 newline\",\n    \"1389\": \"- `\\\\t` \\u2192 tab\",\n    \"1390\": \"- `\\\\r` \\u2192 carriage return\",\n    \"1391\": \"- `\\\\uXXXX` \\u2192 Unicode code point (4 hex digits)\",\n    \"1392\": \"\",\n    \"1393\": \"### Association Lists (Alists)\",\n    \"1394\": \"\",\n    \"1395\": \"Association lists (alists) are immutable key-value mappings with O(1) lookup performance. They are first-class data structures optimized for structured data processing.\"\n  }\n}",
          "error": null
        }
      ]
    },
    {
      "id": "21f2dc03-c46a-4ee8-aee7-7b4378999d5c",
      "timestamp": "2026-01-11T15:21:52.717280+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "b2acbba6-3717-46e7-8939-df74ef9b73f8",
      "timestamp": "2026-01-11T15:21:52.724308+00:00",
      "type": "ai_response",
      "content": "Perfect! The escape sequences reference table is already there. Now let me verify the changes look good by checking what we've updated:",
      "completed": true,
      "usage": {
        "prompt_tokens": 48689,
        "completion_tokens": 122,
        "total_tokens": 48811
      },
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_01ScMUjJEhzwyZemLkgJBzZ5",
          "name": "editor",
          "arguments": {
            "operation": "get_diff",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe"
          }
        }
      ]
    },
    {
      "id": "7d5a6ac3-5b4b-41c2-811d-23726ddc9803",
      "timestamp": "2026-01-11T15:21:54.232383+00:00",
      "type": "tool_call",
      "content": "```json\n{\n  \"id\": \"toolu_01ScMUjJEhzwyZemLkgJBzZ5\",\n  \"name\": \"editor\",\n  \"arguments\": {\n    \"operation\": \"get_diff\",\n    \"tab_id\": \"6f13fcb4-562f-4ae1-822a-ba51a8376abe\"\n  }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_01ScMUjJEhzwyZemLkgJBzZ5",
          "name": "editor",
          "arguments": {
            "operation": "get_diff",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe"
          }
        }
      ]
    },
    {
      "id": "c4ab095a-cdab-4666-bad4-7d63abb4944e",
      "timestamp": "2026-01-11T15:21:54.240459+00:00",
      "type": "tool_result",
      "content": "```json\n{\n  \"id\": \"toolu_01ScMUjJEhzwyZemLkgJBzZ5\",\n  \"name\": \"editor\",\n  \"content\": \"--- a//Users/dave/github/m6r/humbug/src/aifpl/README.md\\n+++ b//Users/dave/github/m6r/humbug/src/aifpl/README.md\\n@@ -5,6 +5,7 @@\\n ## Features\\n \\n - **Pure list representation**: Everything is data - true homoiconicity like traditional Lisp\\n+- **Pure functional**: No side effects, immutable data, safe for AI tool integration\\n - **S-expression syntax**: `(function-or-operator arg1 arg2 ...)`\\n - **Quote special form**: `(quote expr)` and shortcut `'expr` for preventing evaluation and creating data literals\\n - **Pattern matching**: Comprehensive pattern matching with structural and type-based patterns\\n@@ -1101,54 +1102,54 @@\\n \\n AIFPL provides comprehensive type checking functions:\\n \\n-#### Basic Type Predicates\\n-```aifpl\\n-; Number type checking (excludes booleans)\\n-(number? 42)                          ; \\u2192 #t\\n-(number? 3.14)                        ; \\u2192 #t\\n-(number? (+ 1 j))                     ; \\u2192 #t (complex)\\n+```aifpl\\n+; Numeric type checking\\n+(number? 42)                          ; \\u2192 #t (any numeric type)\\n (number? #t)                          ; \\u2192 #f (booleans are not numbers)\\n-(number? \\\"42\\\")                        ; \\u2192 #f\\n-\\n-; Specific numeric type checking\\n (integer? 42)                         ; \\u2192 #t\\n (integer? 3.14)                       ; \\u2192 #f\\n-(integer? #t)                         ; \\u2192 #f (booleans excluded)\\n-\\n (float? 3.14)                         ; \\u2192 #t\\n (float? 42)                           ; \\u2192 #f\\n (float? (/ 1 2))                      ; \\u2192 #t (division produces float)\\n-\\n (complex? (+ 1 j))                    ; \\u2192 #t\\n (complex? 42)                         ; \\u2192 #f\\n-(complex? 3.14)                       ; \\u2192 #f\\n-```\\n-\\n-#### Other Type Predicates\\n-```aifpl\\n+\\n ; String type checking\\n (string? \\\"hello\\\")                     ; \\u2192 #t\\n (string? 42)                          ; \\u2192 #f\\n-(string? (number->string 42))         ; \\u2192 #t\\n \\n ; Boolean type checking\\n (boolean? #t)                         ; \\u2192 #t\\n-(boolean? #f)                         ; \\u2192 #t\\n (boolean? 1)                          ; \\u2192 #f\\n-(boolean? 0)                          ; \\u2192 #f\\n+\\n+; Collection type checking\\n+(list? (list 1 2 3))                  ; \\u2192 #t\\n+(list? \\\"hello\\\")                       ; \\u2192 #f\\n+(list? ())                            ; \\u2192 #t (empty list)\\n+(alist? (alist (\\\"x\\\" 1)))              ; \\u2192 #t\\n+(alist? (list 1 2 3))                 ; \\u2192 #f\\n \\n ; Function type checking\\n (function? (lambda (x) (* x 2)))      ; \\u2192 #t\\n (function? +)                         ; \\u2192 #t\\n-(function? \\\"hello\\\")                   ; \\u2192 #f\\n-\\n-; List type checking (already existed)\\n-(list? (list 1 2 3))                 ; \\u2192 #t\\n-(list? \\\"hello\\\")                       ; \\u2192 #f\\n-(list? ())                            ; \\u2192 #t (empty list)\\n-```\\n-\\n-#### Type Predicate Usage Patterns\\n+```\\n+\\n+### Comments\\n+\\n+AIFPL supports single-line comments using the semicolon (`;`) character:\\n+\\n+```aifpl\\n+; This is a comment\\n+(+ 1 2)  ; Calculate sum\\n+\\n+; Comments can appear anywhere\\n+(let ((x 5))  ; Bind x to 5\\n+  (* x 2))    ; Double it\\n+```\\n+\\n+Comments extend to the end of the line and are ignored during evaluation.\\n+\\n+### Type Predicate Usage Patterns\\n ```aifpl\\n ; Conditional type handling\\n (let ((process-value (lambda (x)\\n\",\n  \"error\": null\n}\n```\n`content` is:\n```diff\n--- a//Users/dave/github/m6r/humbug/src/aifpl/README.md\n+++ b//Users/dave/github/m6r/humbug/src/aifpl/README.md\n@@ -5,6 +5,7 @@\n ## Features\n \n - **Pure list representation**: Everything is data - true homoiconicity like traditional Lisp\n+- **Pure functional**: No side effects, immutable data, safe for AI tool integration\n - **S-expression syntax**: `(function-or-operator arg1 arg2 ...)`\n - **Quote special form**: `(quote expr)` and shortcut `'expr` for preventing evaluation and creating data literals\n - **Pattern matching**: Comprehensive pattern matching with structural and type-based patterns\n@@ -1101,54 +1102,54 @@\n \n AIFPL provides comprehensive type checking functions:\n \n-#### Basic Type Predicates\n-```aifpl\n-; Number type checking (excludes booleans)\n-(number? 42)                          ; \u2192 #t\n-(number? 3.14)                        ; \u2192 #t\n-(number? (+ 1 j))                     ; \u2192 #t (complex)\n+```aifpl\n+; Numeric type checking\n+(number? 42)                          ; \u2192 #t (any numeric type)\n (number? #t)                          ; \u2192 #f (booleans are not numbers)\n-(number? \"42\")                        ; \u2192 #f\n-\n-; Specific numeric type checking\n (integer? 42)                         ; \u2192 #t\n (integer? 3.14)                       ; \u2192 #f\n-(integer? #t)                         ; \u2192 #f (booleans excluded)\n-\n (float? 3.14)                         ; \u2192 #t\n (float? 42)                           ; \u2192 #f\n (float? (/ 1 2))                      ; \u2192 #t (division produces float)\n-\n (complex? (+ 1 j))                    ; \u2192 #t\n (complex? 42)                         ; \u2192 #f\n-(complex? 3.14)                       ; \u2192 #f\n-```\n-\n-#### Other Type Predicates\n-```aifpl\n+\n ; String type checking\n (string? \"hello\")                     ; \u2192 #t\n (string? 42)                          ; \u2192 #f\n-(string? (number->string 42))         ; \u2192 #t\n \n ; Boolean type checking\n (boolean? #t)                         ; \u2192 #t\n-(boolean? #f)                         ; \u2192 #t\n (boolean? 1)                          ; \u2192 #f\n-(boolean? 0)                          ; \u2192 #f\n+\n+; Collection type checking\n+(list? (list 1 2 3))                  ; \u2192 #t\n+(list? \"hello\")                       ; \u2192 #f\n+(list? ())                            ; \u2192 #t (empty list)\n+(alist? (alist (\"x\" 1)))              ; \u2192 #t\n+(alist? (list 1 2 3))                 ; \u2192 #f\n \n ; Function type checking\n (function? (lambda (x) (* x 2)))      ; \u2192 #t\n (function? +)                         ; \u2192 #t\n-(function? \"hello\")                   ; \u2192 #f\n-\n-; List type checking (already existed)\n-(list? (list 1 2 3))                 ; \u2192 #t\n-(list? \"hello\")                       ; \u2192 #f\n-(list? ())                            ; \u2192 #t (empty list)\n-```\n-\n-#### Type Predicate Usage Patterns\n+```\n+\n+### Comments\n+\n+AIFPL supports single-line comments using the semicolon (`;`) character:\n+\n+```aifpl\n+; This is a comment\n+(+ 1 2)  ; Calculate sum\n+\n+; Comments can appear anywhere\n+(let ((x 5))  ; Bind x to 5\n+  (* x 2))    ; Double it\n+```\n+\n+Comments extend to the end of the line and are ignored during evaluation.\n+\n+### Type Predicate Usage Patterns\n ```aifpl\n ; Conditional type handling\n (let ((process-value (lambda (x)\n\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01ScMUjJEhzwyZemLkgJBzZ5",
          "name": "editor",
          "content": "--- a//Users/dave/github/m6r/humbug/src/aifpl/README.md\n+++ b//Users/dave/github/m6r/humbug/src/aifpl/README.md\n@@ -5,6 +5,7 @@\n ## Features\n \n - **Pure list representation**: Everything is data - true homoiconicity like traditional Lisp\n+- **Pure functional**: No side effects, immutable data, safe for AI tool integration\n - **S-expression syntax**: `(function-or-operator arg1 arg2 ...)`\n - **Quote special form**: `(quote expr)` and shortcut `'expr` for preventing evaluation and creating data literals\n - **Pattern matching**: Comprehensive pattern matching with structural and type-based patterns\n@@ -1101,54 +1102,54 @@\n \n AIFPL provides comprehensive type checking functions:\n \n-#### Basic Type Predicates\n-```aifpl\n-; Number type checking (excludes booleans)\n-(number? 42)                          ; \u2192 #t\n-(number? 3.14)                        ; \u2192 #t\n-(number? (+ 1 j))                     ; \u2192 #t (complex)\n+```aifpl\n+; Numeric type checking\n+(number? 42)                          ; \u2192 #t (any numeric type)\n (number? #t)                          ; \u2192 #f (booleans are not numbers)\n-(number? \"42\")                        ; \u2192 #f\n-\n-; Specific numeric type checking\n (integer? 42)                         ; \u2192 #t\n (integer? 3.14)                       ; \u2192 #f\n-(integer? #t)                         ; \u2192 #f (booleans excluded)\n-\n (float? 3.14)                         ; \u2192 #t\n (float? 42)                           ; \u2192 #f\n (float? (/ 1 2))                      ; \u2192 #t (division produces float)\n-\n (complex? (+ 1 j))                    ; \u2192 #t\n (complex? 42)                         ; \u2192 #f\n-(complex? 3.14)                       ; \u2192 #f\n-```\n-\n-#### Other Type Predicates\n-```aifpl\n+\n ; String type checking\n (string? \"hello\")                     ; \u2192 #t\n (string? 42)                          ; \u2192 #f\n-(string? (number->string 42))         ; \u2192 #t\n \n ; Boolean type checking\n (boolean? #t)                         ; \u2192 #t\n-(boolean? #f)                         ; \u2192 #t\n (boolean? 1)                          ; \u2192 #f\n-(boolean? 0)                          ; \u2192 #f\n+\n+; Collection type checking\n+(list? (list 1 2 3))                  ; \u2192 #t\n+(list? \"hello\")                       ; \u2192 #f\n+(list? ())                            ; \u2192 #t (empty list)\n+(alist? (alist (\"x\" 1)))              ; \u2192 #t\n+(alist? (list 1 2 3))                 ; \u2192 #f\n \n ; Function type checking\n (function? (lambda (x) (* x 2)))      ; \u2192 #t\n (function? +)                         ; \u2192 #t\n-(function? \"hello\")                   ; \u2192 #f\n-\n-; List type checking (already existed)\n-(list? (list 1 2 3))                 ; \u2192 #t\n-(list? \"hello\")                       ; \u2192 #f\n-(list? ())                            ; \u2192 #t (empty list)\n-```\n-\n-#### Type Predicate Usage Patterns\n+```\n+\n+### Comments\n+\n+AIFPL supports single-line comments using the semicolon (`;`) character:\n+\n+```aifpl\n+; This is a comment\n+(+ 1 2)  ; Calculate sum\n+\n+; Comments can appear anywhere\n+(let ((x 5))  ; Bind x to 5\n+  (* x 2))    ; Double it\n+```\n+\n+Comments extend to the end of the line and are ignored during evaluation.\n+\n+### Type Predicate Usage Patterns\n ```aifpl\n ; Conditional type handling\n (let ((process-value (lambda (x)\n",
          "error": null
        }
      ]
    },
    {
      "id": "215577e6-35ac-4b02-b37e-545039c483be",
      "timestamp": "2026-01-11T15:21:54.244851+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01ScMUjJEhzwyZemLkgJBzZ5",
          "name": "editor",
          "content": "--- a//Users/dave/github/m6r/humbug/src/aifpl/README.md\n+++ b//Users/dave/github/m6r/humbug/src/aifpl/README.md\n@@ -5,6 +5,7 @@\n ## Features\n \n - **Pure list representation**: Everything is data - true homoiconicity like traditional Lisp\n+- **Pure functional**: No side effects, immutable data, safe for AI tool integration\n - **S-expression syntax**: `(function-or-operator arg1 arg2 ...)`\n - **Quote special form**: `(quote expr)` and shortcut `'expr` for preventing evaluation and creating data literals\n - **Pattern matching**: Comprehensive pattern matching with structural and type-based patterns\n@@ -1101,54 +1102,54 @@\n \n AIFPL provides comprehensive type checking functions:\n \n-#### Basic Type Predicates\n-```aifpl\n-; Number type checking (excludes booleans)\n-(number? 42)                          ; \u2192 #t\n-(number? 3.14)                        ; \u2192 #t\n-(number? (+ 1 j))                     ; \u2192 #t (complex)\n+```aifpl\n+; Numeric type checking\n+(number? 42)                          ; \u2192 #t (any numeric type)\n (number? #t)                          ; \u2192 #f (booleans are not numbers)\n-(number? \"42\")                        ; \u2192 #f\n-\n-; Specific numeric type checking\n (integer? 42)                         ; \u2192 #t\n (integer? 3.14)                       ; \u2192 #f\n-(integer? #t)                         ; \u2192 #f (booleans excluded)\n-\n (float? 3.14)                         ; \u2192 #t\n (float? 42)                           ; \u2192 #f\n (float? (/ 1 2))                      ; \u2192 #t (division produces float)\n-\n (complex? (+ 1 j))                    ; \u2192 #t\n (complex? 42)                         ; \u2192 #f\n-(complex? 3.14)                       ; \u2192 #f\n-```\n-\n-#### Other Type Predicates\n-```aifpl\n+\n ; String type checking\n (string? \"hello\")                     ; \u2192 #t\n (string? 42)                          ; \u2192 #f\n-(string? (number->string 42))         ; \u2192 #t\n \n ; Boolean type checking\n (boolean? #t)                         ; \u2192 #t\n-(boolean? #f)                         ; \u2192 #t\n (boolean? 1)                          ; \u2192 #f\n-(boolean? 0)                          ; \u2192 #f\n+\n+; Collection type checking\n+(list? (list 1 2 3))                  ; \u2192 #t\n+(list? \"hello\")                       ; \u2192 #f\n+(list? ())                            ; \u2192 #t (empty list)\n+(alist? (alist (\"x\" 1)))              ; \u2192 #t\n+(alist? (list 1 2 3))                 ; \u2192 #f\n \n ; Function type checking\n (function? (lambda (x) (* x 2)))      ; \u2192 #t\n (function? +)                         ; \u2192 #t\n-(function? \"hello\")                   ; \u2192 #f\n-\n-; List type checking (already existed)\n-(list? (list 1 2 3))                 ; \u2192 #t\n-(list? \"hello\")                       ; \u2192 #f\n-(list? ())                            ; \u2192 #t (empty list)\n-```\n-\n-#### Type Predicate Usage Patterns\n+```\n+\n+### Comments\n+\n+AIFPL supports single-line comments using the semicolon (`;`) character:\n+\n+```aifpl\n+; This is a comment\n+(+ 1 2)  ; Calculate sum\n+\n+; Comments can appear anywhere\n+(let ((x 5))  ; Bind x to 5\n+  (* x 2))    ; Double it\n+```\n+\n+Comments extend to the end of the line and are ignored during evaluation.\n+\n+### Type Predicate Usage Patterns\n ```aifpl\n ; Conditional type handling\n (let ((process-value (lambda (x)\n",
          "error": null
        }
      ]
    },
    {
      "id": "fb8ec649-3676-4f5c-975e-6b1f5e0bca2b",
      "timestamp": "2026-01-11T15:21:56.320188+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "ca88a4e4-24a0-4e3e-92b3-d809a75b1756",
      "timestamp": "2026-01-11T15:21:56.360032+00:00",
      "type": "ai_response",
      "content": "Perfect! Now let me save the file:",
      "completed": true,
      "usage": {
        "prompt_tokens": 49861,
        "completion_tokens": 105,
        "total_tokens": 49966
      },
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_01R8LYDYnJWYjMgPmZnRfD4f",
          "name": "editor",
          "arguments": {
            "operation": "save_file",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe"
          }
        }
      ]
    },
    {
      "id": "922fc2b0-603a-430e-b4f2-00661dd2ad69",
      "timestamp": "2026-01-11T15:21:57.611973+00:00",
      "type": "tool_call",
      "content": "```json\n{\n  \"id\": \"toolu_01R8LYDYnJWYjMgPmZnRfD4f\",\n  \"name\": \"editor\",\n  \"arguments\": {\n    \"operation\": \"save_file\",\n    \"tab_id\": \"6f13fcb4-562f-4ae1-822a-ba51a8376abe\"\n  }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_01R8LYDYnJWYjMgPmZnRfD4f",
          "name": "editor",
          "arguments": {
            "operation": "save_file",
            "tab_id": "6f13fcb4-562f-4ae1-822a-ba51a8376abe"
          }
        }
      ]
    },
    {
      "id": "14a65529-a7e5-4154-a062-e3ff0ecf8852",
      "timestamp": "2026-01-11T15:22:00.190320+00:00",
      "type": "tool_result",
      "content": "```json\n{\n  \"id\": \"toolu_01R8LYDYnJWYjMgPmZnRfD4f\",\n  \"name\": \"editor\",\n  \"content\": \"Saved file: '/Users/dave/github/m6r/humbug/src/aifpl/README.md'\",\n  \"error\": null\n}\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01R8LYDYnJWYjMgPmZnRfD4f",
          "name": "editor",
          "content": "Saved file: '/Users/dave/github/m6r/humbug/src/aifpl/README.md'",
          "error": null
        }
      ]
    },
    {
      "id": "a669636e-0ff5-4fcc-bf66-f75c1f444f71",
      "timestamp": "2026-01-11T15:22:00.194496+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01R8LYDYnJWYjMgPmZnRfD4f",
          "name": "editor",
          "content": "Saved file: '/Users/dave/github/m6r/humbug/src/aifpl/README.md'",
          "error": null
        }
      ]
    },
    {
      "id": "27a65c93-28f8-4dfc-b3e3-45c2abed7eca",
      "timestamp": "2026-01-11T15:22:03.130173+00:00",
      "type": "ai_connected",
      "content": "AI is thinking...",
      "completed": true,
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "d2a7ef91-772f-4b2f-8ea8-8d17c55d1a6f",
      "timestamp": "2026-01-11T15:22:03.144748+00:00",
      "type": "ai_response",
      "content": "Excellent! I've successfully updated the README.md with the following changes:\n\n## Summary of Changes\n\n### 1. **Added \"Pure functional\" to Features** (line 8)\n   - Emphasizes no side effects, immutable data, and safety for AI tool integration\n\n### 2. **Flattened Type Predicates Section** (lines 1102-1138)\n   - Removed artificial \"Basic\" vs \"Other\" distinction\n   - All type predicates are now treated as first-class equals\n   - Reorganized by logical grouping:\n     - Numeric type checking (`number?`, `integer?`, `float?`, `complex?`)\n     - String type checking (`string?`)\n     - Boolean type checking (`boolean?`)\n     - Collection type checking (`list?`, `alist?`)\n     - Function type checking (`function?`)\n   - **Added missing `alist?` predicate** to the collection type checking section\n\n### 3. **Added New Comments Section** (lines 1139-1151)\n   - Dedicated section explaining comment syntax with semicolon (`;`)\n   - Includes practical examples\n   - Explains that comments extend to end of line\n\n### 4. **Simplified Examples**\n   - Removed redundant examples that didn't add value\n   - Kept the most illustrative examples for each type predicate\n\nThe documentation now accurately reflects all the features in the tool description and treats all type predicates equally as first-class functions!",
      "completed": true,
      "usage": {
        "prompt_tokens": 50007,
        "completion_tokens": 335,
        "total_tokens": 50342
      },
      "model": "claude-sonnet-4-5-20250929",
      "reasoning_capability": 1,
      "temperature": 0.7
    }
  ]
}