{
  "metadata": {
    "version": "0.1",
    "parent": null
  },
  "conversation": [
    {
      "id": "74f6e9d1-eabb-4eaf-95d8-a0a49df8310a",
      "timestamp": "2025-08-29T17:23:49.730577+00:00",
      "type": "user_message",
      "content": "The following preamble describes some elements of a language called Metaphor.  Please pay\nextremely close attention to the details as they will affect the way you interpret\neverything that follows after \"BEGIN DESCRIPTION IN METAPHOR:\"\n\nMetaphor is a structured natural language prompt creation language.  It is designed to\nlet a user convey their requirements to a large language model AI.\n\nMetaphor has the structure of a document tree with branches and leaves being prefixed\nby new sections containing the keywords \"Role:\", \"Context:\" or \"Action:\".  Each of\nthese indicates the start of a new block of information.  Blocks are introduced using\nMarkdown-style headings (using hash symbols).  The number of hashes gives an indication\nof the nesting depth and the parent/child relationship.\n\nBlock keywords have an optional name that will immediately follow them on the same line.\nIf this is missing then the block name is not defined.\n\nAfter a block heading there may be one or more lines of text that will describe the purpose\nof that block.  A block may also include one or more optional child blocks inside them and\nthat further clarify their parent block.\n\nWithin the text of a block, you may be presented with code or document fragments inside a\nblock delimited by 3 backticks.  Please pay close attention to the indentation level of the\nopening 3 backticks.  The identation of such code or document fragments is relative to this,\nnot relative to the block in which the code or document fragment occurs.\n\nIf \"Role:\" block exists then this contains details about the role you should fulfil.  This\nmay also describe specific skills you have, knowledge you should apply, and the\napproach you take to apply these.\n\n\"Context:\" blocks provide context necessary to understand what you will be asked to do.\n\n\"Action:\" blocks describes the task, or tasks, you should do.\n\nIf you are asked to offer any opinions on the Metaphor prompt then always provide the full\nset of parent headings leading up to any block you want to talk about.  This will allow\nthe user to understand which part of the Metaphor prompt is being discussed.\n\nWhen you process the actions please carefully ensure you do all of them accurately and\ncomplete all the elements requested.  Unless otherwise instructed, do not include any\nplaceholders in your responses.\n\nBEGIN DESCRIPTION IN METAPHOR:\n\n# Role:\n\nYou are a world class python programmer, highly skilled in accurate and performant software development.  You\nare going to assist me in making modifications to my application.\n\n# Context:\n\n## Context: Python implementation rules\n\nAs an engineer working with the application, I want the application to be easy to use and understand,\nso I can maintain and enhance it over time.\n\n### Context: Implement in Python 3\n\nThe application will be written in the latest version of Python 3.  Assume a baseline of Python 3.10.\n\n### Context: Indentation of code\n\nCode must be indented by 4 spaces.\n\n### Context: Use docstrings\n\nDocstrings must be used to describe all modules, classes, and functions.  This should follow PEP 257 guidelines.\n\n### Context: Use type hints\n\nType hints must be used for function arguments and return values.\n\nAs we're using Python 3.10 as a minimum, use union types.  E.g. use `T | None` instead of `Optional[T]`.\n\n`self` parameters do not need to have type hints.\n\n### Context: Use comments\n\nComments must be used to describe any complex logic, or rationale that would not be obvious from\nsimply reading the code.  This ensures that anyone reading the code for the first time will be able\nto understand why the code is the way it is.\n\n### Context: PEP 8 imports\n\nThe import list in any module should follow PEP 8 guidelines, including the ordering of imports.\n\n### Context: Avoid unnecessary `elif` and `else` statements\n\nTo improve readability, do not use `elif` or `else` statements if the preceding `if` branch ends with\na `return`, `continue`, or `break`.\n\nFor example, do this:\n\n```python\nif condition:\n    return\n\nnext_statement()\n```\n\ninstead of this:\n\n```python\nif condition:\n    return\nelse:\n    next_statement()\n```\n\nThe first version avoids the unecessary else statement.\n\n### Context: Handle error and exception paths early\n\nIf it is possible to detect errors and exceptions early then do so.  Always prefer to do this as early\nas possible within the code so we have the fewest possible conditional checks by the time we reach the\nmain purpose of any function or method.\n\nThis is sometimes known as \"flattening the code to the left\" as there is generally less indentation required\nwhen we do this.  This makes the code easier to read.\n\nFor example do this:\n\n```python\nif error_condition:\n    return\n\nif another_error_condition:\n    return\n\nhandle_happy_path()\n```\n\ninstead of this:\n\n```python\nif not error_condition:\n    if not another_error_condition:\n        handle_happy_path()\n```\n\nWhile the latter has slightly fewer lines of code, it is far more difficult to understand when reading.\n\n### Context: Exception handling philosophy\n\n#### Context: Exception documentation\n\nDocument what exceptions each function may raise in its docstring.\n\n#### Context: Handling exceptions\n\nAttempt to handle and mitigate exceptions at the level closest to which they are first\ndetected.  If we cannot handle or mitigate the exception then it should be wrapped in a domain-appropriate\nexception class and this re-raised to the next level up the call stack.\n\nInclude contextual information when wrapping exceptions.\n\nPreserve the exception chain using `raise ... from e` syntax.\n\n#### Context: Avoid bare `except:` or `except Exception:` clauses.\n\nAvoid the use of bare `except:` or `except Exception:` clauses unless a function we are calling\ncan only have exceptions handled this way.\n\nWe should always catch specific exception types that could occur from an operation.\n\n#### Context: Exception logging\n\nAll exceptions should be logged when they occur, before re-raising or wrapping them.\n\nUse appropriate log levels:\n- ERROR for exceptions that indicate failure.\n- WARNING for exceptions that can be handled/recovered from.\n- DEBUG for detailed exception information during development.\n\nWe must include sufficient context in log messages to aid debugging.\n\nLogging must use lazy evaluation of any arguments rather.\n\n#### Context: Exception wrapping example\n\nDo this:\n\n```python\ntry:\n    await self.api_client.fetch_data()\n\nexcept ConnectionError as e:\n    logger.error(\"Failed to retrieve data from API endpoint\", exc_info=True)\n    raise DataFetchError(f\"Failed to retrieve data from API endpoint: {e}\") from e\n\nexcept TimeoutError as e:\n    logger.warning(\"API request timed out, will retry\", exc_info=True)\n```\n\nNot this:\n\n```python\ntry:\n    await self.api_client.fetch_data()\nexcept Exception as e:\n    logger.error(f\"Error: {e}\")  # Insufficient context, no stack trace\n    raise  # No wrapping or additional context\n```\n\n## Context: Dependencies\n\nLeverage standard library tools before custom solutions, unless specifically instructed, or\nunless a depdency is already in use.\n\n## Context: Tool use\n\nYou have a number of tools at your disposal.  Before using any of them, consider whether you need to use them or\nif you already have the information you require and only use them if you don't have it, or are unsure.\n\n## Context: Existing code\n\nThe following files are used in my application - as you have them here you do not need to re-read them:\n\nFile: src/humbug/tabs/tab_base.py\n\n```python\nimport uuid\nimport os\nimport logging\n\nfrom PySide6.QtWidgets import QFrame, QWidget\nfrom PySide6.QtCore import Signal, QObject, QEvent\n\nfrom humbug.mindspace.mindspace_file_watcher import MindspaceFileWatcher\nfrom humbug.status_message import StatusMessage\nfrom humbug.tabs.tab_state import TabState\n\n\nclass TabEventFilter(QObject):\n    \"\"\"Event filter to track activation events from child widgets.\"\"\"\n\n    tab_activated = Signal()\n\n    def __init__(self, parent: QWidget | None = None) -> None:\n        \"\"\"Initialize the event filter.\"\"\"\n        super().__init__(parent)\n\n    def eventFilter(self, watched: QObject, event: QEvent) -> bool:\n        \"\"\"Filter events to detect widget activation.\"\"\"\n        if event.type() in (QEvent.Type.MouseButtonPress, QEvent.Type.FocusIn):\n            if isinstance(watched, TabBase):\n                self.tab_activated.emit()\n\n            return False  # Don't consume the event\n\n        return super().eventFilter(watched, event)\n\n\nclass TabBase(QFrame):\n    \"\"\"Base class for all tab content.\"\"\"\n\n    # Common signals that both conversation and editor tabs will need\n    modified_state_changed = Signal(str, bool)  # Emits (tab_id, is_modified)\n    updated_state_changed = Signal(str, bool)  # Emits (tab_id, is_updated)\n    file_state_changed = Signal(str, bool)  # Emits (tab_id, file_exists)\n    status_message = Signal(StatusMessage)\n    activated = Signal()  # Emits when tab is activated by user interaction\n\n    def __init__(self, tab_id: str, parent: QWidget | None = None) -> None:\n        \"\"\"\n        Initialize the base tab.\n\n        Args:\n            tab_id: Unique identifier for this tab.  If not provided, a new UUID will be generated.\n            parent: Optional parent widget\n        \"\"\"\n        super().__init__(parent)\n        if not tab_id:\n            tab_id = str(uuid.uuid4())\n\n        self._tab_id = tab_id\n        self._is_modified = False\n        self._is_updated = False\n        self._is_ephemeral = False\n        self._path: str = \"\"\n        self._logger = logging.getLogger(self.__class__.__name__)\n\n        # File watching\n        self._file_watcher = MindspaceFileWatcher()\n        self._file_exists = True\n\n        # Set up activation tracking\n        self._event_filter = TabEventFilter(self)\n        self._event_filter.tab_activated.connect(self.activated)\n        self.installEventFilter(self._event_filter)\n\n    def __del__(self) -> None:\n        \"\"\"Clean up resources.\"\"\"\n        self._stop_file_watching()\n\n    def activate(self) -> None:\n        \"\"\"Activate the tab.\"\"\"\n\n    def tab_id(self) -> str:\n        \"\"\"Get the tab's unique identifier.\"\"\"\n        return self._tab_id\n\n    def is_modified(self) -> bool:\n        \"\"\"Check if the tab's content has unsaved modifications.\"\"\"\n        return self._is_modified\n\n    def _set_modified(self, modified: bool) -> None:\n        \"\"\"Update the modified state and emit signal if changed.\"\"\"\n        if modified != self._is_modified:\n            self._is_modified = modified\n            self.modified_state_changed.emit(self._tab_id, modified)\n\n    def is_updated(self) -> bool:\n        \"\"\"Check if the tab's content has been updated since last viewed.\"\"\"\n        return self._is_updated\n\n    def set_updated(self, updated: bool) -> None:\n        \"\"\"\n        Update the updated state and emit signal if changed.\n\n        Args:\n            updated: Whether the tab content has been updated\n        \"\"\"\n        if updated != self._is_updated:\n            self._is_updated = updated\n            self.updated_state_changed.emit(self._tab_id, updated)\n\n    def is_ephemeral(self) -> bool:\n        \"\"\"Check if this tab is ephemeral (will be auto-closed).\"\"\"\n        return self._is_ephemeral\n\n    def set_ephemeral(self, ephemeral: bool) -> None:\n        \"\"\"Set the ephemeral state of this tab.\"\"\"\n        self._is_ephemeral = ephemeral\n\n    def path(self) -> str:\n        \"\"\"\n        Get the path associated with this tab, if any.\n\n        Returns:\n            Path as a string, or None if not set\n        \"\"\"\n        return self._path\n\n    def set_path(self, path: str) -> None:\n        \"\"\"\n        Set the path associated with this tab.\n\n        Args:\n            path: Path to associate with this tab\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement set_path\")\n\n    def is_path_missing(self) -> bool:\n        \"\"\"\n        Check if the path associated with this tab exists.\n\n        Returns:\n            True if the path does not exist, False otherwise\n        \"\"\"\n        # If we don't have a path, it can't be missing\n        if not self._path:\n            return False\n\n        return not os.path.exists(self._path)\n\n    def _start_file_watching(self, path: str) -> None:\n        \"\"\"\n        Start watching a file for changes.\n\n        Args:\n            path: Absolute path to watch\n        \"\"\"\n        if not path:\n            return\n\n        assert os.path.isabs(path), f\"Path must be absolute: {path}\"\n\n        # Stop watching the old path if any\n        self._stop_file_watching()\n\n        try:\n            self._file_watcher.watch_file(path, self._handle_file_changed)\n            self._logger.debug(\"Started watching file: %s\", path)\n\n            # Check initial file state\n            self._check_file_state(path)\n\n        except Exception as e:\n            self._logger.error(\"Failed to start file watching for %s: %s\", path, str(e))\n\n    def _stop_file_watching(self) -> None:\n        \"\"\"Stop watching the current file.\"\"\"\n        if self._path:\n            try:\n                self._file_watcher.unwatch_file(self._path, self._handle_file_changed)\n                self._logger.debug(\"Stopped watching file: %s\", self._path)\n\n            except Exception as e:\n                self._logger.error(\"Failed to stop file watching for %s: %s\", self._path, str(e))\n\n    def _handle_file_changed(self, changed_path: str) -> None:\n        \"\"\"\n        Handle notification that the watched file has changed.\n\n        Args:\n            changed_path: Path of the file that changed\n        \"\"\"\n        self._logger.debug(\"File changed: %s\", changed_path)\n        self._check_file_state(changed_path)\n\n    def _check_file_state(self, path: str) -> None:\n        \"\"\"\n        Check if the file exists and emit signal if state changed.\n\n        Args:\n            path: Path to check\n        \"\"\"\n        try:\n            file_exists = os.path.exists(path)\n            if file_exists != self._file_exists:\n                self._file_exists = file_exists\n                self.file_state_changed.emit(self._tab_id, file_exists)\n                self._logger.debug(\"File state changed for %s: exists=%s\", path, file_exists)\n\n        except Exception as e:\n            self._logger.error(\"Failed to check file state for %s: %s\", path, str(e))\n            # Assume file doesn't exist if we can't check\n            if self._file_exists:\n                self._file_exists = False\n                self.file_state_changed.emit(self._tab_id, False)\n\n    def get_state(self, temp_state: bool) -> TabState:\n        \"\"\"\n        Get serializable state for mindspace persistence.\n\n        Must be implemented by subclasses to provide their specific state.\n\n        Args:\n            temp_state: True if we're saving temporary state to restore locally,\n                False if we're persisting state\n\n        Returns:\n            TabState object containing serializable state\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement get_state\")\n\n    @classmethod\n    def restore_from_state(cls, state: TabState, parent: QWidget) -> 'TabBase':\n        \"\"\"\n        Create and restore a tab from serialized state.\n\n        Must be implemented by subclasses to handle their specific state.\n\n        Args:\n            state: TabState object containing serialized state\n                (note: state.type will be string, not TabType enum)\n            parent: Parent widget\n\n        Returns:\n            Newly created and restored tab instance\n\n        Raises:\n            ValueError: If state is invalid for this tab type\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement restore_from_state\")\n\n    def can_close_tab(self) -> bool:\n        \"\"\"\n        Check if the tab can be closed.\n\n        Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement can_close\")\n\n    def close_tab(self) -> None:\n        \"\"\"\n        Close the tab's content if applicable.\n\n        Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement save\")\n\n    def can_save(self) -> bool:\n        \"\"\"\n        Check if the tab can be saved.\n\n        Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement can_save\")\n\n    def save(self) -> bool:\n        \"\"\"\n        Save the tab's content if applicable.\n\n        Must be implemented by subclasses.\n\n        Returns:\n            bool: True if save was successful or not needed\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement save\")\n\n    def can_save_as(self) -> bool:\n        \"\"\"\n        Check if the tab can be saved \"as\".\n\n        Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement can_save_as\")\n\n    def save_as(self) -> bool:\n        \"\"\"\n        Save the tab's content \"as\" if applicable.\n\n        Must be implemented by subclasses.\n\n        Returns:\n            bool: True if save was successful or not needed\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement save_as\")\n\n    def can_undo(self) -> bool:\n        \"\"\"\n        Check if undo operation is available.\n\n        Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement can_undo\")\n\n    def undo(self) -> None:\n        \"\"\"\n        Perform undo operation.\n\n        Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement undo\")\n\n    def can_redo(self) -> bool:\n        \"\"\"\n        Check if redo operation is available.\n\n        Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement can_redo\")\n\n    def redo(self) -> None:\n        \"\"\"\n        Perform redo operation.\n\n        Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement redo\")\n\n    def can_cut(self) -> bool:\n        \"\"\"\n        Check if cut operation is available.\n\n        Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement can_cut\")\n\n    def cut(self) -> None:\n        \"\"\"\n        Perform cut operation.\n\n        Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement cut\")\n\n    def can_copy(self) -> bool:\n        \"\"\"\n        Check if copy operation is available.\n\n        Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement can_copy\")\n\n    def copy(self) -> None:\n        \"\"\"\n        Perform copy operation.\n\n        Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement copy\")\n\n    def can_paste(self) -> bool:\n        \"\"\"\n        Check if paste operation is available.\n\n        Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement can_paste\")\n\n    def paste(self) -> None:\n        \"\"\"\n        Perform paste operation.\n\n        Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement paste\")\n\n    def show_find(self) -> None:\n        \"\"\"Show the find widget.\"\"\"\n        raise NotImplementedError(\"Subclasses must implement show_find\")\n\n    def can_submit(self) -> bool:\n        \"\"\"\n        Check if submit operation is available.\n\n        Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement can_submit\")\n\n    def submit(self) -> None:\n        \"\"\"\n        Submit the current message.\n\n        Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement submit\")\n\n    def update_status(self) -> None:\n        \"\"\"\n        Update status bar with tab-specific status information.\n\n        Must be implemented by subclasses to provide their specific status.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement update_status\")\n```\n\nFile: src/humbug/tabs/editor/editor_tab.py\n\n```python\nimport logging\n\nfrom PySide6.QtWidgets import (\n    QVBoxLayout, QWidget\n)\n\nfrom humbug.language.language_manager import LanguageManager\nfrom humbug.status_message import StatusMessage\nfrom humbug.tabs.editor.editor_widget import EditorWidget\nfrom humbug.tabs.find_widget import FindWidget\nfrom humbug.tabs.tab_base import TabBase\nfrom humbug.tabs.tab_state import TabState\nfrom humbug.tabs.tab_type import TabType\n\n\nclass EditorTab(TabBase):\n    \"\"\"Tab for editing text files.\"\"\"\n\n    def __init__(self, tab_id: str, path: str, untitled_number: int | None, parent: QWidget | None = None) -> None:\n        \"\"\"\n        Initialize editor tab.\n\n        Args:\n            tab_id: Unique identifier for this tab, or a UUID will be generated if not provided\n            path: File path to edit, or empty string for new file\n            untitled_number: Optional untitled file number for new files\n            parent: Optional parent widget\n        \"\"\"\n        super().__init__(tab_id, parent)\n        self._logger = logging.getLogger(\"EditorTab\")\n        self._path = path\n        self._untitled_number = untitled_number\n\n        self._language_manager = LanguageManager()\n        self._language_manager.language_changed.connect(self._on_language_changed)\n\n        # Set up layout\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(0, 0, 0, 0)\n        layout.setSpacing(0)\n\n        # Add find widget at top (initially hidden)\n        self._find_widget = FindWidget()\n        self._find_widget.hide()\n        self._find_widget.closed.connect(self._close_find)\n        self._find_widget.find_next.connect(lambda: self._find_next(True))\n        self._find_widget.find_previous.connect(lambda: self._find_next(False))\n        layout.addWidget(self._find_widget)\n\n        # Create editor widget\n        self._editor_widget = EditorWidget(path, untitled_number, self)\n        self._editor_widget.content_modified.connect(self._on_content_modified)\n        self._editor_widget.status_updated.connect(self.update_status)\n        self._editor_widget.activated.connect(self.activated)\n        self._editor_widget.file_saved.connect(self._on_file_saved)\n        layout.addWidget(self._editor_widget)\n\n        # Start file watching if we have a path\n        if self._path:\n            self._start_file_watching(self._path)\n\n        self.update_status()\n\n    def activate(self) -> None:\n        \"\"\"Activate the tab.\"\"\"\n        self._editor_widget.setFocus()\n\n    def _on_content_modified(self, modified: bool) -> None:\n        \"\"\"Handle content modification changes.\"\"\"\n        self._set_modified(modified)\n\n    def _on_file_saved(self, path: str) -> None:\n        \"\"\"Handle file being saved.\"\"\"\n        self.set_path(path)\n        self.update_status()\n\n    def _on_language_changed(self) -> None:\n        \"\"\"Update language-specific elements.\"\"\"\n        # Update find widget text if visible\n        if not self._find_widget.isHidden():\n            current, total = self._editor_widget.get_match_status()\n            self._find_widget.set_match_status(current, total)\n\n        # Update status bar with translated terms\n        self.update_status()\n\n    def get_state(self, temp_state: bool=False) -> TabState:\n        \"\"\"Get serializable state for mindspace persistence.\"\"\"\n        metadata = self._editor_widget.create_state_metadata(temp_state)\n\n        path = self._editor_widget.path()\n        if not path and self._untitled_number:\n            path = f\"untitled-{self._untitled_number}\"\n\n        return TabState(\n            type=TabType.EDITOR,\n            tab_id=self._tab_id,\n            path=path,\n            metadata=metadata\n        )\n\n    @classmethod\n    def restore_from_state(cls, state: TabState, parent: QWidget) -> 'EditorTab':\n        \"\"\"Create and restore an editor tab from serialized state.\"\"\"\n        # Set filename and load content\n        number: int | None = None\n        path = \"\"\n\n        if state.path.startswith(\"untitled-\"):\n            number = int(state.path.split(\"-\")[1])\n\n        else:\n            path = state.path\n\n        # Create new tab instance\n        tab = cls(state.tab_id, path, number, parent)\n\n        if state.metadata:\n            tab._editor_widget.restore_from_metadata(state.metadata)\n\n        return tab\n\n    def set_path(self, path: str) -> None:\n        \"\"\"\n        Set the file being edited.\n\n        Args:\n            path: Path to file\n        \"\"\"\n        # Stop watching old path\n        if self._path != path:\n            self._stop_file_watching()\n\n        self._path = path\n        self._editor_widget.set_path(path)\n\n        # Start watching new path\n        if path:\n            self._start_file_watching(path)\n\n        self.update_status()\n\n    def update_status(self) -> None:\n        \"\"\"Update status bar with current cursor position.\"\"\"\n        status_info = self._editor_widget.get_status_info()\n        strings = self._language_manager.strings()\n        message = StatusMessage(\n            strings.editor_status.format(**status_info)\n        )\n        self.status_message.emit(message)\n\n    def can_close_tab(self) -> bool:\n        \"\"\"Check if the file can be closed.\"\"\"\n        return self._editor_widget.can_close()\n\n    def close_tab(self) -> None:\n        \"\"\"Close the tab and clean up resources.\"\"\"\n        self._editor_widget.close_widget()\n\n    def can_save(self) -> bool:\n        \"\"\"Check if the file can be saved.\"\"\"\n        return self._editor_widget.is_modified()\n\n    def save(self) -> bool:\n        \"\"\"\n        Save the current file.\n\n        Returns:\n            bool: True if save was successful\n        \"\"\"\n        return self._editor_widget.save_file()\n\n    def can_save_as(self) -> bool:\n        \"\"\"Check if the file can be saved as.\"\"\"\n        return True\n\n    def save_as(self) -> bool:\n        \"\"\"\n        Show save as dialog and save file.\n\n        Returns:\n            bool: True if save was successful\n        \"\"\"\n        return self._editor_widget.save_file_as()\n\n    def can_undo(self) -> bool:\n        \"\"\"Check if undo is available.\"\"\"\n        return self._editor_widget.can_undo()\n\n    def undo(self) -> None:\n        \"\"\"Undo the last edit operation.\"\"\"\n        self._editor_widget.undo()\n\n    def can_redo(self) -> bool:\n        \"\"\"Check if redo is available.\"\"\"\n        return self._editor_widget.can_redo()\n\n    def redo(self) -> None:\n        \"\"\"Redo the last undone edit operation.\"\"\"\n        self._editor_widget.redo()\n\n    def can_cut(self) -> bool:\n        \"\"\"Check if cut is available.\"\"\"\n        return self._editor_widget.can_cut()\n\n    def cut(self) -> None:\n        \"\"\"Cut selected text to clipboard.\"\"\"\n        self._editor_widget.cut()\n\n    def can_copy(self) -> bool:\n        \"\"\"Check if copy is available.\"\"\"\n        return self._editor_widget.can_copy()\n\n    def copy(self) -> None:\n        \"\"\"Copy selected text to clipboard.\"\"\"\n        self._editor_widget.copy()\n\n    def can_paste(self) -> bool:\n        \"\"\"Check if paste is available.\"\"\"\n        return self._editor_widget.can_paste()\n\n    def paste(self) -> None:\n        \"\"\"Paste text from clipboard.\"\"\"\n        self._editor_widget.paste()\n\n    def can_submit(self) -> bool:\n        \"\"\"Check if submit is available (not applicable for editor).\"\"\"\n        return False\n\n    def submit(self) -> None:\n        \"\"\"Submit operation (not applicable for editor).\"\"\"\n\n    def show_find(self) -> None:\n        \"\"\"Show the find widget.\"\"\"\n        cursor = self._editor_widget.textCursor()\n        if cursor.hasSelection():\n            # Get the selected text\n            text = cursor.selectedText()\n\n            # Only use selection if it's on a single line\n            if '\\u2029' not in text:  # Qt uses this character for line breaks\n                self._find_widget.set_search_text(text)\n            else:\n                self._find_widget.set_search_text(\"\")\n\n        self._find_widget.show()\n        self._find_widget.setFocus()\n\n    def _close_find(self) -> None:\n        \"\"\"Close the find widget and clear search state.\"\"\"\n        self._find_widget.hide()\n        self._editor_widget.clear_find()\n\n    def _find_next(self, forward: bool = True) -> None:\n        \"\"\"Find next/previous match.\"\"\"\n        text = self._find_widget.get_search_text()\n        self._editor_widget.find_text(text, forward)\n        current, total = self._editor_widget.get_match_status()\n        self._find_widget.set_match_status(current, total)\n```\n\n# Action:\n\nThe code now tracks if a file being edited exists or not, and if that changes state.  I would like to extend this\nso if the file changes without the user making the change themselves that we will reload the file contents.  We will\ndo this if and only if the file is not modified.  When this occurs, we will also set the updated marker for the tab\nto give the user a visual cue.\n\nI don't want you to code anything yet - I want to understand ways we can do this and to ask questions.",
      "completed": true,
      "model": "claude-sonnet-4-20250514",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "c3a377ee-122d-47c6-b950-030f71365ff7",
      "timestamp": "2025-08-29T17:23:51.476971+00:00",
      "type": "ai_response",
      "content": "Looking at the existing code, I can see a good foundation for implementing file reload functionality. Let me analyze the current architecture and suggest approaches.\n\n## Current Architecture Analysis\n\nThe code already has:\n- File watching via `MindspaceFileWatcher` in `TabBase`\n- Modified state tracking (`_is_modified`)\n- Updated state tracking (`_is_updated`) \n- File existence tracking (`_file_exists`)\n- A `_handle_file_changed()` method that currently only checks file existence\n\n## Proposed Approaches\n\n### Approach 1: Extend Current File Watching\nEnhance the existing `_handle_file_changed()` method in `TabBase` to detect content changes, not just existence changes. The logic would be:\n\n1. When file changes, check if tab is modified\n2. If not modified, trigger a reload in the subclass\n3. Set the updated marker after successful reload\n\n**Questions:**\n- How should we detect that the file content actually changed vs. just metadata (timestamps, permissions)?\n- Should we use file modification time, content hashing, or file size as change detection?\n\n### Approach 2: EditorTab-Specific Implementation\nImplement the reload logic specifically in `EditorTab` by:\n\n1. Override `_handle_file_changed()` in `EditorTab`\n2. Add a new method like `reload_file_content()` to `EditorWidget`\n3. Handle the reload at the editor level where we have access to the actual content\n\n**Questions:**\n- Should this be a `TabBase` feature that all tab types can use, or editor-specific?\n- How do we preserve cursor position and selection after reload?\n\n### Approach 3: Event-Driven Architecture\nCreate a more sophisticated event system:\n\n1. Emit a new signal like `file_content_changed` from `TabBase`\n2. Let `EditorTab` connect to this signal and handle reload\n3. Separate content change detection from reload logic\n\n## Key Design Questions\n\n1. **Change Detection Strategy**: What's the most reliable way to detect actual content changes?\n   - File modification time comparison?\n   - Content hash comparison?\n   - File size + mtime combination?\n\n2. **User Experience**: \n   - Should we show any notification to the user when auto-reload occurs?\n   - Should we preserve undo history after reload?\n   - How do we handle cursor position - restore it or move to top?\n\n3. **Error Handling**:\n   - What if the file becomes unreadable during reload?\n   - What if the file is deleted and then recreated?\n   - Should we have a retry mechanism for transient file system issues?\n\n4. **Race Conditions**:\n   - How do we handle rapid file changes?\n   - What if the user starts typing while a reload is in progress?\n\n5. **Architecture**:\n   - Should `EditorWidget` gain a `reload_from_disk()` method?\n   - Should the reload logic live in `TabBase`, `EditorTab`, or `EditorWidget`?\n\nWhich approach appeals to you most, and how would you like to handle these design decisions?",
      "completed": true,
      "usage": {
        "prompt_tokens": 10357,
        "completion_tokens": 710,
        "total_tokens": 11067
      },
      "model": "claude-sonnet-4-20250514",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "3f9158c2-6f06-4e12-a2a3-31923f973e51",
      "timestamp": "2025-08-29T17:29:54.913035+00:00",
      "type": "user_message",
      "content": "approach 2 seems good.\n\nQuestions:\n\n1. Use the current detection logic. We can enhance this later?\n2. By setting marking the tab updated this will handle this problem.\n3. If the file is unreadable then leave an empty editor view. If the file is deleted and recreated we'll get 2 updates in quick succession. This is ok\n4. Don't worry about rapid updates. Once the user starts typing then the tab will be marked modified and we do not auto-reload modified tabs.\n5. Yes EditorWidget should get a reload_from_disk() method - this should be called `refresh_content()` for consistency with the wiki widget. Reload logic should be in this new method",
      "completed": true,
      "model": "claude-sonnet-4-20250514",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "90aab717-89cb-4cae-8513-b49734938282",
      "timestamp": "2025-08-29T17:29:56.867957+00:00",
      "type": "ai_response",
      "content": "Perfect! That clarifies the approach nicely. Let me summarize what I understand:\n\n## Implementation Plan\n\n### Changes to `EditorTab`:\n1. Override `_handle_file_changed()` to add content reload logic\n2. Check if tab is not modified before triggering reload\n3. Call `refresh_content()` on the `EditorWidget`\n4. Set the updated marker after successful reload\n\n### Changes to `EditorWidget`:\n1. Add a new `refresh_content()` method that:\n   - Reads the current file from disk\n   - Replaces the editor content\n   - Handles the case where file is unreadable (empty editor)\n   - Maintains consistency with wiki widget naming\n\n### Key Logic Flow:\n```\nFile changes \u2192 _handle_file_changed() called\n\u2193\nCheck: is tab modified? \n\u2193 (if not modified)\nCall editor_widget.refresh_content()\n\u2193 (if successful)\nSet tab updated marker\n```\n\n## Questions for Implementation:\n\n1. **Cursor Position**: Should `refresh_content()` attempt to preserve the cursor position, or just reset to the beginning? (Given that content may have changed significantly, preserving position might not always make sense)\n\n2. **Selection**: Similarly, should we clear any text selection after refresh?\n\n3. **Return Value**: Should `refresh_content()` return a boolean indicating success/failure, so `EditorTab` knows whether to set the updated marker?\n\n4. **Error Logging**: Should `refresh_content()` handle its own error logging, or let `EditorTab` handle that?\n\n5. **Modified State**: After `refresh_content()`, should we explicitly ensure the modified state is cleared (in case the refresh somehow triggers modification signals)?\n\nDoes this align with your vision? Any preferences on these implementation details?",
      "completed": true,
      "usage": {
        "prompt_tokens": 11225,
        "completion_tokens": 412,
        "total_tokens": 11637
      },
      "model": "claude-sonnet-4-20250514",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "bd4bb5f2-8d9a-4bec-bda1-fdea50bbaa8d",
      "timestamp": "2025-08-29T17:32:27.445609+00:00",
      "type": "user_message",
      "content": "1. Reset to the beginning\n2. Clear any selections\n3. We probably don't need this as the editor widget signals things already?\n4. It should handle its own logging\n5. We should not change the modification state",
      "completed": true,
      "model": "claude-sonnet-4-20250514",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "462dc3ff-91d5-4002-82df-5a7a1679becf",
      "timestamp": "2025-08-29T17:32:29.443607+00:00",
      "type": "ai_response",
      "content": "Perfect! That makes the implementation much cleaner. Let me confirm my understanding:\n\n## Implementation Summary\n\n### `EditorTab._handle_file_changed()` override:\n- Check if `not self.is_modified()`\n- If true, call `self._editor_widget.refresh_content()`\n- Set `self.set_updated(True)` to give visual cue\n- Let existing file existence logic run via `super()._handle_file_changed()`\n\n### `EditorWidget.refresh_content()` method:\n- Read file from disk (handle unreadable files with empty content)\n- Replace editor content\n- Reset cursor to beginning\n- Clear any selections  \n- Handle its own error logging\n- **Don't** touch the modification state\n- Let existing signals handle any state updates naturally\n\nThis approach is clean because:\n- We leverage existing file watching infrastructure\n- We use existing signaling for state management\n- Error handling is localized\n- The modification state remains untouched (important for the reload condition)\n\nThe flow becomes very straightforward:\n1. File changes \u2192 `_handle_file_changed()` called\n2. If not modified \u2192 refresh content + set updated marker\n3. User gets visual cue via updated marker\n4. All other state management happens through existing signals\n\nDoes this capture what you want? Should I proceed with implementing this?",
      "completed": true,
      "usage": {
        "prompt_tokens": 11689,
        "completion_tokens": 304,
        "total_tokens": 11993
      },
      "model": "claude-sonnet-4-20250514",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "8123b91f-54f9-400b-b32a-df3fcf808a59",
      "timestamp": "2025-08-29T17:32:45.401096+00:00",
      "type": "user_message",
      "content": "great - please update the code",
      "completed": true,
      "model": "claude-sonnet-4-20250514",
      "reasoning_capability": 1,
      "temperature": 0.7
    },
    {
      "id": "20cba65c-f3ed-429d-ae38-606aeb0203db",
      "timestamp": "2025-08-29T17:32:49.048575+00:00",
      "type": "ai_response",
      "content": "I'll implement the changes to both files. Let me start with the `EditorWidget.refresh_content()` method and then update `EditorTab`.",
      "completed": true,
      "usage": {
        "prompt_tokens": 12002,
        "completion_tokens": 118,
        "total_tokens": 12120
      },
      "model": "claude-sonnet-4-20250514",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_01Q1YFBg6h7fCoht5sqdojAe",
          "name": "filesystem",
          "arguments": {
            "operation": "read_file",
            "path": "src/humbug/tabs/editor/editor_widget.py"
          }
        }
      ]
    },
    {
      "id": "5d2fa817-029c-4180-a664-e4a8436b9faf",
      "timestamp": "2025-08-29T17:32:50.548206+00:00",
      "type": "tool_call",
      "content": "```json\n{\n    \"id\": \"toolu_01Q1YFBg6h7fCoht5sqdojAe\",\n    \"name\": \"filesystem\",\n    \"arguments\": {\n        \"operation\": \"read_file\",\n        \"path\": \"src/humbug/tabs/editor/editor_widget.py\"\n    }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_01Q1YFBg6h7fCoht5sqdojAe",
          "name": "filesystem",
          "arguments": {
            "operation": "read_file",
            "path": "src/humbug/tabs/editor/editor_widget.py"
          }
        }
      ]
    },
    {
      "id": "d88e66ba-7491-492c-af37-2a1d8d13882b",
      "timestamp": "2025-08-29T17:32:50.561416+00:00",
      "type": "tool_result",
      "content": "```json\n{\n    \"id\": \"toolu_01Q1YFBg6h7fCoht5sqdojAe\",\n    \"name\": \"filesystem\",\n    \"content\": \"File: src/humbug/tabs/editor/editor_widget.py\\nSize: 42,336 bytes\\nEncoding: utf-8\\n\\nimport logging\\nimport os\\nimport time\\nfrom typing import List, Tuple, Dict, Any, cast\\n\\nfrom PySide6.QtWidgets import QPlainTextEdit, QWidget, QTextEdit, QFileDialog\\nfrom PySide6.QtCore import Qt, QRect, Signal, QObject, QEvent, QTimer\\nfrom PySide6.QtGui import (\\n    QPainter, QTextCursor, QKeyEvent, QPalette, QBrush, QTextCharFormat,\\n    QResizeEvent, QPaintEvent\\n)\\n\\nfrom syntax import ProgrammingLanguage, ProgrammingLanguageUtils\\n\\nfrom humbug.color_role import ColorRole\\nfrom humbug.language.language_manager import LanguageManager\\nfrom humbug.message_box import MessageBox, MessageBoxType, MessageBoxButton\\nfrom humbug.mindspace.mindspace_manager import MindspaceManager\\nfrom humbug.mindspace.mindspace_settings import MindspaceSettings\\nfrom humbug.style_manager import StyleManager\\nfrom humbug.tabs.editor.editor_highlighter import EditorHighlighter\\nfrom humbug.tabs.editor.editor_line_number_area import EditorLineNumberArea\\n\\n\\nclass EditorWidgetEventFilter(QObject):\\n    \\\"\\\"\\\"Event filter to track activation events from child widgets.\\\"\\\"\\\"\\n\\n    widget_activated = Signal(object)\\n    widget_deactivated = Signal(object)\\n\\n    def __init__(self, parent: QWidget | None = None) -> None:\\n        \\\"\\\"\\\"Initialize the event filter.\\\"\\\"\\\"\\n        super().__init__(parent)\\n\\n    def eventFilter(self, watched: QObject, event: QEvent) -> bool:\\n        \\\"\\\"\\\"\\n        Filter events to detect widget activation.\\n\\n        Args:\\n            obj: The object that received the event\\n            event: The event that was received\\n\\n        Returns:\\n            True if event was handled, False to pass to the target object\\n        \\\"\\\"\\\"\\n        if event.type() in (QEvent.Type.MouseButtonPress, QEvent.Type.FocusIn):\\n            # Simply emit the signal with the object that received the event\\n            self.widget_activated.emit(watched)\\n            return False  # Don't consume the event\\n\\n        if event.type() == QEvent.Type.FocusOut:\\n            # Emit a widget deactivated signal\\n            self.widget_deactivated.emit(watched)\\n            return False  # Don't consume the event\\n\\n        return super().eventFilter(watched, event)\\n\\n\\nclass EditorWidget(QPlainTextEdit):\\n    \\\"\\\"\\\"Text editor widget with line numbers, syntax highlighting, and find functionality.\\\"\\\"\\\"\\n\\n    # Content/state changes\\n    content_modified = Signal(bool)  # True if modified, False if saved\\n    status_updated = Signal()        # Request status bar update\\n    activated = Signal()             # User interaction occurred\\n    file_saved = Signal(str)         # File path saved\\n\\n    def __init__(self, path: str = \\\"\\\", untitled_number: int | None = None, parent: QWidget | None = None) -> None:\\n        \\\"\\\"\\\"\\n        Initialize the editor widget.\\n\\n        Args:\\n            path: Optional file path to load\\n            untitled_number: Optional untitled file number for new files\\n            parent: Optional parent widget\\n        \\\"\\\"\\\"\\n        super().__init__(parent)\\n        self._logger = logging.getLogger(\\\"EditorWidget\\\")\\n\\n        # File state\\n        self._path = path\\n        self._untitled_number = untitled_number\\n        self._last_save_content = \\\"\\\"\\n        self._is_modified = False\\n\\n        # Editor settings\\n        self.setLineWrapMode(QPlainTextEdit.LineWrapMode.NoWrap)  # No word wrap for code\\n        self.setTabStopDistance(32)  # 4 spaces worth of tab stops\\n\\n        # Enable standard scrollbars\\n        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)\\n        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)\\n\\n        self._style_manager = StyleManager()\\n        self._init_colour_mode = self._style_manager.color_mode()\\n\\n        # Setup line number area\\n        self._line_number_area = EditorLineNumberArea(\\n            self, self._line_number_area_width, self._line_number_area_paint_event\\n        )\\n        font = self._line_number_area.font()\\n        font.setFamilies(self._style_manager.monospace_font_families())\\n        self.setFont(font)\\n        self._line_number_area.setFont(font)\\n\\n        self.blockCountChanged.connect(self._update_line_number_area_width)\\n        self.updateRequest.connect(self._update_line_number_area)\\n\\n        self._language_manager = LanguageManager()\\n        self._language_manager.language_changed.connect(self._on_language_changed)\\n        self._update_line_number_area_width()\\n\\n        # Highlighted text should retain any underlying colours (e.g. syntax highlighting)\\n        palette = self.palette()\\n        palette.setBrush(QPalette.ColorRole.HighlightedText, QBrush(Qt.BrushStyle.NoBrush))\\n        self.setPalette(palette)\\n\\n        # Initialize find functionality\\n        self._matches: List[Tuple[int, int]] = []  # List of (start, end) positions\\n        self._current_match = -1\\n        self._last_search = \\\"\\\"\\n\\n        # Programming language and syntax highlighting\\n        self._current_programming_language = ProgrammingLanguage.TEXT\\n        self._highlighter = EditorHighlighter(self.document())\\n\\n        # Auto-backup functionality\\n        self._auto_backup_timer = QTimer(self)\\n        self._auto_backup_timer.timeout.connect(self._auto_backup)\\n\\n        # Mindspace integration\\n        self._mindspace_manager = MindspaceManager()\\n        self._mindspace_manager.settings_changed.connect(self._on_mindspace_settings_changed)\\n\\n        # Set up activation tracking\\n        self._event_filter = EditorWidgetEventFilter(self)\\n        self._event_filter.widget_activated.connect(self._on_widget_activated)\\n        self._event_filter.widget_deactivated.connect(self._on_widget_deactivated)\\n        self.installEventFilter(self._event_filter)\\n\\n        # Connect text changes\\n        self.textChanged.connect(self._on_text_changed)\\n        self.cursorPositionChanged.connect(self.status_updated)\\n\\n        # Connect to style changes\\n        self._style_manager.style_changed.connect(self._on_style_changed)\\n        self._on_style_changed()\\n\\n        # Load file if path provided\\n        if self._path:\\n            self._load_file()\\n\\n        # Update programming language based on path\\n        self._update_programming_language_from_path()\\n\\n        # Update auto-backup based on current mindspace settings\\n        self._update_auto_backup_from_settings()\\n\\n    def _load_file(self) -> None:\\n        \\\"\\\"\\\"Load content from file path.\\\"\\\"\\\"\\n        if not self._path or not os.path.exists(self._path):\\n            return\\n\\n        try:\\n            with open(self._path, 'r', encoding='utf-8') as f:\\n                content = f.read()\\n\\n            self.setPlainText(content)\\n            self._last_save_content = content\\n            self._set_modified(False)\\n\\n        except Exception as e:\\n            self._logger.error(\\\"Failed to load file '%s': %s\\\", self._path, str(e))\\n            strings = self._language_manager.strings()\\n            MessageBox.show_message(\\n                self,\\n                MessageBoxType.CRITICAL,\\n                strings.error_opening_file_title,\\n                strings.could_not_open.format(self._path, str(e))\\n            )\\n\\n    def _update_programming_language_from_path(self) -> None:\\n        \\\"\\\"\\\"Update programming language based on current path.\\\"\\\"\\\"\\n        if self._path:\\n            new_language = ProgrammingLanguageUtils.from_file_extension(self._path)\\n\\n        else:\\n            new_language = ProgrammingLanguage.TEXT\\n\\n        self._update_programming_language(new_language)\\n\\n    def _update_programming_language(self, new_language: ProgrammingLanguage) -> None:\\n        \\\"\\\"\\\"\\n        Update the syntax highlighting language.\\n\\n        Args:\\n            new_language: The new programming language to use\\n        \\\"\\\"\\\"\\n        if self._current_programming_language != new_language:\\n            self._current_programming_language = new_language\\n            self._highlighter.set_language(new_language)\\n            self.status_updated.emit()\\n\\n    def _update_auto_backup_from_settings(self) -> None:\\n        \\\"\\\"\\\"Update auto-backup settings from mindspace.\\\"\\\"\\\"\\n        if not self._mindspace_manager.has_mindspace():\\n            self._auto_backup_timer.stop()\\n            return\\n\\n        settings = self._mindspace_manager.settings()\\n        if settings is None:\\n            self._auto_backup_timer.stop()\\n            return\\n\\n        self._update_auto_backup_settings(settings.auto_backup, settings.auto_backup_interval)\\n\\n    def _update_auto_backup_settings(self, enabled: bool, interval: int) -> None:\\n        \\\"\\\"\\\"Update auto-backup settings.\\\"\\\"\\\"\\n        if enabled:\\n            self._auto_backup_timer.setInterval(interval * 1000)  # Convert to milliseconds\\n            if self._is_modified:\\n                # If we have unsaved changes, start backup immediately\\n                self._auto_backup_timer.start()\\n            return\\n\\n        clear_backups = self._auto_backup_timer.isActive()\\n        self._auto_backup_timer.stop()\\n\\n        # Clean up any existing backups since auto-backup is disabled\\n        if clear_backups:\\n            self._cleanup_backup_files()\\n\\n    def _set_modified(self, modified: bool) -> None:\\n        \\\"\\\"\\\"\\n        Set the modified state and emit appropriate signals.\\n\\n        Args:\\n            modified: Whether the content is modified\\n        \\\"\\\"\\\"\\n        if self._is_modified != modified:\\n            self._is_modified = modified\\n            self.content_modified.emit(modified)\\n\\n    def _on_mindspace_settings_changed(self) -> None:\\n        \\\"\\\"\\\"Handle mindspace settings changes.\\\"\\\"\\\"\\n        self._update_auto_backup_from_settings()\\n\\n    def _on_widget_activated(self, _widget: QWidget) -> None:\\n        \\\"\\\"\\\"\\n        Handle activation of a widget.\\n\\n        Args:\\n            widget: The widget that was activated\\n        \\\"\\\"\\\"\\n        # Emit activated signal to let the tab know this editor was clicked\\n        self.activated.emit()\\n\\n    def _on_widget_deactivated(self, widget: QWidget) -> None:\\n        \\\"\\\"\\\"\\n        Handle deactivation of a widget.\\n\\n        Args:\\n            widget: The widget lost focus\\n        \\\"\\\"\\\"\\n\\n    def _on_language_changed(self) -> None:\\n        \\\"\\\"\\\"Handle language changes by updating the UI.\\\"\\\"\\\"\\n        self._update_line_number_area_width()\\n        self.viewport().update()\\n        self.status_updated.emit()\\n\\n    def _on_text_changed(self) -> None:\\n        \\\"\\\"\\\"Handle changes to editor content.\\\"\\\"\\\"\\n        current_content = self.toPlainText()\\n        is_modified = current_content != self._last_save_content\\n        self._set_modified(is_modified)\\n\\n        if not self._mindspace_manager.has_mindspace():\\n            return\\n\\n        settings = self._mindspace_manager.settings()\\n        if settings is None:\\n            return\\n\\n        if settings.auto_backup:\\n            if is_modified and not self._auto_backup_timer.isActive():\\n                self._auto_backup_timer.start()\\n\\n            elif not is_modified:\\n                self._auto_backup_timer.stop()\\n\\n    def _auto_backup(self) -> None:\\n        \\\"\\\"\\\"Handle auto-backup functionality.\\\"\\\"\\\"\\n        if not self._is_modified:\\n            return\\n\\n        # All backups should now go in mindspace .humbug/backups\\n        if not self._mindspace_manager.has_mindspace():\\n            return  # No backups without a mindspace\\n\\n        backup_dir = self._mindspace_manager.get_absolute_path(os.path.join(\\\".humbug\\\", \\\"backups\\\"))\\n        os.makedirs(backup_dir, exist_ok=True)\\n\\n        if not self._path:\\n            # For untitled files, use timestamp-based backup in mindspace\\n            prefix = f\\\"backup-{self._untitled_number}-\\\"\\n            current_time = int(time.time())\\n            try:\\n                # Clean up old backups for this untitled file\\n                for file in os.listdir(backup_dir):\\n                    if file.startswith(prefix):\\n                        file_path = os.path.join(backup_dir, file)\\n\\n                        # Keep only backups from last hour\\n                        if current_time - os.path.getctime(file_path) > 3600:\\n                            try:\\n                                os.remove(file_path)\\n\\n                            except OSError as e:\\n                                self._logger.warning(\\\"Failed to remove old backup %s: %s\\\", file_path, str(e))\\n\\n            except OSError as e:\\n                self._logger.warning(\\\"Failed to clean up old backups: %s\\\", str(e))\\n\\n            backup_file = os.path.join(\\n                backup_dir,\\n                f\\\"{prefix}{current_time}.txt\\\"\\n            )\\n\\n        else:\\n            backup_file = f\\\"{self._path}.backup\\\"\\n\\n            # Clean up any very old backups that might have been left behind\\n            try:\\n                if os.path.exists(backup_file):\\n                    if time.time() - os.path.getctime(backup_file) > 86400:  # 24 hours\\n                        try:\\n                            os.remove(backup_file)\\n\\n                        except OSError:\\n                            pass  # Ignore cleanup errors for old files\\n\\n            except OSError:\\n                pass  # Ignore stat errors\\n\\n        try:\\n            with open(backup_file, 'w', encoding='utf-8') as f:\\n                f.write(self.toPlainText())\\n\\n        except Exception as e:\\n            self._logger.error(\\\"Failed to create backup file '%s': %s\\\", backup_file, str(e))\\n\\n    def _cleanup_backup_files(self) -> None:\\n        \\\"\\\"\\\"Clean up any backup files for this editor.\\\"\\\"\\\"\\n        if not self._mindspace_manager.has_mindspace():\\n            return\\n\\n        if self._path:\\n            # Clean up backup for saved file\\n            backup_file = f\\\"{self._path}.backup\\\"\\n            try:\\n                if os.path.exists(backup_file):\\n                    os.remove(backup_file)\\n\\n            except OSError as e:\\n                self._logger.warning(\\\"Failed to remove backup file %s: %s\\\", backup_file, str(e))\\n\\n        elif self._untitled_number:\\n            # Clean up backups for untitled file\\n            backup_dir = self._mindspace_manager.get_absolute_path(os.path.join(\\\".humbug\\\", \\\"backups\\\"))\\n            prefix = f\\\"backup-{self._untitled_number}-\\\"\\n            try:\\n                for file in os.listdir(backup_dir):\\n                    if file.startswith(prefix):\\n                        try:\\n                            os.remove(os.path.join(backup_dir, file))\\n\\n                        except OSError as e:\\n                            self._logger.warning(\\\"Failed to remove backup %s: %s\\\", file, str(e))\\n\\n            except OSError as e:\\n                self._logger.warning(\\\"Failed to clean up backups: %s\\\", str(e))\\n\\n    def path(self) -> str:\\n        \\\"\\\"\\\"Get the current file path.\\\"\\\"\\\"\\n        return self._path\\n\\n    def set_path(self, path: str) -> None:\\n        \\\"\\\"\\\"\\n        Set the file path and update language detection.\\n\\n        Args:\\n            path: Path to file\\n        \\\"\\\"\\\"\\n        self._path = path\\n        self._untitled_number = None\\n        self._update_programming_language_from_path()\\n\\n    def is_modified(self) -> bool:\\n        \\\"\\\"\\\"Check if the content has been modified.\\\"\\\"\\\"\\n        return self._is_modified\\n\\n    def can_close(self) -> bool:\\n        \\\"\\\"\\\"Check if the editor can be closed, handling unsaved changes.\\\"\\\"\\\"\\n        if not self._is_modified:\\n            return True\\n\\n        strings = self._language_manager.strings()\\n        document_name = self._path or f'Untitled-{self._untitled_number}'\\n        result = MessageBox.show_message(\\n            self,\\n            MessageBoxType.QUESTION,\\n            strings.save_changes_title,\\n            strings.unsaved_changes.format(document_name),\\n            [MessageBoxButton.SAVE, MessageBoxButton.DISCARD, MessageBoxButton.CANCEL]\\n        )\\n\\n        if result == MessageBoxButton.SAVE:\\n            return self.save_file()\\n\\n        if result == MessageBoxButton.DISCARD:\\n            self._set_modified(False)\\n            return True\\n\\n        return False\\n\\n    def close_widget(self) -> None:\\n        \\\"\\\"\\\"Close the editor widget and clean up resources.\\\"\\\"\\\"\\n        # Delete any backup files when we close\\n        if self._auto_backup_timer.isActive():\\n            self._cleanup_backup_files()\\n\\n    def save_file(self) -> bool:\\n        \\\"\\\"\\\"\\n        Save the current file.\\n\\n        Returns:\\n            bool: True if save was successful\\n        \\\"\\\"\\\"\\n        if not self._path:\\n            return self.save_file_as()\\n\\n        try:\\n            content = self.toPlainText()\\n            with open(self._path, 'w', encoding='utf-8') as f:\\n                f.write(content)\\n\\n            self._last_save_content = content\\n            self._set_modified(False)\\n\\n            # Delete any backup files\\n            backup_file = f\\\"{self._path}.backup\\\"\\n            try:\\n                if os.path.exists(backup_file):\\n                    os.remove(backup_file)\\n\\n            except OSError as e:\\n                self._logger.warning(\\\"Failed to remove backup file %s: %s\\\", backup_file, str(e))\\n\\n            self.file_saved.emit(self._path)\\n            return True\\n\\n        except Exception as e:\\n            strings = self._language_manager.strings()\\n            MessageBox.show_message(\\n                self,\\n                MessageBoxType.CRITICAL,\\n                strings.error_saving_file_title,\\n                strings.could_not_save.format(self._path, str(e))\\n            )\\n            return False\\n\\n    def save_file_as(self) -> bool:\\n        \\\"\\\"\\\"\\n        Show save as dialog and save file.\\n\\n        Returns:\\n            bool: True if save was successful\\n        \\\"\\\"\\\"\\n        strings = self._language_manager.strings()\\n        export_dialog = QFileDialog()\\n        export_dialog.setWindowTitle(strings.file_dialog_save_file)\\n\\n        if self._path:\\n            export_dialog.setDirectory(self._path)\\n\\n        else:\\n            fd_dir = self._mindspace_manager.file_dialog_directory()\\n            if not fd_dir:\\n                return False\\n\\n            export_dialog.setDirectory(fd_dir)\\n\\n        export_dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptSave)\\n        if export_dialog.exec_() != QFileDialog.DialogCode.Accepted:\\n            return False\\n\\n        filename = export_dialog.selectedFiles()[0]\\n        self._mindspace_manager.update_file_dialog_directory(filename)\\n        self.set_path(filename)\\n\\n        return self.save_file()\\n\\n    def get_status_info(self) -> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Get status information for the status bar.\\n\\n        Returns:\\n            Dictionary with status information\\n        \\\"\\\"\\\"\\n        cursor = self.textCursor()\\n        line = cursor.blockNumber() + 1\\n        column = cursor.columnNumber() + 1\\n\\n        # Get file info\\n        encoding = \\\"UTF-8\\\"\\n        line_ending = \\\"LF\\\"  # We could detect this from file content\\n\\n        # Get language name for display\\n        file_type = ProgrammingLanguageUtils.get_display_name(self._current_programming_language)\\n\\n        return {\\n            'line': line,\\n            'column': column,\\n            'encoding': encoding,\\n            'line_ending': line_ending,\\n            'type': file_type\\n        }\\n\\n    def create_state_metadata(self, temp_state: bool) -> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Create metadata dictionary capturing current widget state.\\n\\n        Args:\\n            temp_state: Whether this is temporary state for moving tabs\\n\\n        Returns:\\n            Dictionary containing editor state metadata\\n        \\\"\\\"\\\"\\n        metadata: Dict[str, Any] = {}\\n\\n        metadata[\\\"language\\\"] = self._current_programming_language.name\\n        metadata[\\\"cursor\\\"] = self._get_cursor_position()\\n        metadata[\\\"horizontal_scroll\\\"] = self.horizontalScrollBar().value()\\n        metadata[\\\"vertical_scroll\\\"] = self.verticalScrollBar().value()\\n\\n        if temp_state:\\n            metadata[\\\"content\\\"] = self.toPlainText()\\n\\n        return metadata\\n\\n    def restore_from_metadata(self, metadata: Dict[str, Any]) -> None:\\n        \\\"\\\"\\\"\\n        Restore widget state from metadata.\\n\\n        Args:\\n            metadata: Dictionary containing state metadata\\n        \\\"\\\"\\\"\\n        if not metadata:\\n            return\\n\\n        if \\\"content\\\" in metadata:\\n            self.setPlainText(metadata[\\\"content\\\"])\\n\\n        # Restore language if specified\\n        if \\\"language\\\" in metadata:\\n            language = ProgrammingLanguage[metadata[\\\"language\\\"]]\\n            self._update_programming_language(language)\\n\\n        # Restore cursor position if present\\n        if \\\"cursor\\\" in metadata:\\n            self._set_cursor_position(metadata[\\\"cursor\\\"])\\n\\n        # Restore scroll positions if present\\n        if \\\"horizontal_scroll\\\" in metadata:\\n            self.horizontalScrollBar().setValue(metadata[\\\"horizontal_scroll\\\"])\\n\\n        if \\\"vertical_scroll\\\" in metadata:\\n            self.verticalScrollBar().setValue(metadata[\\\"vertical_scroll\\\"])\\n\\n    def _set_cursor_position(self, position: Dict[str, int]) -> None:\\n        \\\"\\\"\\\"\\n        Set cursor position in editor.\\n\\n        Args:\\n            position: Dictionary with 'line' and 'column' keys\\n        \\\"\\\"\\\"\\n        if not position:\\n            return\\n\\n        cursor = self.textCursor()\\n        cursor.movePosition(QTextCursor.MoveOperation.Start)\\n\\n        # Move cursor to specified position\\n        for _ in range(position.get(\\\"line\\\", 0)):\\n            cursor.movePosition(QTextCursor.MoveOperation.NextBlock)\\n\\n        cursor.movePosition(\\n            QTextCursor.MoveOperation.Right,\\n            QTextCursor.MoveMode.MoveAnchor,\\n            position.get(\\\"column\\\", 0)\\n        )\\n\\n        self.setTextCursor(cursor)\\n        self.ensureCursorVisible()\\n\\n    def _get_cursor_position(self) -> Dict[str, int]:\\n        \\\"\\\"\\\"\\n        Get current cursor position from editor.\\n\\n        Returns:\\n            Dictionary with 'line' and 'column' keys\\n        \\\"\\\"\\\"\\n        cursor = self.textCursor()\\n        return {\\n            \\\"line\\\": cursor.blockNumber(),\\n            \\\"column\\\": cursor.columnNumber()\\n        }\\n\\n    def _line_number_area_width(self) -> int:\\n        \\\"\\\"\\\"Calculate the width needed for the line number area.\\\"\\\"\\\"\\n        digits = 1\\n        max_num = max(1, self.blockCount())\\n        while max_num >= 10:\\n            max_num //= 10\\n            digits += 1\\n\\n        digit_width = self.fontMetrics().horizontalAdvance('9')\\n        return digit_width * (digits + 4)\\n\\n    def _update_line_number_area_width(self) -> None:\\n        \\\"\\\"\\\"Update the margins to accommodate the line numbers.\\\"\\\"\\\"\\n        width = self._line_number_area_width()\\n\\n        # Set margin on appropriate side based on layout direction\\n        if self.layoutDirection() == Qt.LayoutDirection.RightToLeft:\\n            self.setViewportMargins(0, 0, 0, 0)  # Right margin\\n\\n        else:\\n            self.setViewportMargins(width, 0, 0, 0)  # Left margin\\n\\n    def _update_line_number_area(self, rect: QRect, dy: int) -> None:\\n        \\\"\\\"\\\"Handle updates to the line number area.\\\"\\\"\\\"\\n        if dy:\\n            self._line_number_area.scroll(0, dy)\\n\\n        else:\\n            self._line_number_area.update(0, rect.y(),\\n                self._line_number_area.width(), rect.height())\\n\\n        if rect.contains(self.viewport().rect()):\\n            self._update_line_number_area_width()\\n\\n    def resizeEvent(self, event: QResizeEvent) -> None:  # type: ignore[override]\\n        \\\"\\\"\\\"Handle resize events.\\\"\\\"\\\"\\n        super().resizeEvent(event)\\n        cr = self.contentsRect()\\n        width = self._line_number_area_width()\\n\\n        if self.layoutDirection() == Qt.LayoutDirection.RightToLeft:\\n            self._line_number_area.setGeometry(\\n                cr.right() - width,\\n                cr.top(),\\n                width,\\n                cr.height()\\n            )\\n\\n        else:\\n            self._line_number_area.setGeometry(\\n                cr.left(),\\n                cr.top(),\\n                width,\\n                cr.height()\\n            )\\n\\n    def _line_number_area_paint_event(self, event: QPaintEvent) -> None:\\n        \\\"\\\"\\\"Paint the line numbers.\\\"\\\"\\\"\\n        painter = QPainter(self._line_number_area)\\n        bg_color = self._style_manager.get_color(ColorRole.TAB_BACKGROUND_ACTIVE)\\n        painter.fillRect(event.rect(), bg_color)\\n\\n        painter.setFont(self.font())\\n\\n        block = self.firstVisibleBlock()\\n        block_number = block.blockNumber()\\n        offset = self.contentOffset()\\n        top = self.blockBoundingGeometry(block).translated(offset).top()\\n        bottom = top + self.blockBoundingRect(block).height()\\n\\n        # Use two space widths for padding\\n        padding = self.fontMetrics().horizontalAdvance('9') * 2\\n\\n        # Adjust alignment and padding based on layout direction\\n        is_rtl = self.layoutDirection() == Qt.LayoutDirection.RightToLeft\\n        alignment = Qt.AlignmentFlag.AlignLeft if is_rtl else Qt.AlignmentFlag.AlignRight\\n\\n        while block.isValid() and top <= event.rect().bottom():\\n            if block.isVisible() and bottom >= event.rect().top():\\n                number = str(block_number + 1)\\n                text_color = self._style_manager.get_color(ColorRole.LINE_NUMBER)\\n                painter.setPen(text_color)\\n                text_rect = QRect(\\n                    0,\\n                    int(top),\\n                    self._line_number_area.width() - padding,\\n                    self.fontMetrics().height()\\n                )\\n                painter.drawText(text_rect, alignment, number)\\n\\n            block = block.next()\\n            top = bottom\\n            bottom = top + self.blockBoundingRect(block).height()\\n            block_number += 1\\n\\n    def _indent_single_line_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\\n        \\\"\\\"\\\"\\n        Indent a single line using soft tabs.\\n\\n        Args:\\n            cursor: The current text cursor\\n            tab_size: Number of spaces to use for indentation\\n        \\\"\\\"\\\"\\n        # Calculate spaces needed to reach next tab stop\\n        current_column = cursor.position() - cursor.block().position()\\n        spaces_needed = tab_size - (current_column % tab_size)\\n        cursor.insertText(\\\" \\\" * spaces_needed)\\n\\n    def _indent_single_line_hard_tabs(self, cursor: QTextCursor) -> None:\\n        \\\"\\\"\\\"\\n        Indent a single line using hard tabs.\\n\\n        Args:\\n            cursor: The current text cursor\\n        \\\"\\\"\\\"\\n        cursor.insertText(\\\"\\\\t\\\")\\n\\n    def _indent_block_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\\n        \\\"\\\"\\\"\\n        Indent a block of text using soft tabs.\\n\\n        Args:\\n            cursor: The current text cursor\\n            tab_size: Number of spaces to use for indentation\\n        \\\"\\\"\\\"\\n        start = cursor.selectionStart()\\n        end = cursor.selectionEnd()\\n        reverse: bool = start == cursor.position()\\n\\n        cursor.setPosition(start)\\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\\n\\n        # If selection ends at start of line, don't indent that line\\n        end_offs = 0\\n        check_cursor = QTextCursor(cursor)\\n        check_cursor.setPosition(end)\\n        if check_cursor.atBlockStart():\\n            end_offs = 1\\n\\n        start += tab_size\\n        while cursor.position() <= end - end_offs:\\n            if not cursor.atBlockEnd():\\n                cursor.insertText(\\\" \\\" * tab_size)\\n                end += tab_size\\n\\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\\n                # We hit the end of the file\\n                break\\n\\n        cursor.setPosition(start if not reverse else end)\\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\\n\\n    def _indent_block_hard_tabs(self, cursor: QTextCursor) -> None:\\n        \\\"\\\"\\\"\\n        Indent a block of text using hard tabs.\\n\\n        Args:\\n            cursor: The current text cursor\\n        \\\"\\\"\\\"\\n        start = cursor.selectionStart()\\n        end = cursor.selectionEnd()\\n        reverse: bool = start == cursor.position()\\n\\n        cursor.setPosition(start)\\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\\n\\n        # If selection ends at start of line, don't indent that line\\n        end_offs = 0\\n        check_cursor = QTextCursor(cursor)\\n        check_cursor.setPosition(end)\\n        if check_cursor.atBlockStart():\\n            end_offs = 1\\n\\n        start += 1\\n        while cursor.position() <= end - end_offs:\\n            if not cursor.atBlockEnd():\\n                cursor.insertText(\\\"\\\\t\\\")\\n                end += 1\\n\\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\\n                # We hit the end of the file\\n                break\\n\\n        cursor.setPosition(start if not reverse else end)\\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\\n\\n    def _outdent_single_line_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\\n        \\\"\\\"\\\"\\n        Outdent a single line using soft tabs.\\n\\n        Args:\\n            cursor: The current text cursor\\n            tab_size: Number of spaces to use for indentation\\n        \\\"\\\"\\\"\\n        current_column = cursor.position() - cursor.block().position()\\n        deletes_needed = 1 + ((current_column - 1) % tab_size)\\n        deletes_needed = min(deletes_needed, current_column)\\n\\n        while deletes_needed > 0:\\n            text = cursor.block().text()\\n            if not text or text[current_column - 1] != \\\" \\\":\\n                break\\n\\n            cursor.deletePreviousChar()\\n            current_column -= 1\\n            deletes_needed -= 1\\n\\n    def _outdent_single_line_hard_tabs(self, cursor: QTextCursor) -> None:\\n        \\\"\\\"\\\"\\n        Outdent a single line using hard tabs.\\n\\n        Args:\\n            cursor: The current text cursor\\n        \\\"\\\"\\\"\\n        current_column = cursor.position() - cursor.block().position()\\n        if current_column > 0:\\n            text = cursor.block().text()\\n            if text and text[current_column - 1] == \\\"\\\\t\\\":\\n                cursor.deletePreviousChar()\\n\\n    def _outdent_block_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\\n        \\\"\\\"\\\"\\n        Outdent a block of text using soft tabs.\\n\\n        Args:\\n            cursor: The current text cursor\\n            tab_size: Number of spaces to use for indentation\\n        \\\"\\\"\\\"\\n        start = cursor.selectionStart()\\n        end = cursor.selectionEnd()\\n        reverse: bool = start == cursor.position()\\n\\n        cursor.setPosition(start)\\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\\n\\n        # If selection ends at start of line, don't outdent that line\\n        end_offs = 0\\n        check_cursor = QTextCursor(cursor)\\n        check_cursor.setPosition(end)\\n        if check_cursor.atBlockStart():\\n            end_offs = 1\\n\\n        # Work out how far to move the start postion\\n        current_column = start - cursor.block().position()\\n        first_line = cursor.block().text()\\n        first_line_spaces = len(first_line) - len(first_line.lstrip(\\\" \\\"))\\n        first_line_spaces = min(first_line_spaces, tab_size)\\n        first_line_spaces = min(first_line_spaces, current_column)\\n        start -= first_line_spaces\\n\\n        while cursor.position() <= end - end_offs:\\n            deletes_needed = tab_size\\n\\n            while deletes_needed > 0:\\n                text = cursor.block().text()\\n                if not text or text[0] != \\\" \\\":\\n                    break\\n\\n                cursor.deleteChar()\\n                deletes_needed -= 1\\n                end -= 1\\n\\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\\n                # We hit the end of the block\\n                break\\n\\n        cursor.setPosition(start if not reverse else end)\\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\\n\\n    def _outdent_block_hard_tabs(self, cursor: QTextCursor) -> None:\\n        \\\"\\\"\\\"\\n        Outdent a block of text using hard tabs.\\n\\n        Args:\\n            cursor: The current text cursor\\n        \\\"\\\"\\\"\\n        start = cursor.selectionStart()\\n        end = cursor.selectionEnd()\\n        reverse: bool = start == cursor.position()\\n\\n        cursor.setPosition(start)\\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\\n\\n        # If selection ends at start of line, don't outdent that line\\n        end_offs = 0\\n        check_cursor = QTextCursor(cursor)\\n        check_cursor.setPosition(end)\\n        if check_cursor.atBlockStart():\\n            end_offs = 1\\n\\n        # Work out how far to move the start postion\\n        current_column = start - cursor.block().position()\\n        first_line = cursor.block().text()\\n        if first_line and first_line[0] == \\\"\\\\t\\\" and current_column > 0:\\n            start -= 1\\n\\n        while cursor.position() <= end - end_offs:\\n            text = cursor.block().text()\\n            if text and text[0] == \\\"\\\\t\\\":\\n                cursor.deleteChar()\\n                end -= 1\\n\\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\\n                # We hit the end of the block\\n                break\\n\\n        cursor.setPosition(start if not reverse else end)\\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\\n\\n    def keyPressEvent(self, event: QKeyEvent) -> None:  # type: ignore[override]\\n        \\\"\\\"\\\"\\n        Handle special key events.\\n\\n        Args:\\n            event: The key event to handle\\n        \\\"\\\"\\\"\\n        if event.key() == Qt.Key.Key_Home:\\n            cursor = self.textCursor()\\n            cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\\n            self.setTextCursor(cursor)\\n            event.accept()\\n            return\\n\\n        if event.key() == Qt.Key.Key_End:\\n            cursor = self.textCursor()\\n            cursor.movePosition(QTextCursor.MoveOperation.EndOfLine)\\n            self.setTextCursor(cursor)\\n            event.accept()\\n            return\\n\\n        if event.key() == Qt.Key.Key_Tab:\\n            cursor = self.textCursor()\\n            mindspace_manager = MindspaceManager()\\n            if not mindspace_manager.has_mindspace():\\n                super().keyPressEvent(event)\\n                return\\n\\n            settings = cast(MindspaceSettings, mindspace_manager.settings())\\n\\n            scrollbar = self.verticalScrollBar()\\n            current_scroll = scrollbar.value()\\n            cursor.beginEditBlock()\\n            try:\\n                if not cursor.hasSelection():\\n                    if settings.use_soft_tabs:\\n                        self._indent_single_line_soft_tabs(cursor, settings.tab_size)\\n\\n                    else:\\n                        self._indent_single_line_hard_tabs(cursor)\\n\\n                else:\\n                    if settings.use_soft_tabs:\\n                        self._indent_block_soft_tabs(cursor, settings.tab_size)\\n\\n                    else:\\n                        self._indent_block_hard_tabs(cursor)\\n\\n            finally:\\n                cursor.endEditBlock()\\n                self.setTextCursor(cursor)\\n                scrollbar.setValue(current_scroll)\\n\\n            event.accept()\\n            return\\n\\n        if event.key() == Qt.Key.Key_Backtab:  # Shift+Tab\\n            cursor = self.textCursor()\\n            mindspace_manager = MindspaceManager()\\n            if not mindspace_manager.has_mindspace():\\n                super().keyPressEvent(event)\\n                return\\n\\n            settings = cast(MindspaceSettings, mindspace_manager.settings())\\n\\n            scrollbar = self.verticalScrollBar()\\n            current_scroll = scrollbar.value()\\n            cursor.beginEditBlock()\\n            try:\\n                if not cursor.hasSelection():\\n                    if settings.use_soft_tabs:\\n                        self._outdent_single_line_soft_tabs(cursor, settings.tab_size)\\n\\n                    else:\\n                        self._outdent_single_line_hard_tabs(cursor)\\n\\n                else:\\n                    if settings.use_soft_tabs:\\n                        self._outdent_block_soft_tabs(cursor, settings.tab_size)\\n\\n                    else:\\n                        self._outdent_block_hard_tabs(cursor)\\n\\n            finally:\\n                cursor.endEditBlock()\\n                self.setTextCursor(cursor)\\n                scrollbar.setValue(current_scroll)\\n\\n            event.accept()\\n            return\\n\\n        super().keyPressEvent(event)\\n\\n    def _on_style_changed(self) -> None:\\n        \\\"\\\"\\\"Handle style changes affecting search highlighting.\\\"\\\"\\\"\\n        # Update font size\\n        zoom_factor = self._style_manager.zoom_factor()\\n        font = self.font()\\n        base_size = self._style_manager.base_font_size()\\n        font.setPointSizeF(base_size * zoom_factor)\\n        self.setFont(font)\\n\\n        # Update tab stops - scale with zoom\\n        space_width = self._style_manager.get_space_width()\\n        self.setTabStopDistance(space_width * 8)\\n\\n        # If we changed colour mode then re-highlight\\n        if self._style_manager.color_mode() != self._init_colour_mode:\\n            self._init_colour_mode = self._style_manager.color_mode()\\n            self._highlighter.rehighlight()\\n\\n        self.setStyleSheet(f\\\"\\\"\\\"\\n            QWidget {{\\n                background-color: {self._style_manager.get_color_str(ColorRole.TAB_BACKGROUND_ACTIVE)};\\n            }}\\n\\n            QPlainTextEdit {{\\n                border: none;\\n                selection-background-color: {self._style_manager.get_color_str(ColorRole.TEXT_SELECTED)};\\n                selection-color: none;\\n            }}\\n\\n            QScrollBar:vertical, QScrollBar:horizontal {{\\n                background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_BACKGROUND)};\\n                width: 12px;\\n                height: 12px;\\n            }}\\n            QScrollBar::handle:vertical, QScrollBar::handle:horizontal {{\\n                background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_HANDLE)};\\n                min-height: 20px;\\n                min-width: 20px;\\n            }}\\n            QScrollBar::add-page, QScrollBar::sub-page {{\\n                background: none;\\n            }}\\n            QScrollBar::add-line, QScrollBar::sub-line {{\\n                height: 0px;\\n                width: 0px;\\n            }}\\n\\n            QAbstractScrollArea::corner {{\\n                background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_BACKGROUND)};\\n            }}\\n        \\\"\\\"\\\")\\n\\n        # Scale line number area\\n        self._update_line_number_area_width()\\n\\n        self._highlight_matches()\\n\\n    def find_text(self, text: str, forward: bool = True) -> None:\\n        \\\"\\\"\\\"\\n        Find all instances of text and highlight them.\\n\\n        Args:\\n            text: Text to search for\\n            forward: Whether to search forward from current position\\n        \\\"\\\"\\\"\\n        # Clear existing highlights if search text changed\\n        if text != self._last_search:\\n            self._clear_highlights()\\n            self._matches = []\\n            self._current_match = -1\\n            self._last_search = text\\n\\n        document = self.document()\\n\\n        # Find all matches if this is a new search\\n        if not self._matches and text:\\n            cursor = QTextCursor(document)\\n            while True:\\n                cursor = document.find(text, cursor)\\n                if cursor.isNull():\\n                    break\\n\\n                self._matches.append((cursor.selectionStart(), cursor.selectionEnd()))\\n\\n        if not self._matches:\\n            return\\n\\n        # Move to next/previous match\\n        if forward:\\n            self._current_match = (self._current_match + 1) % len(self._matches)\\n\\n        else:\\n            self._current_match = (self._current_match - 1) if self._current_match > 0 else len(self._matches) - 1\\n\\n        # Highlight all matches\\n        self._highlight_matches()\\n\\n        # Scroll to current match\\n        self._scroll_to_match(self._current_match)\\n\\n    def _highlight_matches(self) -> None:\\n        \\\"\\\"\\\"Update the highlighting of all matches.\\\"\\\"\\\"\\n        self._clear_highlights()\\n\\n        if not self._matches:\\n            return\\n\\n        found_format = QTextCharFormat()\\n        found_format.setBackground(self._style_manager.get_color(ColorRole.TEXT_FOUND))\\n        dim_found_format = QTextCharFormat()\\n        dim_found_format.setBackground(self._style_manager.get_color(ColorRole.TEXT_FOUND_DIM))\\n\\n        # Create extra selections list\\n        selections = []\\n\\n        # Highlight all matches\\n        for i, (start, end) in enumerate(self._matches):\\n            cursor = QTextCursor(self.document())\\n            cursor.setPosition(start)\\n            cursor.setPosition(end, QTextCursor.MoveMode.KeepAnchor)\\n\\n            # Create extra selection\\n            extra_selection = QTextEdit.ExtraSelection()\\n\\n            # We have to tell mypy to ingore attributes it doesn't know about\\n            extra_selection.cursor = cursor  # type: ignore\\n\\n            # Use different format for current match\\n            if i == self._current_match:\\n                extra_selection.format = found_format  # type: ignore\\n\\n            else:\\n                extra_selection.format = dim_found_format  # type: ignore\\n\\n            selections.append(extra_selection)\\n\\n        # Apply selections\\n        self.setExtraSelections(selections)\\n\\n    def _scroll_to_match(self, match_index: int) -> None:\\n        \\\"\\\"\\\"\\n        Scroll to ensure the given match is visible.\\n\\n        Args:\\n            match_index: Index of match to scroll to\\n        \\\"\\\"\\\"\\n        if 0 <= match_index < len(self._matches):\\n            cursor = QTextCursor(self.document())\\n            cursor.setPosition(self._matches[match_index][0])\\n            self.setTextCursor(cursor)\\n            self.ensureCursorVisible()\\n\\n    def _clear_highlights(self) -> None:\\n        \\\"\\\"\\\"Clear all search highlights.\\\"\\\"\\\"\\n        self.setExtraSelections([])\\n\\n    def get_match_status(self) -> Tuple[int, int]:\\n        \\\"\\\"\\\"\\n        Get the current match status.\\n\\n        Returns:\\n            Tuple of (current_match, total_matches)\\n        \\\"\\\"\\\"\\n        return self._current_match + 1, len(self._matches)\\n\\n    def clear_find(self) -> None:\\n        \\\"\\\"\\\"Clear all find state.\\\"\\\"\\\"\\n        self._clear_highlights()\\n        self._matches = []\\n        self._current_match = -1\\n        self._last_search = \\\"\\\"\\n\\n    def can_undo(self) -> bool:\\n        \\\"\\\"\\\"Check if undo is available.\\\"\\\"\\\"\\n        return self.document().isUndoAvailable()\\n\\n    def can_redo(self) -> bool:\\n        \\\"\\\"\\\"Check if redo is available.\\\"\\\"\\\"\\n        return self.document().isRedoAvailable()\\n\\n    def can_cut(self) -> bool:\\n        \\\"\\\"\\\"Check if cut is available.\\\"\\\"\\\"\\n        return self.textCursor().hasSelection()\\n\\n    def can_copy(self) -> bool:\\n        \\\"\\\"\\\"Check if copy is available.\\\"\\\"\\\"\\n        return self.textCursor().hasSelection()\\n\\n    def can_paste(self) -> bool:\\n        \\\"\\\"\\\"Check if paste is available.\\\"\\\"\\\"\\n        return True\\n\",\n    \"error\": null\n}\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01Q1YFBg6h7fCoht5sqdojAe",
          "name": "filesystem",
          "content": "File: src/humbug/tabs/editor/editor_widget.py\nSize: 42,336 bytes\nEncoding: utf-8\n\nimport logging\nimport os\nimport time\nfrom typing import List, Tuple, Dict, Any, cast\n\nfrom PySide6.QtWidgets import QPlainTextEdit, QWidget, QTextEdit, QFileDialog\nfrom PySide6.QtCore import Qt, QRect, Signal, QObject, QEvent, QTimer\nfrom PySide6.QtGui import (\n    QPainter, QTextCursor, QKeyEvent, QPalette, QBrush, QTextCharFormat,\n    QResizeEvent, QPaintEvent\n)\n\nfrom syntax import ProgrammingLanguage, ProgrammingLanguageUtils\n\nfrom humbug.color_role import ColorRole\nfrom humbug.language.language_manager import LanguageManager\nfrom humbug.message_box import MessageBox, MessageBoxType, MessageBoxButton\nfrom humbug.mindspace.mindspace_manager import MindspaceManager\nfrom humbug.mindspace.mindspace_settings import MindspaceSettings\nfrom humbug.style_manager import StyleManager\nfrom humbug.tabs.editor.editor_highlighter import EditorHighlighter\nfrom humbug.tabs.editor.editor_line_number_area import EditorLineNumberArea\n\n\nclass EditorWidgetEventFilter(QObject):\n    \"\"\"Event filter to track activation events from child widgets.\"\"\"\n\n    widget_activated = Signal(object)\n    widget_deactivated = Signal(object)\n\n    def __init__(self, parent: QWidget | None = None) -> None:\n        \"\"\"Initialize the event filter.\"\"\"\n        super().__init__(parent)\n\n    def eventFilter(self, watched: QObject, event: QEvent) -> bool:\n        \"\"\"\n        Filter events to detect widget activation.\n\n        Args:\n            obj: The object that received the event\n            event: The event that was received\n\n        Returns:\n            True if event was handled, False to pass to the target object\n        \"\"\"\n        if event.type() in (QEvent.Type.MouseButtonPress, QEvent.Type.FocusIn):\n            # Simply emit the signal with the object that received the event\n            self.widget_activated.emit(watched)\n            return False  # Don't consume the event\n\n        if event.type() == QEvent.Type.FocusOut:\n            # Emit a widget deactivated signal\n            self.widget_deactivated.emit(watched)\n            return False  # Don't consume the event\n\n        return super().eventFilter(watched, event)\n\n\nclass EditorWidget(QPlainTextEdit):\n    \"\"\"Text editor widget with line numbers, syntax highlighting, and find functionality.\"\"\"\n\n    # Content/state changes\n    content_modified = Signal(bool)  # True if modified, False if saved\n    status_updated = Signal()        # Request status bar update\n    activated = Signal()             # User interaction occurred\n    file_saved = Signal(str)         # File path saved\n\n    def __init__(self, path: str = \"\", untitled_number: int | None = None, parent: QWidget | None = None) -> None:\n        \"\"\"\n        Initialize the editor widget.\n\n        Args:\n            path: Optional file path to load\n            untitled_number: Optional untitled file number for new files\n            parent: Optional parent widget\n        \"\"\"\n        super().__init__(parent)\n        self._logger = logging.getLogger(\"EditorWidget\")\n\n        # File state\n        self._path = path\n        self._untitled_number = untitled_number\n        self._last_save_content = \"\"\n        self._is_modified = False\n\n        # Editor settings\n        self.setLineWrapMode(QPlainTextEdit.LineWrapMode.NoWrap)  # No word wrap for code\n        self.setTabStopDistance(32)  # 4 spaces worth of tab stops\n\n        # Enable standard scrollbars\n        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)\n        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)\n\n        self._style_manager = StyleManager()\n        self._init_colour_mode = self._style_manager.color_mode()\n\n        # Setup line number area\n        self._line_number_area = EditorLineNumberArea(\n            self, self._line_number_area_width, self._line_number_area_paint_event\n        )\n        font = self._line_number_area.font()\n        font.setFamilies(self._style_manager.monospace_font_families())\n        self.setFont(font)\n        self._line_number_area.setFont(font)\n\n        self.blockCountChanged.connect(self._update_line_number_area_width)\n        self.updateRequest.connect(self._update_line_number_area)\n\n        self._language_manager = LanguageManager()\n        self._language_manager.language_changed.connect(self._on_language_changed)\n        self._update_line_number_area_width()\n\n        # Highlighted text should retain any underlying colours (e.g. syntax highlighting)\n        palette = self.palette()\n        palette.setBrush(QPalette.ColorRole.HighlightedText, QBrush(Qt.BrushStyle.NoBrush))\n        self.setPalette(palette)\n\n        # Initialize find functionality\n        self._matches: List[Tuple[int, int]] = []  # List of (start, end) positions\n        self._current_match = -1\n        self._last_search = \"\"\n\n        # Programming language and syntax highlighting\n        self._current_programming_language = ProgrammingLanguage.TEXT\n        self._highlighter = EditorHighlighter(self.document())\n\n        # Auto-backup functionality\n        self._auto_backup_timer = QTimer(self)\n        self._auto_backup_timer.timeout.connect(self._auto_backup)\n\n        # Mindspace integration\n        self._mindspace_manager = MindspaceManager()\n        self._mindspace_manager.settings_changed.connect(self._on_mindspace_settings_changed)\n\n        # Set up activation tracking\n        self._event_filter = EditorWidgetEventFilter(self)\n        self._event_filter.widget_activated.connect(self._on_widget_activated)\n        self._event_filter.widget_deactivated.connect(self._on_widget_deactivated)\n        self.installEventFilter(self._event_filter)\n\n        # Connect text changes\n        self.textChanged.connect(self._on_text_changed)\n        self.cursorPositionChanged.connect(self.status_updated)\n\n        # Connect to style changes\n        self._style_manager.style_changed.connect(self._on_style_changed)\n        self._on_style_changed()\n\n        # Load file if path provided\n        if self._path:\n            self._load_file()\n\n        # Update programming language based on path\n        self._update_programming_language_from_path()\n\n        # Update auto-backup based on current mindspace settings\n        self._update_auto_backup_from_settings()\n\n    def _load_file(self) -> None:\n        \"\"\"Load content from file path.\"\"\"\n        if not self._path or not os.path.exists(self._path):\n            return\n\n        try:\n            with open(self._path, 'r', encoding='utf-8') as f:\n                content = f.read()\n\n            self.setPlainText(content)\n            self._last_save_content = content\n            self._set_modified(False)\n\n        except Exception as e:\n            self._logger.error(\"Failed to load file '%s': %s\", self._path, str(e))\n            strings = self._language_manager.strings()\n            MessageBox.show_message(\n                self,\n                MessageBoxType.CRITICAL,\n                strings.error_opening_file_title,\n                strings.could_not_open.format(self._path, str(e))\n            )\n\n    def _update_programming_language_from_path(self) -> None:\n        \"\"\"Update programming language based on current path.\"\"\"\n        if self._path:\n            new_language = ProgrammingLanguageUtils.from_file_extension(self._path)\n\n        else:\n            new_language = ProgrammingLanguage.TEXT\n\n        self._update_programming_language(new_language)\n\n    def _update_programming_language(self, new_language: ProgrammingLanguage) -> None:\n        \"\"\"\n        Update the syntax highlighting language.\n\n        Args:\n            new_language: The new programming language to use\n        \"\"\"\n        if self._current_programming_language != new_language:\n            self._current_programming_language = new_language\n            self._highlighter.set_language(new_language)\n            self.status_updated.emit()\n\n    def _update_auto_backup_from_settings(self) -> None:\n        \"\"\"Update auto-backup settings from mindspace.\"\"\"\n        if not self._mindspace_manager.has_mindspace():\n            self._auto_backup_timer.stop()\n            return\n\n        settings = self._mindspace_manager.settings()\n        if settings is None:\n            self._auto_backup_timer.stop()\n            return\n\n        self._update_auto_backup_settings(settings.auto_backup, settings.auto_backup_interval)\n\n    def _update_auto_backup_settings(self, enabled: bool, interval: int) -> None:\n        \"\"\"Update auto-backup settings.\"\"\"\n        if enabled:\n            self._auto_backup_timer.setInterval(interval * 1000)  # Convert to milliseconds\n            if self._is_modified:\n                # If we have unsaved changes, start backup immediately\n                self._auto_backup_timer.start()\n            return\n\n        clear_backups = self._auto_backup_timer.isActive()\n        self._auto_backup_timer.stop()\n\n        # Clean up any existing backups since auto-backup is disabled\n        if clear_backups:\n            self._cleanup_backup_files()\n\n    def _set_modified(self, modified: bool) -> None:\n        \"\"\"\n        Set the modified state and emit appropriate signals.\n\n        Args:\n            modified: Whether the content is modified\n        \"\"\"\n        if self._is_modified != modified:\n            self._is_modified = modified\n            self.content_modified.emit(modified)\n\n    def _on_mindspace_settings_changed(self) -> None:\n        \"\"\"Handle mindspace settings changes.\"\"\"\n        self._update_auto_backup_from_settings()\n\n    def _on_widget_activated(self, _widget: QWidget) -> None:\n        \"\"\"\n        Handle activation of a widget.\n\n        Args:\n            widget: The widget that was activated\n        \"\"\"\n        # Emit activated signal to let the tab know this editor was clicked\n        self.activated.emit()\n\n    def _on_widget_deactivated(self, widget: QWidget) -> None:\n        \"\"\"\n        Handle deactivation of a widget.\n\n        Args:\n            widget: The widget lost focus\n        \"\"\"\n\n    def _on_language_changed(self) -> None:\n        \"\"\"Handle language changes by updating the UI.\"\"\"\n        self._update_line_number_area_width()\n        self.viewport().update()\n        self.status_updated.emit()\n\n    def _on_text_changed(self) -> None:\n        \"\"\"Handle changes to editor content.\"\"\"\n        current_content = self.toPlainText()\n        is_modified = current_content != self._last_save_content\n        self._set_modified(is_modified)\n\n        if not self._mindspace_manager.has_mindspace():\n            return\n\n        settings = self._mindspace_manager.settings()\n        if settings is None:\n            return\n\n        if settings.auto_backup:\n            if is_modified and not self._auto_backup_timer.isActive():\n                self._auto_backup_timer.start()\n\n            elif not is_modified:\n                self._auto_backup_timer.stop()\n\n    def _auto_backup(self) -> None:\n        \"\"\"Handle auto-backup functionality.\"\"\"\n        if not self._is_modified:\n            return\n\n        # All backups should now go in mindspace .humbug/backups\n        if not self._mindspace_manager.has_mindspace():\n            return  # No backups without a mindspace\n\n        backup_dir = self._mindspace_manager.get_absolute_path(os.path.join(\".humbug\", \"backups\"))\n        os.makedirs(backup_dir, exist_ok=True)\n\n        if not self._path:\n            # For untitled files, use timestamp-based backup in mindspace\n            prefix = f\"backup-{self._untitled_number}-\"\n            current_time = int(time.time())\n            try:\n                # Clean up old backups for this untitled file\n                for file in os.listdir(backup_dir):\n                    if file.startswith(prefix):\n                        file_path = os.path.join(backup_dir, file)\n\n                        # Keep only backups from last hour\n                        if current_time - os.path.getctime(file_path) > 3600:\n                            try:\n                                os.remove(file_path)\n\n                            except OSError as e:\n                                self._logger.warning(\"Failed to remove old backup %s: %s\", file_path, str(e))\n\n            except OSError as e:\n                self._logger.warning(\"Failed to clean up old backups: %s\", str(e))\n\n            backup_file = os.path.join(\n                backup_dir,\n                f\"{prefix}{current_time}.txt\"\n            )\n\n        else:\n            backup_file = f\"{self._path}.backup\"\n\n            # Clean up any very old backups that might have been left behind\n            try:\n                if os.path.exists(backup_file):\n                    if time.time() - os.path.getctime(backup_file) > 86400:  # 24 hours\n                        try:\n                            os.remove(backup_file)\n\n                        except OSError:\n                            pass  # Ignore cleanup errors for old files\n\n            except OSError:\n                pass  # Ignore stat errors\n\n        try:\n            with open(backup_file, 'w', encoding='utf-8') as f:\n                f.write(self.toPlainText())\n\n        except Exception as e:\n            self._logger.error(\"Failed to create backup file '%s': %s\", backup_file, str(e))\n\n    def _cleanup_backup_files(self) -> None:\n        \"\"\"Clean up any backup files for this editor.\"\"\"\n        if not self._mindspace_manager.has_mindspace():\n            return\n\n        if self._path:\n            # Clean up backup for saved file\n            backup_file = f\"{self._path}.backup\"\n            try:\n                if os.path.exists(backup_file):\n                    os.remove(backup_file)\n\n            except OSError as e:\n                self._logger.warning(\"Failed to remove backup file %s: %s\", backup_file, str(e))\n\n        elif self._untitled_number:\n            # Clean up backups for untitled file\n            backup_dir = self._mindspace_manager.get_absolute_path(os.path.join(\".humbug\", \"backups\"))\n            prefix = f\"backup-{self._untitled_number}-\"\n            try:\n                for file in os.listdir(backup_dir):\n                    if file.startswith(prefix):\n                        try:\n                            os.remove(os.path.join(backup_dir, file))\n\n                        except OSError as e:\n                            self._logger.warning(\"Failed to remove backup %s: %s\", file, str(e))\n\n            except OSError as e:\n                self._logger.warning(\"Failed to clean up backups: %s\", str(e))\n\n    def path(self) -> str:\n        \"\"\"Get the current file path.\"\"\"\n        return self._path\n\n    def set_path(self, path: str) -> None:\n        \"\"\"\n        Set the file path and update language detection.\n\n        Args:\n            path: Path to file\n        \"\"\"\n        self._path = path\n        self._untitled_number = None\n        self._update_programming_language_from_path()\n\n    def is_modified(self) -> bool:\n        \"\"\"Check if the content has been modified.\"\"\"\n        return self._is_modified\n\n    def can_close(self) -> bool:\n        \"\"\"Check if the editor can be closed, handling unsaved changes.\"\"\"\n        if not self._is_modified:\n            return True\n\n        strings = self._language_manager.strings()\n        document_name = self._path or f'Untitled-{self._untitled_number}'\n        result = MessageBox.show_message(\n            self,\n            MessageBoxType.QUESTION,\n            strings.save_changes_title,\n            strings.unsaved_changes.format(document_name),\n            [MessageBoxButton.SAVE, MessageBoxButton.DISCARD, MessageBoxButton.CANCEL]\n        )\n\n        if result == MessageBoxButton.SAVE:\n            return self.save_file()\n\n        if result == MessageBoxButton.DISCARD:\n            self._set_modified(False)\n            return True\n\n        return False\n\n    def close_widget(self) -> None:\n        \"\"\"Close the editor widget and clean up resources.\"\"\"\n        # Delete any backup files when we close\n        if self._auto_backup_timer.isActive():\n            self._cleanup_backup_files()\n\n    def save_file(self) -> bool:\n        \"\"\"\n        Save the current file.\n\n        Returns:\n            bool: True if save was successful\n        \"\"\"\n        if not self._path:\n            return self.save_file_as()\n\n        try:\n            content = self.toPlainText()\n            with open(self._path, 'w', encoding='utf-8') as f:\n                f.write(content)\n\n            self._last_save_content = content\n            self._set_modified(False)\n\n            # Delete any backup files\n            backup_file = f\"{self._path}.backup\"\n            try:\n                if os.path.exists(backup_file):\n                    os.remove(backup_file)\n\n            except OSError as e:\n                self._logger.warning(\"Failed to remove backup file %s: %s\", backup_file, str(e))\n\n            self.file_saved.emit(self._path)\n            return True\n\n        except Exception as e:\n            strings = self._language_manager.strings()\n            MessageBox.show_message(\n                self,\n                MessageBoxType.CRITICAL,\n                strings.error_saving_file_title,\n                strings.could_not_save.format(self._path, str(e))\n            )\n            return False\n\n    def save_file_as(self) -> bool:\n        \"\"\"\n        Show save as dialog and save file.\n\n        Returns:\n            bool: True if save was successful\n        \"\"\"\n        strings = self._language_manager.strings()\n        export_dialog = QFileDialog()\n        export_dialog.setWindowTitle(strings.file_dialog_save_file)\n\n        if self._path:\n            export_dialog.setDirectory(self._path)\n\n        else:\n            fd_dir = self._mindspace_manager.file_dialog_directory()\n            if not fd_dir:\n                return False\n\n            export_dialog.setDirectory(fd_dir)\n\n        export_dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptSave)\n        if export_dialog.exec_() != QFileDialog.DialogCode.Accepted:\n            return False\n\n        filename = export_dialog.selectedFiles()[0]\n        self._mindspace_manager.update_file_dialog_directory(filename)\n        self.set_path(filename)\n\n        return self.save_file()\n\n    def get_status_info(self) -> Dict[str, Any]:\n        \"\"\"\n        Get status information for the status bar.\n\n        Returns:\n            Dictionary with status information\n        \"\"\"\n        cursor = self.textCursor()\n        line = cursor.blockNumber() + 1\n        column = cursor.columnNumber() + 1\n\n        # Get file info\n        encoding = \"UTF-8\"\n        line_ending = \"LF\"  # We could detect this from file content\n\n        # Get language name for display\n        file_type = ProgrammingLanguageUtils.get_display_name(self._current_programming_language)\n\n        return {\n            'line': line,\n            'column': column,\n            'encoding': encoding,\n            'line_ending': line_ending,\n            'type': file_type\n        }\n\n    def create_state_metadata(self, temp_state: bool) -> Dict[str, Any]:\n        \"\"\"\n        Create metadata dictionary capturing current widget state.\n\n        Args:\n            temp_state: Whether this is temporary state for moving tabs\n\n        Returns:\n            Dictionary containing editor state metadata\n        \"\"\"\n        metadata: Dict[str, Any] = {}\n\n        metadata[\"language\"] = self._current_programming_language.name\n        metadata[\"cursor\"] = self._get_cursor_position()\n        metadata[\"horizontal_scroll\"] = self.horizontalScrollBar().value()\n        metadata[\"vertical_scroll\"] = self.verticalScrollBar().value()\n\n        if temp_state:\n            metadata[\"content\"] = self.toPlainText()\n\n        return metadata\n\n    def restore_from_metadata(self, metadata: Dict[str, Any]) -> None:\n        \"\"\"\n        Restore widget state from metadata.\n\n        Args:\n            metadata: Dictionary containing state metadata\n        \"\"\"\n        if not metadata:\n            return\n\n        if \"content\" in metadata:\n            self.setPlainText(metadata[\"content\"])\n\n        # Restore language if specified\n        if \"language\" in metadata:\n            language = ProgrammingLanguage[metadata[\"language\"]]\n            self._update_programming_language(language)\n\n        # Restore cursor position if present\n        if \"cursor\" in metadata:\n            self._set_cursor_position(metadata[\"cursor\"])\n\n        # Restore scroll positions if present\n        if \"horizontal_scroll\" in metadata:\n            self.horizontalScrollBar().setValue(metadata[\"horizontal_scroll\"])\n\n        if \"vertical_scroll\" in metadata:\n            self.verticalScrollBar().setValue(metadata[\"vertical_scroll\"])\n\n    def _set_cursor_position(self, position: Dict[str, int]) -> None:\n        \"\"\"\n        Set cursor position in editor.\n\n        Args:\n            position: Dictionary with 'line' and 'column' keys\n        \"\"\"\n        if not position:\n            return\n\n        cursor = self.textCursor()\n        cursor.movePosition(QTextCursor.MoveOperation.Start)\n\n        # Move cursor to specified position\n        for _ in range(position.get(\"line\", 0)):\n            cursor.movePosition(QTextCursor.MoveOperation.NextBlock)\n\n        cursor.movePosition(\n            QTextCursor.MoveOperation.Right,\n            QTextCursor.MoveMode.MoveAnchor,\n            position.get(\"column\", 0)\n        )\n\n        self.setTextCursor(cursor)\n        self.ensureCursorVisible()\n\n    def _get_cursor_position(self) -> Dict[str, int]:\n        \"\"\"\n        Get current cursor position from editor.\n\n        Returns:\n            Dictionary with 'line' and 'column' keys\n        \"\"\"\n        cursor = self.textCursor()\n        return {\n            \"line\": cursor.blockNumber(),\n            \"column\": cursor.columnNumber()\n        }\n\n    def _line_number_area_width(self) -> int:\n        \"\"\"Calculate the width needed for the line number area.\"\"\"\n        digits = 1\n        max_num = max(1, self.blockCount())\n        while max_num >= 10:\n            max_num //= 10\n            digits += 1\n\n        digit_width = self.fontMetrics().horizontalAdvance('9')\n        return digit_width * (digits + 4)\n\n    def _update_line_number_area_width(self) -> None:\n        \"\"\"Update the margins to accommodate the line numbers.\"\"\"\n        width = self._line_number_area_width()\n\n        # Set margin on appropriate side based on layout direction\n        if self.layoutDirection() == Qt.LayoutDirection.RightToLeft:\n            self.setViewportMargins(0, 0, 0, 0)  # Right margin\n\n        else:\n            self.setViewportMargins(width, 0, 0, 0)  # Left margin\n\n    def _update_line_number_area(self, rect: QRect, dy: int) -> None:\n        \"\"\"Handle updates to the line number area.\"\"\"\n        if dy:\n            self._line_number_area.scroll(0, dy)\n\n        else:\n            self._line_number_area.update(0, rect.y(),\n                self._line_number_area.width(), rect.height())\n\n        if rect.contains(self.viewport().rect()):\n            self._update_line_number_area_width()\n\n    def resizeEvent(self, event: QResizeEvent) -> None:  # type: ignore[override]\n        \"\"\"Handle resize events.\"\"\"\n        super().resizeEvent(event)\n        cr = self.contentsRect()\n        width = self._line_number_area_width()\n\n        if self.layoutDirection() == Qt.LayoutDirection.RightToLeft:\n            self._line_number_area.setGeometry(\n                cr.right() - width,\n                cr.top(),\n                width,\n                cr.height()\n            )\n\n        else:\n            self._line_number_area.setGeometry(\n                cr.left(),\n                cr.top(),\n                width,\n                cr.height()\n            )\n\n    def _line_number_area_paint_event(self, event: QPaintEvent) -> None:\n        \"\"\"Paint the line numbers.\"\"\"\n        painter = QPainter(self._line_number_area)\n        bg_color = self._style_manager.get_color(ColorRole.TAB_BACKGROUND_ACTIVE)\n        painter.fillRect(event.rect(), bg_color)\n\n        painter.setFont(self.font())\n\n        block = self.firstVisibleBlock()\n        block_number = block.blockNumber()\n        offset = self.contentOffset()\n        top = self.blockBoundingGeometry(block).translated(offset).top()\n        bottom = top + self.blockBoundingRect(block).height()\n\n        # Use two space widths for padding\n        padding = self.fontMetrics().horizontalAdvance('9') * 2\n\n        # Adjust alignment and padding based on layout direction\n        is_rtl = self.layoutDirection() == Qt.LayoutDirection.RightToLeft\n        alignment = Qt.AlignmentFlag.AlignLeft if is_rtl else Qt.AlignmentFlag.AlignRight\n\n        while block.isValid() and top <= event.rect().bottom():\n            if block.isVisible() and bottom >= event.rect().top():\n                number = str(block_number + 1)\n                text_color = self._style_manager.get_color(ColorRole.LINE_NUMBER)\n                painter.setPen(text_color)\n                text_rect = QRect(\n                    0,\n                    int(top),\n                    self._line_number_area.width() - padding,\n                    self.fontMetrics().height()\n                )\n                painter.drawText(text_rect, alignment, number)\n\n            block = block.next()\n            top = bottom\n            bottom = top + self.blockBoundingRect(block).height()\n            block_number += 1\n\n    def _indent_single_line_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n        \"\"\"\n        Indent a single line using soft tabs.\n\n        Args:\n            cursor: The current text cursor\n            tab_size: Number of spaces to use for indentation\n        \"\"\"\n        # Calculate spaces needed to reach next tab stop\n        current_column = cursor.position() - cursor.block().position()\n        spaces_needed = tab_size - (current_column % tab_size)\n        cursor.insertText(\" \" * spaces_needed)\n\n    def _indent_single_line_hard_tabs(self, cursor: QTextCursor) -> None:\n        \"\"\"\n        Indent a single line using hard tabs.\n\n        Args:\n            cursor: The current text cursor\n        \"\"\"\n        cursor.insertText(\"\\t\")\n\n    def _indent_block_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n        \"\"\"\n        Indent a block of text using soft tabs.\n\n        Args:\n            cursor: The current text cursor\n            tab_size: Number of spaces to use for indentation\n        \"\"\"\n        start = cursor.selectionStart()\n        end = cursor.selectionEnd()\n        reverse: bool = start == cursor.position()\n\n        cursor.setPosition(start)\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n\n        # If selection ends at start of line, don't indent that line\n        end_offs = 0\n        check_cursor = QTextCursor(cursor)\n        check_cursor.setPosition(end)\n        if check_cursor.atBlockStart():\n            end_offs = 1\n\n        start += tab_size\n        while cursor.position() <= end - end_offs:\n            if not cursor.atBlockEnd():\n                cursor.insertText(\" \" * tab_size)\n                end += tab_size\n\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\n                # We hit the end of the file\n                break\n\n        cursor.setPosition(start if not reverse else end)\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\n\n    def _indent_block_hard_tabs(self, cursor: QTextCursor) -> None:\n        \"\"\"\n        Indent a block of text using hard tabs.\n\n        Args:\n            cursor: The current text cursor\n        \"\"\"\n        start = cursor.selectionStart()\n        end = cursor.selectionEnd()\n        reverse: bool = start == cursor.position()\n\n        cursor.setPosition(start)\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n\n        # If selection ends at start of line, don't indent that line\n        end_offs = 0\n        check_cursor = QTextCursor(cursor)\n        check_cursor.setPosition(end)\n        if check_cursor.atBlockStart():\n            end_offs = 1\n\n        start += 1\n        while cursor.position() <= end - end_offs:\n            if not cursor.atBlockEnd():\n                cursor.insertText(\"\\t\")\n                end += 1\n\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\n                # We hit the end of the file\n                break\n\n        cursor.setPosition(start if not reverse else end)\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\n\n    def _outdent_single_line_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n        \"\"\"\n        Outdent a single line using soft tabs.\n\n        Args:\n            cursor: The current text cursor\n            tab_size: Number of spaces to use for indentation\n        \"\"\"\n        current_column = cursor.position() - cursor.block().position()\n        deletes_needed = 1 + ((current_column - 1) % tab_size)\n        deletes_needed = min(deletes_needed, current_column)\n\n        while deletes_needed > 0:\n            text = cursor.block().text()\n            if not text or text[current_column - 1] != \" \":\n                break\n\n            cursor.deletePreviousChar()\n            current_column -= 1\n            deletes_needed -= 1\n\n    def _outdent_single_line_hard_tabs(self, cursor: QTextCursor) -> None:\n        \"\"\"\n        Outdent a single line using hard tabs.\n\n        Args:\n            cursor: The current text cursor\n        \"\"\"\n        current_column = cursor.position() - cursor.block().position()\n        if current_column > 0:\n            text = cursor.block().text()\n            if text and text[current_column - 1] == \"\\t\":\n                cursor.deletePreviousChar()\n\n    def _outdent_block_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n        \"\"\"\n        Outdent a block of text using soft tabs.\n\n        Args:\n            cursor: The current text cursor\n            tab_size: Number of spaces to use for indentation\n        \"\"\"\n        start = cursor.selectionStart()\n        end = cursor.selectionEnd()\n        reverse: bool = start == cursor.position()\n\n        cursor.setPosition(start)\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n\n        # If selection ends at start of line, don't outdent that line\n        end_offs = 0\n        check_cursor = QTextCursor(cursor)\n        check_cursor.setPosition(end)\n        if check_cursor.atBlockStart():\n            end_offs = 1\n\n        # Work out how far to move the start postion\n        current_column = start - cursor.block().position()\n        first_line = cursor.block().text()\n        first_line_spaces = len(first_line) - len(first_line.lstrip(\" \"))\n        first_line_spaces = min(first_line_spaces, tab_size)\n        first_line_spaces = min(first_line_spaces, current_column)\n        start -= first_line_spaces\n\n        while cursor.position() <= end - end_offs:\n            deletes_needed = tab_size\n\n            while deletes_needed > 0:\n                text = cursor.block().text()\n                if not text or text[0] != \" \":\n                    break\n\n                cursor.deleteChar()\n                deletes_needed -= 1\n                end -= 1\n\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\n                # We hit the end of the block\n                break\n\n        cursor.setPosition(start if not reverse else end)\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\n\n    def _outdent_block_hard_tabs(self, cursor: QTextCursor) -> None:\n        \"\"\"\n        Outdent a block of text using hard tabs.\n\n        Args:\n            cursor: The current text cursor\n        \"\"\"\n        start = cursor.selectionStart()\n        end = cursor.selectionEnd()\n        reverse: bool = start == cursor.position()\n\n        cursor.setPosition(start)\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n\n        # If selection ends at start of line, don't outdent that line\n        end_offs = 0\n        check_cursor = QTextCursor(cursor)\n        check_cursor.setPosition(end)\n        if check_cursor.atBlockStart():\n            end_offs = 1\n\n        # Work out how far to move the start postion\n        current_column = start - cursor.block().position()\n        first_line = cursor.block().text()\n        if first_line and first_line[0] == \"\\t\" and current_column > 0:\n            start -= 1\n\n        while cursor.position() <= end - end_offs:\n            text = cursor.block().text()\n            if text and text[0] == \"\\t\":\n                cursor.deleteChar()\n                end -= 1\n\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\n                # We hit the end of the block\n                break\n\n        cursor.setPosition(start if not reverse else end)\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\n\n    def keyPressEvent(self, event: QKeyEvent) -> None:  # type: ignore[override]\n        \"\"\"\n        Handle special key events.\n\n        Args:\n            event: The key event to handle\n        \"\"\"\n        if event.key() == Qt.Key.Key_Home:\n            cursor = self.textCursor()\n            cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n            self.setTextCursor(cursor)\n            event.accept()\n            return\n\n        if event.key() == Qt.Key.Key_End:\n            cursor = self.textCursor()\n            cursor.movePosition(QTextCursor.MoveOperation.EndOfLine)\n            self.setTextCursor(cursor)\n            event.accept()\n            return\n\n        if event.key() == Qt.Key.Key_Tab:\n            cursor = self.textCursor()\n            mindspace_manager = MindspaceManager()\n            if not mindspace_manager.has_mindspace():\n                super().keyPressEvent(event)\n                return\n\n            settings = cast(MindspaceSettings, mindspace_manager.settings())\n\n            scrollbar = self.verticalScrollBar()\n            current_scroll = scrollbar.value()\n            cursor.beginEditBlock()\n            try:\n                if not cursor.hasSelection():\n                    if settings.use_soft_tabs:\n                        self._indent_single_line_soft_tabs(cursor, settings.tab_size)\n\n                    else:\n                        self._indent_single_line_hard_tabs(cursor)\n\n                else:\n                    if settings.use_soft_tabs:\n                        self._indent_block_soft_tabs(cursor, settings.tab_size)\n\n                    else:\n                        self._indent_block_hard_tabs(cursor)\n\n            finally:\n                cursor.endEditBlock()\n                self.setTextCursor(cursor)\n                scrollbar.setValue(current_scroll)\n\n            event.accept()\n            return\n\n        if event.key() == Qt.Key.Key_Backtab:  # Shift+Tab\n            cursor = self.textCursor()\n            mindspace_manager = MindspaceManager()\n            if not mindspace_manager.has_mindspace():\n                super().keyPressEvent(event)\n                return\n\n            settings = cast(MindspaceSettings, mindspace_manager.settings())\n\n            scrollbar = self.verticalScrollBar()\n            current_scroll = scrollbar.value()\n            cursor.beginEditBlock()\n            try:\n                if not cursor.hasSelection():\n                    if settings.use_soft_tabs:\n                        self._outdent_single_line_soft_tabs(cursor, settings.tab_size)\n\n                    else:\n                        self._outdent_single_line_hard_tabs(cursor)\n\n                else:\n                    if settings.use_soft_tabs:\n                        self._outdent_block_soft_tabs(cursor, settings.tab_size)\n\n                    else:\n                        self._outdent_block_hard_tabs(cursor)\n\n            finally:\n                cursor.endEditBlock()\n                self.setTextCursor(cursor)\n                scrollbar.setValue(current_scroll)\n\n            event.accept()\n            return\n\n        super().keyPressEvent(event)\n\n    def _on_style_changed(self) -> None:\n        \"\"\"Handle style changes affecting search highlighting.\"\"\"\n        # Update font size\n        zoom_factor = self._style_manager.zoom_factor()\n        font = self.font()\n        base_size = self._style_manager.base_font_size()\n        font.setPointSizeF(base_size * zoom_factor)\n        self.setFont(font)\n\n        # Update tab stops - scale with zoom\n        space_width = self._style_manager.get_space_width()\n        self.setTabStopDistance(space_width * 8)\n\n        # If we changed colour mode then re-highlight\n        if self._style_manager.color_mode() != self._init_colour_mode:\n            self._init_colour_mode = self._style_manager.color_mode()\n            self._highlighter.rehighlight()\n\n        self.setStyleSheet(f\"\"\"\n            QWidget {{\n                background-color: {self._style_manager.get_color_str(ColorRole.TAB_BACKGROUND_ACTIVE)};\n            }}\n\n            QPlainTextEdit {{\n                border: none;\n                selection-background-color: {self._style_manager.get_color_str(ColorRole.TEXT_SELECTED)};\n                selection-color: none;\n            }}\n\n            QScrollBar:vertical, QScrollBar:horizontal {{\n                background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_BACKGROUND)};\n                width: 12px;\n                height: 12px;\n            }}\n            QScrollBar::handle:vertical, QScrollBar::handle:horizontal {{\n                background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_HANDLE)};\n                min-height: 20px;\n                min-width: 20px;\n            }}\n            QScrollBar::add-page, QScrollBar::sub-page {{\n                background: none;\n            }}\n            QScrollBar::add-line, QScrollBar::sub-line {{\n                height: 0px;\n                width: 0px;\n            }}\n\n            QAbstractScrollArea::corner {{\n                background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_BACKGROUND)};\n            }}\n        \"\"\")\n\n        # Scale line number area\n        self._update_line_number_area_width()\n\n        self._highlight_matches()\n\n    def find_text(self, text: str, forward: bool = True) -> None:\n        \"\"\"\n        Find all instances of text and highlight them.\n\n        Args:\n            text: Text to search for\n            forward: Whether to search forward from current position\n        \"\"\"\n        # Clear existing highlights if search text changed\n        if text != self._last_search:\n            self._clear_highlights()\n            self._matches = []\n            self._current_match = -1\n            self._last_search = text\n\n        document = self.document()\n\n        # Find all matches if this is a new search\n        if not self._matches and text:\n            cursor = QTextCursor(document)\n            while True:\n                cursor = document.find(text, cursor)\n                if cursor.isNull():\n                    break\n\n                self._matches.append((cursor.selectionStart(), cursor.selectionEnd()))\n\n        if not self._matches:\n            return\n\n        # Move to next/previous match\n        if forward:\n            self._current_match = (self._current_match + 1) % len(self._matches)\n\n        else:\n            self._current_match = (self._current_match - 1) if self._current_match > 0 else len(self._matches) - 1\n\n        # Highlight all matches\n        self._highlight_matches()\n\n        # Scroll to current match\n        self._scroll_to_match(self._current_match)\n\n    def _highlight_matches(self) -> None:\n        \"\"\"Update the highlighting of all matches.\"\"\"\n        self._clear_highlights()\n\n        if not self._matches:\n            return\n\n        found_format = QTextCharFormat()\n        found_format.setBackground(self._style_manager.get_color(ColorRole.TEXT_FOUND))\n        dim_found_format = QTextCharFormat()\n        dim_found_format.setBackground(self._style_manager.get_color(ColorRole.TEXT_FOUND_DIM))\n\n        # Create extra selections list\n        selections = []\n\n        # Highlight all matches\n        for i, (start, end) in enumerate(self._matches):\n            cursor = QTextCursor(self.document())\n            cursor.setPosition(start)\n            cursor.setPosition(end, QTextCursor.MoveMode.KeepAnchor)\n\n            # Create extra selection\n            extra_selection = QTextEdit.ExtraSelection()\n\n            # We have to tell mypy to ingore attributes it doesn't know about\n            extra_selection.cursor = cursor  # type: ignore\n\n            # Use different format for current match\n            if i == self._current_match:\n                extra_selection.format = found_format  # type: ignore\n\n            else:\n                extra_selection.format = dim_found_format  # type: ignore\n\n            selections.append(extra_selection)\n\n        # Apply selections\n        self.setExtraSelections(selections)\n\n    def _scroll_to_match(self, match_index: int) -> None:\n        \"\"\"\n        Scroll to ensure the given match is visible.\n\n        Args:\n            match_index: Index of match to scroll to\n        \"\"\"\n        if 0 <= match_index < len(self._matches):\n            cursor = QTextCursor(self.document())\n            cursor.setPosition(self._matches[match_index][0])\n            self.setTextCursor(cursor)\n            self.ensureCursorVisible()\n\n    def _clear_highlights(self) -> None:\n        \"\"\"Clear all search highlights.\"\"\"\n        self.setExtraSelections([])\n\n    def get_match_status(self) -> Tuple[int, int]:\n        \"\"\"\n        Get the current match status.\n\n        Returns:\n            Tuple of (current_match, total_matches)\n        \"\"\"\n        return self._current_match + 1, len(self._matches)\n\n    def clear_find(self) -> None:\n        \"\"\"Clear all find state.\"\"\"\n        self._clear_highlights()\n        self._matches = []\n        self._current_match = -1\n        self._last_search = \"\"\n\n    def can_undo(self) -> bool:\n        \"\"\"Check if undo is available.\"\"\"\n        return self.document().isUndoAvailable()\n\n    def can_redo(self) -> bool:\n        \"\"\"Check if redo is available.\"\"\"\n        return self.document().isRedoAvailable()\n\n    def can_cut(self) -> bool:\n        \"\"\"Check if cut is available.\"\"\"\n        return self.textCursor().hasSelection()\n\n    def can_copy(self) -> bool:\n        \"\"\"Check if copy is available.\"\"\"\n        return self.textCursor().hasSelection()\n\n    def can_paste(self) -> bool:\n        \"\"\"Check if paste is available.\"\"\"\n        return True\n",
          "error": null
        }
      ]
    },
    {
      "id": "b67391b8-197a-4a57-af91-782c80d61be4",
      "timestamp": "2025-08-29T17:32:50.576358+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01Q1YFBg6h7fCoht5sqdojAe",
          "name": "filesystem",
          "content": "File: src/humbug/tabs/editor/editor_widget.py\nSize: 42,336 bytes\nEncoding: utf-8\n\nimport logging\nimport os\nimport time\nfrom typing import List, Tuple, Dict, Any, cast\n\nfrom PySide6.QtWidgets import QPlainTextEdit, QWidget, QTextEdit, QFileDialog\nfrom PySide6.QtCore import Qt, QRect, Signal, QObject, QEvent, QTimer\nfrom PySide6.QtGui import (\n    QPainter, QTextCursor, QKeyEvent, QPalette, QBrush, QTextCharFormat,\n    QResizeEvent, QPaintEvent\n)\n\nfrom syntax import ProgrammingLanguage, ProgrammingLanguageUtils\n\nfrom humbug.color_role import ColorRole\nfrom humbug.language.language_manager import LanguageManager\nfrom humbug.message_box import MessageBox, MessageBoxType, MessageBoxButton\nfrom humbug.mindspace.mindspace_manager import MindspaceManager\nfrom humbug.mindspace.mindspace_settings import MindspaceSettings\nfrom humbug.style_manager import StyleManager\nfrom humbug.tabs.editor.editor_highlighter import EditorHighlighter\nfrom humbug.tabs.editor.editor_line_number_area import EditorLineNumberArea\n\n\nclass EditorWidgetEventFilter(QObject):\n    \"\"\"Event filter to track activation events from child widgets.\"\"\"\n\n    widget_activated = Signal(object)\n    widget_deactivated = Signal(object)\n\n    def __init__(self, parent: QWidget | None = None) -> None:\n        \"\"\"Initialize the event filter.\"\"\"\n        super().__init__(parent)\n\n    def eventFilter(self, watched: QObject, event: QEvent) -> bool:\n        \"\"\"\n        Filter events to detect widget activation.\n\n        Args:\n            obj: The object that received the event\n            event: The event that was received\n\n        Returns:\n            True if event was handled, False to pass to the target object\n        \"\"\"\n        if event.type() in (QEvent.Type.MouseButtonPress, QEvent.Type.FocusIn):\n            # Simply emit the signal with the object that received the event\n            self.widget_activated.emit(watched)\n            return False  # Don't consume the event\n\n        if event.type() == QEvent.Type.FocusOut:\n            # Emit a widget deactivated signal\n            self.widget_deactivated.emit(watched)\n            return False  # Don't consume the event\n\n        return super().eventFilter(watched, event)\n\n\nclass EditorWidget(QPlainTextEdit):\n    \"\"\"Text editor widget with line numbers, syntax highlighting, and find functionality.\"\"\"\n\n    # Content/state changes\n    content_modified = Signal(bool)  # True if modified, False if saved\n    status_updated = Signal()        # Request status bar update\n    activated = Signal()             # User interaction occurred\n    file_saved = Signal(str)         # File path saved\n\n    def __init__(self, path: str = \"\", untitled_number: int | None = None, parent: QWidget | None = None) -> None:\n        \"\"\"\n        Initialize the editor widget.\n\n        Args:\n            path: Optional file path to load\n            untitled_number: Optional untitled file number for new files\n            parent: Optional parent widget\n        \"\"\"\n        super().__init__(parent)\n        self._logger = logging.getLogger(\"EditorWidget\")\n\n        # File state\n        self._path = path\n        self._untitled_number = untitled_number\n        self._last_save_content = \"\"\n        self._is_modified = False\n\n        # Editor settings\n        self.setLineWrapMode(QPlainTextEdit.LineWrapMode.NoWrap)  # No word wrap for code\n        self.setTabStopDistance(32)  # 4 spaces worth of tab stops\n\n        # Enable standard scrollbars\n        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)\n        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)\n\n        self._style_manager = StyleManager()\n        self._init_colour_mode = self._style_manager.color_mode()\n\n        # Setup line number area\n        self._line_number_area = EditorLineNumberArea(\n            self, self._line_number_area_width, self._line_number_area_paint_event\n        )\n        font = self._line_number_area.font()\n        font.setFamilies(self._style_manager.monospace_font_families())\n        self.setFont(font)\n        self._line_number_area.setFont(font)\n\n        self.blockCountChanged.connect(self._update_line_number_area_width)\n        self.updateRequest.connect(self._update_line_number_area)\n\n        self._language_manager = LanguageManager()\n        self._language_manager.language_changed.connect(self._on_language_changed)\n        self._update_line_number_area_width()\n\n        # Highlighted text should retain any underlying colours (e.g. syntax highlighting)\n        palette = self.palette()\n        palette.setBrush(QPalette.ColorRole.HighlightedText, QBrush(Qt.BrushStyle.NoBrush))\n        self.setPalette(palette)\n\n        # Initialize find functionality\n        self._matches: List[Tuple[int, int]] = []  # List of (start, end) positions\n        self._current_match = -1\n        self._last_search = \"\"\n\n        # Programming language and syntax highlighting\n        self._current_programming_language = ProgrammingLanguage.TEXT\n        self._highlighter = EditorHighlighter(self.document())\n\n        # Auto-backup functionality\n        self._auto_backup_timer = QTimer(self)\n        self._auto_backup_timer.timeout.connect(self._auto_backup)\n\n        # Mindspace integration\n        self._mindspace_manager = MindspaceManager()\n        self._mindspace_manager.settings_changed.connect(self._on_mindspace_settings_changed)\n\n        # Set up activation tracking\n        self._event_filter = EditorWidgetEventFilter(self)\n        self._event_filter.widget_activated.connect(self._on_widget_activated)\n        self._event_filter.widget_deactivated.connect(self._on_widget_deactivated)\n        self.installEventFilter(self._event_filter)\n\n        # Connect text changes\n        self.textChanged.connect(self._on_text_changed)\n        self.cursorPositionChanged.connect(self.status_updated)\n\n        # Connect to style changes\n        self._style_manager.style_changed.connect(self._on_style_changed)\n        self._on_style_changed()\n\n        # Load file if path provided\n        if self._path:\n            self._load_file()\n\n        # Update programming language based on path\n        self._update_programming_language_from_path()\n\n        # Update auto-backup based on current mindspace settings\n        self._update_auto_backup_from_settings()\n\n    def _load_file(self) -> None:\n        \"\"\"Load content from file path.\"\"\"\n        if not self._path or not os.path.exists(self._path):\n            return\n\n        try:\n            with open(self._path, 'r', encoding='utf-8') as f:\n                content = f.read()\n\n            self.setPlainText(content)\n            self._last_save_content = content\n            self._set_modified(False)\n\n        except Exception as e:\n            self._logger.error(\"Failed to load file '%s': %s\", self._path, str(e))\n            strings = self._language_manager.strings()\n            MessageBox.show_message(\n                self,\n                MessageBoxType.CRITICAL,\n                strings.error_opening_file_title,\n                strings.could_not_open.format(self._path, str(e))\n            )\n\n    def _update_programming_language_from_path(self) -> None:\n        \"\"\"Update programming language based on current path.\"\"\"\n        if self._path:\n            new_language = ProgrammingLanguageUtils.from_file_extension(self._path)\n\n        else:\n            new_language = ProgrammingLanguage.TEXT\n\n        self._update_programming_language(new_language)\n\n    def _update_programming_language(self, new_language: ProgrammingLanguage) -> None:\n        \"\"\"\n        Update the syntax highlighting language.\n\n        Args:\n            new_language: The new programming language to use\n        \"\"\"\n        if self._current_programming_language != new_language:\n            self._current_programming_language = new_language\n            self._highlighter.set_language(new_language)\n            self.status_updated.emit()\n\n    def _update_auto_backup_from_settings(self) -> None:\n        \"\"\"Update auto-backup settings from mindspace.\"\"\"\n        if not self._mindspace_manager.has_mindspace():\n            self._auto_backup_timer.stop()\n            return\n\n        settings = self._mindspace_manager.settings()\n        if settings is None:\n            self._auto_backup_timer.stop()\n            return\n\n        self._update_auto_backup_settings(settings.auto_backup, settings.auto_backup_interval)\n\n    def _update_auto_backup_settings(self, enabled: bool, interval: int) -> None:\n        \"\"\"Update auto-backup settings.\"\"\"\n        if enabled:\n            self._auto_backup_timer.setInterval(interval * 1000)  # Convert to milliseconds\n            if self._is_modified:\n                # If we have unsaved changes, start backup immediately\n                self._auto_backup_timer.start()\n            return\n\n        clear_backups = self._auto_backup_timer.isActive()\n        self._auto_backup_timer.stop()\n\n        # Clean up any existing backups since auto-backup is disabled\n        if clear_backups:\n            self._cleanup_backup_files()\n\n    def _set_modified(self, modified: bool) -> None:\n        \"\"\"\n        Set the modified state and emit appropriate signals.\n\n        Args:\n            modified: Whether the content is modified\n        \"\"\"\n        if self._is_modified != modified:\n            self._is_modified = modified\n            self.content_modified.emit(modified)\n\n    def _on_mindspace_settings_changed(self) -> None:\n        \"\"\"Handle mindspace settings changes.\"\"\"\n        self._update_auto_backup_from_settings()\n\n    def _on_widget_activated(self, _widget: QWidget) -> None:\n        \"\"\"\n        Handle activation of a widget.\n\n        Args:\n            widget: The widget that was activated\n        \"\"\"\n        # Emit activated signal to let the tab know this editor was clicked\n        self.activated.emit()\n\n    def _on_widget_deactivated(self, widget: QWidget) -> None:\n        \"\"\"\n        Handle deactivation of a widget.\n\n        Args:\n            widget: The widget lost focus\n        \"\"\"\n\n    def _on_language_changed(self) -> None:\n        \"\"\"Handle language changes by updating the UI.\"\"\"\n        self._update_line_number_area_width()\n        self.viewport().update()\n        self.status_updated.emit()\n\n    def _on_text_changed(self) -> None:\n        \"\"\"Handle changes to editor content.\"\"\"\n        current_content = self.toPlainText()\n        is_modified = current_content != self._last_save_content\n        self._set_modified(is_modified)\n\n        if not self._mindspace_manager.has_mindspace():\n            return\n\n        settings = self._mindspace_manager.settings()\n        if settings is None:\n            return\n\n        if settings.auto_backup:\n            if is_modified and not self._auto_backup_timer.isActive():\n                self._auto_backup_timer.start()\n\n            elif not is_modified:\n                self._auto_backup_timer.stop()\n\n    def _auto_backup(self) -> None:\n        \"\"\"Handle auto-backup functionality.\"\"\"\n        if not self._is_modified:\n            return\n\n        # All backups should now go in mindspace .humbug/backups\n        if not self._mindspace_manager.has_mindspace():\n            return  # No backups without a mindspace\n\n        backup_dir = self._mindspace_manager.get_absolute_path(os.path.join(\".humbug\", \"backups\"))\n        os.makedirs(backup_dir, exist_ok=True)\n\n        if not self._path:\n            # For untitled files, use timestamp-based backup in mindspace\n            prefix = f\"backup-{self._untitled_number}-\"\n            current_time = int(time.time())\n            try:\n                # Clean up old backups for this untitled file\n                for file in os.listdir(backup_dir):\n                    if file.startswith(prefix):\n                        file_path = os.path.join(backup_dir, file)\n\n                        # Keep only backups from last hour\n                        if current_time - os.path.getctime(file_path) > 3600:\n                            try:\n                                os.remove(file_path)\n\n                            except OSError as e:\n                                self._logger.warning(\"Failed to remove old backup %s: %s\", file_path, str(e))\n\n            except OSError as e:\n                self._logger.warning(\"Failed to clean up old backups: %s\", str(e))\n\n            backup_file = os.path.join(\n                backup_dir,\n                f\"{prefix}{current_time}.txt\"\n            )\n\n        else:\n            backup_file = f\"{self._path}.backup\"\n\n            # Clean up any very old backups that might have been left behind\n            try:\n                if os.path.exists(backup_file):\n                    if time.time() - os.path.getctime(backup_file) > 86400:  # 24 hours\n                        try:\n                            os.remove(backup_file)\n\n                        except OSError:\n                            pass  # Ignore cleanup errors for old files\n\n            except OSError:\n                pass  # Ignore stat errors\n\n        try:\n            with open(backup_file, 'w', encoding='utf-8') as f:\n                f.write(self.toPlainText())\n\n        except Exception as e:\n            self._logger.error(\"Failed to create backup file '%s': %s\", backup_file, str(e))\n\n    def _cleanup_backup_files(self) -> None:\n        \"\"\"Clean up any backup files for this editor.\"\"\"\n        if not self._mindspace_manager.has_mindspace():\n            return\n\n        if self._path:\n            # Clean up backup for saved file\n            backup_file = f\"{self._path}.backup\"\n            try:\n                if os.path.exists(backup_file):\n                    os.remove(backup_file)\n\n            except OSError as e:\n                self._logger.warning(\"Failed to remove backup file %s: %s\", backup_file, str(e))\n\n        elif self._untitled_number:\n            # Clean up backups for untitled file\n            backup_dir = self._mindspace_manager.get_absolute_path(os.path.join(\".humbug\", \"backups\"))\n            prefix = f\"backup-{self._untitled_number}-\"\n            try:\n                for file in os.listdir(backup_dir):\n                    if file.startswith(prefix):\n                        try:\n                            os.remove(os.path.join(backup_dir, file))\n\n                        except OSError as e:\n                            self._logger.warning(\"Failed to remove backup %s: %s\", file, str(e))\n\n            except OSError as e:\n                self._logger.warning(\"Failed to clean up backups: %s\", str(e))\n\n    def path(self) -> str:\n        \"\"\"Get the current file path.\"\"\"\n        return self._path\n\n    def set_path(self, path: str) -> None:\n        \"\"\"\n        Set the file path and update language detection.\n\n        Args:\n            path: Path to file\n        \"\"\"\n        self._path = path\n        self._untitled_number = None\n        self._update_programming_language_from_path()\n\n    def is_modified(self) -> bool:\n        \"\"\"Check if the content has been modified.\"\"\"\n        return self._is_modified\n\n    def can_close(self) -> bool:\n        \"\"\"Check if the editor can be closed, handling unsaved changes.\"\"\"\n        if not self._is_modified:\n            return True\n\n        strings = self._language_manager.strings()\n        document_name = self._path or f'Untitled-{self._untitled_number}'\n        result = MessageBox.show_message(\n            self,\n            MessageBoxType.QUESTION,\n            strings.save_changes_title,\n            strings.unsaved_changes.format(document_name),\n            [MessageBoxButton.SAVE, MessageBoxButton.DISCARD, MessageBoxButton.CANCEL]\n        )\n\n        if result == MessageBoxButton.SAVE:\n            return self.save_file()\n\n        if result == MessageBoxButton.DISCARD:\n            self._set_modified(False)\n            return True\n\n        return False\n\n    def close_widget(self) -> None:\n        \"\"\"Close the editor widget and clean up resources.\"\"\"\n        # Delete any backup files when we close\n        if self._auto_backup_timer.isActive():\n            self._cleanup_backup_files()\n\n    def save_file(self) -> bool:\n        \"\"\"\n        Save the current file.\n\n        Returns:\n            bool: True if save was successful\n        \"\"\"\n        if not self._path:\n            return self.save_file_as()\n\n        try:\n            content = self.toPlainText()\n            with open(self._path, 'w', encoding='utf-8') as f:\n                f.write(content)\n\n            self._last_save_content = content\n            self._set_modified(False)\n\n            # Delete any backup files\n            backup_file = f\"{self._path}.backup\"\n            try:\n                if os.path.exists(backup_file):\n                    os.remove(backup_file)\n\n            except OSError as e:\n                self._logger.warning(\"Failed to remove backup file %s: %s\", backup_file, str(e))\n\n            self.file_saved.emit(self._path)\n            return True\n\n        except Exception as e:\n            strings = self._language_manager.strings()\n            MessageBox.show_message(\n                self,\n                MessageBoxType.CRITICAL,\n                strings.error_saving_file_title,\n                strings.could_not_save.format(self._path, str(e))\n            )\n            return False\n\n    def save_file_as(self) -> bool:\n        \"\"\"\n        Show save as dialog and save file.\n\n        Returns:\n            bool: True if save was successful\n        \"\"\"\n        strings = self._language_manager.strings()\n        export_dialog = QFileDialog()\n        export_dialog.setWindowTitle(strings.file_dialog_save_file)\n\n        if self._path:\n            export_dialog.setDirectory(self._path)\n\n        else:\n            fd_dir = self._mindspace_manager.file_dialog_directory()\n            if not fd_dir:\n                return False\n\n            export_dialog.setDirectory(fd_dir)\n\n        export_dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptSave)\n        if export_dialog.exec_() != QFileDialog.DialogCode.Accepted:\n            return False\n\n        filename = export_dialog.selectedFiles()[0]\n        self._mindspace_manager.update_file_dialog_directory(filename)\n        self.set_path(filename)\n\n        return self.save_file()\n\n    def get_status_info(self) -> Dict[str, Any]:\n        \"\"\"\n        Get status information for the status bar.\n\n        Returns:\n            Dictionary with status information\n        \"\"\"\n        cursor = self.textCursor()\n        line = cursor.blockNumber() + 1\n        column = cursor.columnNumber() + 1\n\n        # Get file info\n        encoding = \"UTF-8\"\n        line_ending = \"LF\"  # We could detect this from file content\n\n        # Get language name for display\n        file_type = ProgrammingLanguageUtils.get_display_name(self._current_programming_language)\n\n        return {\n            'line': line,\n            'column': column,\n            'encoding': encoding,\n            'line_ending': line_ending,\n            'type': file_type\n        }\n\n    def create_state_metadata(self, temp_state: bool) -> Dict[str, Any]:\n        \"\"\"\n        Create metadata dictionary capturing current widget state.\n\n        Args:\n            temp_state: Whether this is temporary state for moving tabs\n\n        Returns:\n            Dictionary containing editor state metadata\n        \"\"\"\n        metadata: Dict[str, Any] = {}\n\n        metadata[\"language\"] = self._current_programming_language.name\n        metadata[\"cursor\"] = self._get_cursor_position()\n        metadata[\"horizontal_scroll\"] = self.horizontalScrollBar().value()\n        metadata[\"vertical_scroll\"] = self.verticalScrollBar().value()\n\n        if temp_state:\n            metadata[\"content\"] = self.toPlainText()\n\n        return metadata\n\n    def restore_from_metadata(self, metadata: Dict[str, Any]) -> None:\n        \"\"\"\n        Restore widget state from metadata.\n\n        Args:\n            metadata: Dictionary containing state metadata\n        \"\"\"\n        if not metadata:\n            return\n\n        if \"content\" in metadata:\n            self.setPlainText(metadata[\"content\"])\n\n        # Restore language if specified\n        if \"language\" in metadata:\n            language = ProgrammingLanguage[metadata[\"language\"]]\n            self._update_programming_language(language)\n\n        # Restore cursor position if present\n        if \"cursor\" in metadata:\n            self._set_cursor_position(metadata[\"cursor\"])\n\n        # Restore scroll positions if present\n        if \"horizontal_scroll\" in metadata:\n            self.horizontalScrollBar().setValue(metadata[\"horizontal_scroll\"])\n\n        if \"vertical_scroll\" in metadata:\n            self.verticalScrollBar().setValue(metadata[\"vertical_scroll\"])\n\n    def _set_cursor_position(self, position: Dict[str, int]) -> None:\n        \"\"\"\n        Set cursor position in editor.\n\n        Args:\n            position: Dictionary with 'line' and 'column' keys\n        \"\"\"\n        if not position:\n            return\n\n        cursor = self.textCursor()\n        cursor.movePosition(QTextCursor.MoveOperation.Start)\n\n        # Move cursor to specified position\n        for _ in range(position.get(\"line\", 0)):\n            cursor.movePosition(QTextCursor.MoveOperation.NextBlock)\n\n        cursor.movePosition(\n            QTextCursor.MoveOperation.Right,\n            QTextCursor.MoveMode.MoveAnchor,\n            position.get(\"column\", 0)\n        )\n\n        self.setTextCursor(cursor)\n        self.ensureCursorVisible()\n\n    def _get_cursor_position(self) -> Dict[str, int]:\n        \"\"\"\n        Get current cursor position from editor.\n\n        Returns:\n            Dictionary with 'line' and 'column' keys\n        \"\"\"\n        cursor = self.textCursor()\n        return {\n            \"line\": cursor.blockNumber(),\n            \"column\": cursor.columnNumber()\n        }\n\n    def _line_number_area_width(self) -> int:\n        \"\"\"Calculate the width needed for the line number area.\"\"\"\n        digits = 1\n        max_num = max(1, self.blockCount())\n        while max_num >= 10:\n            max_num //= 10\n            digits += 1\n\n        digit_width = self.fontMetrics().horizontalAdvance('9')\n        return digit_width * (digits + 4)\n\n    def _update_line_number_area_width(self) -> None:\n        \"\"\"Update the margins to accommodate the line numbers.\"\"\"\n        width = self._line_number_area_width()\n\n        # Set margin on appropriate side based on layout direction\n        if self.layoutDirection() == Qt.LayoutDirection.RightToLeft:\n            self.setViewportMargins(0, 0, 0, 0)  # Right margin\n\n        else:\n            self.setViewportMargins(width, 0, 0, 0)  # Left margin\n\n    def _update_line_number_area(self, rect: QRect, dy: int) -> None:\n        \"\"\"Handle updates to the line number area.\"\"\"\n        if dy:\n            self._line_number_area.scroll(0, dy)\n\n        else:\n            self._line_number_area.update(0, rect.y(),\n                self._line_number_area.width(), rect.height())\n\n        if rect.contains(self.viewport().rect()):\n            self._update_line_number_area_width()\n\n    def resizeEvent(self, event: QResizeEvent) -> None:  # type: ignore[override]\n        \"\"\"Handle resize events.\"\"\"\n        super().resizeEvent(event)\n        cr = self.contentsRect()\n        width = self._line_number_area_width()\n\n        if self.layoutDirection() == Qt.LayoutDirection.RightToLeft:\n            self._line_number_area.setGeometry(\n                cr.right() - width,\n                cr.top(),\n                width,\n                cr.height()\n            )\n\n        else:\n            self._line_number_area.setGeometry(\n                cr.left(),\n                cr.top(),\n                width,\n                cr.height()\n            )\n\n    def _line_number_area_paint_event(self, event: QPaintEvent) -> None:\n        \"\"\"Paint the line numbers.\"\"\"\n        painter = QPainter(self._line_number_area)\n        bg_color = self._style_manager.get_color(ColorRole.TAB_BACKGROUND_ACTIVE)\n        painter.fillRect(event.rect(), bg_color)\n\n        painter.setFont(self.font())\n\n        block = self.firstVisibleBlock()\n        block_number = block.blockNumber()\n        offset = self.contentOffset()\n        top = self.blockBoundingGeometry(block).translated(offset).top()\n        bottom = top + self.blockBoundingRect(block).height()\n\n        # Use two space widths for padding\n        padding = self.fontMetrics().horizontalAdvance('9') * 2\n\n        # Adjust alignment and padding based on layout direction\n        is_rtl = self.layoutDirection() == Qt.LayoutDirection.RightToLeft\n        alignment = Qt.AlignmentFlag.AlignLeft if is_rtl else Qt.AlignmentFlag.AlignRight\n\n        while block.isValid() and top <= event.rect().bottom():\n            if block.isVisible() and bottom >= event.rect().top():\n                number = str(block_number + 1)\n                text_color = self._style_manager.get_color(ColorRole.LINE_NUMBER)\n                painter.setPen(text_color)\n                text_rect = QRect(\n                    0,\n                    int(top),\n                    self._line_number_area.width() - padding,\n                    self.fontMetrics().height()\n                )\n                painter.drawText(text_rect, alignment, number)\n\n            block = block.next()\n            top = bottom\n            bottom = top + self.blockBoundingRect(block).height()\n            block_number += 1\n\n    def _indent_single_line_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n        \"\"\"\n        Indent a single line using soft tabs.\n\n        Args:\n            cursor: The current text cursor\n            tab_size: Number of spaces to use for indentation\n        \"\"\"\n        # Calculate spaces needed to reach next tab stop\n        current_column = cursor.position() - cursor.block().position()\n        spaces_needed = tab_size - (current_column % tab_size)\n        cursor.insertText(\" \" * spaces_needed)\n\n    def _indent_single_line_hard_tabs(self, cursor: QTextCursor) -> None:\n        \"\"\"\n        Indent a single line using hard tabs.\n\n        Args:\n            cursor: The current text cursor\n        \"\"\"\n        cursor.insertText(\"\\t\")\n\n    def _indent_block_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n        \"\"\"\n        Indent a block of text using soft tabs.\n\n        Args:\n            cursor: The current text cursor\n            tab_size: Number of spaces to use for indentation\n        \"\"\"\n        start = cursor.selectionStart()\n        end = cursor.selectionEnd()\n        reverse: bool = start == cursor.position()\n\n        cursor.setPosition(start)\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n\n        # If selection ends at start of line, don't indent that line\n        end_offs = 0\n        check_cursor = QTextCursor(cursor)\n        check_cursor.setPosition(end)\n        if check_cursor.atBlockStart():\n            end_offs = 1\n\n        start += tab_size\n        while cursor.position() <= end - end_offs:\n            if not cursor.atBlockEnd():\n                cursor.insertText(\" \" * tab_size)\n                end += tab_size\n\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\n                # We hit the end of the file\n                break\n\n        cursor.setPosition(start if not reverse else end)\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\n\n    def _indent_block_hard_tabs(self, cursor: QTextCursor) -> None:\n        \"\"\"\n        Indent a block of text using hard tabs.\n\n        Args:\n            cursor: The current text cursor\n        \"\"\"\n        start = cursor.selectionStart()\n        end = cursor.selectionEnd()\n        reverse: bool = start == cursor.position()\n\n        cursor.setPosition(start)\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n\n        # If selection ends at start of line, don't indent that line\n        end_offs = 0\n        check_cursor = QTextCursor(cursor)\n        check_cursor.setPosition(end)\n        if check_cursor.atBlockStart():\n            end_offs = 1\n\n        start += 1\n        while cursor.position() <= end - end_offs:\n            if not cursor.atBlockEnd():\n                cursor.insertText(\"\\t\")\n                end += 1\n\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\n                # We hit the end of the file\n                break\n\n        cursor.setPosition(start if not reverse else end)\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\n\n    def _outdent_single_line_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n        \"\"\"\n        Outdent a single line using soft tabs.\n\n        Args:\n            cursor: The current text cursor\n            tab_size: Number of spaces to use for indentation\n        \"\"\"\n        current_column = cursor.position() - cursor.block().position()\n        deletes_needed = 1 + ((current_column - 1) % tab_size)\n        deletes_needed = min(deletes_needed, current_column)\n\n        while deletes_needed > 0:\n            text = cursor.block().text()\n            if not text or text[current_column - 1] != \" \":\n                break\n\n            cursor.deletePreviousChar()\n            current_column -= 1\n            deletes_needed -= 1\n\n    def _outdent_single_line_hard_tabs(self, cursor: QTextCursor) -> None:\n        \"\"\"\n        Outdent a single line using hard tabs.\n\n        Args:\n            cursor: The current text cursor\n        \"\"\"\n        current_column = cursor.position() - cursor.block().position()\n        if current_column > 0:\n            text = cursor.block().text()\n            if text and text[current_column - 1] == \"\\t\":\n                cursor.deletePreviousChar()\n\n    def _outdent_block_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n        \"\"\"\n        Outdent a block of text using soft tabs.\n\n        Args:\n            cursor: The current text cursor\n            tab_size: Number of spaces to use for indentation\n        \"\"\"\n        start = cursor.selectionStart()\n        end = cursor.selectionEnd()\n        reverse: bool = start == cursor.position()\n\n        cursor.setPosition(start)\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n\n        # If selection ends at start of line, don't outdent that line\n        end_offs = 0\n        check_cursor = QTextCursor(cursor)\n        check_cursor.setPosition(end)\n        if check_cursor.atBlockStart():\n            end_offs = 1\n\n        # Work out how far to move the start postion\n        current_column = start - cursor.block().position()\n        first_line = cursor.block().text()\n        first_line_spaces = len(first_line) - len(first_line.lstrip(\" \"))\n        first_line_spaces = min(first_line_spaces, tab_size)\n        first_line_spaces = min(first_line_spaces, current_column)\n        start -= first_line_spaces\n\n        while cursor.position() <= end - end_offs:\n            deletes_needed = tab_size\n\n            while deletes_needed > 0:\n                text = cursor.block().text()\n                if not text or text[0] != \" \":\n                    break\n\n                cursor.deleteChar()\n                deletes_needed -= 1\n                end -= 1\n\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\n                # We hit the end of the block\n                break\n\n        cursor.setPosition(start if not reverse else end)\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\n\n    def _outdent_block_hard_tabs(self, cursor: QTextCursor) -> None:\n        \"\"\"\n        Outdent a block of text using hard tabs.\n\n        Args:\n            cursor: The current text cursor\n        \"\"\"\n        start = cursor.selectionStart()\n        end = cursor.selectionEnd()\n        reverse: bool = start == cursor.position()\n\n        cursor.setPosition(start)\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n\n        # If selection ends at start of line, don't outdent that line\n        end_offs = 0\n        check_cursor = QTextCursor(cursor)\n        check_cursor.setPosition(end)\n        if check_cursor.atBlockStart():\n            end_offs = 1\n\n        # Work out how far to move the start postion\n        current_column = start - cursor.block().position()\n        first_line = cursor.block().text()\n        if first_line and first_line[0] == \"\\t\" and current_column > 0:\n            start -= 1\n\n        while cursor.position() <= end - end_offs:\n            text = cursor.block().text()\n            if text and text[0] == \"\\t\":\n                cursor.deleteChar()\n                end -= 1\n\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\n                # We hit the end of the block\n                break\n\n        cursor.setPosition(start if not reverse else end)\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\n\n    def keyPressEvent(self, event: QKeyEvent) -> None:  # type: ignore[override]\n        \"\"\"\n        Handle special key events.\n\n        Args:\n            event: The key event to handle\n        \"\"\"\n        if event.key() == Qt.Key.Key_Home:\n            cursor = self.textCursor()\n            cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n            self.setTextCursor(cursor)\n            event.accept()\n            return\n\n        if event.key() == Qt.Key.Key_End:\n            cursor = self.textCursor()\n            cursor.movePosition(QTextCursor.MoveOperation.EndOfLine)\n            self.setTextCursor(cursor)\n            event.accept()\n            return\n\n        if event.key() == Qt.Key.Key_Tab:\n            cursor = self.textCursor()\n            mindspace_manager = MindspaceManager()\n            if not mindspace_manager.has_mindspace():\n                super().keyPressEvent(event)\n                return\n\n            settings = cast(MindspaceSettings, mindspace_manager.settings())\n\n            scrollbar = self.verticalScrollBar()\n            current_scroll = scrollbar.value()\n            cursor.beginEditBlock()\n            try:\n                if not cursor.hasSelection():\n                    if settings.use_soft_tabs:\n                        self._indent_single_line_soft_tabs(cursor, settings.tab_size)\n\n                    else:\n                        self._indent_single_line_hard_tabs(cursor)\n\n                else:\n                    if settings.use_soft_tabs:\n                        self._indent_block_soft_tabs(cursor, settings.tab_size)\n\n                    else:\n                        self._indent_block_hard_tabs(cursor)\n\n            finally:\n                cursor.endEditBlock()\n                self.setTextCursor(cursor)\n                scrollbar.setValue(current_scroll)\n\n            event.accept()\n            return\n\n        if event.key() == Qt.Key.Key_Backtab:  # Shift+Tab\n            cursor = self.textCursor()\n            mindspace_manager = MindspaceManager()\n            if not mindspace_manager.has_mindspace():\n                super().keyPressEvent(event)\n                return\n\n            settings = cast(MindspaceSettings, mindspace_manager.settings())\n\n            scrollbar = self.verticalScrollBar()\n            current_scroll = scrollbar.value()\n            cursor.beginEditBlock()\n            try:\n                if not cursor.hasSelection():\n                    if settings.use_soft_tabs:\n                        self._outdent_single_line_soft_tabs(cursor, settings.tab_size)\n\n                    else:\n                        self._outdent_single_line_hard_tabs(cursor)\n\n                else:\n                    if settings.use_soft_tabs:\n                        self._outdent_block_soft_tabs(cursor, settings.tab_size)\n\n                    else:\n                        self._outdent_block_hard_tabs(cursor)\n\n            finally:\n                cursor.endEditBlock()\n                self.setTextCursor(cursor)\n                scrollbar.setValue(current_scroll)\n\n            event.accept()\n            return\n\n        super().keyPressEvent(event)\n\n    def _on_style_changed(self) -> None:\n        \"\"\"Handle style changes affecting search highlighting.\"\"\"\n        # Update font size\n        zoom_factor = self._style_manager.zoom_factor()\n        font = self.font()\n        base_size = self._style_manager.base_font_size()\n        font.setPointSizeF(base_size * zoom_factor)\n        self.setFont(font)\n\n        # Update tab stops - scale with zoom\n        space_width = self._style_manager.get_space_width()\n        self.setTabStopDistance(space_width * 8)\n\n        # If we changed colour mode then re-highlight\n        if self._style_manager.color_mode() != self._init_colour_mode:\n            self._init_colour_mode = self._style_manager.color_mode()\n            self._highlighter.rehighlight()\n\n        self.setStyleSheet(f\"\"\"\n            QWidget {{\n                background-color: {self._style_manager.get_color_str(ColorRole.TAB_BACKGROUND_ACTIVE)};\n            }}\n\n            QPlainTextEdit {{\n                border: none;\n                selection-background-color: {self._style_manager.get_color_str(ColorRole.TEXT_SELECTED)};\n                selection-color: none;\n            }}\n\n            QScrollBar:vertical, QScrollBar:horizontal {{\n                background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_BACKGROUND)};\n                width: 12px;\n                height: 12px;\n            }}\n            QScrollBar::handle:vertical, QScrollBar::handle:horizontal {{\n                background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_HANDLE)};\n                min-height: 20px;\n                min-width: 20px;\n            }}\n            QScrollBar::add-page, QScrollBar::sub-page {{\n                background: none;\n            }}\n            QScrollBar::add-line, QScrollBar::sub-line {{\n                height: 0px;\n                width: 0px;\n            }}\n\n            QAbstractScrollArea::corner {{\n                background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_BACKGROUND)};\n            }}\n        \"\"\")\n\n        # Scale line number area\n        self._update_line_number_area_width()\n\n        self._highlight_matches()\n\n    def find_text(self, text: str, forward: bool = True) -> None:\n        \"\"\"\n        Find all instances of text and highlight them.\n\n        Args:\n            text: Text to search for\n            forward: Whether to search forward from current position\n        \"\"\"\n        # Clear existing highlights if search text changed\n        if text != self._last_search:\n            self._clear_highlights()\n            self._matches = []\n            self._current_match = -1\n            self._last_search = text\n\n        document = self.document()\n\n        # Find all matches if this is a new search\n        if not self._matches and text:\n            cursor = QTextCursor(document)\n            while True:\n                cursor = document.find(text, cursor)\n                if cursor.isNull():\n                    break\n\n                self._matches.append((cursor.selectionStart(), cursor.selectionEnd()))\n\n        if not self._matches:\n            return\n\n        # Move to next/previous match\n        if forward:\n            self._current_match = (self._current_match + 1) % len(self._matches)\n\n        else:\n            self._current_match = (self._current_match - 1) if self._current_match > 0 else len(self._matches) - 1\n\n        # Highlight all matches\n        self._highlight_matches()\n\n        # Scroll to current match\n        self._scroll_to_match(self._current_match)\n\n    def _highlight_matches(self) -> None:\n        \"\"\"Update the highlighting of all matches.\"\"\"\n        self._clear_highlights()\n\n        if not self._matches:\n            return\n\n        found_format = QTextCharFormat()\n        found_format.setBackground(self._style_manager.get_color(ColorRole.TEXT_FOUND))\n        dim_found_format = QTextCharFormat()\n        dim_found_format.setBackground(self._style_manager.get_color(ColorRole.TEXT_FOUND_DIM))\n\n        # Create extra selections list\n        selections = []\n\n        # Highlight all matches\n        for i, (start, end) in enumerate(self._matches):\n            cursor = QTextCursor(self.document())\n            cursor.setPosition(start)\n            cursor.setPosition(end, QTextCursor.MoveMode.KeepAnchor)\n\n            # Create extra selection\n            extra_selection = QTextEdit.ExtraSelection()\n\n            # We have to tell mypy to ingore attributes it doesn't know about\n            extra_selection.cursor = cursor  # type: ignore\n\n            # Use different format for current match\n            if i == self._current_match:\n                extra_selection.format = found_format  # type: ignore\n\n            else:\n                extra_selection.format = dim_found_format  # type: ignore\n\n            selections.append(extra_selection)\n\n        # Apply selections\n        self.setExtraSelections(selections)\n\n    def _scroll_to_match(self, match_index: int) -> None:\n        \"\"\"\n        Scroll to ensure the given match is visible.\n\n        Args:\n            match_index: Index of match to scroll to\n        \"\"\"\n        if 0 <= match_index < len(self._matches):\n            cursor = QTextCursor(self.document())\n            cursor.setPosition(self._matches[match_index][0])\n            self.setTextCursor(cursor)\n            self.ensureCursorVisible()\n\n    def _clear_highlights(self) -> None:\n        \"\"\"Clear all search highlights.\"\"\"\n        self.setExtraSelections([])\n\n    def get_match_status(self) -> Tuple[int, int]:\n        \"\"\"\n        Get the current match status.\n\n        Returns:\n            Tuple of (current_match, total_matches)\n        \"\"\"\n        return self._current_match + 1, len(self._matches)\n\n    def clear_find(self) -> None:\n        \"\"\"Clear all find state.\"\"\"\n        self._clear_highlights()\n        self._matches = []\n        self._current_match = -1\n        self._last_search = \"\"\n\n    def can_undo(self) -> bool:\n        \"\"\"Check if undo is available.\"\"\"\n        return self.document().isUndoAvailable()\n\n    def can_redo(self) -> bool:\n        \"\"\"Check if redo is available.\"\"\"\n        return self.document().isRedoAvailable()\n\n    def can_cut(self) -> bool:\n        \"\"\"Check if cut is available.\"\"\"\n        return self.textCursor().hasSelection()\n\n    def can_copy(self) -> bool:\n        \"\"\"Check if copy is available.\"\"\"\n        return self.textCursor().hasSelection()\n\n    def can_paste(self) -> bool:\n        \"\"\"Check if paste is available.\"\"\"\n        return True\n",
          "error": null
        }
      ]
    },
    {
      "id": "cff7b18d-b634-493d-9b1b-0388ed6b3e8c",
      "timestamp": "2025-08-29T17:32:53.509465+00:00",
      "type": "ai_response",
      "content": "Now I'll add the `refresh_content()` method to the `EditorWidget` class:",
      "completed": true,
      "usage": {
        "prompt_tokens": 23298,
        "completion_tokens": 11683,
        "total_tokens": 34981
      },
      "model": "claude-sonnet-4-20250514",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_014YQpakDHa9HtBixJLyrnkZ",
          "name": "filesystem",
          "arguments": {
            "operation": "write_file",
            "path": "src/humbug/tabs/editor/editor_widget.py",
            "content": "import logging\nimport os\nimport time\nfrom typing import List, Tuple, Dict, Any, cast\n\nfrom PySide6.QtWidgets import QPlainTextEdit, QWidget, QTextEdit, QFileDialog\nfrom PySide6.QtCore import Qt, QRect, Signal, QObject, QEvent, QTimer\nfrom PySide6.QtGui import (\n    QPainter, QTextCursor, QKeyEvent, QPalette, QBrush, QTextCharFormat,\n    QResizeEvent, QPaintEvent\n)\n\nfrom syntax import ProgrammingLanguage, ProgrammingLanguageUtils\n\nfrom humbug.color_role import ColorRole\nfrom humbug.language.language_manager import LanguageManager\nfrom humbug.message_box import MessageBox, MessageBoxType, MessageBoxButton\nfrom humbug.mindspace.mindspace_manager import MindspaceManager\nfrom humbug.mindspace.mindspace_settings import MindspaceSettings\nfrom humbug.style_manager import StyleManager\nfrom humbug.tabs.editor.editor_highlighter import EditorHighlighter\nfrom humbug.tabs.editor.editor_line_number_area import EditorLineNumberArea\n\n\nclass EditorWidgetEventFilter(QObject):\n    \"\"\"Event filter to track activation events from child widgets.\"\"\"\n\n    widget_activated = Signal(object)\n    widget_deactivated = Signal(object)\n\n    def __init__(self, parent: QWidget | None = None) -> None:\n        \"\"\"Initialize the event filter.\"\"\"\n        super().__init__(parent)\n\n    def eventFilter(self, watched: QObject, event: QEvent) -> bool:\n        \"\"\"\n        Filter events to detect widget activation.\n\n        Args:\n            obj: The object that received the event\n            event: The event that was received\n\n        Returns:\n            True if event was handled, False to pass to the target object\n        \"\"\"\n        if event.type() in (QEvent.Type.MouseButtonPress, QEvent.Type.FocusIn):\n            # Simply emit the signal with the object that received the event\n            self.widget_activated.emit(watched)\n            return False  # Don't consume the event\n\n        if event.type() == QEvent.Type.FocusOut:\n            # Emit a widget deactivated signal\n            self.widget_deactivated.emit(watched)\n            return False  # Don't consume the event\n\n        return super().eventFilter(watched, event)\n\n\nclass EditorWidget(QPlainTextEdit):\n    \"\"\"Text editor widget with line numbers, syntax highlighting, and find functionality.\"\"\"\n\n    # Content/state changes\n    content_modified = Signal(bool)  # True if modified, False if saved\n    status_updated = Signal()        # Request status bar update\n    activated = Signal()             # User interaction occurred\n    file_saved = Signal(str)         # File path saved\n\n    def __init__(self, path: str = \"\", untitled_number: int | None = None, parent: QWidget | None = None) -> None:\n        \"\"\"\n        Initialize the editor widget.\n\n        Args:\n            path: Optional file path to load\n            untitled_number: Optional untitled file number for new files\n            parent: Optional parent widget\n        \"\"\"\n        super().__init__(parent)\n        self._logger = logging.getLogger(\"EditorWidget\")\n\n        # File state\n        self._path = path\n        self._untitled_number = untitled_number\n        self._last_save_content = \"\"\n        self._is_modified = False\n\n        # Editor settings\n        self.setLineWrapMode(QPlainTextEdit.LineWrapMode.NoWrap)  # No word wrap for code\n        self.setTabStopDistance(32)  # 4 spaces worth of tab stops\n\n        # Enable standard scrollbars\n        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)\n        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)\n\n        self._style_manager = StyleManager()\n        self._init_colour_mode = self._style_manager.color_mode()\n\n        # Setup line number area\n        self._line_number_area = EditorLineNumberArea(\n            self, self._line_number_area_width, self._line_number_area_paint_event\n        )\n        font = self._line_number_area.font()\n        font.setFamilies(self._style_manager.monospace_font_families())\n        self.setFont(font)\n        self._line_number_area.setFont(font)\n\n        self.blockCountChanged.connect(self._update_line_number_area_width)\n        self.updateRequest.connect(self._update_line_number_area)\n\n        self._language_manager = LanguageManager()\n        self._language_manager.language_changed.connect(self._on_language_changed)\n        self._update_line_number_area_width()\n\n        # Highlighted text should retain any underlying colours (e.g. syntax highlighting)\n        palette = self.palette()\n        palette.setBrush(QPalette.ColorRole.HighlightedText, QBrush(Qt.BrushStyle.NoBrush))\n        self.setPalette(palette)\n\n        # Initialize find functionality\n        self._matches: List[Tuple[int, int]] = []  # List of (start, end) positions\n        self._current_match = -1\n        self._last_search = \"\"\n\n        # Programming language and syntax highlighting\n        self._current_programming_language = ProgrammingLanguage.TEXT\n        self._highlighter = EditorHighlighter(self.document())\n\n        # Auto-backup functionality\n        self._auto_backup_timer = QTimer(self)\n        self._auto_backup_timer.timeout.connect(self._auto_backup)\n\n        # Mindspace integration\n        self._mindspace_manager = MindspaceManager()\n        self._mindspace_manager.settings_changed.connect(self._on_mindspace_settings_changed)\n\n        # Set up activation tracking\n        self._event_filter = EditorWidgetEventFilter(self)\n        self._event_filter.widget_activated.connect(self._on_widget_activated)\n        self._event_filter.widget_deactivated.connect(self._on_widget_deactivated)\n        self.installEventFilter(self._event_filter)\n\n        # Connect text changes\n        self.textChanged.connect(self._on_text_changed)\n        self.cursorPositionChanged.connect(self.status_updated)\n\n        # Connect to style changes\n        self._style_manager.style_changed.connect(self._on_style_changed)\n        self._on_style_changed()\n\n        # Load file if path provided\n        if self._path:\n            self._load_file()\n\n        # Update programming language based on path\n        self._update_programming_language_from_path()\n\n        # Update auto-backup based on current mindspace settings\n        self._update_auto_backup_from_settings()\n\n    def _load_file(self) -> None:\n        \"\"\"Load content from file path.\"\"\"\n        if not self._path or not os.path.exists(self._path):\n            return\n\n        try:\n            with open(self._path, 'r', encoding='utf-8') as f:\n                content = f.read()\n\n            self.setPlainText(content)\n            self._last_save_content = content\n            self._set_modified(False)\n\n        except Exception as e:\n            self._logger.error(\"Failed to load file '%s': %s\", self._path, str(e))\n            strings = self._language_manager.strings()\n            MessageBox.show_message(\n                self,\n                MessageBoxType.CRITICAL,\n                strings.error_opening_file_title,\n                strings.could_not_open.format(self._path, str(e))\n            )\n\n    def refresh_content(self) -> None:\n        \"\"\"\n        Refresh the editor content from disk.\n        \n        This method reads the current file from disk and replaces the editor content.\n        If the file is unreadable, the editor will be left empty.\n        The cursor position will be reset to the beginning and any selection will be cleared.\n        \"\"\"\n        if not self._path:\n            self._logger.debug(\"No path set, cannot refresh content\")\n            return\n\n        try:\n            if os.path.exists(self._path):\n                with open(self._path, 'r', encoding='utf-8') as f:\n                    content = f.read()\n                    \n                self._logger.debug(\"Refreshing content from file: %s\", self._path)\n                self.setPlainText(content)\n                self._last_save_content = content\n                \n            else:\n                self._logger.debug(\"File no longer exists, clearing content: %s\", self._path)\n                self.setPlainText(\"\")\n                self._last_save_content = \"\"\n            \n            # Reset cursor to beginning and clear selection\n            cursor = QTextCursor(self.document())\n            cursor.movePosition(QTextCursor.MoveOperation.Start)\n            self.setTextCursor(cursor)\n            \n        except Exception as e:\n            self._logger.error(\"Failed to refresh content from file '%s': %s\", self._path, str(e))\n            # If file is unreadable, leave empty editor view\n            self.setPlainText(\"\")\n            self._last_save_content = \"\"\n            \n            # Reset cursor to beginning\n            cursor = QTextCursor(self.document())\n            cursor.movePosition(QTextCursor.MoveOperation.Start)\n            self.setTextCursor(cursor)\n\n    def _update_programming_language_from_path(self) -> None:\n        \"\"\"Update programming language based on current path.\"\"\"\n        if self._path:\n            new_language = ProgrammingLanguageUtils.from_file_extension(self._path)\n\n        else:\n            new_language = ProgrammingLanguage.TEXT\n\n        self._update_programming_language(new_language)\n\n    def _update_programming_language(self, new_language: ProgrammingLanguage) -> None:\n        \"\"\"\n        Update the syntax highlighting language.\n\n        Args:\n            new_language: The new programming language to use\n        \"\"\"\n        if self._current_programming_language != new_language:\n            self._current_programming_language = new_language\n            self._highlighter.set_language(new_language)\n            self.status_updated.emit()\n\n    def _update_auto_backup_from_settings(self) -> None:\n        \"\"\"Update auto-backup settings from mindspace.\"\"\"\n        if not self._mindspace_manager.has_mindspace():\n            self._auto_backup_timer.stop()\n            return\n\n        settings = self._mindspace_manager.settings()\n        if settings is None:\n            self._auto_backup_timer.stop()\n            return\n\n        self._update_auto_backup_settings(settings.auto_backup, settings.auto_backup_interval)\n\n    def _update_auto_backup_settings(self, enabled: bool, interval: int) -> None:\n        \"\"\"Update auto-backup settings.\"\"\"\n        if enabled:\n            self._auto_backup_timer.setInterval(interval * 1000)  # Convert to milliseconds\n            if self._is_modified:\n                # If we have unsaved changes, start backup immediately\n                self._auto_backup_timer.start()\n            return\n\n        clear_backups = self._auto_backup_timer.isActive()\n        self._auto_backup_timer.stop()\n\n        # Clean up any existing backups since auto-backup is disabled\n        if clear_backups:\n            self._cleanup_backup_files()\n\n    def _set_modified(self, modified: bool) -> None:\n        \"\"\"\n        Set the modified state and emit appropriate signals.\n\n        Args:\n            modified: Whether the content is modified\n        \"\"\"\n        if self._is_modified != modified:\n            self._is_modified = modified\n            self.content_modified.emit(modified)\n\n    def _on_mindspace_settings_changed(self) -> None:\n        \"\"\"Handle mindspace settings changes.\"\"\"\n        self._update_auto_backup_from_settings()\n\n    def _on_widget_activated(self, _widget: QWidget) -> None:\n        \"\"\"\n        Handle activation of a widget.\n\n        Args:\n            widget: The widget that was activated\n        \"\"\"\n        # Emit activated signal to let the tab know this editor was clicked\n        self.activated.emit()\n\n    def _on_widget_deactivated(self, widget: QWidget) -> None:\n        \"\"\"\n        Handle deactivation of a widget.\n\n        Args:\n            widget: The widget lost focus\n        \"\"\"\n\n    def _on_language_changed(self) -> None:\n        \"\"\"Handle language changes by updating the UI.\"\"\"\n        self._update_line_number_area_width()\n        self.viewport().update()\n        self.status_updated.emit()\n\n    def _on_text_changed(self) -> None:\n        \"\"\"Handle changes to editor content.\"\"\"\n        current_content = self.toPlainText()\n        is_modified = current_content != self._last_save_content\n        self._set_modified(is_modified)\n\n        if not self._mindspace_manager.has_mindspace():\n            return\n\n        settings = self._mindspace_manager.settings()\n        if settings is None:\n            return\n\n        if settings.auto_backup:\n            if is_modified and not self._auto_backup_timer.isActive():\n                self._auto_backup_timer.start()\n\n            elif not is_modified:\n                self._auto_backup_timer.stop()\n\n    def _auto_backup(self) -> None:\n        \"\"\"Handle auto-backup functionality.\"\"\"\n        if not self._is_modified:\n            return\n\n        # All backups should now go in mindspace .humbug/backups\n        if not self._mindspace_manager.has_mindspace():\n            return  # No backups without a mindspace\n\n        backup_dir = self._mindspace_manager.get_absolute_path(os.path.join(\".humbug\", \"backups\"))\n        os.makedirs(backup_dir, exist_ok=True)\n\n        if not self._path:\n            # For untitled files, use timestamp-based backup in mindspace\n            prefix = f\"backup-{self._untitled_number}-\"\n            current_time = int(time.time())\n            try:\n                # Clean up old backups for this untitled file\n                for file in os.listdir(backup_dir):\n                    if file.startswith(prefix):\n                        file_path = os.path.join(backup_dir, file)\n\n                        # Keep only backups from last hour\n                        if current_time - os.path.getctime(file_path) > 3600:\n                            try:\n                                os.remove(file_path)\n\n                            except OSError as e:\n                                self._logger.warning(\"Failed to remove old backup %s: %s\", file_path, str(e))\n\n            except OSError as e:\n                self._logger.warning(\"Failed to clean up old backups: %s\", str(e))\n\n            backup_file = os.path.join(\n                backup_dir,\n                f\"{prefix}{current_time}.txt\"\n            )\n\n        else:\n            backup_file = f\"{self._path}.backup\"\n\n            # Clean up any very old backups that might have been left behind\n            try:\n                if os.path.exists(backup_file):\n                    if time.time() - os.path.getctime(backup_file) > 86400:  # 24 hours\n                        try:\n                            os.remove(backup_file)\n\n                        except OSError:\n                            pass  # Ignore cleanup errors for old files\n\n            except OSError:\n                pass  # Ignore stat errors\n\n        try:\n            with open(backup_file, 'w', encoding='utf-8') as f:\n                f.write(self.toPlainText())\n\n        except Exception as e:\n            self._logger.error(\"Failed to create backup file '%s': %s\", backup_file, str(e))\n\n    def _cleanup_backup_files(self) -> None:\n        \"\"\"Clean up any backup files for this editor.\"\"\"\n        if not self._mindspace_manager.has_mindspace():\n            return\n\n        if self._path:\n            # Clean up backup for saved file\n            backup_file = f\"{self._path}.backup\"\n            try:\n                if os.path.exists(backup_file):\n                    os.remove(backup_file)\n\n            except OSError as e:\n                self._logger.warning(\"Failed to remove backup file %s: %s\", backup_file, str(e))\n\n        elif self._untitled_number:\n            # Clean up backups for untitled file\n            backup_dir = self._mindspace_manager.get_absolute_path(os.path.join(\".humbug\", \"backups\"))\n            prefix = f\"backup-{self._untitled_number}-\"\n            try:\n                for file in os.listdir(backup_dir):\n                    if file.startswith(prefix):\n                        try:\n                            os.remove(os.path.join(backup_dir, file))\n\n                        except OSError as e:\n                            self._logger.warning(\"Failed to remove backup %s: %s\", file, str(e))\n\n            except OSError as e:\n                self._logger.warning(\"Failed to clean up backups: %s\", str(e))\n\n    def path(self) -> str:\n        \"\"\"Get the current file path.\"\"\"\n        return self._path\n\n    def set_path(self, path: str) -> None:\n        \"\"\"\n        Set the file path and update language detection.\n\n        Args:\n            path: Path to file\n        \"\"\"\n        self._path = path\n        self._untitled_number = None\n        self._update_programming_language_from_path()\n\n    def is_modified(self) -> bool:\n        \"\"\"Check if the content has been modified.\"\"\"\n        return self._is_modified\n\n    def can_close(self) -> bool:\n        \"\"\"Check if the editor can be closed, handling unsaved changes.\"\"\"\n        if not self._is_modified:\n            return True\n\n        strings = self._language_manager.strings()\n        document_name = self._path or f'Untitled-{self._untitled_number}'\n        result = MessageBox.show_message(\n            self,\n            MessageBoxType.QUESTION,\n            strings.save_changes_title,\n            strings.unsaved_changes.format(document_name),\n            [MessageBoxButton.SAVE, MessageBoxButton.DISCARD, MessageBoxButton.CANCEL]\n        )\n\n        if result == MessageBoxButton.SAVE:\n            return self.save_file()\n\n        if result == MessageBoxButton.DISCARD:\n            self._set_modified(False)\n            return True\n\n        return False\n\n    def close_widget(self) -> None:\n        \"\"\"Close the editor widget and clean up resources.\"\"\"\n        # Delete any backup files when we close\n        if self._auto_backup_timer.isActive():\n            self._cleanup_backup_files()\n\n    def save_file(self) -> bool:\n        \"\"\"\n        Save the current file.\n\n        Returns:\n            bool: True if save was successful\n        \"\"\"\n        if not self._path:\n            return self.save_file_as()\n\n        try:\n            content = self.toPlainText()\n            with open(self._path, 'w', encoding='utf-8') as f:\n                f.write(content)\n\n            self._last_save_content = content\n            self._set_modified(False)\n\n            # Delete any backup files\n            backup_file = f\"{self._path}.backup\"\n            try:\n                if os.path.exists(backup_file):\n                    os.remove(backup_file)\n\n            except OSError as e:\n                self._logger.warning(\"Failed to remove backup file %s: %s\", backup_file, str(e))\n\n            self.file_saved.emit(self._path)\n            return True\n\n        except Exception as e:\n            strings = self._language_manager.strings()\n            MessageBox.show_message(\n                self,\n                MessageBoxType.CRITICAL,\n                strings.error_saving_file_title,\n                strings.could_not_save.format(self._path, str(e))\n            )\n            return False\n\n    def save_file_as(self) -> bool:\n        \"\"\"\n        Show save as dialog and save file.\n\n        Returns:\n            bool: True if save was successful\n        \"\"\"\n        strings = self._language_manager.strings()\n        export_dialog = QFileDialog()\n        export_dialog.setWindowTitle(strings.file_dialog_save_file)\n\n        if self._path:\n            export_dialog.setDirectory(self._path)\n\n        else:\n            fd_dir = self._mindspace_manager.file_dialog_directory()\n            if not fd_dir:\n                return False\n\n            export_dialog.setDirectory(fd_dir)\n\n        export_dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptSave)\n        if export_dialog.exec_() != QFileDialog.DialogCode.Accepted:\n            return False\n\n        filename = export_dialog.selectedFiles()[0]\n        self._mindspace_manager.update_file_dialog_directory(filename)\n        self.set_path(filename)\n\n        return self.save_file()\n\n    def get_status_info(self) -> Dict[str, Any]:\n        \"\"\"\n        Get status information for the status bar.\n\n        Returns:\n            Dictionary with status information\n        \"\"\"\n        cursor = self.textCursor()\n        line = cursor.blockNumber() + 1\n        column = cursor.columnNumber() + 1\n\n        # Get file info\n        encoding = \"UTF-8\"\n        line_ending = \"LF\"  # We could detect this from file content\n\n        # Get language name for display\n        file_type = ProgrammingLanguageUtils.get_display_name(self._current_programming_language)\n\n        return {\n            'line': line,\n            'column': column,\n            'encoding': encoding,\n            'line_ending': line_ending,\n            'type': file_type\n        }\n\n    def create_state_metadata(self, temp_state: bool) -> Dict[str, Any]:\n        \"\"\"\n        Create metadata dictionary capturing current widget state.\n\n        Args:\n            temp_state: Whether this is temporary state for moving tabs\n\n        Returns:\n            Dictionary containing editor state metadata\n        \"\"\"\n        metadata: Dict[str, Any] = {}\n\n        metadata[\"language\"] = self._current_programming_language.name\n        metadata[\"cursor\"] = self._get_cursor_position()\n        metadata[\"horizontal_scroll\"] = self.horizontalScrollBar().value()\n        metadata[\"vertical_scroll\"] = self.verticalScrollBar().value()\n\n        if temp_state:\n            metadata[\"content\"] = self.toPlainText()\n\n        return metadata\n\n    def restore_from_metadata(self, metadata: Dict[str, Any]) -> None:\n        \"\"\"\n        Restore widget state from metadata.\n\n        Args:\n            metadata: Dictionary containing state metadata\n        \"\"\"\n        if not metadata:\n            return\n\n        if \"content\" in metadata:\n            self.setPlainText(metadata[\"content\"])\n\n        # Restore language if specified\n        if \"language\" in metadata:\n            language = ProgrammingLanguage[metadata[\"language\"]]\n            self._update_programming_language(language)\n\n        # Restore cursor position if present\n        if \"cursor\" in metadata:\n            self._set_cursor_position(metadata[\"cursor\"])\n\n        # Restore scroll positions if present\n        if \"horizontal_scroll\" in metadata:\n            self.horizontalScrollBar().setValue(metadata[\"horizontal_scroll\"])\n\n        if \"vertical_scroll\" in metadata:\n            self.verticalScrollBar().setValue(metadata[\"vertical_scroll\"])\n\n    def _set_cursor_position(self, position: Dict[str, int]) -> None:\n        \"\"\"\n        Set cursor position in editor.\n\n        Args:\n            position: Dictionary with 'line' and 'column' keys\n        \"\"\"\n        if not position:\n            return\n\n        cursor = self.textCursor()\n        cursor.movePosition(QTextCursor.MoveOperation.Start)\n\n        # Move cursor to specified position\n        for _ in range(position.get(\"line\", 0)):\n            cursor.movePosition(QTextCursor.MoveOperation.NextBlock)\n\n        cursor.movePosition(\n            QTextCursor.MoveOperation.Right,\n            QTextCursor.MoveMode.MoveAnchor,\n            position.get(\"column\", 0)\n        )\n\n        self.setTextCursor(cursor)\n        self.ensureCursorVisible()\n\n    def _get_cursor_position(self) -> Dict[str, int]:\n        \"\"\"\n        Get current cursor position from editor.\n\n        Returns:\n            Dictionary with 'line' and 'column' keys\n        \"\"\"\n        cursor = self.textCursor()\n        return {\n            \"line\": cursor.blockNumber(),\n            \"column\": cursor.columnNumber()\n        }\n\n    def _line_number_area_width(self) -> int:\n        \"\"\"Calculate the width needed for the line number area.\"\"\"\n        digits = 1\n        max_num = max(1, self.blockCount())\n        while max_num >= 10:\n            max_num //= 10\n            digits += 1\n\n        digit_width = self.fontMetrics().horizontalAdvance('9')\n        return digit_width * (digits + 4)\n\n    def _update_line_number_area_width(self) -> None:\n        \"\"\"Update the margins to accommodate the line numbers.\"\"\"\n        width = self._line_number_area_width()\n\n        # Set margin on appropriate side based on layout direction\n        if self.layoutDirection() == Qt.LayoutDirection.RightToLeft:\n            self.setViewportMargins(0, 0, 0, 0)  # Right margin\n\n        else:\n            self.setViewportMargins(width, 0, 0, 0)  # Left margin\n\n    def _update_line_number_area(self, rect: QRect, dy: int) -> None:\n        \"\"\"Handle updates to the line number area.\"\"\"\n        if dy:\n            self._line_number_area.scroll(0, dy)\n\n        else:\n            self._line_number_area.update(0, rect.y(),\n                self._line_number_area.width(), rect.height())\n\n        if rect.contains(self.viewport().rect()):\n            self._update_line_number_area_width()\n\n    def resizeEvent(self, event: QResizeEvent) -> None:  # type: ignore[override]\n        \"\"\"Handle resize events.\"\"\"\n        super().resizeEvent(event)\n        cr = self.contentsRect()\n        width = self._line_number_area_width()\n\n        if self.layoutDirection() == Qt.LayoutDirection.RightToLeft:\n            self._line_number_area.setGeometry(\n                cr.right() - width,\n                cr.top(),\n                width,\n                cr.height()\n            )\n\n        else:\n            self._line_number_area.setGeometry(\n                cr.left(),\n                cr.top(),\n                width,\n                cr.height()\n            )\n\n    def _line_number_area_paint_event(self, event: QPaintEvent) -> None:\n        \"\"\"Paint the line numbers.\"\"\"\n        painter = QPainter(self._line_number_area)\n        bg_color = self._style_manager.get_color(ColorRole.TAB_BACKGROUND_ACTIVE)\n        painter.fillRect(event.rect(), bg_color)\n\n        painter.setFont(self.font())\n\n        block = self.firstVisibleBlock()\n        block_number = block.blockNumber()\n        offset = self.contentOffset()\n        top = self.blockBoundingGeometry(block).translated(offset).top()\n        bottom = top + self.blockBoundingRect(block).height()\n\n        # Use two space widths for padding\n        padding = self.fontMetrics().horizontalAdvance('9') * 2\n\n        # Adjust alignment and padding based on layout direction\n        is_rtl = self.layoutDirection() == Qt.LayoutDirection.RightToLeft\n        alignment = Qt.AlignmentFlag.AlignLeft if is_rtl else Qt.AlignmentFlag.AlignRight\n\n        while block.isValid() and top <= event.rect().bottom():\n            if block.isVisible() and bottom >= event.rect().top():\n                number = str(block_number + 1)\n                text_color = self._style_manager.get_color(ColorRole.LINE_NUMBER)\n                painter.setPen(text_color)\n                text_rect = QRect(\n                    0,\n                    int(top),\n                    self._line_number_area.width() - padding,\n                    self.fontMetrics().height()\n                )\n                painter.drawText(text_rect, alignment, number)\n\n            block = block.next()\n            top = bottom\n            bottom = top + self.blockBoundingRect(block).height()\n            block_number += 1\n\n    def _indent_single_line_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n        \"\"\"\n        Indent a single line using soft tabs.\n\n        Args:\n            cursor: The current text cursor\n            tab_size: Number of spaces to use for indentation\n        \"\"\"\n        # Calculate spaces needed to reach next tab stop\n        current_column = cursor.position() - cursor.block().position()\n        spaces_needed = tab_size - (current_column % tab_size)\n        cursor.insertText(\" \" * spaces_needed)\n\n    def _indent_single_line_hard_tabs(self, cursor: QTextCursor) -> None:\n        \"\"\"\n        Indent a single line using hard tabs.\n\n        Args:\n            cursor: The current text cursor\n        \"\"\"\n        cursor.insertText(\"\\t\")\n\n    def _indent_block_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n        \"\"\"\n        Indent a block of text using soft tabs.\n\n        Args:\n            cursor: The current text cursor\n            tab_size: Number of spaces to use for indentation\n        \"\"\"\n        start = cursor.selectionStart()\n        end = cursor.selectionEnd()\n        reverse: bool = start == cursor.position()\n\n        cursor.setPosition(start)\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n\n        # If selection ends at start of line, don't indent that line\n        end_offs = 0\n        check_cursor = QTextCursor(cursor)\n        check_cursor.setPosition(end)\n        if check_cursor.atBlockStart():\n            end_offs = 1\n\n        start += tab_size\n        while cursor.position() <= end - end_offs:\n            if not cursor.atBlockEnd():\n                cursor.insertText(\" \" * tab_size)\n                end += tab_size\n\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\n                # We hit the end of the file\n                break\n\n        cursor.setPosition(start if not reverse else end)\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\n\n    def _indent_block_hard_tabs(self, cursor: QTextCursor) -> None:\n        \"\"\"\n        Indent a block of text using hard tabs.\n\n        Args:\n            cursor: The current text cursor\n        \"\"\"\n        start = cursor.selectionStart()\n        end = cursor.selectionEnd()\n        reverse: bool = start == cursor.position()\n\n        cursor.setPosition(start)\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n\n        # If selection ends at start of line, don't indent that line\n        end_offs = 0\n        check_cursor = QTextCursor(cursor)\n        check_cursor.setPosition(end)\n        if check_cursor.atBlockStart():\n            end_offs = 1\n\n        start += 1\n        while cursor.position() <= end - end_offs:\n            if not cursor.atBlockEnd():\n                cursor.insertText(\"\\t\")\n                end += 1\n\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\n                # We hit the end of the file\n                break\n\n        cursor.setPosition(start if not reverse else end)\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\n\n    def _outdent_single_line_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n        \"\"\"\n        Outdent a single line using soft tabs.\n\n        Args:\n            cursor: The current text cursor\n            tab_size: Number of spaces to use for indentation\n        \"\"\"\n        current_column = cursor.position() - cursor.block().position()\n        deletes_needed = 1 + ((current_column - 1) % tab_size)\n        deletes_needed = min(deletes_needed, current_column)\n\n        while deletes_needed > 0:\n            text = cursor.block().text()\n            if not text or text[current_column - 1] != \" \":\n                break\n\n            cursor.deletePreviousChar()\n            current_column -= 1\n            deletes_needed -= 1\n\n    def _outdent_single_line_hard_tabs(self, cursor: QTextCursor) -> None:\n        \"\"\"\n        Outdent a single line using hard tabs.\n\n        Args:\n            cursor: The current text cursor\n        \"\"\"\n        current_column = cursor.position() - cursor.block().position()\n        if current_column > 0:\n            text = cursor.block().text()\n            if text and text[current_column - 1] == \"\\t\":\n                cursor.deletePreviousChar()\n\n    def _outdent_block_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n        \"\"\"\n        Outdent a block of text using soft tabs.\n\n        Args:\n            cursor: The current text cursor\n            tab_size: Number of spaces to use for indentation\n        \"\"\"\n        start = cursor.selectionStart()\n        end = cursor.selectionEnd()\n        reverse: bool = start == cursor.position()\n\n        cursor.setPosition(start)\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n\n        # If selection ends at start of line, don't outdent that line\n        end_offs = 0\n        check_cursor = QTextCursor(cursor)\n        check_cursor.setPosition(end)\n        if check_cursor.atBlockStart():\n            end_offs = 1\n\n        # Work out how far to move the start postion\n        current_column = start - cursor.block().position()\n        first_line = cursor.block().text()\n        first_line_spaces = len(first_line) - len(first_line.lstrip(\" \"))\n        first_line_spaces = min(first_line_spaces, tab_size)\n        first_line_spaces = min(first_line_spaces, current_column)\n        start -= first_line_spaces\n\n        while cursor.position() <= end - end_offs:\n            deletes_needed = tab_size\n\n            while deletes_needed > 0:\n                text = cursor.block().text()\n                if not text or text[0] != \" \":\n                    break\n\n                cursor.deleteChar()\n                deletes_needed -= 1\n                end -= 1\n\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\n                # We hit the end of the block\n                break\n\n        cursor.setPosition(start if not reverse else end)\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\n\n    def _outdent_block_hard_tabs(self, cursor: QTextCursor) -> None:\n        \"\"\"\n        Outdent a block of text using hard tabs.\n\n        Args:\n            cursor: The current text cursor\n        \"\"\"\n        start = cursor.selectionStart()\n        end = cursor.selectionEnd()\n        reverse: bool = start == cursor.position()\n\n        cursor.setPosition(start)\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n\n        # If selection ends at start of line, don't outdent that line\n        end_offs = 0\n        check_cursor = QTextCursor(cursor)\n        check_cursor.setPosition(end)\n        if check_cursor.atBlockStart():\n            end_offs = 1\n\n        # Work out how far to move the start postion\n        current_column = start - cursor.block().position()\n        first_line = cursor.block().text()\n        if first_line and first_line[0] == \"\\t\" and current_column > 0:\n            start -= 1\n\n        while cursor.position() <= end - end_offs:\n            text = cursor.block().text()\n            if text and text[0] == \"\\t\":\n                cursor.deleteChar()\n                end -= 1\n\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\n                # We hit the end of the block\n                break\n\n        cursor.setPosition(start if not reverse else end)\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\n\n    def keyPressEvent(self, event: QKeyEvent) -> None:  # type: ignore[override]\n        \"\"\"\n        Handle special key events.\n\n        Args:\n            event: The key event to handle\n        \"\"\"\n        if event.key() == Qt.Key.Key_Home:\n            cursor = self.textCursor()\n            cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n            self.setTextCursor(cursor)\n            event.accept()\n            return\n\n        if event.key() == Qt.Key.Key_End:\n            cursor = self.textCursor()\n            cursor.movePosition(QTextCursor.MoveOperation.EndOfLine)\n            self.setTextCursor(cursor)\n            event.accept()\n            return\n\n        if event.key() == Qt.Key.Key_Tab:\n            cursor = self.textCursor()\n            mindspace_manager = MindspaceManager()\n            if not mindspace_manager.has_mindspace():\n                super().keyPressEvent(event)\n                return\n\n            settings = cast(MindspaceSettings, mindspace_manager.settings())\n\n            scrollbar = self.verticalScrollBar()\n            current_scroll = scrollbar.value()\n            cursor.beginEditBlock()\n            try:\n                if not cursor.hasSelection():\n                    if settings.use_soft_tabs:\n                        self._indent_single_line_soft_tabs(cursor, settings.tab_size)\n\n                    else:\n                        self._indent_single_line_hard_tabs(cursor)\n\n                else:\n                    if settings.use_soft_tabs:\n                        self._indent_block_soft_tabs(cursor, settings.tab_size)\n\n                    else:\n                        self._indent_block_hard_tabs(cursor)\n\n            finally:\n                cursor.endEditBlock()\n                self.setTextCursor(cursor)\n                scrollbar.setValue(current_scroll)\n\n            event.accept()\n            return\n\n        if event.key() == Qt.Key.Key_Backtab:  # Shift+Tab\n            cursor = self.textCursor()\n            mindspace_manager = MindspaceManager()\n            if not mindspace_manager.has_mindspace():\n                super().keyPressEvent(event)\n                return\n\n            settings = cast(MindspaceSettings, mindspace_manager.settings())\n\n            scrollbar = self.verticalScrollBar()\n            current_scroll = scrollbar.value()\n            cursor.beginEditBlock()\n            try:\n                if not cursor.hasSelection():\n                    if settings.use_soft_tabs:\n                        self._outdent_single_line_soft_tabs(cursor, settings.tab_size)\n\n                    else:\n                        self._outdent_single_line_hard_tabs(cursor)\n\n                else:\n                    if settings.use_soft_tabs:\n                        self._outdent_block_soft_tabs(cursor, settings.tab_size)\n\n                    else:\n                        self._outdent_block_hard_tabs(cursor)\n\n            finally:\n                cursor.endEditBlock()\n                self.setTextCursor(cursor)\n                scrollbar.setValue(current_scroll)\n\n            event.accept()\n            return\n\n        super().keyPressEvent(event)\n\n    def _on_style_changed(self) -> None:\n        \"\"\"Handle style changes affecting search highlighting.\"\"\"\n        # Update font size\n        zoom_factor = self._style_manager.zoom_factor()\n        font = self.font()\n        base_size = self._style_manager.base_font_size()\n        font.setPointSizeF(base_size * zoom_factor)\n        self.setFont(font)\n\n        # Update tab stops - scale with zoom\n        space_width = self._style_manager.get_space_width()\n        self.setTabStopDistance(space_width * 8)\n\n        # If we changed colour mode then re-highlight\n        if self._style_manager.color_mode() != self._init_colour_mode:\n            self._init_colour_mode = self._style_manager.color_mode()\n            self._highlighter.rehighlight()\n\n        self.setStyleSheet(f\"\"\"\n            QWidget {{\n                background-color: {self._style_manager.get_color_str(ColorRole.TAB_BACKGROUND_ACTIVE)};\n            }}\n\n            QPlainTextEdit {{\n                border: none;\n                selection-background-color: {self._style_manager.get_color_str(ColorRole.TEXT_SELECTED)};\n                selection-color: none;\n            }}\n\n            QScrollBar:vertical, QScrollBar:horizontal {{\n                background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_BACKGROUND)};\n                width: 12px;\n                height: 12px;\n            }}\n            QScrollBar::handle:vertical, QScrollBar::handle:horizontal {{\n                background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_HANDLE)};\n                min-height: 20px;\n                min-width: 20px;\n            }}\n            QScrollBar::add-page, QScrollBar::sub-page {{\n                background: none;\n            }}\n            QScrollBar::add-line, QScrollBar::sub-line {{\n                height: 0px;\n                width: 0px;\n            }}\n\n            QAbstractScrollArea::corner {{\n                background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_BACKGROUND)};\n            }}\n        \"\"\")\n\n        # Scale line number area\n        self._update_line_number_area_width()\n\n        self._highlight_matches()\n\n    def find_text(self, text: str, forward: bool = True) -> None:\n        \"\"\"\n        Find all instances of text and highlight them.\n\n        Args:\n            text: Text to search for\n            forward: Whether to search forward from current position\n        \"\"\"\n        # Clear existing highlights if search text changed\n        if text != self._last_search:\n            self._clear_highlights()\n            self._matches = []\n            self._current_match = -1\n            self._last_search = text\n\n        document = self.document()\n\n        # Find all matches if this is a new search\n        if not self._matches and text:\n            cursor = QTextCursor(document)\n            while True:\n                cursor = document.find(text, cursor)\n                if cursor.isNull():\n                    break\n\n                self._matches.append((cursor.selectionStart(), cursor.selectionEnd()))\n\n        if not self._matches:\n            return\n\n        # Move to next/previous match\n        if forward:\n            self._current_match = (self._current_match + 1) % len(self._matches)\n\n        else:\n            self._current_match = (self._current_match - 1) if self._current_match > 0 else len(self._matches) - 1\n\n        # Highlight all matches\n        self._highlight_matches()\n\n        # Scroll to current match\n        self._scroll_to_match(self._current_match)\n\n    def _highlight_matches(self) -> None:\n        \"\"\"Update the highlighting of all matches.\"\"\"\n        self._clear_highlights()\n\n        if not self._matches:\n            return\n\n        found_format = QTextCharFormat()\n        found_format.setBackground(self._style_manager.get_color(ColorRole.TEXT_FOUND))\n        dim_found_format = QTextCharFormat()\n        dim_found_format.setBackground(self._style_manager.get_color(ColorRole.TEXT_FOUND_DIM))\n\n        # Create extra selections list\n        selections = []\n\n        # Highlight all matches\n        for i, (start, end) in enumerate(self._matches):\n            cursor = QTextCursor(self.document())\n            cursor.setPosition(start)\n            cursor.setPosition(end, QTextCursor.MoveMode.KeepAnchor)\n\n            # Create extra selection\n            extra_selection = QTextEdit.ExtraSelection()\n\n            # We have to tell mypy to ingore attributes it doesn't know about\n            extra_selection.cursor = cursor  # type: ignore\n\n            # Use different format for current match\n            if i == self._current_match:\n                extra_selection.format = found_format  # type: ignore\n\n            else:\n                extra_selection.format = dim_found_format  # type: ignore\n\n            selections.append(extra_selection)\n\n        # Apply selections\n        self.setExtraSelections(selections)\n\n    def _scroll_to_match(self, match_index: int) -> None:\n        \"\"\"\n        Scroll to ensure the given match is visible.\n\n        Args:\n            match_index: Index of match to scroll to\n        \"\"\"\n        if 0 <= match_index < len(self._matches):\n            cursor = QTextCursor(self.document())\n            cursor.setPosition(self._matches[match_index][0])\n            self.setTextCursor(cursor)\n            self.ensureCursorVisible()\n\n    def _clear_highlights(self) -> None:\n        \"\"\"Clear all search highlights.\"\"\"\n        self.setExtraSelections([])\n\n    def get_match_status(self) -> Tuple[int, int]:\n        \"\"\"\n        Get the current match status.\n\n        Returns:\n            Tuple of (current_match, total_matches)\n        \"\"\"\n        return self._current_match + 1, len(self._matches)\n\n    def clear_find(self) -> None:\n        \"\"\"Clear all find state.\"\"\"\n        self._clear_highlights()\n        self._matches = []\n        self._current_match = -1\n        self._last_search = \"\"\n\n    def can_undo(self) -> bool:\n        \"\"\"Check if undo is available.\"\"\"\n        return self.document().isUndoAvailable()\n\n    def can_redo(self) -> bool:\n        \"\"\"Check if redo is available.\"\"\"\n        return self.document().isRedoAvailable()\n\n    def can_cut(self) -> bool:\n        \"\"\"Check if cut is available.\"\"\"\n        return self.textCursor().hasSelection()\n\n    def can_copy(self) -> bool:\n        \"\"\"Check if copy is available.\"\"\"\n        return self.textCursor().hasSelection()\n\n    def can_paste(self) -> bool:\n        \"\"\"Check if paste is available.\"\"\"\n        return True"
          }
        }
      ]
    },
    {
      "id": "4028ca93-6aba-43fd-9613-5a09d3daff5f",
      "timestamp": "2025-08-29T17:35:20.360179+00:00",
      "type": "tool_call",
      "content": "```json\n{\n    \"id\": \"toolu_014YQpakDHa9HtBixJLyrnkZ\",\n    \"name\": \"filesystem\",\n    \"arguments\": {\n        \"operation\": \"write_file\",\n        \"path\": \"src/humbug/tabs/editor/editor_widget.py\",\n        \"content\": \"import logging\\nimport os\\nimport time\\nfrom typing import List, Tuple, Dict, Any, cast\\n\\nfrom PySide6.QtWidgets import QPlainTextEdit, QWidget, QTextEdit, QFileDialog\\nfrom PySide6.QtCore import Qt, QRect, Signal, QObject, QEvent, QTimer\\nfrom PySide6.QtGui import (\\n    QPainter, QTextCursor, QKeyEvent, QPalette, QBrush, QTextCharFormat,\\n    QResizeEvent, QPaintEvent\\n)\\n\\nfrom syntax import ProgrammingLanguage, ProgrammingLanguageUtils\\n\\nfrom humbug.color_role import ColorRole\\nfrom humbug.language.language_manager import LanguageManager\\nfrom humbug.message_box import MessageBox, MessageBoxType, MessageBoxButton\\nfrom humbug.mindspace.mindspace_manager import MindspaceManager\\nfrom humbug.mindspace.mindspace_settings import MindspaceSettings\\nfrom humbug.style_manager import StyleManager\\nfrom humbug.tabs.editor.editor_highlighter import EditorHighlighter\\nfrom humbug.tabs.editor.editor_line_number_area import EditorLineNumberArea\\n\\n\\nclass EditorWidgetEventFilter(QObject):\\n    \\\"\\\"\\\"Event filter to track activation events from child widgets.\\\"\\\"\\\"\\n\\n    widget_activated = Signal(object)\\n    widget_deactivated = Signal(object)\\n\\n    def __init__(self, parent: QWidget | None = None) -> None:\\n        \\\"\\\"\\\"Initialize the event filter.\\\"\\\"\\\"\\n        super().__init__(parent)\\n\\n    def eventFilter(self, watched: QObject, event: QEvent) -> bool:\\n        \\\"\\\"\\\"\\n        Filter events to detect widget activation.\\n\\n        Args:\\n            obj: The object that received the event\\n            event: The event that was received\\n\\n        Returns:\\n            True if event was handled, False to pass to the target object\\n        \\\"\\\"\\\"\\n        if event.type() in (QEvent.Type.MouseButtonPress, QEvent.Type.FocusIn):\\n            # Simply emit the signal with the object that received the event\\n            self.widget_activated.emit(watched)\\n            return False  # Don't consume the event\\n\\n        if event.type() == QEvent.Type.FocusOut:\\n            # Emit a widget deactivated signal\\n            self.widget_deactivated.emit(watched)\\n            return False  # Don't consume the event\\n\\n        return super().eventFilter(watched, event)\\n\\n\\nclass EditorWidget(QPlainTextEdit):\\n    \\\"\\\"\\\"Text editor widget with line numbers, syntax highlighting, and find functionality.\\\"\\\"\\\"\\n\\n    # Content/state changes\\n    content_modified = Signal(bool)  # True if modified, False if saved\\n    status_updated = Signal()        # Request status bar update\\n    activated = Signal()             # User interaction occurred\\n    file_saved = Signal(str)         # File path saved\\n\\n    def __init__(self, path: str = \\\"\\\", untitled_number: int | None = None, parent: QWidget | None = None) -> None:\\n        \\\"\\\"\\\"\\n        Initialize the editor widget.\\n\\n        Args:\\n            path: Optional file path to load\\n            untitled_number: Optional untitled file number for new files\\n            parent: Optional parent widget\\n        \\\"\\\"\\\"\\n        super().__init__(parent)\\n        self._logger = logging.getLogger(\\\"EditorWidget\\\")\\n\\n        # File state\\n        self._path = path\\n        self._untitled_number = untitled_number\\n        self._last_save_content = \\\"\\\"\\n        self._is_modified = False\\n\\n        # Editor settings\\n        self.setLineWrapMode(QPlainTextEdit.LineWrapMode.NoWrap)  # No word wrap for code\\n        self.setTabStopDistance(32)  # 4 spaces worth of tab stops\\n\\n        # Enable standard scrollbars\\n        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)\\n        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)\\n\\n        self._style_manager = StyleManager()\\n        self._init_colour_mode = self._style_manager.color_mode()\\n\\n        # Setup line number area\\n        self._line_number_area = EditorLineNumberArea(\\n            self, self._line_number_area_width, self._line_number_area_paint_event\\n        )\\n        font = self._line_number_area.font()\\n        font.setFamilies(self._style_manager.monospace_font_families())\\n        self.setFont(font)\\n        self._line_number_area.setFont(font)\\n\\n        self.blockCountChanged.connect(self._update_line_number_area_width)\\n        self.updateRequest.connect(self._update_line_number_area)\\n\\n        self._language_manager = LanguageManager()\\n        self._language_manager.language_changed.connect(self._on_language_changed)\\n        self._update_line_number_area_width()\\n\\n        # Highlighted text should retain any underlying colours (e.g. syntax highlighting)\\n        palette = self.palette()\\n        palette.setBrush(QPalette.ColorRole.HighlightedText, QBrush(Qt.BrushStyle.NoBrush))\\n        self.setPalette(palette)\\n\\n        # Initialize find functionality\\n        self._matches: List[Tuple[int, int]] = []  # List of (start, end) positions\\n        self._current_match = -1\\n        self._last_search = \\\"\\\"\\n\\n        # Programming language and syntax highlighting\\n        self._current_programming_language = ProgrammingLanguage.TEXT\\n        self._highlighter = EditorHighlighter(self.document())\\n\\n        # Auto-backup functionality\\n        self._auto_backup_timer = QTimer(self)\\n        self._auto_backup_timer.timeout.connect(self._auto_backup)\\n\\n        # Mindspace integration\\n        self._mindspace_manager = MindspaceManager()\\n        self._mindspace_manager.settings_changed.connect(self._on_mindspace_settings_changed)\\n\\n        # Set up activation tracking\\n        self._event_filter = EditorWidgetEventFilter(self)\\n        self._event_filter.widget_activated.connect(self._on_widget_activated)\\n        self._event_filter.widget_deactivated.connect(self._on_widget_deactivated)\\n        self.installEventFilter(self._event_filter)\\n\\n        # Connect text changes\\n        self.textChanged.connect(self._on_text_changed)\\n        self.cursorPositionChanged.connect(self.status_updated)\\n\\n        # Connect to style changes\\n        self._style_manager.style_changed.connect(self._on_style_changed)\\n        self._on_style_changed()\\n\\n        # Load file if path provided\\n        if self._path:\\n            self._load_file()\\n\\n        # Update programming language based on path\\n        self._update_programming_language_from_path()\\n\\n        # Update auto-backup based on current mindspace settings\\n        self._update_auto_backup_from_settings()\\n\\n    def _load_file(self) -> None:\\n        \\\"\\\"\\\"Load content from file path.\\\"\\\"\\\"\\n        if not self._path or not os.path.exists(self._path):\\n            return\\n\\n        try:\\n            with open(self._path, 'r', encoding='utf-8') as f:\\n                content = f.read()\\n\\n            self.setPlainText(content)\\n            self._last_save_content = content\\n            self._set_modified(False)\\n\\n        except Exception as e:\\n            self._logger.error(\\\"Failed to load file '%s': %s\\\", self._path, str(e))\\n            strings = self._language_manager.strings()\\n            MessageBox.show_message(\\n                self,\\n                MessageBoxType.CRITICAL,\\n                strings.error_opening_file_title,\\n                strings.could_not_open.format(self._path, str(e))\\n            )\\n\\n    def refresh_content(self) -> None:\\n        \\\"\\\"\\\"\\n        Refresh the editor content from disk.\\n        \\n        This method reads the current file from disk and replaces the editor content.\\n        If the file is unreadable, the editor will be left empty.\\n        The cursor position will be reset to the beginning and any selection will be cleared.\\n        \\\"\\\"\\\"\\n        if not self._path:\\n            self._logger.debug(\\\"No path set, cannot refresh content\\\")\\n            return\\n\\n        try:\\n            if os.path.exists(self._path):\\n                with open(self._path, 'r', encoding='utf-8') as f:\\n                    content = f.read()\\n                    \\n                self._logger.debug(\\\"Refreshing content from file: %s\\\", self._path)\\n                self.setPlainText(content)\\n                self._last_save_content = content\\n                \\n            else:\\n                self._logger.debug(\\\"File no longer exists, clearing content: %s\\\", self._path)\\n                self.setPlainText(\\\"\\\")\\n                self._last_save_content = \\\"\\\"\\n            \\n            # Reset cursor to beginning and clear selection\\n            cursor = QTextCursor(self.document())\\n            cursor.movePosition(QTextCursor.MoveOperation.Start)\\n            self.setTextCursor(cursor)\\n            \\n        except Exception as e:\\n            self._logger.error(\\\"Failed to refresh content from file '%s': %s\\\", self._path, str(e))\\n            # If file is unreadable, leave empty editor view\\n            self.setPlainText(\\\"\\\")\\n            self._last_save_content = \\\"\\\"\\n            \\n            # Reset cursor to beginning\\n            cursor = QTextCursor(self.document())\\n            cursor.movePosition(QTextCursor.MoveOperation.Start)\\n            self.setTextCursor(cursor)\\n\\n    def _update_programming_language_from_path(self) -> None:\\n        \\\"\\\"\\\"Update programming language based on current path.\\\"\\\"\\\"\\n        if self._path:\\n            new_language = ProgrammingLanguageUtils.from_file_extension(self._path)\\n\\n        else:\\n            new_language = ProgrammingLanguage.TEXT\\n\\n        self._update_programming_language(new_language)\\n\\n    def _update_programming_language(self, new_language: ProgrammingLanguage) -> None:\\n        \\\"\\\"\\\"\\n        Update the syntax highlighting language.\\n\\n        Args:\\n            new_language: The new programming language to use\\n        \\\"\\\"\\\"\\n        if self._current_programming_language != new_language:\\n            self._current_programming_language = new_language\\n            self._highlighter.set_language(new_language)\\n            self.status_updated.emit()\\n\\n    def _update_auto_backup_from_settings(self) -> None:\\n        \\\"\\\"\\\"Update auto-backup settings from mindspace.\\\"\\\"\\\"\\n        if not self._mindspace_manager.has_mindspace():\\n            self._auto_backup_timer.stop()\\n            return\\n\\n        settings = self._mindspace_manager.settings()\\n        if settings is None:\\n            self._auto_backup_timer.stop()\\n            return\\n\\n        self._update_auto_backup_settings(settings.auto_backup, settings.auto_backup_interval)\\n\\n    def _update_auto_backup_settings(self, enabled: bool, interval: int) -> None:\\n        \\\"\\\"\\\"Update auto-backup settings.\\\"\\\"\\\"\\n        if enabled:\\n            self._auto_backup_timer.setInterval(interval * 1000)  # Convert to milliseconds\\n            if self._is_modified:\\n                # If we have unsaved changes, start backup immediately\\n                self._auto_backup_timer.start()\\n            return\\n\\n        clear_backups = self._auto_backup_timer.isActive()\\n        self._auto_backup_timer.stop()\\n\\n        # Clean up any existing backups since auto-backup is disabled\\n        if clear_backups:\\n            self._cleanup_backup_files()\\n\\n    def _set_modified(self, modified: bool) -> None:\\n        \\\"\\\"\\\"\\n        Set the modified state and emit appropriate signals.\\n\\n        Args:\\n            modified: Whether the content is modified\\n        \\\"\\\"\\\"\\n        if self._is_modified != modified:\\n            self._is_modified = modified\\n            self.content_modified.emit(modified)\\n\\n    def _on_mindspace_settings_changed(self) -> None:\\n        \\\"\\\"\\\"Handle mindspace settings changes.\\\"\\\"\\\"\\n        self._update_auto_backup_from_settings()\\n\\n    def _on_widget_activated(self, _widget: QWidget) -> None:\\n        \\\"\\\"\\\"\\n        Handle activation of a widget.\\n\\n        Args:\\n            widget: The widget that was activated\\n        \\\"\\\"\\\"\\n        # Emit activated signal to let the tab know this editor was clicked\\n        self.activated.emit()\\n\\n    def _on_widget_deactivated(self, widget: QWidget) -> None:\\n        \\\"\\\"\\\"\\n        Handle deactivation of a widget.\\n\\n        Args:\\n            widget: The widget lost focus\\n        \\\"\\\"\\\"\\n\\n    def _on_language_changed(self) -> None:\\n        \\\"\\\"\\\"Handle language changes by updating the UI.\\\"\\\"\\\"\\n        self._update_line_number_area_width()\\n        self.viewport().update()\\n        self.status_updated.emit()\\n\\n    def _on_text_changed(self) -> None:\\n        \\\"\\\"\\\"Handle changes to editor content.\\\"\\\"\\\"\\n        current_content = self.toPlainText()\\n        is_modified = current_content != self._last_save_content\\n        self._set_modified(is_modified)\\n\\n        if not self._mindspace_manager.has_mindspace():\\n            return\\n\\n        settings = self._mindspace_manager.settings()\\n        if settings is None:\\n            return\\n\\n        if settings.auto_backup:\\n            if is_modified and not self._auto_backup_timer.isActive():\\n                self._auto_backup_timer.start()\\n\\n            elif not is_modified:\\n                self._auto_backup_timer.stop()\\n\\n    def _auto_backup(self) -> None:\\n        \\\"\\\"\\\"Handle auto-backup functionality.\\\"\\\"\\\"\\n        if not self._is_modified:\\n            return\\n\\n        # All backups should now go in mindspace .humbug/backups\\n        if not self._mindspace_manager.has_mindspace():\\n            return  # No backups without a mindspace\\n\\n        backup_dir = self._mindspace_manager.get_absolute_path(os.path.join(\\\".humbug\\\", \\\"backups\\\"))\\n        os.makedirs(backup_dir, exist_ok=True)\\n\\n        if not self._path:\\n            # For untitled files, use timestamp-based backup in mindspace\\n            prefix = f\\\"backup-{self._untitled_number}-\\\"\\n            current_time = int(time.time())\\n            try:\\n                # Clean up old backups for this untitled file\\n                for file in os.listdir(backup_dir):\\n                    if file.startswith(prefix):\\n                        file_path = os.path.join(backup_dir, file)\\n\\n                        # Keep only backups from last hour\\n                        if current_time - os.path.getctime(file_path) > 3600:\\n                            try:\\n                                os.remove(file_path)\\n\\n                            except OSError as e:\\n                                self._logger.warning(\\\"Failed to remove old backup %s: %s\\\", file_path, str(e))\\n\\n            except OSError as e:\\n                self._logger.warning(\\\"Failed to clean up old backups: %s\\\", str(e))\\n\\n            backup_file = os.path.join(\\n                backup_dir,\\n                f\\\"{prefix}{current_time}.txt\\\"\\n            )\\n\\n        else:\\n            backup_file = f\\\"{self._path}.backup\\\"\\n\\n            # Clean up any very old backups that might have been left behind\\n            try:\\n                if os.path.exists(backup_file):\\n                    if time.time() - os.path.getctime(backup_file) > 86400:  # 24 hours\\n                        try:\\n                            os.remove(backup_file)\\n\\n                        except OSError:\\n                            pass  # Ignore cleanup errors for old files\\n\\n            except OSError:\\n                pass  # Ignore stat errors\\n\\n        try:\\n            with open(backup_file, 'w', encoding='utf-8') as f:\\n                f.write(self.toPlainText())\\n\\n        except Exception as e:\\n            self._logger.error(\\\"Failed to create backup file '%s': %s\\\", backup_file, str(e))\\n\\n    def _cleanup_backup_files(self) -> None:\\n        \\\"\\\"\\\"Clean up any backup files for this editor.\\\"\\\"\\\"\\n        if not self._mindspace_manager.has_mindspace():\\n            return\\n\\n        if self._path:\\n            # Clean up backup for saved file\\n            backup_file = f\\\"{self._path}.backup\\\"\\n            try:\\n                if os.path.exists(backup_file):\\n                    os.remove(backup_file)\\n\\n            except OSError as e:\\n                self._logger.warning(\\\"Failed to remove backup file %s: %s\\\", backup_file, str(e))\\n\\n        elif self._untitled_number:\\n            # Clean up backups for untitled file\\n            backup_dir = self._mindspace_manager.get_absolute_path(os.path.join(\\\".humbug\\\", \\\"backups\\\"))\\n            prefix = f\\\"backup-{self._untitled_number}-\\\"\\n            try:\\n                for file in os.listdir(backup_dir):\\n                    if file.startswith(prefix):\\n                        try:\\n                            os.remove(os.path.join(backup_dir, file))\\n\\n                        except OSError as e:\\n                            self._logger.warning(\\\"Failed to remove backup %s: %s\\\", file, str(e))\\n\\n            except OSError as e:\\n                self._logger.warning(\\\"Failed to clean up backups: %s\\\", str(e))\\n\\n    def path(self) -> str:\\n        \\\"\\\"\\\"Get the current file path.\\\"\\\"\\\"\\n        return self._path\\n\\n    def set_path(self, path: str) -> None:\\n        \\\"\\\"\\\"\\n        Set the file path and update language detection.\\n\\n        Args:\\n            path: Path to file\\n        \\\"\\\"\\\"\\n        self._path = path\\n        self._untitled_number = None\\n        self._update_programming_language_from_path()\\n\\n    def is_modified(self) -> bool:\\n        \\\"\\\"\\\"Check if the content has been modified.\\\"\\\"\\\"\\n        return self._is_modified\\n\\n    def can_close(self) -> bool:\\n        \\\"\\\"\\\"Check if the editor can be closed, handling unsaved changes.\\\"\\\"\\\"\\n        if not self._is_modified:\\n            return True\\n\\n        strings = self._language_manager.strings()\\n        document_name = self._path or f'Untitled-{self._untitled_number}'\\n        result = MessageBox.show_message(\\n            self,\\n            MessageBoxType.QUESTION,\\n            strings.save_changes_title,\\n            strings.unsaved_changes.format(document_name),\\n            [MessageBoxButton.SAVE, MessageBoxButton.DISCARD, MessageBoxButton.CANCEL]\\n        )\\n\\n        if result == MessageBoxButton.SAVE:\\n            return self.save_file()\\n\\n        if result == MessageBoxButton.DISCARD:\\n            self._set_modified(False)\\n            return True\\n\\n        return False\\n\\n    def close_widget(self) -> None:\\n        \\\"\\\"\\\"Close the editor widget and clean up resources.\\\"\\\"\\\"\\n        # Delete any backup files when we close\\n        if self._auto_backup_timer.isActive():\\n            self._cleanup_backup_files()\\n\\n    def save_file(self) -> bool:\\n        \\\"\\\"\\\"\\n        Save the current file.\\n\\n        Returns:\\n            bool: True if save was successful\\n        \\\"\\\"\\\"\\n        if not self._path:\\n            return self.save_file_as()\\n\\n        try:\\n            content = self.toPlainText()\\n            with open(self._path, 'w', encoding='utf-8') as f:\\n                f.write(content)\\n\\n            self._last_save_content = content\\n            self._set_modified(False)\\n\\n            # Delete any backup files\\n            backup_file = f\\\"{self._path}.backup\\\"\\n            try:\\n                if os.path.exists(backup_file):\\n                    os.remove(backup_file)\\n\\n            except OSError as e:\\n                self._logger.warning(\\\"Failed to remove backup file %s: %s\\\", backup_file, str(e))\\n\\n            self.file_saved.emit(self._path)\\n            return True\\n\\n        except Exception as e:\\n            strings = self._language_manager.strings()\\n            MessageBox.show_message(\\n                self,\\n                MessageBoxType.CRITICAL,\\n                strings.error_saving_file_title,\\n                strings.could_not_save.format(self._path, str(e))\\n            )\\n            return False\\n\\n    def save_file_as(self) -> bool:\\n        \\\"\\\"\\\"\\n        Show save as dialog and save file.\\n\\n        Returns:\\n            bool: True if save was successful\\n        \\\"\\\"\\\"\\n        strings = self._language_manager.strings()\\n        export_dialog = QFileDialog()\\n        export_dialog.setWindowTitle(strings.file_dialog_save_file)\\n\\n        if self._path:\\n            export_dialog.setDirectory(self._path)\\n\\n        else:\\n            fd_dir = self._mindspace_manager.file_dialog_directory()\\n            if not fd_dir:\\n                return False\\n\\n            export_dialog.setDirectory(fd_dir)\\n\\n        export_dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptSave)\\n        if export_dialog.exec_() != QFileDialog.DialogCode.Accepted:\\n            return False\\n\\n        filename = export_dialog.selectedFiles()[0]\\n        self._mindspace_manager.update_file_dialog_directory(filename)\\n        self.set_path(filename)\\n\\n        return self.save_file()\\n\\n    def get_status_info(self) -> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Get status information for the status bar.\\n\\n        Returns:\\n            Dictionary with status information\\n        \\\"\\\"\\\"\\n        cursor = self.textCursor()\\n        line = cursor.blockNumber() + 1\\n        column = cursor.columnNumber() + 1\\n\\n        # Get file info\\n        encoding = \\\"UTF-8\\\"\\n        line_ending = \\\"LF\\\"  # We could detect this from file content\\n\\n        # Get language name for display\\n        file_type = ProgrammingLanguageUtils.get_display_name(self._current_programming_language)\\n\\n        return {\\n            'line': line,\\n            'column': column,\\n            'encoding': encoding,\\n            'line_ending': line_ending,\\n            'type': file_type\\n        }\\n\\n    def create_state_metadata(self, temp_state: bool) -> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Create metadata dictionary capturing current widget state.\\n\\n        Args:\\n            temp_state: Whether this is temporary state for moving tabs\\n\\n        Returns:\\n            Dictionary containing editor state metadata\\n        \\\"\\\"\\\"\\n        metadata: Dict[str, Any] = {}\\n\\n        metadata[\\\"language\\\"] = self._current_programming_language.name\\n        metadata[\\\"cursor\\\"] = self._get_cursor_position()\\n        metadata[\\\"horizontal_scroll\\\"] = self.horizontalScrollBar().value()\\n        metadata[\\\"vertical_scroll\\\"] = self.verticalScrollBar().value()\\n\\n        if temp_state:\\n            metadata[\\\"content\\\"] = self.toPlainText()\\n\\n        return metadata\\n\\n    def restore_from_metadata(self, metadata: Dict[str, Any]) -> None:\\n        \\\"\\\"\\\"\\n        Restore widget state from metadata.\\n\\n        Args:\\n            metadata: Dictionary containing state metadata\\n        \\\"\\\"\\\"\\n        if not metadata:\\n            return\\n\\n        if \\\"content\\\" in metadata:\\n            self.setPlainText(metadata[\\\"content\\\"])\\n\\n        # Restore language if specified\\n        if \\\"language\\\" in metadata:\\n            language = ProgrammingLanguage[metadata[\\\"language\\\"]]\\n            self._update_programming_language(language)\\n\\n        # Restore cursor position if present\\n        if \\\"cursor\\\" in metadata:\\n            self._set_cursor_position(metadata[\\\"cursor\\\"])\\n\\n        # Restore scroll positions if present\\n        if \\\"horizontal_scroll\\\" in metadata:\\n            self.horizontalScrollBar().setValue(metadata[\\\"horizontal_scroll\\\"])\\n\\n        if \\\"vertical_scroll\\\" in metadata:\\n            self.verticalScrollBar().setValue(metadata[\\\"vertical_scroll\\\"])\\n\\n    def _set_cursor_position(self, position: Dict[str, int]) -> None:\\n        \\\"\\\"\\\"\\n        Set cursor position in editor.\\n\\n        Args:\\n            position: Dictionary with 'line' and 'column' keys\\n        \\\"\\\"\\\"\\n        if not position:\\n            return\\n\\n        cursor = self.textCursor()\\n        cursor.movePosition(QTextCursor.MoveOperation.Start)\\n\\n        # Move cursor to specified position\\n        for _ in range(position.get(\\\"line\\\", 0)):\\n            cursor.movePosition(QTextCursor.MoveOperation.NextBlock)\\n\\n        cursor.movePosition(\\n            QTextCursor.MoveOperation.Right,\\n            QTextCursor.MoveMode.MoveAnchor,\\n            position.get(\\\"column\\\", 0)\\n        )\\n\\n        self.setTextCursor(cursor)\\n        self.ensureCursorVisible()\\n\\n    def _get_cursor_position(self) -> Dict[str, int]:\\n        \\\"\\\"\\\"\\n        Get current cursor position from editor.\\n\\n        Returns:\\n            Dictionary with 'line' and 'column' keys\\n        \\\"\\\"\\\"\\n        cursor = self.textCursor()\\n        return {\\n            \\\"line\\\": cursor.blockNumber(),\\n            \\\"column\\\": cursor.columnNumber()\\n        }\\n\\n    def _line_number_area_width(self) -> int:\\n        \\\"\\\"\\\"Calculate the width needed for the line number area.\\\"\\\"\\\"\\n        digits = 1\\n        max_num = max(1, self.blockCount())\\n        while max_num >= 10:\\n            max_num //= 10\\n            digits += 1\\n\\n        digit_width = self.fontMetrics().horizontalAdvance('9')\\n        return digit_width * (digits + 4)\\n\\n    def _update_line_number_area_width(self) -> None:\\n        \\\"\\\"\\\"Update the margins to accommodate the line numbers.\\\"\\\"\\\"\\n        width = self._line_number_area_width()\\n\\n        # Set margin on appropriate side based on layout direction\\n        if self.layoutDirection() == Qt.LayoutDirection.RightToLeft:\\n            self.setViewportMargins(0, 0, 0, 0)  # Right margin\\n\\n        else:\\n            self.setViewportMargins(width, 0, 0, 0)  # Left margin\\n\\n    def _update_line_number_area(self, rect: QRect, dy: int) -> None:\\n        \\\"\\\"\\\"Handle updates to the line number area.\\\"\\\"\\\"\\n        if dy:\\n            self._line_number_area.scroll(0, dy)\\n\\n        else:\\n            self._line_number_area.update(0, rect.y(),\\n                self._line_number_area.width(), rect.height())\\n\\n        if rect.contains(self.viewport().rect()):\\n            self._update_line_number_area_width()\\n\\n    def resizeEvent(self, event: QResizeEvent) -> None:  # type: ignore[override]\\n        \\\"\\\"\\\"Handle resize events.\\\"\\\"\\\"\\n        super().resizeEvent(event)\\n        cr = self.contentsRect()\\n        width = self._line_number_area_width()\\n\\n        if self.layoutDirection() == Qt.LayoutDirection.RightToLeft:\\n            self._line_number_area.setGeometry(\\n                cr.right() - width,\\n                cr.top(),\\n                width,\\n                cr.height()\\n            )\\n\\n        else:\\n            self._line_number_area.setGeometry(\\n                cr.left(),\\n                cr.top(),\\n                width,\\n                cr.height()\\n            )\\n\\n    def _line_number_area_paint_event(self, event: QPaintEvent) -> None:\\n        \\\"\\\"\\\"Paint the line numbers.\\\"\\\"\\\"\\n        painter = QPainter(self._line_number_area)\\n        bg_color = self._style_manager.get_color(ColorRole.TAB_BACKGROUND_ACTIVE)\\n        painter.fillRect(event.rect(), bg_color)\\n\\n        painter.setFont(self.font())\\n\\n        block = self.firstVisibleBlock()\\n        block_number = block.blockNumber()\\n        offset = self.contentOffset()\\n        top = self.blockBoundingGeometry(block).translated(offset).top()\\n        bottom = top + self.blockBoundingRect(block).height()\\n\\n        # Use two space widths for padding\\n        padding = self.fontMetrics().horizontalAdvance('9') * 2\\n\\n        # Adjust alignment and padding based on layout direction\\n        is_rtl = self.layoutDirection() == Qt.LayoutDirection.RightToLeft\\n        alignment = Qt.AlignmentFlag.AlignLeft if is_rtl else Qt.AlignmentFlag.AlignRight\\n\\n        while block.isValid() and top <= event.rect().bottom():\\n            if block.isVisible() and bottom >= event.rect().top():\\n                number = str(block_number + 1)\\n                text_color = self._style_manager.get_color(ColorRole.LINE_NUMBER)\\n                painter.setPen(text_color)\\n                text_rect = QRect(\\n                    0,\\n                    int(top),\\n                    self._line_number_area.width() - padding,\\n                    self.fontMetrics().height()\\n                )\\n                painter.drawText(text_rect, alignment, number)\\n\\n            block = block.next()\\n            top = bottom\\n            bottom = top + self.blockBoundingRect(block).height()\\n            block_number += 1\\n\\n    def _indent_single_line_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\\n        \\\"\\\"\\\"\\n        Indent a single line using soft tabs.\\n\\n        Args:\\n            cursor: The current text cursor\\n            tab_size: Number of spaces to use for indentation\\n        \\\"\\\"\\\"\\n        # Calculate spaces needed to reach next tab stop\\n        current_column = cursor.position() - cursor.block().position()\\n        spaces_needed = tab_size - (current_column % tab_size)\\n        cursor.insertText(\\\" \\\" * spaces_needed)\\n\\n    def _indent_single_line_hard_tabs(self, cursor: QTextCursor) -> None:\\n        \\\"\\\"\\\"\\n        Indent a single line using hard tabs.\\n\\n        Args:\\n            cursor: The current text cursor\\n        \\\"\\\"\\\"\\n        cursor.insertText(\\\"\\\\t\\\")\\n\\n    def _indent_block_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\\n        \\\"\\\"\\\"\\n        Indent a block of text using soft tabs.\\n\\n        Args:\\n            cursor: The current text cursor\\n            tab_size: Number of spaces to use for indentation\\n        \\\"\\\"\\\"\\n        start = cursor.selectionStart()\\n        end = cursor.selectionEnd()\\n        reverse: bool = start == cursor.position()\\n\\n        cursor.setPosition(start)\\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\\n\\n        # If selection ends at start of line, don't indent that line\\n        end_offs = 0\\n        check_cursor = QTextCursor(cursor)\\n        check_cursor.setPosition(end)\\n        if check_cursor.atBlockStart():\\n            end_offs = 1\\n\\n        start += tab_size\\n        while cursor.position() <= end - end_offs:\\n            if not cursor.atBlockEnd():\\n                cursor.insertText(\\\" \\\" * tab_size)\\n                end += tab_size\\n\\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\\n                # We hit the end of the file\\n                break\\n\\n        cursor.setPosition(start if not reverse else end)\\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\\n\\n    def _indent_block_hard_tabs(self, cursor: QTextCursor) -> None:\\n        \\\"\\\"\\\"\\n        Indent a block of text using hard tabs.\\n\\n        Args:\\n            cursor: The current text cursor\\n        \\\"\\\"\\\"\\n        start = cursor.selectionStart()\\n        end = cursor.selectionEnd()\\n        reverse: bool = start == cursor.position()\\n\\n        cursor.setPosition(start)\\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\\n\\n        # If selection ends at start of line, don't indent that line\\n        end_offs = 0\\n        check_cursor = QTextCursor(cursor)\\n        check_cursor.setPosition(end)\\n        if check_cursor.atBlockStart():\\n            end_offs = 1\\n\\n        start += 1\\n        while cursor.position() <= end - end_offs:\\n            if not cursor.atBlockEnd():\\n                cursor.insertText(\\\"\\\\t\\\")\\n                end += 1\\n\\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\\n                # We hit the end of the file\\n                break\\n\\n        cursor.setPosition(start if not reverse else end)\\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\\n\\n    def _outdent_single_line_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\\n        \\\"\\\"\\\"\\n        Outdent a single line using soft tabs.\\n\\n        Args:\\n            cursor: The current text cursor\\n            tab_size: Number of spaces to use for indentation\\n        \\\"\\\"\\\"\\n        current_column = cursor.position() - cursor.block().position()\\n        deletes_needed = 1 + ((current_column - 1) % tab_size)\\n        deletes_needed = min(deletes_needed, current_column)\\n\\n        while deletes_needed > 0:\\n            text = cursor.block().text()\\n            if not text or text[current_column - 1] != \\\" \\\":\\n                break\\n\\n            cursor.deletePreviousChar()\\n            current_column -= 1\\n            deletes_needed -= 1\\n\\n    def _outdent_single_line_hard_tabs(self, cursor: QTextCursor) -> None:\\n        \\\"\\\"\\\"\\n        Outdent a single line using hard tabs.\\n\\n        Args:\\n            cursor: The current text cursor\\n        \\\"\\\"\\\"\\n        current_column = cursor.position() - cursor.block().position()\\n        if current_column > 0:\\n            text = cursor.block().text()\\n            if text and text[current_column - 1] == \\\"\\\\t\\\":\\n                cursor.deletePreviousChar()\\n\\n    def _outdent_block_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\\n        \\\"\\\"\\\"\\n        Outdent a block of text using soft tabs.\\n\\n        Args:\\n            cursor: The current text cursor\\n            tab_size: Number of spaces to use for indentation\\n        \\\"\\\"\\\"\\n        start = cursor.selectionStart()\\n        end = cursor.selectionEnd()\\n        reverse: bool = start == cursor.position()\\n\\n        cursor.setPosition(start)\\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\\n\\n        # If selection ends at start of line, don't outdent that line\\n        end_offs = 0\\n        check_cursor = QTextCursor(cursor)\\n        check_cursor.setPosition(end)\\n        if check_cursor.atBlockStart():\\n            end_offs = 1\\n\\n        # Work out how far to move the start postion\\n        current_column = start - cursor.block().position()\\n        first_line = cursor.block().text()\\n        first_line_spaces = len(first_line) - len(first_line.lstrip(\\\" \\\"))\\n        first_line_spaces = min(first_line_spaces, tab_size)\\n        first_line_spaces = min(first_line_spaces, current_column)\\n        start -= first_line_spaces\\n\\n        while cursor.position() <= end - end_offs:\\n            deletes_needed = tab_size\\n\\n            while deletes_needed > 0:\\n                text = cursor.block().text()\\n                if not text or text[0] != \\\" \\\":\\n                    break\\n\\n                cursor.deleteChar()\\n                deletes_needed -= 1\\n                end -= 1\\n\\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\\n                # We hit the end of the block\\n                break\\n\\n        cursor.setPosition(start if not reverse else end)\\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\\n\\n    def _outdent_block_hard_tabs(self, cursor: QTextCursor) -> None:\\n        \\\"\\\"\\\"\\n        Outdent a block of text using hard tabs.\\n\\n        Args:\\n            cursor: The current text cursor\\n        \\\"\\\"\\\"\\n        start = cursor.selectionStart()\\n        end = cursor.selectionEnd()\\n        reverse: bool = start == cursor.position()\\n\\n        cursor.setPosition(start)\\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\\n\\n        # If selection ends at start of line, don't outdent that line\\n        end_offs = 0\\n        check_cursor = QTextCursor(cursor)\\n        check_cursor.setPosition(end)\\n        if check_cursor.atBlockStart():\\n            end_offs = 1\\n\\n        # Work out how far to move the start postion\\n        current_column = start - cursor.block().position()\\n        first_line = cursor.block().text()\\n        if first_line and first_line[0] == \\\"\\\\t\\\" and current_column > 0:\\n            start -= 1\\n\\n        while cursor.position() <= end - end_offs:\\n            text = cursor.block().text()\\n            if text and text[0] == \\\"\\\\t\\\":\\n                cursor.deleteChar()\\n                end -= 1\\n\\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\\n                # We hit the end of the block\\n                break\\n\\n        cursor.setPosition(start if not reverse else end)\\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\\n\\n    def keyPressEvent(self, event: QKeyEvent) -> None:  # type: ignore[override]\\n        \\\"\\\"\\\"\\n        Handle special key events.\\n\\n        Args:\\n            event: The key event to handle\\n        \\\"\\\"\\\"\\n        if event.key() == Qt.Key.Key_Home:\\n            cursor = self.textCursor()\\n            cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\\n            self.setTextCursor(cursor)\\n            event.accept()\\n            return\\n\\n        if event.key() == Qt.Key.Key_End:\\n            cursor = self.textCursor()\\n            cursor.movePosition(QTextCursor.MoveOperation.EndOfLine)\\n            self.setTextCursor(cursor)\\n            event.accept()\\n            return\\n\\n        if event.key() == Qt.Key.Key_Tab:\\n            cursor = self.textCursor()\\n            mindspace_manager = MindspaceManager()\\n            if not mindspace_manager.has_mindspace():\\n                super().keyPressEvent(event)\\n                return\\n\\n            settings = cast(MindspaceSettings, mindspace_manager.settings())\\n\\n            scrollbar = self.verticalScrollBar()\\n            current_scroll = scrollbar.value()\\n            cursor.beginEditBlock()\\n            try:\\n                if not cursor.hasSelection():\\n                    if settings.use_soft_tabs:\\n                        self._indent_single_line_soft_tabs(cursor, settings.tab_size)\\n\\n                    else:\\n                        self._indent_single_line_hard_tabs(cursor)\\n\\n                else:\\n                    if settings.use_soft_tabs:\\n                        self._indent_block_soft_tabs(cursor, settings.tab_size)\\n\\n                    else:\\n                        self._indent_block_hard_tabs(cursor)\\n\\n            finally:\\n                cursor.endEditBlock()\\n                self.setTextCursor(cursor)\\n                scrollbar.setValue(current_scroll)\\n\\n            event.accept()\\n            return\\n\\n        if event.key() == Qt.Key.Key_Backtab:  # Shift+Tab\\n            cursor = self.textCursor()\\n            mindspace_manager = MindspaceManager()\\n            if not mindspace_manager.has_mindspace():\\n                super().keyPressEvent(event)\\n                return\\n\\n            settings = cast(MindspaceSettings, mindspace_manager.settings())\\n\\n            scrollbar = self.verticalScrollBar()\\n            current_scroll = scrollbar.value()\\n            cursor.beginEditBlock()\\n            try:\\n                if not cursor.hasSelection():\\n                    if settings.use_soft_tabs:\\n                        self._outdent_single_line_soft_tabs(cursor, settings.tab_size)\\n\\n                    else:\\n                        self._outdent_single_line_hard_tabs(cursor)\\n\\n                else:\\n                    if settings.use_soft_tabs:\\n                        self._outdent_block_soft_tabs(cursor, settings.tab_size)\\n\\n                    else:\\n                        self._outdent_block_hard_tabs(cursor)\\n\\n            finally:\\n                cursor.endEditBlock()\\n                self.setTextCursor(cursor)\\n                scrollbar.setValue(current_scroll)\\n\\n            event.accept()\\n            return\\n\\n        super().keyPressEvent(event)\\n\\n    def _on_style_changed(self) -> None:\\n        \\\"\\\"\\\"Handle style changes affecting search highlighting.\\\"\\\"\\\"\\n        # Update font size\\n        zoom_factor = self._style_manager.zoom_factor()\\n        font = self.font()\\n        base_size = self._style_manager.base_font_size()\\n        font.setPointSizeF(base_size * zoom_factor)\\n        self.setFont(font)\\n\\n        # Update tab stops - scale with zoom\\n        space_width = self._style_manager.get_space_width()\\n        self.setTabStopDistance(space_width * 8)\\n\\n        # If we changed colour mode then re-highlight\\n        if self._style_manager.color_mode() != self._init_colour_mode:\\n            self._init_colour_mode = self._style_manager.color_mode()\\n            self._highlighter.rehighlight()\\n\\n        self.setStyleSheet(f\\\"\\\"\\\"\\n            QWidget {{\\n                background-color: {self._style_manager.get_color_str(ColorRole.TAB_BACKGROUND_ACTIVE)};\\n            }}\\n\\n            QPlainTextEdit {{\\n                border: none;\\n                selection-background-color: {self._style_manager.get_color_str(ColorRole.TEXT_SELECTED)};\\n                selection-color: none;\\n            }}\\n\\n            QScrollBar:vertical, QScrollBar:horizontal {{\\n                background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_BACKGROUND)};\\n                width: 12px;\\n                height: 12px;\\n            }}\\n            QScrollBar::handle:vertical, QScrollBar::handle:horizontal {{\\n                background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_HANDLE)};\\n                min-height: 20px;\\n                min-width: 20px;\\n            }}\\n            QScrollBar::add-page, QScrollBar::sub-page {{\\n                background: none;\\n            }}\\n            QScrollBar::add-line, QScrollBar::sub-line {{\\n                height: 0px;\\n                width: 0px;\\n            }}\\n\\n            QAbstractScrollArea::corner {{\\n                background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_BACKGROUND)};\\n            }}\\n        \\\"\\\"\\\")\\n\\n        # Scale line number area\\n        self._update_line_number_area_width()\\n\\n        self._highlight_matches()\\n\\n    def find_text(self, text: str, forward: bool = True) -> None:\\n        \\\"\\\"\\\"\\n        Find all instances of text and highlight them.\\n\\n        Args:\\n            text: Text to search for\\n            forward: Whether to search forward from current position\\n        \\\"\\\"\\\"\\n        # Clear existing highlights if search text changed\\n        if text != self._last_search:\\n            self._clear_highlights()\\n            self._matches = []\\n            self._current_match = -1\\n            self._last_search = text\\n\\n        document = self.document()\\n\\n        # Find all matches if this is a new search\\n        if not self._matches and text:\\n            cursor = QTextCursor(document)\\n            while True:\\n                cursor = document.find(text, cursor)\\n                if cursor.isNull():\\n                    break\\n\\n                self._matches.append((cursor.selectionStart(), cursor.selectionEnd()))\\n\\n        if not self._matches:\\n            return\\n\\n        # Move to next/previous match\\n        if forward:\\n            self._current_match = (self._current_match + 1) % len(self._matches)\\n\\n        else:\\n            self._current_match = (self._current_match - 1) if self._current_match > 0 else len(self._matches) - 1\\n\\n        # Highlight all matches\\n        self._highlight_matches()\\n\\n        # Scroll to current match\\n        self._scroll_to_match(self._current_match)\\n\\n    def _highlight_matches(self) -> None:\\n        \\\"\\\"\\\"Update the highlighting of all matches.\\\"\\\"\\\"\\n        self._clear_highlights()\\n\\n        if not self._matches:\\n            return\\n\\n        found_format = QTextCharFormat()\\n        found_format.setBackground(self._style_manager.get_color(ColorRole.TEXT_FOUND))\\n        dim_found_format = QTextCharFormat()\\n        dim_found_format.setBackground(self._style_manager.get_color(ColorRole.TEXT_FOUND_DIM))\\n\\n        # Create extra selections list\\n        selections = []\\n\\n        # Highlight all matches\\n        for i, (start, end) in enumerate(self._matches):\\n            cursor = QTextCursor(self.document())\\n            cursor.setPosition(start)\\n            cursor.setPosition(end, QTextCursor.MoveMode.KeepAnchor)\\n\\n            # Create extra selection\\n            extra_selection = QTextEdit.ExtraSelection()\\n\\n            # We have to tell mypy to ingore attributes it doesn't know about\\n            extra_selection.cursor = cursor  # type: ignore\\n\\n            # Use different format for current match\\n            if i == self._current_match:\\n                extra_selection.format = found_format  # type: ignore\\n\\n            else:\\n                extra_selection.format = dim_found_format  # type: ignore\\n\\n            selections.append(extra_selection)\\n\\n        # Apply selections\\n        self.setExtraSelections(selections)\\n\\n    def _scroll_to_match(self, match_index: int) -> None:\\n        \\\"\\\"\\\"\\n        Scroll to ensure the given match is visible.\\n\\n        Args:\\n            match_index: Index of match to scroll to\\n        \\\"\\\"\\\"\\n        if 0 <= match_index < len(self._matches):\\n            cursor = QTextCursor(self.document())\\n            cursor.setPosition(self._matches[match_index][0])\\n            self.setTextCursor(cursor)\\n            self.ensureCursorVisible()\\n\\n    def _clear_highlights(self) -> None:\\n        \\\"\\\"\\\"Clear all search highlights.\\\"\\\"\\\"\\n        self.setExtraSelections([])\\n\\n    def get_match_status(self) -> Tuple[int, int]:\\n        \\\"\\\"\\\"\\n        Get the current match status.\\n\\n        Returns:\\n            Tuple of (current_match, total_matches)\\n        \\\"\\\"\\\"\\n        return self._current_match + 1, len(self._matches)\\n\\n    def clear_find(self) -> None:\\n        \\\"\\\"\\\"Clear all find state.\\\"\\\"\\\"\\n        self._clear_highlights()\\n        self._matches = []\\n        self._current_match = -1\\n        self._last_search = \\\"\\\"\\n\\n    def can_undo(self) -> bool:\\n        \\\"\\\"\\\"Check if undo is available.\\\"\\\"\\\"\\n        return self.document().isUndoAvailable()\\n\\n    def can_redo(self) -> bool:\\n        \\\"\\\"\\\"Check if redo is available.\\\"\\\"\\\"\\n        return self.document().isRedoAvailable()\\n\\n    def can_cut(self) -> bool:\\n        \\\"\\\"\\\"Check if cut is available.\\\"\\\"\\\"\\n        return self.textCursor().hasSelection()\\n\\n    def can_copy(self) -> bool:\\n        \\\"\\\"\\\"Check if copy is available.\\\"\\\"\\\"\\n        return self.textCursor().hasSelection()\\n\\n    def can_paste(self) -> bool:\\n        \\\"\\\"\\\"Check if paste is available.\\\"\\\"\\\"\\n        return True\"\n    }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_014YQpakDHa9HtBixJLyrnkZ",
          "name": "filesystem",
          "arguments": {
            "operation": "write_file",
            "path": "src/humbug/tabs/editor/editor_widget.py",
            "content": "import logging\nimport os\nimport time\nfrom typing import List, Tuple, Dict, Any, cast\n\nfrom PySide6.QtWidgets import QPlainTextEdit, QWidget, QTextEdit, QFileDialog\nfrom PySide6.QtCore import Qt, QRect, Signal, QObject, QEvent, QTimer\nfrom PySide6.QtGui import (\n    QPainter, QTextCursor, QKeyEvent, QPalette, QBrush, QTextCharFormat,\n    QResizeEvent, QPaintEvent\n)\n\nfrom syntax import ProgrammingLanguage, ProgrammingLanguageUtils\n\nfrom humbug.color_role import ColorRole\nfrom humbug.language.language_manager import LanguageManager\nfrom humbug.message_box import MessageBox, MessageBoxType, MessageBoxButton\nfrom humbug.mindspace.mindspace_manager import MindspaceManager\nfrom humbug.mindspace.mindspace_settings import MindspaceSettings\nfrom humbug.style_manager import StyleManager\nfrom humbug.tabs.editor.editor_highlighter import EditorHighlighter\nfrom humbug.tabs.editor.editor_line_number_area import EditorLineNumberArea\n\n\nclass EditorWidgetEventFilter(QObject):\n    \"\"\"Event filter to track activation events from child widgets.\"\"\"\n\n    widget_activated = Signal(object)\n    widget_deactivated = Signal(object)\n\n    def __init__(self, parent: QWidget | None = None) -> None:\n        \"\"\"Initialize the event filter.\"\"\"\n        super().__init__(parent)\n\n    def eventFilter(self, watched: QObject, event: QEvent) -> bool:\n        \"\"\"\n        Filter events to detect widget activation.\n\n        Args:\n            obj: The object that received the event\n            event: The event that was received\n\n        Returns:\n            True if event was handled, False to pass to the target object\n        \"\"\"\n        if event.type() in (QEvent.Type.MouseButtonPress, QEvent.Type.FocusIn):\n            # Simply emit the signal with the object that received the event\n            self.widget_activated.emit(watched)\n            return False  # Don't consume the event\n\n        if event.type() == QEvent.Type.FocusOut:\n            # Emit a widget deactivated signal\n            self.widget_deactivated.emit(watched)\n            return False  # Don't consume the event\n\n        return super().eventFilter(watched, event)\n\n\nclass EditorWidget(QPlainTextEdit):\n    \"\"\"Text editor widget with line numbers, syntax highlighting, and find functionality.\"\"\"\n\n    # Content/state changes\n    content_modified = Signal(bool)  # True if modified, False if saved\n    status_updated = Signal()        # Request status bar update\n    activated = Signal()             # User interaction occurred\n    file_saved = Signal(str)         # File path saved\n\n    def __init__(self, path: str = \"\", untitled_number: int | None = None, parent: QWidget | None = None) -> None:\n        \"\"\"\n        Initialize the editor widget.\n\n        Args:\n            path: Optional file path to load\n            untitled_number: Optional untitled file number for new files\n            parent: Optional parent widget\n        \"\"\"\n        super().__init__(parent)\n        self._logger = logging.getLogger(\"EditorWidget\")\n\n        # File state\n        self._path = path\n        self._untitled_number = untitled_number\n        self._last_save_content = \"\"\n        self._is_modified = False\n\n        # Editor settings\n        self.setLineWrapMode(QPlainTextEdit.LineWrapMode.NoWrap)  # No word wrap for code\n        self.setTabStopDistance(32)  # 4 spaces worth of tab stops\n\n        # Enable standard scrollbars\n        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)\n        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)\n\n        self._style_manager = StyleManager()\n        self._init_colour_mode = self._style_manager.color_mode()\n\n        # Setup line number area\n        self._line_number_area = EditorLineNumberArea(\n            self, self._line_number_area_width, self._line_number_area_paint_event\n        )\n        font = self._line_number_area.font()\n        font.setFamilies(self._style_manager.monospace_font_families())\n        self.setFont(font)\n        self._line_number_area.setFont(font)\n\n        self.blockCountChanged.connect(self._update_line_number_area_width)\n        self.updateRequest.connect(self._update_line_number_area)\n\n        self._language_manager = LanguageManager()\n        self._language_manager.language_changed.connect(self._on_language_changed)\n        self._update_line_number_area_width()\n\n        # Highlighted text should retain any underlying colours (e.g. syntax highlighting)\n        palette = self.palette()\n        palette.setBrush(QPalette.ColorRole.HighlightedText, QBrush(Qt.BrushStyle.NoBrush))\n        self.setPalette(palette)\n\n        # Initialize find functionality\n        self._matches: List[Tuple[int, int]] = []  # List of (start, end) positions\n        self._current_match = -1\n        self._last_search = \"\"\n\n        # Programming language and syntax highlighting\n        self._current_programming_language = ProgrammingLanguage.TEXT\n        self._highlighter = EditorHighlighter(self.document())\n\n        # Auto-backup functionality\n        self._auto_backup_timer = QTimer(self)\n        self._auto_backup_timer.timeout.connect(self._auto_backup)\n\n        # Mindspace integration\n        self._mindspace_manager = MindspaceManager()\n        self._mindspace_manager.settings_changed.connect(self._on_mindspace_settings_changed)\n\n        # Set up activation tracking\n        self._event_filter = EditorWidgetEventFilter(self)\n        self._event_filter.widget_activated.connect(self._on_widget_activated)\n        self._event_filter.widget_deactivated.connect(self._on_widget_deactivated)\n        self.installEventFilter(self._event_filter)\n\n        # Connect text changes\n        self.textChanged.connect(self._on_text_changed)\n        self.cursorPositionChanged.connect(self.status_updated)\n\n        # Connect to style changes\n        self._style_manager.style_changed.connect(self._on_style_changed)\n        self._on_style_changed()\n\n        # Load file if path provided\n        if self._path:\n            self._load_file()\n\n        # Update programming language based on path\n        self._update_programming_language_from_path()\n\n        # Update auto-backup based on current mindspace settings\n        self._update_auto_backup_from_settings()\n\n    def _load_file(self) -> None:\n        \"\"\"Load content from file path.\"\"\"\n        if not self._path or not os.path.exists(self._path):\n            return\n\n        try:\n            with open(self._path, 'r', encoding='utf-8') as f:\n                content = f.read()\n\n            self.setPlainText(content)\n            self._last_save_content = content\n            self._set_modified(False)\n\n        except Exception as e:\n            self._logger.error(\"Failed to load file '%s': %s\", self._path, str(e))\n            strings = self._language_manager.strings()\n            MessageBox.show_message(\n                self,\n                MessageBoxType.CRITICAL,\n                strings.error_opening_file_title,\n                strings.could_not_open.format(self._path, str(e))\n            )\n\n    def refresh_content(self) -> None:\n        \"\"\"\n        Refresh the editor content from disk.\n        \n        This method reads the current file from disk and replaces the editor content.\n        If the file is unreadable, the editor will be left empty.\n        The cursor position will be reset to the beginning and any selection will be cleared.\n        \"\"\"\n        if not self._path:\n            self._logger.debug(\"No path set, cannot refresh content\")\n            return\n\n        try:\n            if os.path.exists(self._path):\n                with open(self._path, 'r', encoding='utf-8') as f:\n                    content = f.read()\n                    \n                self._logger.debug(\"Refreshing content from file: %s\", self._path)\n                self.setPlainText(content)\n                self._last_save_content = content\n                \n            else:\n                self._logger.debug(\"File no longer exists, clearing content: %s\", self._path)\n                self.setPlainText(\"\")\n                self._last_save_content = \"\"\n            \n            # Reset cursor to beginning and clear selection\n            cursor = QTextCursor(self.document())\n            cursor.movePosition(QTextCursor.MoveOperation.Start)\n            self.setTextCursor(cursor)\n            \n        except Exception as e:\n            self._logger.error(\"Failed to refresh content from file '%s': %s\", self._path, str(e))\n            # If file is unreadable, leave empty editor view\n            self.setPlainText(\"\")\n            self._last_save_content = \"\"\n            \n            # Reset cursor to beginning\n            cursor = QTextCursor(self.document())\n            cursor.movePosition(QTextCursor.MoveOperation.Start)\n            self.setTextCursor(cursor)\n\n    def _update_programming_language_from_path(self) -> None:\n        \"\"\"Update programming language based on current path.\"\"\"\n        if self._path:\n            new_language = ProgrammingLanguageUtils.from_file_extension(self._path)\n\n        else:\n            new_language = ProgrammingLanguage.TEXT\n\n        self._update_programming_language(new_language)\n\n    def _update_programming_language(self, new_language: ProgrammingLanguage) -> None:\n        \"\"\"\n        Update the syntax highlighting language.\n\n        Args:\n            new_language: The new programming language to use\n        \"\"\"\n        if self._current_programming_language != new_language:\n            self._current_programming_language = new_language\n            self._highlighter.set_language(new_language)\n            self.status_updated.emit()\n\n    def _update_auto_backup_from_settings(self) -> None:\n        \"\"\"Update auto-backup settings from mindspace.\"\"\"\n        if not self._mindspace_manager.has_mindspace():\n            self._auto_backup_timer.stop()\n            return\n\n        settings = self._mindspace_manager.settings()\n        if settings is None:\n            self._auto_backup_timer.stop()\n            return\n\n        self._update_auto_backup_settings(settings.auto_backup, settings.auto_backup_interval)\n\n    def _update_auto_backup_settings(self, enabled: bool, interval: int) -> None:\n        \"\"\"Update auto-backup settings.\"\"\"\n        if enabled:\n            self._auto_backup_timer.setInterval(interval * 1000)  # Convert to milliseconds\n            if self._is_modified:\n                # If we have unsaved changes, start backup immediately\n                self._auto_backup_timer.start()\n            return\n\n        clear_backups = self._auto_backup_timer.isActive()\n        self._auto_backup_timer.stop()\n\n        # Clean up any existing backups since auto-backup is disabled\n        if clear_backups:\n            self._cleanup_backup_files()\n\n    def _set_modified(self, modified: bool) -> None:\n        \"\"\"\n        Set the modified state and emit appropriate signals.\n\n        Args:\n            modified: Whether the content is modified\n        \"\"\"\n        if self._is_modified != modified:\n            self._is_modified = modified\n            self.content_modified.emit(modified)\n\n    def _on_mindspace_settings_changed(self) -> None:\n        \"\"\"Handle mindspace settings changes.\"\"\"\n        self._update_auto_backup_from_settings()\n\n    def _on_widget_activated(self, _widget: QWidget) -> None:\n        \"\"\"\n        Handle activation of a widget.\n\n        Args:\n            widget: The widget that was activated\n        \"\"\"\n        # Emit activated signal to let the tab know this editor was clicked\n        self.activated.emit()\n\n    def _on_widget_deactivated(self, widget: QWidget) -> None:\n        \"\"\"\n        Handle deactivation of a widget.\n\n        Args:\n            widget: The widget lost focus\n        \"\"\"\n\n    def _on_language_changed(self) -> None:\n        \"\"\"Handle language changes by updating the UI.\"\"\"\n        self._update_line_number_area_width()\n        self.viewport().update()\n        self.status_updated.emit()\n\n    def _on_text_changed(self) -> None:\n        \"\"\"Handle changes to editor content.\"\"\"\n        current_content = self.toPlainText()\n        is_modified = current_content != self._last_save_content\n        self._set_modified(is_modified)\n\n        if not self._mindspace_manager.has_mindspace():\n            return\n\n        settings = self._mindspace_manager.settings()\n        if settings is None:\n            return\n\n        if settings.auto_backup:\n            if is_modified and not self._auto_backup_timer.isActive():\n                self._auto_backup_timer.start()\n\n            elif not is_modified:\n                self._auto_backup_timer.stop()\n\n    def _auto_backup(self) -> None:\n        \"\"\"Handle auto-backup functionality.\"\"\"\n        if not self._is_modified:\n            return\n\n        # All backups should now go in mindspace .humbug/backups\n        if not self._mindspace_manager.has_mindspace():\n            return  # No backups without a mindspace\n\n        backup_dir = self._mindspace_manager.get_absolute_path(os.path.join(\".humbug\", \"backups\"))\n        os.makedirs(backup_dir, exist_ok=True)\n\n        if not self._path:\n            # For untitled files, use timestamp-based backup in mindspace\n            prefix = f\"backup-{self._untitled_number}-\"\n            current_time = int(time.time())\n            try:\n                # Clean up old backups for this untitled file\n                for file in os.listdir(backup_dir):\n                    if file.startswith(prefix):\n                        file_path = os.path.join(backup_dir, file)\n\n                        # Keep only backups from last hour\n                        if current_time - os.path.getctime(file_path) > 3600:\n                            try:\n                                os.remove(file_path)\n\n                            except OSError as e:\n                                self._logger.warning(\"Failed to remove old backup %s: %s\", file_path, str(e))\n\n            except OSError as e:\n                self._logger.warning(\"Failed to clean up old backups: %s\", str(e))\n\n            backup_file = os.path.join(\n                backup_dir,\n                f\"{prefix}{current_time}.txt\"\n            )\n\n        else:\n            backup_file = f\"{self._path}.backup\"\n\n            # Clean up any very old backups that might have been left behind\n            try:\n                if os.path.exists(backup_file):\n                    if time.time() - os.path.getctime(backup_file) > 86400:  # 24 hours\n                        try:\n                            os.remove(backup_file)\n\n                        except OSError:\n                            pass  # Ignore cleanup errors for old files\n\n            except OSError:\n                pass  # Ignore stat errors\n\n        try:\n            with open(backup_file, 'w', encoding='utf-8') as f:\n                f.write(self.toPlainText())\n\n        except Exception as e:\n            self._logger.error(\"Failed to create backup file '%s': %s\", backup_file, str(e))\n\n    def _cleanup_backup_files(self) -> None:\n        \"\"\"Clean up any backup files for this editor.\"\"\"\n        if not self._mindspace_manager.has_mindspace():\n            return\n\n        if self._path:\n            # Clean up backup for saved file\n            backup_file = f\"{self._path}.backup\"\n            try:\n                if os.path.exists(backup_file):\n                    os.remove(backup_file)\n\n            except OSError as e:\n                self._logger.warning(\"Failed to remove backup file %s: %s\", backup_file, str(e))\n\n        elif self._untitled_number:\n            # Clean up backups for untitled file\n            backup_dir = self._mindspace_manager.get_absolute_path(os.path.join(\".humbug\", \"backups\"))\n            prefix = f\"backup-{self._untitled_number}-\"\n            try:\n                for file in os.listdir(backup_dir):\n                    if file.startswith(prefix):\n                        try:\n                            os.remove(os.path.join(backup_dir, file))\n\n                        except OSError as e:\n                            self._logger.warning(\"Failed to remove backup %s: %s\", file, str(e))\n\n            except OSError as e:\n                self._logger.warning(\"Failed to clean up backups: %s\", str(e))\n\n    def path(self) -> str:\n        \"\"\"Get the current file path.\"\"\"\n        return self._path\n\n    def set_path(self, path: str) -> None:\n        \"\"\"\n        Set the file path and update language detection.\n\n        Args:\n            path: Path to file\n        \"\"\"\n        self._path = path\n        self._untitled_number = None\n        self._update_programming_language_from_path()\n\n    def is_modified(self) -> bool:\n        \"\"\"Check if the content has been modified.\"\"\"\n        return self._is_modified\n\n    def can_close(self) -> bool:\n        \"\"\"Check if the editor can be closed, handling unsaved changes.\"\"\"\n        if not self._is_modified:\n            return True\n\n        strings = self._language_manager.strings()\n        document_name = self._path or f'Untitled-{self._untitled_number}'\n        result = MessageBox.show_message(\n            self,\n            MessageBoxType.QUESTION,\n            strings.save_changes_title,\n            strings.unsaved_changes.format(document_name),\n            [MessageBoxButton.SAVE, MessageBoxButton.DISCARD, MessageBoxButton.CANCEL]\n        )\n\n        if result == MessageBoxButton.SAVE:\n            return self.save_file()\n\n        if result == MessageBoxButton.DISCARD:\n            self._set_modified(False)\n            return True\n\n        return False\n\n    def close_widget(self) -> None:\n        \"\"\"Close the editor widget and clean up resources.\"\"\"\n        # Delete any backup files when we close\n        if self._auto_backup_timer.isActive():\n            self._cleanup_backup_files()\n\n    def save_file(self) -> bool:\n        \"\"\"\n        Save the current file.\n\n        Returns:\n            bool: True if save was successful\n        \"\"\"\n        if not self._path:\n            return self.save_file_as()\n\n        try:\n            content = self.toPlainText()\n            with open(self._path, 'w', encoding='utf-8') as f:\n                f.write(content)\n\n            self._last_save_content = content\n            self._set_modified(False)\n\n            # Delete any backup files\n            backup_file = f\"{self._path}.backup\"\n            try:\n                if os.path.exists(backup_file):\n                    os.remove(backup_file)\n\n            except OSError as e:\n                self._logger.warning(\"Failed to remove backup file %s: %s\", backup_file, str(e))\n\n            self.file_saved.emit(self._path)\n            return True\n\n        except Exception as e:\n            strings = self._language_manager.strings()\n            MessageBox.show_message(\n                self,\n                MessageBoxType.CRITICAL,\n                strings.error_saving_file_title,\n                strings.could_not_save.format(self._path, str(e))\n            )\n            return False\n\n    def save_file_as(self) -> bool:\n        \"\"\"\n        Show save as dialog and save file.\n\n        Returns:\n            bool: True if save was successful\n        \"\"\"\n        strings = self._language_manager.strings()\n        export_dialog = QFileDialog()\n        export_dialog.setWindowTitle(strings.file_dialog_save_file)\n\n        if self._path:\n            export_dialog.setDirectory(self._path)\n\n        else:\n            fd_dir = self._mindspace_manager.file_dialog_directory()\n            if not fd_dir:\n                return False\n\n            export_dialog.setDirectory(fd_dir)\n\n        export_dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptSave)\n        if export_dialog.exec_() != QFileDialog.DialogCode.Accepted:\n            return False\n\n        filename = export_dialog.selectedFiles()[0]\n        self._mindspace_manager.update_file_dialog_directory(filename)\n        self.set_path(filename)\n\n        return self.save_file()\n\n    def get_status_info(self) -> Dict[str, Any]:\n        \"\"\"\n        Get status information for the status bar.\n\n        Returns:\n            Dictionary with status information\n        \"\"\"\n        cursor = self.textCursor()\n        line = cursor.blockNumber() + 1\n        column = cursor.columnNumber() + 1\n\n        # Get file info\n        encoding = \"UTF-8\"\n        line_ending = \"LF\"  # We could detect this from file content\n\n        # Get language name for display\n        file_type = ProgrammingLanguageUtils.get_display_name(self._current_programming_language)\n\n        return {\n            'line': line,\n            'column': column,\n            'encoding': encoding,\n            'line_ending': line_ending,\n            'type': file_type\n        }\n\n    def create_state_metadata(self, temp_state: bool) -> Dict[str, Any]:\n        \"\"\"\n        Create metadata dictionary capturing current widget state.\n\n        Args:\n            temp_state: Whether this is temporary state for moving tabs\n\n        Returns:\n            Dictionary containing editor state metadata\n        \"\"\"\n        metadata: Dict[str, Any] = {}\n\n        metadata[\"language\"] = self._current_programming_language.name\n        metadata[\"cursor\"] = self._get_cursor_position()\n        metadata[\"horizontal_scroll\"] = self.horizontalScrollBar().value()\n        metadata[\"vertical_scroll\"] = self.verticalScrollBar().value()\n\n        if temp_state:\n            metadata[\"content\"] = self.toPlainText()\n\n        return metadata\n\n    def restore_from_metadata(self, metadata: Dict[str, Any]) -> None:\n        \"\"\"\n        Restore widget state from metadata.\n\n        Args:\n            metadata: Dictionary containing state metadata\n        \"\"\"\n        if not metadata:\n            return\n\n        if \"content\" in metadata:\n            self.setPlainText(metadata[\"content\"])\n\n        # Restore language if specified\n        if \"language\" in metadata:\n            language = ProgrammingLanguage[metadata[\"language\"]]\n            self._update_programming_language(language)\n\n        # Restore cursor position if present\n        if \"cursor\" in metadata:\n            self._set_cursor_position(metadata[\"cursor\"])\n\n        # Restore scroll positions if present\n        if \"horizontal_scroll\" in metadata:\n            self.horizontalScrollBar().setValue(metadata[\"horizontal_scroll\"])\n\n        if \"vertical_scroll\" in metadata:\n            self.verticalScrollBar().setValue(metadata[\"vertical_scroll\"])\n\n    def _set_cursor_position(self, position: Dict[str, int]) -> None:\n        \"\"\"\n        Set cursor position in editor.\n\n        Args:\n            position: Dictionary with 'line' and 'column' keys\n        \"\"\"\n        if not position:\n            return\n\n        cursor = self.textCursor()\n        cursor.movePosition(QTextCursor.MoveOperation.Start)\n\n        # Move cursor to specified position\n        for _ in range(position.get(\"line\", 0)):\n            cursor.movePosition(QTextCursor.MoveOperation.NextBlock)\n\n        cursor.movePosition(\n            QTextCursor.MoveOperation.Right,\n            QTextCursor.MoveMode.MoveAnchor,\n            position.get(\"column\", 0)\n        )\n\n        self.setTextCursor(cursor)\n        self.ensureCursorVisible()\n\n    def _get_cursor_position(self) -> Dict[str, int]:\n        \"\"\"\n        Get current cursor position from editor.\n\n        Returns:\n            Dictionary with 'line' and 'column' keys\n        \"\"\"\n        cursor = self.textCursor()\n        return {\n            \"line\": cursor.blockNumber(),\n            \"column\": cursor.columnNumber()\n        }\n\n    def _line_number_area_width(self) -> int:\n        \"\"\"Calculate the width needed for the line number area.\"\"\"\n        digits = 1\n        max_num = max(1, self.blockCount())\n        while max_num >= 10:\n            max_num //= 10\n            digits += 1\n\n        digit_width = self.fontMetrics().horizontalAdvance('9')\n        return digit_width * (digits + 4)\n\n    def _update_line_number_area_width(self) -> None:\n        \"\"\"Update the margins to accommodate the line numbers.\"\"\"\n        width = self._line_number_area_width()\n\n        # Set margin on appropriate side based on layout direction\n        if self.layoutDirection() == Qt.LayoutDirection.RightToLeft:\n            self.setViewportMargins(0, 0, 0, 0)  # Right margin\n\n        else:\n            self.setViewportMargins(width, 0, 0, 0)  # Left margin\n\n    def _update_line_number_area(self, rect: QRect, dy: int) -> None:\n        \"\"\"Handle updates to the line number area.\"\"\"\n        if dy:\n            self._line_number_area.scroll(0, dy)\n\n        else:\n            self._line_number_area.update(0, rect.y(),\n                self._line_number_area.width(), rect.height())\n\n        if rect.contains(self.viewport().rect()):\n            self._update_line_number_area_width()\n\n    def resizeEvent(self, event: QResizeEvent) -> None:  # type: ignore[override]\n        \"\"\"Handle resize events.\"\"\"\n        super().resizeEvent(event)\n        cr = self.contentsRect()\n        width = self._line_number_area_width()\n\n        if self.layoutDirection() == Qt.LayoutDirection.RightToLeft:\n            self._line_number_area.setGeometry(\n                cr.right() - width,\n                cr.top(),\n                width,\n                cr.height()\n            )\n\n        else:\n            self._line_number_area.setGeometry(\n                cr.left(),\n                cr.top(),\n                width,\n                cr.height()\n            )\n\n    def _line_number_area_paint_event(self, event: QPaintEvent) -> None:\n        \"\"\"Paint the line numbers.\"\"\"\n        painter = QPainter(self._line_number_area)\n        bg_color = self._style_manager.get_color(ColorRole.TAB_BACKGROUND_ACTIVE)\n        painter.fillRect(event.rect(), bg_color)\n\n        painter.setFont(self.font())\n\n        block = self.firstVisibleBlock()\n        block_number = block.blockNumber()\n        offset = self.contentOffset()\n        top = self.blockBoundingGeometry(block).translated(offset).top()\n        bottom = top + self.blockBoundingRect(block).height()\n\n        # Use two space widths for padding\n        padding = self.fontMetrics().horizontalAdvance('9') * 2\n\n        # Adjust alignment and padding based on layout direction\n        is_rtl = self.layoutDirection() == Qt.LayoutDirection.RightToLeft\n        alignment = Qt.AlignmentFlag.AlignLeft if is_rtl else Qt.AlignmentFlag.AlignRight\n\n        while block.isValid() and top <= event.rect().bottom():\n            if block.isVisible() and bottom >= event.rect().top():\n                number = str(block_number + 1)\n                text_color = self._style_manager.get_color(ColorRole.LINE_NUMBER)\n                painter.setPen(text_color)\n                text_rect = QRect(\n                    0,\n                    int(top),\n                    self._line_number_area.width() - padding,\n                    self.fontMetrics().height()\n                )\n                painter.drawText(text_rect, alignment, number)\n\n            block = block.next()\n            top = bottom\n            bottom = top + self.blockBoundingRect(block).height()\n            block_number += 1\n\n    def _indent_single_line_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n        \"\"\"\n        Indent a single line using soft tabs.\n\n        Args:\n            cursor: The current text cursor\n            tab_size: Number of spaces to use for indentation\n        \"\"\"\n        # Calculate spaces needed to reach next tab stop\n        current_column = cursor.position() - cursor.block().position()\n        spaces_needed = tab_size - (current_column % tab_size)\n        cursor.insertText(\" \" * spaces_needed)\n\n    def _indent_single_line_hard_tabs(self, cursor: QTextCursor) -> None:\n        \"\"\"\n        Indent a single line using hard tabs.\n\n        Args:\n            cursor: The current text cursor\n        \"\"\"\n        cursor.insertText(\"\\t\")\n\n    def _indent_block_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n        \"\"\"\n        Indent a block of text using soft tabs.\n\n        Args:\n            cursor: The current text cursor\n            tab_size: Number of spaces to use for indentation\n        \"\"\"\n        start = cursor.selectionStart()\n        end = cursor.selectionEnd()\n        reverse: bool = start == cursor.position()\n\n        cursor.setPosition(start)\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n\n        # If selection ends at start of line, don't indent that line\n        end_offs = 0\n        check_cursor = QTextCursor(cursor)\n        check_cursor.setPosition(end)\n        if check_cursor.atBlockStart():\n            end_offs = 1\n\n        start += tab_size\n        while cursor.position() <= end - end_offs:\n            if not cursor.atBlockEnd():\n                cursor.insertText(\" \" * tab_size)\n                end += tab_size\n\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\n                # We hit the end of the file\n                break\n\n        cursor.setPosition(start if not reverse else end)\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\n\n    def _indent_block_hard_tabs(self, cursor: QTextCursor) -> None:\n        \"\"\"\n        Indent a block of text using hard tabs.\n\n        Args:\n            cursor: The current text cursor\n        \"\"\"\n        start = cursor.selectionStart()\n        end = cursor.selectionEnd()\n        reverse: bool = start == cursor.position()\n\n        cursor.setPosition(start)\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n\n        # If selection ends at start of line, don't indent that line\n        end_offs = 0\n        check_cursor = QTextCursor(cursor)\n        check_cursor.setPosition(end)\n        if check_cursor.atBlockStart():\n            end_offs = 1\n\n        start += 1\n        while cursor.position() <= end - end_offs:\n            if not cursor.atBlockEnd():\n                cursor.insertText(\"\\t\")\n                end += 1\n\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\n                # We hit the end of the file\n                break\n\n        cursor.setPosition(start if not reverse else end)\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\n\n    def _outdent_single_line_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n        \"\"\"\n        Outdent a single line using soft tabs.\n\n        Args:\n            cursor: The current text cursor\n            tab_size: Number of spaces to use for indentation\n        \"\"\"\n        current_column = cursor.position() - cursor.block().position()\n        deletes_needed = 1 + ((current_column - 1) % tab_size)\n        deletes_needed = min(deletes_needed, current_column)\n\n        while deletes_needed > 0:\n            text = cursor.block().text()\n            if not text or text[current_column - 1] != \" \":\n                break\n\n            cursor.deletePreviousChar()\n            current_column -= 1\n            deletes_needed -= 1\n\n    def _outdent_single_line_hard_tabs(self, cursor: QTextCursor) -> None:\n        \"\"\"\n        Outdent a single line using hard tabs.\n\n        Args:\n            cursor: The current text cursor\n        \"\"\"\n        current_column = cursor.position() - cursor.block().position()\n        if current_column > 0:\n            text = cursor.block().text()\n            if text and text[current_column - 1] == \"\\t\":\n                cursor.deletePreviousChar()\n\n    def _outdent_block_soft_tabs(self, cursor: QTextCursor, tab_size: int) -> None:\n        \"\"\"\n        Outdent a block of text using soft tabs.\n\n        Args:\n            cursor: The current text cursor\n            tab_size: Number of spaces to use for indentation\n        \"\"\"\n        start = cursor.selectionStart()\n        end = cursor.selectionEnd()\n        reverse: bool = start == cursor.position()\n\n        cursor.setPosition(start)\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n\n        # If selection ends at start of line, don't outdent that line\n        end_offs = 0\n        check_cursor = QTextCursor(cursor)\n        check_cursor.setPosition(end)\n        if check_cursor.atBlockStart():\n            end_offs = 1\n\n        # Work out how far to move the start postion\n        current_column = start - cursor.block().position()\n        first_line = cursor.block().text()\n        first_line_spaces = len(first_line) - len(first_line.lstrip(\" \"))\n        first_line_spaces = min(first_line_spaces, tab_size)\n        first_line_spaces = min(first_line_spaces, current_column)\n        start -= first_line_spaces\n\n        while cursor.position() <= end - end_offs:\n            deletes_needed = tab_size\n\n            while deletes_needed > 0:\n                text = cursor.block().text()\n                if not text or text[0] != \" \":\n                    break\n\n                cursor.deleteChar()\n                deletes_needed -= 1\n                end -= 1\n\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\n                # We hit the end of the block\n                break\n\n        cursor.setPosition(start if not reverse else end)\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\n\n    def _outdent_block_hard_tabs(self, cursor: QTextCursor) -> None:\n        \"\"\"\n        Outdent a block of text using hard tabs.\n\n        Args:\n            cursor: The current text cursor\n        \"\"\"\n        start = cursor.selectionStart()\n        end = cursor.selectionEnd()\n        reverse: bool = start == cursor.position()\n\n        cursor.setPosition(start)\n        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n\n        # If selection ends at start of line, don't outdent that line\n        end_offs = 0\n        check_cursor = QTextCursor(cursor)\n        check_cursor.setPosition(end)\n        if check_cursor.atBlockStart():\n            end_offs = 1\n\n        # Work out how far to move the start postion\n        current_column = start - cursor.block().position()\n        first_line = cursor.block().text()\n        if first_line and first_line[0] == \"\\t\" and current_column > 0:\n            start -= 1\n\n        while cursor.position() <= end - end_offs:\n            text = cursor.block().text()\n            if text and text[0] == \"\\t\":\n                cursor.deleteChar()\n                end -= 1\n\n            if not cursor.movePosition(QTextCursor.MoveOperation.NextBlock):\n                # We hit the end of the block\n                break\n\n        cursor.setPosition(start if not reverse else end)\n        cursor.setPosition(end if not reverse else start, QTextCursor.MoveMode.KeepAnchor)\n\n    def keyPressEvent(self, event: QKeyEvent) -> None:  # type: ignore[override]\n        \"\"\"\n        Handle special key events.\n\n        Args:\n            event: The key event to handle\n        \"\"\"\n        if event.key() == Qt.Key.Key_Home:\n            cursor = self.textCursor()\n            cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)\n            self.setTextCursor(cursor)\n            event.accept()\n            return\n\n        if event.key() == Qt.Key.Key_End:\n            cursor = self.textCursor()\n            cursor.movePosition(QTextCursor.MoveOperation.EndOfLine)\n            self.setTextCursor(cursor)\n            event.accept()\n            return\n\n        if event.key() == Qt.Key.Key_Tab:\n            cursor = self.textCursor()\n            mindspace_manager = MindspaceManager()\n            if not mindspace_manager.has_mindspace():\n                super().keyPressEvent(event)\n                return\n\n            settings = cast(MindspaceSettings, mindspace_manager.settings())\n\n            scrollbar = self.verticalScrollBar()\n            current_scroll = scrollbar.value()\n            cursor.beginEditBlock()\n            try:\n                if not cursor.hasSelection():\n                    if settings.use_soft_tabs:\n                        self._indent_single_line_soft_tabs(cursor, settings.tab_size)\n\n                    else:\n                        self._indent_single_line_hard_tabs(cursor)\n\n                else:\n                    if settings.use_soft_tabs:\n                        self._indent_block_soft_tabs(cursor, settings.tab_size)\n\n                    else:\n                        self._indent_block_hard_tabs(cursor)\n\n            finally:\n                cursor.endEditBlock()\n                self.setTextCursor(cursor)\n                scrollbar.setValue(current_scroll)\n\n            event.accept()\n            return\n\n        if event.key() == Qt.Key.Key_Backtab:  # Shift+Tab\n            cursor = self.textCursor()\n            mindspace_manager = MindspaceManager()\n            if not mindspace_manager.has_mindspace():\n                super().keyPressEvent(event)\n                return\n\n            settings = cast(MindspaceSettings, mindspace_manager.settings())\n\n            scrollbar = self.verticalScrollBar()\n            current_scroll = scrollbar.value()\n            cursor.beginEditBlock()\n            try:\n                if not cursor.hasSelection():\n                    if settings.use_soft_tabs:\n                        self._outdent_single_line_soft_tabs(cursor, settings.tab_size)\n\n                    else:\n                        self._outdent_single_line_hard_tabs(cursor)\n\n                else:\n                    if settings.use_soft_tabs:\n                        self._outdent_block_soft_tabs(cursor, settings.tab_size)\n\n                    else:\n                        self._outdent_block_hard_tabs(cursor)\n\n            finally:\n                cursor.endEditBlock()\n                self.setTextCursor(cursor)\n                scrollbar.setValue(current_scroll)\n\n            event.accept()\n            return\n\n        super().keyPressEvent(event)\n\n    def _on_style_changed(self) -> None:\n        \"\"\"Handle style changes affecting search highlighting.\"\"\"\n        # Update font size\n        zoom_factor = self._style_manager.zoom_factor()\n        font = self.font()\n        base_size = self._style_manager.base_font_size()\n        font.setPointSizeF(base_size * zoom_factor)\n        self.setFont(font)\n\n        # Update tab stops - scale with zoom\n        space_width = self._style_manager.get_space_width()\n        self.setTabStopDistance(space_width * 8)\n\n        # If we changed colour mode then re-highlight\n        if self._style_manager.color_mode() != self._init_colour_mode:\n            self._init_colour_mode = self._style_manager.color_mode()\n            self._highlighter.rehighlight()\n\n        self.setStyleSheet(f\"\"\"\n            QWidget {{\n                background-color: {self._style_manager.get_color_str(ColorRole.TAB_BACKGROUND_ACTIVE)};\n            }}\n\n            QPlainTextEdit {{\n                border: none;\n                selection-background-color: {self._style_manager.get_color_str(ColorRole.TEXT_SELECTED)};\n                selection-color: none;\n            }}\n\n            QScrollBar:vertical, QScrollBar:horizontal {{\n                background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_BACKGROUND)};\n                width: 12px;\n                height: 12px;\n            }}\n            QScrollBar::handle:vertical, QScrollBar::handle:horizontal {{\n                background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_HANDLE)};\n                min-height: 20px;\n                min-width: 20px;\n            }}\n            QScrollBar::add-page, QScrollBar::sub-page {{\n                background: none;\n            }}\n            QScrollBar::add-line, QScrollBar::sub-line {{\n                height: 0px;\n                width: 0px;\n            }}\n\n            QAbstractScrollArea::corner {{\n                background-color: {self._style_manager.get_color_str(ColorRole.SCROLLBAR_BACKGROUND)};\n            }}\n        \"\"\")\n\n        # Scale line number area\n        self._update_line_number_area_width()\n\n        self._highlight_matches()\n\n    def find_text(self, text: str, forward: bool = True) -> None:\n        \"\"\"\n        Find all instances of text and highlight them.\n\n        Args:\n            text: Text to search for\n            forward: Whether to search forward from current position\n        \"\"\"\n        # Clear existing highlights if search text changed\n        if text != self._last_search:\n            self._clear_highlights()\n            self._matches = []\n            self._current_match = -1\n            self._last_search = text\n\n        document = self.document()\n\n        # Find all matches if this is a new search\n        if not self._matches and text:\n            cursor = QTextCursor(document)\n            while True:\n                cursor = document.find(text, cursor)\n                if cursor.isNull():\n                    break\n\n                self._matches.append((cursor.selectionStart(), cursor.selectionEnd()))\n\n        if not self._matches:\n            return\n\n        # Move to next/previous match\n        if forward:\n            self._current_match = (self._current_match + 1) % len(self._matches)\n\n        else:\n            self._current_match = (self._current_match - 1) if self._current_match > 0 else len(self._matches) - 1\n\n        # Highlight all matches\n        self._highlight_matches()\n\n        # Scroll to current match\n        self._scroll_to_match(self._current_match)\n\n    def _highlight_matches(self) -> None:\n        \"\"\"Update the highlighting of all matches.\"\"\"\n        self._clear_highlights()\n\n        if not self._matches:\n            return\n\n        found_format = QTextCharFormat()\n        found_format.setBackground(self._style_manager.get_color(ColorRole.TEXT_FOUND))\n        dim_found_format = QTextCharFormat()\n        dim_found_format.setBackground(self._style_manager.get_color(ColorRole.TEXT_FOUND_DIM))\n\n        # Create extra selections list\n        selections = []\n\n        # Highlight all matches\n        for i, (start, end) in enumerate(self._matches):\n            cursor = QTextCursor(self.document())\n            cursor.setPosition(start)\n            cursor.setPosition(end, QTextCursor.MoveMode.KeepAnchor)\n\n            # Create extra selection\n            extra_selection = QTextEdit.ExtraSelection()\n\n            # We have to tell mypy to ingore attributes it doesn't know about\n            extra_selection.cursor = cursor  # type: ignore\n\n            # Use different format for current match\n            if i == self._current_match:\n                extra_selection.format = found_format  # type: ignore\n\n            else:\n                extra_selection.format = dim_found_format  # type: ignore\n\n            selections.append(extra_selection)\n\n        # Apply selections\n        self.setExtraSelections(selections)\n\n    def _scroll_to_match(self, match_index: int) -> None:\n        \"\"\"\n        Scroll to ensure the given match is visible.\n\n        Args:\n            match_index: Index of match to scroll to\n        \"\"\"\n        if 0 <= match_index < len(self._matches):\n            cursor = QTextCursor(self.document())\n            cursor.setPosition(self._matches[match_index][0])\n            self.setTextCursor(cursor)\n            self.ensureCursorVisible()\n\n    def _clear_highlights(self) -> None:\n        \"\"\"Clear all search highlights.\"\"\"\n        self.setExtraSelections([])\n\n    def get_match_status(self) -> Tuple[int, int]:\n        \"\"\"\n        Get the current match status.\n\n        Returns:\n            Tuple of (current_match, total_matches)\n        \"\"\"\n        return self._current_match + 1, len(self._matches)\n\n    def clear_find(self) -> None:\n        \"\"\"Clear all find state.\"\"\"\n        self._clear_highlights()\n        self._matches = []\n        self._current_match = -1\n        self._last_search = \"\"\n\n    def can_undo(self) -> bool:\n        \"\"\"Check if undo is available.\"\"\"\n        return self.document().isUndoAvailable()\n\n    def can_redo(self) -> bool:\n        \"\"\"Check if redo is available.\"\"\"\n        return self.document().isRedoAvailable()\n\n    def can_cut(self) -> bool:\n        \"\"\"Check if cut is available.\"\"\"\n        return self.textCursor().hasSelection()\n\n    def can_copy(self) -> bool:\n        \"\"\"Check if copy is available.\"\"\"\n        return self.textCursor().hasSelection()\n\n    def can_paste(self) -> bool:\n        \"\"\"Check if paste is available.\"\"\"\n        return True"
          }
        }
      ]
    },
    {
      "id": "a431b8ca-cbf0-47ef-bb61-7567ae888220",
      "timestamp": "2025-08-29T17:35:23.054937+00:00",
      "type": "tool_result",
      "content": "```json\n{\n    \"id\": \"toolu_014YQpakDHa9HtBixJLyrnkZ\",\n    \"name\": \"filesystem\",\n    \"content\": \"File written successfully: src/humbug/tabs/editor/editor_widget.py (44,101 bytes)\",\n    \"error\": null\n}\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_014YQpakDHa9HtBixJLyrnkZ",
          "name": "filesystem",
          "content": "File written successfully: src/humbug/tabs/editor/editor_widget.py (44,101 bytes)",
          "error": null
        }
      ]
    },
    {
      "id": "9d2a6aa5-f20e-42dc-af66-53d96559f6a5",
      "timestamp": "2025-08-29T17:35:23.060967+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_014YQpakDHa9HtBixJLyrnkZ",
          "name": "filesystem",
          "content": "File written successfully: src/humbug/tabs/editor/editor_widget.py (44,101 bytes)",
          "error": null
        }
      ]
    },
    {
      "id": "333ef550-f548-4618-b552-b509381bd48c",
      "timestamp": "2025-08-29T17:35:28.304996+00:00",
      "type": "ai_response",
      "content": "Now I'll update the `EditorTab` class to override the `_handle_file_changed()` method:",
      "completed": true,
      "usage": {
        "prompt_tokens": 35017,
        "completion_tokens": 2604,
        "total_tokens": 37621
      },
      "model": "claude-sonnet-4-20250514",
      "reasoning_capability": 1,
      "temperature": 0.7,
      "tool_calls": [
        {
          "id": "toolu_01JHwpUPj1YVJbPxanTMyut1",
          "name": "filesystem",
          "arguments": {
            "operation": "write_file",
            "path": "src/humbug/tabs/editor/editor_tab.py",
            "content": "import logging\n\nfrom PySide6.QtWidgets import (\n    QVBoxLayout, QWidget\n)\n\nfrom humbug.language.language_manager import LanguageManager\nfrom humbug.status_message import StatusMessage\nfrom humbug.tabs.editor.editor_widget import EditorWidget\nfrom humbug.tabs.find_widget import FindWidget\nfrom humbug.tabs.tab_base import TabBase\nfrom humbug.tabs.tab_state import TabState\nfrom humbug.tabs.tab_type import TabType\n\n\nclass EditorTab(TabBase):\n    \"\"\"Tab for editing text files.\"\"\"\n\n    def __init__(self, tab_id: str, path: str, untitled_number: int | None, parent: QWidget | None = None) -> None:\n        \"\"\"\n        Initialize editor tab.\n\n        Args:\n            tab_id: Unique identifier for this tab, or a UUID will be generated if not provided\n            path: File path to edit, or empty string for new file\n            untitled_number: Optional untitled file number for new files\n            parent: Optional parent widget\n        \"\"\"\n        super().__init__(tab_id, parent)\n        self._logger = logging.getLogger(\"EditorTab\")\n        self._path = path\n        self._untitled_number = untitled_number\n\n        self._language_manager = LanguageManager()\n        self._language_manager.language_changed.connect(self._on_language_changed)\n\n        # Set up layout\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(0, 0, 0, 0)\n        layout.setSpacing(0)\n\n        # Add find widget at top (initially hidden)\n        self._find_widget = FindWidget()\n        self._find_widget.hide()\n        self._find_widget.closed.connect(self._close_find)\n        self._find_widget.find_next.connect(lambda: self._find_next(True))\n        self._find_widget.find_previous.connect(lambda: self._find_next(False))\n        layout.addWidget(self._find_widget)\n\n        # Create editor widget\n        self._editor_widget = EditorWidget(path, untitled_number, self)\n        self._editor_widget.content_modified.connect(self._on_content_modified)\n        self._editor_widget.status_updated.connect(self.update_status)\n        self._editor_widget.activated.connect(self.activated)\n        self._editor_widget.file_saved.connect(self._on_file_saved)\n        layout.addWidget(self._editor_widget)\n\n        # Start file watching if we have a path\n        if self._path:\n            self._start_file_watching(self._path)\n\n        self.update_status()\n\n    def activate(self) -> None:\n        \"\"\"Activate the tab.\"\"\"\n        self._editor_widget.setFocus()\n\n    def _on_content_modified(self, modified: bool) -> None:\n        \"\"\"Handle content modification changes.\"\"\"\n        self._set_modified(modified)\n\n    def _on_file_saved(self, path: str) -> None:\n        \"\"\"Handle file being saved.\"\"\"\n        self.set_path(path)\n        self.update_status()\n\n    def _on_language_changed(self) -> None:\n        \"\"\"Update language-specific elements.\"\"\"\n        # Update find widget text if visible\n        if not self._find_widget.isHidden():\n            current, total = self._editor_widget.get_match_status()\n            self._find_widget.set_match_status(current, total)\n\n        # Update status bar with translated terms\n        self.update_status()\n\n    def _handle_file_changed(self, changed_path: str) -> None:\n        \"\"\"\n        Handle notification that the watched file has changed.\n        \n        If the tab is not modified, refresh the content from disk and set the updated marker.\n\n        Args:\n            changed_path: Path of the file that changed\n        \"\"\"\n        # First, let the parent handle file existence checking\n        super()._handle_file_changed(changed_path)\n        \n        # If the tab is not modified, refresh the content\n        if not self.is_modified():\n            self._logger.debug(\"File changed and tab not modified, refreshing content: %s\", changed_path)\n            self._editor_widget.refresh_content()\n            self.set_updated(True)\n\n    def get_state(self, temp_state: bool=False) -> TabState:\n        \"\"\"Get serializable state for mindspace persistence.\"\"\"\n        metadata = self._editor_widget.create_state_metadata(temp_state)\n\n        path = self._editor_widget.path()\n        if not path and self._untitled_number:\n            path = f\"untitled-{self._untitled_number}\"\n\n        return TabState(\n            type=TabType.EDITOR,\n            tab_id=self._tab_id,\n            path=path,\n            metadata=metadata\n        )\n\n    @classmethod\n    def restore_from_state(cls, state: TabState, parent: QWidget) -> 'EditorTab':\n        \"\"\"Create and restore an editor tab from serialized state.\"\"\"\n        # Set filename and load content\n        number: int | None = None\n        path = \"\"\n\n        if state.path.startswith(\"untitled-\"):\n            number = int(state.path.split(\"-\")[1])\n\n        else:\n            path = state.path\n\n        # Create new tab instance\n        tab = cls(state.tab_id, path, number, parent)\n\n        if state.metadata:\n            tab._editor_widget.restore_from_metadata(state.metadata)\n\n        return tab\n\n    def set_path(self, path: str) -> None:\n        \"\"\"\n        Set the file being edited.\n\n        Args:\n            path: Path to file\n        \"\"\"\n        # Stop watching old path\n        if self._path != path:\n            self._stop_file_watching()\n\n        self._path = path\n        self._editor_widget.set_path(path)\n\n        # Start watching new path\n        if path:\n            self._start_file_watching(path)\n\n        self.update_status()\n\n    def update_status(self) -> None:\n        \"\"\"Update status bar with current cursor position.\"\"\"\n        status_info = self._editor_widget.get_status_info()\n        strings = self._language_manager.strings()\n        message = StatusMessage(\n            strings.editor_status.format(**status_info)\n        )\n        self.status_message.emit(message)\n\n    def can_close_tab(self) -> bool:\n        \"\"\"Check if the file can be closed.\"\"\"\n        return self._editor_widget.can_close()\n\n    def close_tab(self) -> None:\n        \"\"\"Close the tab and clean up resources.\"\"\"\n        self._editor_widget.close_widget()\n\n    def can_save(self) -> bool:\n        \"\"\"Check if the file can be saved.\"\"\"\n        return self._editor_widget.is_modified()\n\n    def save(self) -> bool:\n        \"\"\"\n        Save the current file.\n\n        Returns:\n            bool: True if save was successful\n        \"\"\"\n        return self._editor_widget.save_file()\n\n    def can_save_as(self) -> bool:\n        \"\"\"Check if the file can be saved as.\"\"\"\n        return True\n\n    def save_as(self) -> bool:\n        \"\"\"\n        Show save as dialog and save file.\n\n        Returns:\n            bool: True if save was successful\n        \"\"\"\n        return self._editor_widget.save_file_as()\n\n    def can_undo(self) -> bool:\n        \"\"\"Check if undo is available.\"\"\"\n        return self._editor_widget.can_undo()\n\n    def undo(self) -> None:\n        \"\"\"Undo the last edit operation.\"\"\"\n        self._editor_widget.undo()\n\n    def can_redo(self) -> bool:\n        \"\"\"Check if redo is available.\"\"\"\n        return self._editor_widget.can_redo()\n\n    def redo(self) -> None:\n        \"\"\"Redo the last undone edit operation.\"\"\"\n        self._editor_widget.redo()\n\n    def can_cut(self) -> bool:\n        \"\"\"Check if cut is available.\"\"\"\n        return self._editor_widget.can_cut()\n\n    def cut(self) -> None:\n        \"\"\"Cut selected text to clipboard.\"\"\"\n        self._editor_widget.cut()\n\n    def can_copy(self) -> bool:\n        \"\"\"Check if copy is available.\"\"\"\n        return self._editor_widget.can_copy()\n\n    def copy(self) -> None:\n        \"\"\"Copy selected text to clipboard.\"\"\"\n        self._editor_widget.copy()\n\n    def can_paste(self) -> bool:\n        \"\"\"Check if paste is available.\"\"\"\n        return self._editor_widget.can_paste()\n\n    def paste(self) -> None:\n        \"\"\"Paste text from clipboard.\"\"\"\n        self._editor_widget.paste()\n\n    def can_submit(self) -> bool:\n        \"\"\"Check if submit is available (not applicable for editor).\"\"\"\n        return False\n\n    def submit(self) -> None:\n        \"\"\"Submit operation (not applicable for editor).\"\"\"\n\n    def show_find(self) -> None:\n        \"\"\"Show the find widget.\"\"\"\n        cursor = self._editor_widget.textCursor()\n        if cursor.hasSelection():\n            # Get the selected text\n            text = cursor.selectedText()\n\n            # Only use selection if it's on a single line\n            if '\\u2029' not in text:  # Qt uses this character for line breaks\n                self._find_widget.set_search_text(text)\n            else:\n                self._find_widget.set_search_text(\"\")\n\n        self._find_widget.show()\n        self._find_widget.setFocus()\n\n    def _close_find(self) -> None:\n        \"\"\"Close the find widget and clear search state.\"\"\"\n        self._find_widget.hide()\n        self._editor_widget.clear_find()\n\n    def _find_next(self, forward: bool = True) -> None:\n        \"\"\"Find next/previous match.\"\"\"\n        text = self._find_widget.get_search_text()\n        self._editor_widget.find_text(text, forward)\n        current, total = self._editor_widget.get_match_status()\n        self._find_widget.set_match_status(current, total)"
          }
        }
      ]
    },
    {
      "id": "32feaa62-1e21-4ddb-92a9-0c7b14ee00ed",
      "timestamp": "2025-08-29T17:36:02.756376+00:00",
      "type": "tool_call",
      "content": "```json\n{\n    \"id\": \"toolu_01JHwpUPj1YVJbPxanTMyut1\",\n    \"name\": \"filesystem\",\n    \"arguments\": {\n        \"operation\": \"write_file\",\n        \"path\": \"src/humbug/tabs/editor/editor_tab.py\",\n        \"content\": \"import logging\\n\\nfrom PySide6.QtWidgets import (\\n    QVBoxLayout, QWidget\\n)\\n\\nfrom humbug.language.language_manager import LanguageManager\\nfrom humbug.status_message import StatusMessage\\nfrom humbug.tabs.editor.editor_widget import EditorWidget\\nfrom humbug.tabs.find_widget import FindWidget\\nfrom humbug.tabs.tab_base import TabBase\\nfrom humbug.tabs.tab_state import TabState\\nfrom humbug.tabs.tab_type import TabType\\n\\n\\nclass EditorTab(TabBase):\\n    \\\"\\\"\\\"Tab for editing text files.\\\"\\\"\\\"\\n\\n    def __init__(self, tab_id: str, path: str, untitled_number: int | None, parent: QWidget | None = None) -> None:\\n        \\\"\\\"\\\"\\n        Initialize editor tab.\\n\\n        Args:\\n            tab_id: Unique identifier for this tab, or a UUID will be generated if not provided\\n            path: File path to edit, or empty string for new file\\n            untitled_number: Optional untitled file number for new files\\n            parent: Optional parent widget\\n        \\\"\\\"\\\"\\n        super().__init__(tab_id, parent)\\n        self._logger = logging.getLogger(\\\"EditorTab\\\")\\n        self._path = path\\n        self._untitled_number = untitled_number\\n\\n        self._language_manager = LanguageManager()\\n        self._language_manager.language_changed.connect(self._on_language_changed)\\n\\n        # Set up layout\\n        layout = QVBoxLayout(self)\\n        layout.setContentsMargins(0, 0, 0, 0)\\n        layout.setSpacing(0)\\n\\n        # Add find widget at top (initially hidden)\\n        self._find_widget = FindWidget()\\n        self._find_widget.hide()\\n        self._find_widget.closed.connect(self._close_find)\\n        self._find_widget.find_next.connect(lambda: self._find_next(True))\\n        self._find_widget.find_previous.connect(lambda: self._find_next(False))\\n        layout.addWidget(self._find_widget)\\n\\n        # Create editor widget\\n        self._editor_widget = EditorWidget(path, untitled_number, self)\\n        self._editor_widget.content_modified.connect(self._on_content_modified)\\n        self._editor_widget.status_updated.connect(self.update_status)\\n        self._editor_widget.activated.connect(self.activated)\\n        self._editor_widget.file_saved.connect(self._on_file_saved)\\n        layout.addWidget(self._editor_widget)\\n\\n        # Start file watching if we have a path\\n        if self._path:\\n            self._start_file_watching(self._path)\\n\\n        self.update_status()\\n\\n    def activate(self) -> None:\\n        \\\"\\\"\\\"Activate the tab.\\\"\\\"\\\"\\n        self._editor_widget.setFocus()\\n\\n    def _on_content_modified(self, modified: bool) -> None:\\n        \\\"\\\"\\\"Handle content modification changes.\\\"\\\"\\\"\\n        self._set_modified(modified)\\n\\n    def _on_file_saved(self, path: str) -> None:\\n        \\\"\\\"\\\"Handle file being saved.\\\"\\\"\\\"\\n        self.set_path(path)\\n        self.update_status()\\n\\n    def _on_language_changed(self) -> None:\\n        \\\"\\\"\\\"Update language-specific elements.\\\"\\\"\\\"\\n        # Update find widget text if visible\\n        if not self._find_widget.isHidden():\\n            current, total = self._editor_widget.get_match_status()\\n            self._find_widget.set_match_status(current, total)\\n\\n        # Update status bar with translated terms\\n        self.update_status()\\n\\n    def _handle_file_changed(self, changed_path: str) -> None:\\n        \\\"\\\"\\\"\\n        Handle notification that the watched file has changed.\\n        \\n        If the tab is not modified, refresh the content from disk and set the updated marker.\\n\\n        Args:\\n            changed_path: Path of the file that changed\\n        \\\"\\\"\\\"\\n        # First, let the parent handle file existence checking\\n        super()._handle_file_changed(changed_path)\\n        \\n        # If the tab is not modified, refresh the content\\n        if not self.is_modified():\\n            self._logger.debug(\\\"File changed and tab not modified, refreshing content: %s\\\", changed_path)\\n            self._editor_widget.refresh_content()\\n            self.set_updated(True)\\n\\n    def get_state(self, temp_state: bool=False) -> TabState:\\n        \\\"\\\"\\\"Get serializable state for mindspace persistence.\\\"\\\"\\\"\\n        metadata = self._editor_widget.create_state_metadata(temp_state)\\n\\n        path = self._editor_widget.path()\\n        if not path and self._untitled_number:\\n            path = f\\\"untitled-{self._untitled_number}\\\"\\n\\n        return TabState(\\n            type=TabType.EDITOR,\\n            tab_id=self._tab_id,\\n            path=path,\\n            metadata=metadata\\n        )\\n\\n    @classmethod\\n    def restore_from_state(cls, state: TabState, parent: QWidget) -> 'EditorTab':\\n        \\\"\\\"\\\"Create and restore an editor tab from serialized state.\\\"\\\"\\\"\\n        # Set filename and load content\\n        number: int | None = None\\n        path = \\\"\\\"\\n\\n        if state.path.startswith(\\\"untitled-\\\"):\\n            number = int(state.path.split(\\\"-\\\")[1])\\n\\n        else:\\n            path = state.path\\n\\n        # Create new tab instance\\n        tab = cls(state.tab_id, path, number, parent)\\n\\n        if state.metadata:\\n            tab._editor_widget.restore_from_metadata(state.metadata)\\n\\n        return tab\\n\\n    def set_path(self, path: str) -> None:\\n        \\\"\\\"\\\"\\n        Set the file being edited.\\n\\n        Args:\\n            path: Path to file\\n        \\\"\\\"\\\"\\n        # Stop watching old path\\n        if self._path != path:\\n            self._stop_file_watching()\\n\\n        self._path = path\\n        self._editor_widget.set_path(path)\\n\\n        # Start watching new path\\n        if path:\\n            self._start_file_watching(path)\\n\\n        self.update_status()\\n\\n    def update_status(self) -> None:\\n        \\\"\\\"\\\"Update status bar with current cursor position.\\\"\\\"\\\"\\n        status_info = self._editor_widget.get_status_info()\\n        strings = self._language_manager.strings()\\n        message = StatusMessage(\\n            strings.editor_status.format(**status_info)\\n        )\\n        self.status_message.emit(message)\\n\\n    def can_close_tab(self) -> bool:\\n        \\\"\\\"\\\"Check if the file can be closed.\\\"\\\"\\\"\\n        return self._editor_widget.can_close()\\n\\n    def close_tab(self) -> None:\\n        \\\"\\\"\\\"Close the tab and clean up resources.\\\"\\\"\\\"\\n        self._editor_widget.close_widget()\\n\\n    def can_save(self) -> bool:\\n        \\\"\\\"\\\"Check if the file can be saved.\\\"\\\"\\\"\\n        return self._editor_widget.is_modified()\\n\\n    def save(self) -> bool:\\n        \\\"\\\"\\\"\\n        Save the current file.\\n\\n        Returns:\\n            bool: True if save was successful\\n        \\\"\\\"\\\"\\n        return self._editor_widget.save_file()\\n\\n    def can_save_as(self) -> bool:\\n        \\\"\\\"\\\"Check if the file can be saved as.\\\"\\\"\\\"\\n        return True\\n\\n    def save_as(self) -> bool:\\n        \\\"\\\"\\\"\\n        Show save as dialog and save file.\\n\\n        Returns:\\n            bool: True if save was successful\\n        \\\"\\\"\\\"\\n        return self._editor_widget.save_file_as()\\n\\n    def can_undo(self) -> bool:\\n        \\\"\\\"\\\"Check if undo is available.\\\"\\\"\\\"\\n        return self._editor_widget.can_undo()\\n\\n    def undo(self) -> None:\\n        \\\"\\\"\\\"Undo the last edit operation.\\\"\\\"\\\"\\n        self._editor_widget.undo()\\n\\n    def can_redo(self) -> bool:\\n        \\\"\\\"\\\"Check if redo is available.\\\"\\\"\\\"\\n        return self._editor_widget.can_redo()\\n\\n    def redo(self) -> None:\\n        \\\"\\\"\\\"Redo the last undone edit operation.\\\"\\\"\\\"\\n        self._editor_widget.redo()\\n\\n    def can_cut(self) -> bool:\\n        \\\"\\\"\\\"Check if cut is available.\\\"\\\"\\\"\\n        return self._editor_widget.can_cut()\\n\\n    def cut(self) -> None:\\n        \\\"\\\"\\\"Cut selected text to clipboard.\\\"\\\"\\\"\\n        self._editor_widget.cut()\\n\\n    def can_copy(self) -> bool:\\n        \\\"\\\"\\\"Check if copy is available.\\\"\\\"\\\"\\n        return self._editor_widget.can_copy()\\n\\n    def copy(self) -> None:\\n        \\\"\\\"\\\"Copy selected text to clipboard.\\\"\\\"\\\"\\n        self._editor_widget.copy()\\n\\n    def can_paste(self) -> bool:\\n        \\\"\\\"\\\"Check if paste is available.\\\"\\\"\\\"\\n        return self._editor_widget.can_paste()\\n\\n    def paste(self) -> None:\\n        \\\"\\\"\\\"Paste text from clipboard.\\\"\\\"\\\"\\n        self._editor_widget.paste()\\n\\n    def can_submit(self) -> bool:\\n        \\\"\\\"\\\"Check if submit is available (not applicable for editor).\\\"\\\"\\\"\\n        return False\\n\\n    def submit(self) -> None:\\n        \\\"\\\"\\\"Submit operation (not applicable for editor).\\\"\\\"\\\"\\n\\n    def show_find(self) -> None:\\n        \\\"\\\"\\\"Show the find widget.\\\"\\\"\\\"\\n        cursor = self._editor_widget.textCursor()\\n        if cursor.hasSelection():\\n            # Get the selected text\\n            text = cursor.selectedText()\\n\\n            # Only use selection if it's on a single line\\n            if '\\\\u2029' not in text:  # Qt uses this character for line breaks\\n                self._find_widget.set_search_text(text)\\n            else:\\n                self._find_widget.set_search_text(\\\"\\\")\\n\\n        self._find_widget.show()\\n        self._find_widget.setFocus()\\n\\n    def _close_find(self) -> None:\\n        \\\"\\\"\\\"Close the find widget and clear search state.\\\"\\\"\\\"\\n        self._find_widget.hide()\\n        self._editor_widget.clear_find()\\n\\n    def _find_next(self, forward: bool = True) -> None:\\n        \\\"\\\"\\\"Find next/previous match.\\\"\\\"\\\"\\n        text = self._find_widget.get_search_text()\\n        self._editor_widget.find_text(text, forward)\\n        current, total = self._editor_widget.get_match_status()\\n        self._find_widget.set_match_status(current, total)\"\n    }\n}\n```",
      "completed": true,
      "tool_calls": [
        {
          "id": "toolu_01JHwpUPj1YVJbPxanTMyut1",
          "name": "filesystem",
          "arguments": {
            "operation": "write_file",
            "path": "src/humbug/tabs/editor/editor_tab.py",
            "content": "import logging\n\nfrom PySide6.QtWidgets import (\n    QVBoxLayout, QWidget\n)\n\nfrom humbug.language.language_manager import LanguageManager\nfrom humbug.status_message import StatusMessage\nfrom humbug.tabs.editor.editor_widget import EditorWidget\nfrom humbug.tabs.find_widget import FindWidget\nfrom humbug.tabs.tab_base import TabBase\nfrom humbug.tabs.tab_state import TabState\nfrom humbug.tabs.tab_type import TabType\n\n\nclass EditorTab(TabBase):\n    \"\"\"Tab for editing text files.\"\"\"\n\n    def __init__(self, tab_id: str, path: str, untitled_number: int | None, parent: QWidget | None = None) -> None:\n        \"\"\"\n        Initialize editor tab.\n\n        Args:\n            tab_id: Unique identifier for this tab, or a UUID will be generated if not provided\n            path: File path to edit, or empty string for new file\n            untitled_number: Optional untitled file number for new files\n            parent: Optional parent widget\n        \"\"\"\n        super().__init__(tab_id, parent)\n        self._logger = logging.getLogger(\"EditorTab\")\n        self._path = path\n        self._untitled_number = untitled_number\n\n        self._language_manager = LanguageManager()\n        self._language_manager.language_changed.connect(self._on_language_changed)\n\n        # Set up layout\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(0, 0, 0, 0)\n        layout.setSpacing(0)\n\n        # Add find widget at top (initially hidden)\n        self._find_widget = FindWidget()\n        self._find_widget.hide()\n        self._find_widget.closed.connect(self._close_find)\n        self._find_widget.find_next.connect(lambda: self._find_next(True))\n        self._find_widget.find_previous.connect(lambda: self._find_next(False))\n        layout.addWidget(self._find_widget)\n\n        # Create editor widget\n        self._editor_widget = EditorWidget(path, untitled_number, self)\n        self._editor_widget.content_modified.connect(self._on_content_modified)\n        self._editor_widget.status_updated.connect(self.update_status)\n        self._editor_widget.activated.connect(self.activated)\n        self._editor_widget.file_saved.connect(self._on_file_saved)\n        layout.addWidget(self._editor_widget)\n\n        # Start file watching if we have a path\n        if self._path:\n            self._start_file_watching(self._path)\n\n        self.update_status()\n\n    def activate(self) -> None:\n        \"\"\"Activate the tab.\"\"\"\n        self._editor_widget.setFocus()\n\n    def _on_content_modified(self, modified: bool) -> None:\n        \"\"\"Handle content modification changes.\"\"\"\n        self._set_modified(modified)\n\n    def _on_file_saved(self, path: str) -> None:\n        \"\"\"Handle file being saved.\"\"\"\n        self.set_path(path)\n        self.update_status()\n\n    def _on_language_changed(self) -> None:\n        \"\"\"Update language-specific elements.\"\"\"\n        # Update find widget text if visible\n        if not self._find_widget.isHidden():\n            current, total = self._editor_widget.get_match_status()\n            self._find_widget.set_match_status(current, total)\n\n        # Update status bar with translated terms\n        self.update_status()\n\n    def _handle_file_changed(self, changed_path: str) -> None:\n        \"\"\"\n        Handle notification that the watched file has changed.\n        \n        If the tab is not modified, refresh the content from disk and set the updated marker.\n\n        Args:\n            changed_path: Path of the file that changed\n        \"\"\"\n        # First, let the parent handle file existence checking\n        super()._handle_file_changed(changed_path)\n        \n        # If the tab is not modified, refresh the content\n        if not self.is_modified():\n            self._logger.debug(\"File changed and tab not modified, refreshing content: %s\", changed_path)\n            self._editor_widget.refresh_content()\n            self.set_updated(True)\n\n    def get_state(self, temp_state: bool=False) -> TabState:\n        \"\"\"Get serializable state for mindspace persistence.\"\"\"\n        metadata = self._editor_widget.create_state_metadata(temp_state)\n\n        path = self._editor_widget.path()\n        if not path and self._untitled_number:\n            path = f\"untitled-{self._untitled_number}\"\n\n        return TabState(\n            type=TabType.EDITOR,\n            tab_id=self._tab_id,\n            path=path,\n            metadata=metadata\n        )\n\n    @classmethod\n    def restore_from_state(cls, state: TabState, parent: QWidget) -> 'EditorTab':\n        \"\"\"Create and restore an editor tab from serialized state.\"\"\"\n        # Set filename and load content\n        number: int | None = None\n        path = \"\"\n\n        if state.path.startswith(\"untitled-\"):\n            number = int(state.path.split(\"-\")[1])\n\n        else:\n            path = state.path\n\n        # Create new tab instance\n        tab = cls(state.tab_id, path, number, parent)\n\n        if state.metadata:\n            tab._editor_widget.restore_from_metadata(state.metadata)\n\n        return tab\n\n    def set_path(self, path: str) -> None:\n        \"\"\"\n        Set the file being edited.\n\n        Args:\n            path: Path to file\n        \"\"\"\n        # Stop watching old path\n        if self._path != path:\n            self._stop_file_watching()\n\n        self._path = path\n        self._editor_widget.set_path(path)\n\n        # Start watching new path\n        if path:\n            self._start_file_watching(path)\n\n        self.update_status()\n\n    def update_status(self) -> None:\n        \"\"\"Update status bar with current cursor position.\"\"\"\n        status_info = self._editor_widget.get_status_info()\n        strings = self._language_manager.strings()\n        message = StatusMessage(\n            strings.editor_status.format(**status_info)\n        )\n        self.status_message.emit(message)\n\n    def can_close_tab(self) -> bool:\n        \"\"\"Check if the file can be closed.\"\"\"\n        return self._editor_widget.can_close()\n\n    def close_tab(self) -> None:\n        \"\"\"Close the tab and clean up resources.\"\"\"\n        self._editor_widget.close_widget()\n\n    def can_save(self) -> bool:\n        \"\"\"Check if the file can be saved.\"\"\"\n        return self._editor_widget.is_modified()\n\n    def save(self) -> bool:\n        \"\"\"\n        Save the current file.\n\n        Returns:\n            bool: True if save was successful\n        \"\"\"\n        return self._editor_widget.save_file()\n\n    def can_save_as(self) -> bool:\n        \"\"\"Check if the file can be saved as.\"\"\"\n        return True\n\n    def save_as(self) -> bool:\n        \"\"\"\n        Show save as dialog and save file.\n\n        Returns:\n            bool: True if save was successful\n        \"\"\"\n        return self._editor_widget.save_file_as()\n\n    def can_undo(self) -> bool:\n        \"\"\"Check if undo is available.\"\"\"\n        return self._editor_widget.can_undo()\n\n    def undo(self) -> None:\n        \"\"\"Undo the last edit operation.\"\"\"\n        self._editor_widget.undo()\n\n    def can_redo(self) -> bool:\n        \"\"\"Check if redo is available.\"\"\"\n        return self._editor_widget.can_redo()\n\n    def redo(self) -> None:\n        \"\"\"Redo the last undone edit operation.\"\"\"\n        self._editor_widget.redo()\n\n    def can_cut(self) -> bool:\n        \"\"\"Check if cut is available.\"\"\"\n        return self._editor_widget.can_cut()\n\n    def cut(self) -> None:\n        \"\"\"Cut selected text to clipboard.\"\"\"\n        self._editor_widget.cut()\n\n    def can_copy(self) -> bool:\n        \"\"\"Check if copy is available.\"\"\"\n        return self._editor_widget.can_copy()\n\n    def copy(self) -> None:\n        \"\"\"Copy selected text to clipboard.\"\"\"\n        self._editor_widget.copy()\n\n    def can_paste(self) -> bool:\n        \"\"\"Check if paste is available.\"\"\"\n        return self._editor_widget.can_paste()\n\n    def paste(self) -> None:\n        \"\"\"Paste text from clipboard.\"\"\"\n        self._editor_widget.paste()\n\n    def can_submit(self) -> bool:\n        \"\"\"Check if submit is available (not applicable for editor).\"\"\"\n        return False\n\n    def submit(self) -> None:\n        \"\"\"Submit operation (not applicable for editor).\"\"\"\n\n    def show_find(self) -> None:\n        \"\"\"Show the find widget.\"\"\"\n        cursor = self._editor_widget.textCursor()\n        if cursor.hasSelection():\n            # Get the selected text\n            text = cursor.selectedText()\n\n            # Only use selection if it's on a single line\n            if '\\u2029' not in text:  # Qt uses this character for line breaks\n                self._find_widget.set_search_text(text)\n            else:\n                self._find_widget.set_search_text(\"\")\n\n        self._find_widget.show()\n        self._find_widget.setFocus()\n\n    def _close_find(self) -> None:\n        \"\"\"Close the find widget and clear search state.\"\"\"\n        self._find_widget.hide()\n        self._editor_widget.clear_find()\n\n    def _find_next(self, forward: bool = True) -> None:\n        \"\"\"Find next/previous match.\"\"\"\n        text = self._find_widget.get_search_text()\n        self._editor_widget.find_text(text, forward)\n        current, total = self._editor_widget.get_match_status()\n        self._find_widget.set_match_status(current, total)"
          }
        }
      ]
    },
    {
      "id": "4e4845f8-6c71-45a1-8a0b-49919126a15c",
      "timestamp": "2025-08-29T17:36:04.726598+00:00",
      "type": "tool_result",
      "content": "```json\n{\n    \"id\": \"toolu_01JHwpUPj1YVJbPxanTMyut1\",\n    \"name\": \"filesystem\",\n    \"content\": \"File written successfully: src/humbug/tabs/editor/editor_tab.py (9,126 bytes)\",\n    \"error\": null\n}\n```",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01JHwpUPj1YVJbPxanTMyut1",
          "name": "filesystem",
          "content": "File written successfully: src/humbug/tabs/editor/editor_tab.py (9,126 bytes)",
          "error": null
        }
      ]
    },
    {
      "id": "7f1864f2-5140-43a3-98a0-4c606fb87d82",
      "timestamp": "2025-08-29T17:36:04.732430+00:00",
      "type": "user_message",
      "content": "",
      "completed": true,
      "tool_results": [
        {
          "id": "toolu_01JHwpUPj1YVJbPxanTMyut1",
          "name": "filesystem",
          "content": "File written successfully: src/humbug/tabs/editor/editor_tab.py (9,126 bytes)",
          "error": null
        }
      ]
    },
    {
      "id": "2b94917b-b817-4be6-ad7d-092b166a8e40",
      "timestamp": "2025-08-29T17:36:06.876762+00:00",
      "type": "ai_response",
      "content": "Perfect! I've successfully implemented the file reload functionality as requested. Here's a summary of the changes:\n\n## Changes Made\n\n### 1. Added `refresh_content()` method to `EditorWidget`\n- **Location**: `src/humbug/tabs/editor/editor_widget.py`\n- **Functionality**:\n  - Reads the current file from disk and replaces editor content\n  - Handles unreadable files by leaving empty editor view\n  - Handles deleted files by clearing content\n  - Resets cursor to beginning and clears any selection\n  - Includes comprehensive error logging\n  - Updates `_last_save_content` to maintain proper modified state tracking\n\n### 2. Overrode `_handle_file_changed()` method in `EditorTab`\n- **Location**: `src/humbug/tabs/editor/editor_tab.py`\n- **Functionality**:\n  - Calls parent's `_handle_file_changed()` to maintain file existence tracking\n  - Checks if tab is not modified before triggering reload\n  - Calls `refresh_content()` on the editor widget\n  - Sets the updated marker to give user visual cue\n  - Includes debug logging for the reload operation\n\n## Key Implementation Details\n\n\u2705 **Uses existing file watching infrastructure** - No changes needed to the file watching system  \n\u2705 **Only reloads unmodified tabs** - Modified tabs are never auto-reloaded  \n\u2705 **Handles error cases gracefully** - Unreadable files result in empty editor  \n\u2705 **Provides user feedback** - Updated marker gives visual cue when reload occurs  \n\u2705 **Maintains cursor consistency** - Always resets to beginning after reload  \n\u2705 **Proper error logging** - All error handling includes appropriate logging  \n\u2705 **Preserves modification state** - Doesn't interfere with existing modified state logic  \n\nThe implementation follows the existing code patterns and integrates seamlessly with the current architecture. The file reload will now happen automatically when:\n1. A file being edited changes on disk\n2. The tab is not currently modified by the user\n3. The file system watcher detects the change\n\nThe user will see the updated marker on the tab to know that the content has been refreshed from disk.",
      "completed": true,
      "usage": {
        "prompt_tokens": 37656,
        "completion_tokens": 522,
        "total_tokens": 38178
      },
      "model": "claude-sonnet-4-20250514",
      "reasoning_capability": 1,
      "temperature": 0.7
    }
  ]
}