; Test Cases for Constant Folding Analysis
; Each section demonstrates a different optimization opportunity

; =============================================================================
; 1. SIMPLE ARITHMETIC CONSTANTS
; =============================================================================
(let ((buffer-size (integer* 1024 1024))
      (timeout-ms (integer* 1000 30))
      (max-retries (integer+ 3 2)))
  (integer+ buffer-size timeout-ms max-retries))

; =============================================================================
; 2. NESTED ARITHMETIC
; =============================================================================
(let ((a (integer* 2 3))
      (b (integer+ 4 5))
      (c (integer- 10 1)))
  (integer+ (integer* a b) c))

; =============================================================================
; 3. MATHEMATICAL CONSTANTS
; =============================================================================
(let ((gravity (float* 9.8 1.0))
      (pi-over-2 (float/ 3.14159 2.0))
      (degrees-to-radians (float/ 3.14159 180.0)))
  (lambda (angle)
    (float* angle degrees-to-radians)))

; =============================================================================
; 4. UNIT CONVERSIONS
; =============================================================================
(let ((meters-to-feet (float/ 1.0 0.3048))
      (kg-to-pounds (float/ 1.0 0.453592)))
  (lambda (meters kg)
    (list (float* meters meters-to-feet)
          (float* kg kg-to-pounds))))

; =============================================================================
; 5. BIT OPERATIONS
; =============================================================================
(let ((read-flag (bit-shift-left 1 0))
      (write-flag (bit-shift-left 1 1))
      (exec-flag (bit-shift-left 1 2))
      (all-flags (bit-or (bit-or 1 2) 4)))
  all-flags)

; =============================================================================
; 6. BOOLEAN LOGIC
; =============================================================================
(let ((debug-mode (and #t #t))
      (production-mode (and #f #t))
      (enable-logging (or #t #f)))
  debug-mode)

; =============================================================================
; 7. CONFIGURATION OBJECT
; =============================================================================
(dict 
  (list "port" (integer+ 8000 80))
  (list "workers" (integer* 4 2))
  (list "timeout" (integer* 60 5))
  (list "buffer-size" (integer* 1024 8))
  (list "max-connections" (integer+ 100 50)))

; =============================================================================
; 8. ALGORITHM PARAMETERS
; =============================================================================
(let ((learning-rate (float/ 1.0 1000.0))
      (batch-size (integer* 32 4))
      (epochs (integer+ 50 50))
      (hidden-units (integer* 128 2)))
  (list learning-rate batch-size epochs hidden-units))

; =============================================================================
; 9. RANGE CALCULATIONS
; =============================================================================
(let ((start-index (integer+ 0 1))
      (end-index (integer- 100 1))
      (step-size (integer+ 1 1)))
  (range start-index end-index step-size))

; =============================================================================
; 10. COMPARISON OPERATIONS
; =============================================================================
(let ((min-value (integer<? 5 10))
      (max-value (integer>? 100 50))
      (equal-check (integer=? 42 42)))
  (and min-value max-value equal-check))
